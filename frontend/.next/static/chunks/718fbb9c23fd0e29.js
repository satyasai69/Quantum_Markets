(globalThis.TURBOPACK||(globalThis.TURBOPACK=[])).push(["object"==typeof document?document.currentScript:void 0,926268,e=>{"use strict";var n,t,a,i,s=e.i(843476),r=e.i(72903),o=e.i(271645),c=e.i(825158),l=e.i(4550),d=e.i(426049),u=e.i(511059),g=e.i(302769),h=e.i(806264),p=e.i(213444),f=e.i(880211),A=e.i(651816),w=e.i(172819),m=e.i(447187),y=e.i(286505),v=e.i(379688),T=e.i(994999),S=e.i(648328),b=e.i(912440),I=e.i(902910),E=e.i(771567),O=e.i(442690),W=e.i(945367),C=e.i(263588),j=e.i(437206),U=e.i(166953),F=e.i(5729),M=e.i(432317),_=e.i(660851);let x=["solana:mainnet","solana:devnet","solana:testnet"];function P(e,n){if(!Object.prototype.hasOwnProperty.call(e,n))throw TypeError("attempted to use private field on non-instance");return e}var N=0,D="__private_"+N+++"__implementation";function L(e,n){if(!Object.prototype.hasOwnProperty.call(e,n))throw TypeError("attempted to use private field on non-instance");return e}var B=0;function R(e){return"__private_"+B+++"_"+e}var k=R("_address"),V=R("_publicKey"),z=R("_chains"),K=R("_features"),Q=R("_label"),Y=R("_icon");class G{get address(){return L(this,k)[k]}get publicKey(){return L(this,V)[V].slice()}get chains(){return L(this,z)[z].slice()}get features(){return L(this,K)[K].slice()}get label(){return L(this,Q)[Q]}get icon(){return L(this,Y)[Y]}constructor({address:e,publicKey:n,label:t,icon:a}){Object.defineProperty(this,k,{writable:!0,value:void 0}),Object.defineProperty(this,V,{writable:!0,value:void 0}),Object.defineProperty(this,z,{writable:!0,value:void 0}),Object.defineProperty(this,K,{writable:!0,value:void 0}),Object.defineProperty(this,Q,{writable:!0,value:void 0}),Object.defineProperty(this,Y,{writable:!0,value:void 0}),L(this,k)[k]=e,L(this,V)[V]=n,L(this,z)[z]=x,L(this,Q)[Q]=t,L(this,Y)[Y]=a,L(this,K)[K]=["solana:signAndSendTransaction","solana:signTransaction","solana:signMessage"],new.target===G&&Object.freeze(this)}}function H(e,n){if(!Object.prototype.hasOwnProperty.call(e,n))throw TypeError("attempted to use private field on non-instance");return e}var J=0;function $(e){return"__private_"+J+++"_"+e}var Z=$("_listeners"),q=$("_version"),X=$("_name"),ee=$("_icon"),en=$("_injection"),et=$("_isPrivyWallet"),ea=$("_accounts"),ei=$("_on"),es=$("_emit"),er=$("_off"),eo=$("_connected"),ec=$("_connect"),el=$("_disconnect"),ed=$("_signMessage"),eu=$("_signAndSendTransaction"),eg=$("_signTransaction");function eh(e,...n){H(this,Z)[Z][e]?.forEach(e=>e.apply(null,n))}function ep(e,n){H(this,Z)[Z][e]=H(this,Z)[Z][e]?.filter(e=>n!==e)}function ef(){let{isHeadlessSigning:e,walletProxy:n,initializeWalletProxy:t,recoverEmbeddedWallet:a,openModal:i,privy:s,client:r}=(0,y.u)(),{user:o}=(0,W.u)(),{setModalData:c}=(0,v.a)(),{signWithUserSigner:l}=(0,F.u)();return{signMessage:({message:d,address:u,options:g})=>new Promise(async(h,p)=>{let f=(0,v.h)(o,u);if("privy"!==f?.walletClientType)return void p(new y.a("Wallet is not a Privy wallet",void 0,y.b.EMBEDDED_WALLET_NOT_FOUND));let{entropyId:A,entropyIdVerifier:w}=(0,C.g)(o,f),m=(0,v.d)(f),T=(0,_.b)(d).toString("base64");if(T.length<1)return void p(new y.a("Message must be a non-empty string",void 0,y.b.INVALID_MESSAGE));let S=async()=>{let e;if(!o)throw Error("User must be authenticated before signing with a Privy wallet");let i=await r.getAccessToken();if(!i)throw Error("User must be authenticated to use their embedded wallet.");let c=n??await t(15e3);if(!c)throw Error("Failed to initialize embedded wallet proxy.");if(!await a({address:f.address}))throw Error("Unable to connect to wallet");if(m){let n=await (0,E.rpc)(s,l,{chain_type:"solana",method:"signMessage",params:{message:T,encoding:"base64"},wallet_id:f.id});if(!n.data||!("signature"in n.data))throw Error("Failed to sign message");e=n.data.signature}else{let{response:n}=await c.rpc({accessToken:i,entropyId:A,entropyIdVerifier:w,chainType:"solana",hdWalletIndex:f.walletIndex??0,requesterAppId:g?.uiOptions?.requesterAppId,request:{method:"signMessage",params:{message:T}}});e=n.data.signature}return e};if(e({showWalletUIs:g?.uiOptions?.showWalletUIs}))try{let e=await S(),n=new Uint8Array((0,_.b)(e,"base64"));h({signature:n})}catch(e){p(e)}else c({signMessage:{method:"solana_signMessage",data:T,confirmAndSign:S,onSuccess:e=>{h({signature:new Uint8Array((0,_.b)(e,"base64"))})},onFailure:e=>{p(e)},uiOptions:g?.uiOptions??{}},connectWallet:{recoveryMethod:f.recoveryMethod,connectingWalletAddress:f.address,entropyId:A,entropyIdVerifier:w,isUnifiedWallet:m,onCompleteNavigateTo:"SignRequestScreen",onFailure:e=>{p(new y.a("Failed to connect to wallet",e,y.b.UNKNOWN_CONNECT_WALLET_ERROR))}}}),i("EmbeddedWalletConnectingScreen")})}}function eA(){let{isHeadlessSigning:e,openModal:n}=(0,y.u)(),{setModalData:t}=(0,v.a)(),{signMessage:a}=ef(),{user:i}=(0,W.u)();return{signTransaction:async({transaction:s,options:r,chain:o="solana:mainnet",address:c})=>{async function l(e){let n,t,{signature:i}=await a({message:(0,_.a)(e),address:c,options:{...r,uiOptions:{...r?.uiOptions,showWalletUIs:!1}}});return{signedTransaction:(n=structuredClone((0,S.getTransactionDecoder)().decode(e)),(t=(0,b.address)(c))in n.signatures&&(n.signatures[t]=i),new Uint8Array((0,S.getTransactionEncoder)().encode(n)))}}return e({showWalletUIs:r?.uiOptions?.showWalletUIs})?l(s):new Promise(async(e,a)=>{let d=(0,v.h)(i,c);if("privy"!==d?.walletClientType)return void a(new y.a("Wallet is not a Privy wallet",void 0,y.b.EMBEDDED_WALLET_NOT_FOUND));let{entropyId:u,entropyIdVerifier:g}=(0,C.g)(i,d),h=(0,v.d)(d);function p(e){return n=>{a(n instanceof y.a?n:new y.a("Failed to connect to wallet",n,e))}}let f={account:d,transaction:s,chain:o,signOnly:!0,uiOptions:r?.uiOptions||{},onConfirm:l,onSuccess:e,onFailure:p(y.b.TRANSACTION_FAILURE)};t({connectWallet:{recoveryMethod:d.recoveryMethod,connectingWalletAddress:d.address,entropyId:u,entropyIdVerifier:g,isUnifiedWallet:h,onCompleteNavigateTo:"StandardSignAndSendTransactionScreen",onFailure:p(y.b.UNKNOWN_CONNECT_WALLET_ERROR)},standardSignAndSendTransaction:f}),n("EmbeddedWalletConnectingScreen")})}}}let ew=new class extends j.default{setImplementation(e){P(this,D)[D]=e}async signMessage(e){return P(this,D)[D].signMessage(e)}async signAndSendTransaction(e){return P(this,D)[D].signAndSendTransaction(e)}async signTransaction(e){return P(this,D)[D].signTransaction(e)}constructor(e){super(),Object.defineProperty(this,D,{writable:!0,value:void 0}),P(this,D)[D]=e}}({signTransaction:(0,y.k)("signTransaction was not injected"),signAndSendTransaction:(0,y.k)("signAndSendTransaction was not injected"),signMessage:(0,y.k)("signMessage was not injected")}),em=new class{get version(){return H(this,q)[q]}get name(){return H(this,X)[X]}get icon(){return H(this,ee)[ee]}get chains(){return x.slice()}get features(){return{"standard:connect":{version:"1.0.0",connect:H(this,ec)[ec]},"standard:disconnect":{version:"1.0.0",disconnect:H(this,el)[el]},"standard:events":{version:"1.0.0",on:H(this,ei)[ei]},"solana:signAndSendTransaction":{version:"1.0.0",supportedTransactionVersions:["legacy",0],signAndSendTransaction:H(this,eu)[eu]},"solana:signTransaction":{version:"1.0.0",supportedTransactionVersions:["legacy",0],signTransaction:H(this,eg)[eg]},"solana:signMessage":{version:"1.0.0",signMessage:H(this,ed)[ed]},"privy:":{privy:{signMessage:H(this,en)[en].signMessage,signTransaction:H(this,en)[en].signTransaction,signAndSendTransaction:H(this,en)[en].signAndSendTransaction}}}}get accounts(){return H(this,ea)[ea].slice()}get isPrivyWallet(){return H(this,et)[et]}constructor({name:e,icon:n,version:t,injection:a,wallets:i}){Object.defineProperty(this,es,{value:eh}),Object.defineProperty(this,er,{value:ep}),Object.defineProperty(this,Z,{writable:!0,value:void 0}),Object.defineProperty(this,q,{writable:!0,value:void 0}),Object.defineProperty(this,X,{writable:!0,value:void 0}),Object.defineProperty(this,ee,{writable:!0,value:void 0}),Object.defineProperty(this,en,{writable:!0,value:void 0}),Object.defineProperty(this,et,{writable:!0,value:void 0}),Object.defineProperty(this,ea,{writable:!0,value:void 0}),Object.defineProperty(this,ei,{writable:!0,value:void 0}),Object.defineProperty(this,eo,{writable:!0,value:void 0}),Object.defineProperty(this,ec,{writable:!0,value:void 0}),Object.defineProperty(this,el,{writable:!0,value:void 0}),Object.defineProperty(this,ed,{writable:!0,value:void 0}),Object.defineProperty(this,eu,{writable:!0,value:void 0}),Object.defineProperty(this,eg,{writable:!0,value:void 0}),H(this,Z)[Z]={},H(this,ei)[ei]=(e,n)=>(H(this,Z)[Z][e]?.push(n)||(H(this,Z)[Z][e]=[n]),()=>H(this,er)[er](e,n)),H(this,eo)[eo]=e=>{null!=e&&(H(this,ea)[ea]=e.map(({address:e})=>new G({address:e,publicKey:U.base58.decode(e)}))),H(this,es)[es]("change",{accounts:this.accounts})},H(this,ec)[ec]=async()=>(H(this,es)[es]("change",{accounts:this.accounts}),{accounts:this.accounts}),H(this,el)[el]=async()=>{H(this,es)[es]("change",{accounts:this.accounts})},H(this,ed)[ed]=async(...e)=>{let n=[];for(let{account:t,...a}of e){let{signature:e}=await H(this,en)[en].signMessage({...a,address:t.address});n.push({signedMessage:a.message,signature:e})}return n},H(this,eu)[eu]=async(...e)=>{let n=[];for(let t of e){let{signature:e}=await H(this,en)[en].signAndSendTransaction({...t,transaction:t.transaction,address:t.account.address,chain:t.chain||"solana:mainnet",options:t.options});n.push({signature:e})}return n},H(this,eg)[eg]=async(...e)=>{let n=[];for(let{transaction:t,account:a,options:i,chain:s}of e){let{signedTransaction:e}=await H(this,en)[en].signTransaction({transaction:t,address:a.address,chain:s||"solana:mainnet",options:i});n.push({signedTransaction:e})}return n},H(this,X)[X]=e,H(this,ee)[ee]=n,H(this,q)[q]=t,H(this,en)[en]=a,H(this,ea)[ea]=[],H(this,et)[et]=!0,a.on("accountChanged",H(this,eo)[eo],this),H(this,eo)[eo](i)}}({name:"Privy",version:"1.0.0",icon:"data:image/png;base64,AAABAAEAFBQAAAAAIABlAQAAFgAAAIlQTkcNChoKAAAADUlIRFIAAAAUAAAAFAgGAAAAjYkdDQAAAAlwSFlzAAAOwwAADsMBx2+oZAAAAQVJREFUeJxiYMANZIC4E4ivAPFPIP4FxDeAuB+IlfDowwBMQFwJxF+B+D8O/AOI66Bq8QJGIF6ExyB0vAqImfEZmEeCYTDcgMswPiB+T4aB34FYApuBsWQYBsP52AycToGBK7EZuJECAw9jM3AVBQbuwWZgIwUGTsZmoDkFBnpiMxAEjpJh2FV8iVsbiD+TYBgoDVrgMgwGnID4HRGGgTKBGyHDYEAaiBdCSxh0g/5AU4Q8sYYhAzEgjoGmABBOgFo2eACowFABYn0oVgViAVINkQTiZUD8DIj/ATF6GILEXgLxCiCWIsZAbiAuBeKtQHwHiEHJ6C8UfwHie0C8E4jLoWpRAAAAAP//rcbhsQAAAAZJREFUAwBYFs3VKJ0cuQAAAABJRU5ErkJggg==",wallets:[],injection:ew});var ey=e.i(514131),ev=e.i(377799);e.i(247167);var eT=e.i(631157),eS=e.i(38340),eb=e.i(587896);e.i(696319),e.i(634583);var eI=e.i(441960),eE=e.i(654312),eO=((n=eO||{})[n.Uninitialized=0]="Uninitialized",n[n.Initialized=1]="Initialized",n),eW=((t=eW||{})[t.Legacy=0]="Legacy",t[t.Current=1]="Current",t),eC=((a=eC||{})[a.Nonce=0]="Nonce",a),ej=((i=ej||{})[i.CreateAccount=0]="CreateAccount",i[i.Assign=1]="Assign",i[i.TransferSol=2]="TransferSol",i[i.CreateAccountWithSeed=3]="CreateAccountWithSeed",i[i.AdvanceNonceAccount=4]="AdvanceNonceAccount",i[i.WithdrawNonceAccount=5]="WithdrawNonceAccount",i[i.InitializeNonceAccount=6]="InitializeNonceAccount",i[i.AuthorizeNonceAccount=7]="AuthorizeNonceAccount",i[i.Allocate=8]="Allocate",i[i.AllocateWithSeed=9]="AllocateWithSeed",i[i.AssignWithSeed=10]="AssignWithSeed",i[i.TransferSolWithSeed=11]="TransferSolWithSeed",i[i.UpgradeNonceAccount=12]="UpgradeNonceAccount",i);function eU(e){return!!e&&"object"==typeof e&&"address"in e&&(0,eE.isTransactionSigner)(e)}var eF=e.i(631985),eM=e.i(421720),e_=e.i(104076),ex=e.i(640694),eP=e.i(681964),eN=e.i(223606);function eD({rows:e}){return(0,s.jsx)(w.a,{children:e.filter(e=>!!e).map((e,n)=>null!=e.value||e.isLoading?(0,s.jsxs)(w.R,{children:[(0,s.jsx)(A.L,{children:e.label}),(0,s.jsx)(A.V,{$isLoading:e.isLoading,children:e.value})]},n):null)})}function eL(e){return BigInt(Math.floor(1e9*parseFloat(e)))}function eB(e){return+eR.format(parseFloat(e.toString())/1e9)}e.i(33750),e.i(189934);let eR=Intl.NumberFormat(void 0,{maximumFractionDigits:8});async function ek({tx:e,solanaClient:n,amount:t,asset:a,tokenPrice:i}){if(!e)return null;if("SOL"===a&&i){let a=eL(t),s=(0,ex.g)(a,i),r=await (0,_.f)({solanaClient:n,tx:e});return{amountInUsd:s,feeInUsd:i?(0,ex.g)(r,i):void 0,totalInUsd:(0,ex.g)(a+r,i)}}if("USDC"===a&&i){let a,s="$"+t,r=await (0,_.f)({solanaClient:n,tx:e}),o=(a=parseFloat(r.toString())/ex.L*i)<.01?0:a;return{amountInUsd:s,feeInUsd:(0,ex.g)(r,i),totalInUsd:"$"+(parseFloat(t)+o).toFixed(2)}}if("SOL"===a){let a=eL(t),i=await (0,_.f)({solanaClient:n,tx:e});return{amountInSol:t+" SOL",feeInSol:eB(i)+" SOL",totalInSol:eB(a+i)+" SOL"}}return{amountInUsdc:t+" USDC",feeInSol:eB(await (0,_.f)({solanaClient:n,tx:e}))+" SOL"}}let eV={component:function(){let e=(0,m.u)(),{closePrivyModal:n,createAnalyticsEvent:t}=(0,y.u)(),{data:a,setModalData:i,navigate:A}=(0,v.a)(),{wallets:w}=function(){let{ready:e,wallets:n}=function(){let{client:e}=(0,y.u)(),{ready:n,wallet:t}=function(){let{ready:e}=(0,C.u)(),{user:n}=(0,W.u)(),{signMessage:t}=ef(),{signTransaction:a}=eA(),{signAndSendTransaction:i}=function(){let e=(0,m.u)(),{isHeadlessSigning:n,openModal:t}=(0,y.u)(),{setModalData:a}=(0,v.a)(),{signTransaction:i}=eA(),s=(0,_.u)(),{user:r}=(0,W.u)(),{signWithUserSigner:o}=(0,F.u)();return{signAndSendTransaction:async({transaction:c,address:l,chain:d="solana:mainnet",options:u})=>{let g=(0,v.h)(r,l);if("privy"!==g?.walletClientType)throw new y.a("Wallet is not a Privy wallet",void 0,y.b.EMBEDDED_WALLET_NOT_FOUND);let h=(0,v.d)(g);async function p(n){if(u?.sponsor)return await (async n=>{if(!h)throw new y.a("Sponsoring transactions is only supported for wallets on the TEE stack",y.b.INVALID_DATA);let t=new I.default({appId:e.id,clientId:e.appClientId,storage:M.u}),a=await (0,E.rpc)(t,o,{chain_type:"solana",method:"signAndSendTransaction",sponsor:!0,params:{transaction:(0,_.b)(n).toString("base64"),encoding:"base64"},caip2:`solana:${(await s(d).rpc.getGenesisHash().send()).substring(0,32)}`,wallet_id:g.id});if(a.data&&"hash"in a.data)return{signature:U.base58.decode(a.data.hash)};throw Error("Failed to sign and send transaction")})(n);let{signedTransaction:t}=await i({transaction:n,address:l,chain:d,options:{...u,uiOptions:{...u?.uiOptions,showWalletUIs:!1}}}),{signature:a}=await s(d).sendAndConfirmTransaction(t);return{signature:a}}return n({showWalletUIs:u?.uiOptions?.showWalletUIs})?p(c):new Promise(async(n,i)=>{let s,o,{entropyId:f,entropyIdVerifier:A}=(0,C.g)(r,g);function w(e){return n=>{i(n instanceof y.a?n:new y.a("Failed to connect to wallet",n,e))}}let m={account:g,transaction:c,chain:d,signOnly:!1,uiOptions:u?.uiOptions||{},onConfirm:p,onSuccess:n,onFailure:w(y.b.TRANSACTION_FAILURE),isSponsored:!!u?.sponsor},v={recoveryMethod:g.recoveryMethod,connectingWalletAddress:g.address,entropyId:f,entropyIdVerifier:A,isUnifiedWallet:h,onCompleteNavigateTo:"StandardSignAndSendTransactionScreen",onFailure:w(y.b.UNKNOWN_CONNECT_WALLET_ERROR)};e.fundingConfig&&(s=(0,M.g)({address:l,appConfig:e,methodScreen:"FundingMethodSelectionScreen",fundWalletConfig:{...u,asset:"native-currency",chain:d},externalSolanaFundingScreen:"FundSolWalletWithExternalSolanaWallet"}),o={amount:e.fundingConfig.defaultRecommendedAmount,asset:"SOL",chain:d,destinationAddress:l,afterSuccessScreen:"StandardSignAndSendTransactionScreen",sourceWalletData:void 0}),a({connectWallet:v,standardSignAndSendTransaction:m,funding:s,solanaFundingData:o}),t("EmbeddedWalletConnectingScreen")})}}}(),s=(0,o.useMemo)(()=>{let e=[...(0,v.o)(n).sort((e,n)=>(e.walletIndex??0)-(n.walletIndex??0))],t=(0,v.j)(n);return t.length?[...e,...t]:e},[n]),r=(0,o.useMemo)(()=>({signMessage:async({message:e,address:n,options:a})=>await t({message:e,address:n,options:a}),signTransaction:async({transaction:e,address:n,chain:t,options:i})=>await a({transaction:e,address:n,chain:t,options:i}),async signAndSendTransaction({transaction:e,address:n,chain:t,options:a}){let{signature:s}=await i({transaction:e,address:n,chain:t,options:a});return{signature:s}}}),[t,a,i]);return(0,o.useEffect)(()=>{ew?.setImplementation(r)},[r]),(0,o.useEffect)(()=>{var n;!e||(n=em.accounts).length===s.length&&n.every((e,n)=>e.address===s[n]?.address)||ew?.emit("accountChanged",s)},[e,s]),{ready:e,wallet:em}}(),[a,i]=(0,o.useState)([]),[s,r]=(0,o.useState)([]);return(0,o.useEffect)(()=>{let e=[t,...a.filter(e=>"solana"===e.chainType&&!!e.wallet.features).map(e=>e.wallet)];r(e);let n=a.flatMap(n=>{let t=()=>r([...e]);return n.on("walletsUpdated",t),{connector:n,off:t}}),i=e.map(n=>n.features["standard:events"]?.on("change",()=>{r([...e])}));return()=>{i.forEach(e=>e?.()),n.forEach(({connector:e,off:n})=>e.off("walletsUpdated",n))}},[a]),(0,o.useEffect)(()=>{i(e.connectors?.walletConnectors.filter(e=>"solana"===e.chainType)??[]);let n=()=>{i(e.connectors?.walletConnectors.filter(e=>"solana"===e.chainType)??[])};return e.connectors?.on("connectorInitialized",n),()=>{e.connectors?.off("connectorInitialized",n)}},[n,e.connectors]),{ready:n,wallets:s}}();return{ready:e,wallets:(0,o.useMemo)(()=>n.flatMap(e=>e.accounts.map(n=>new O.ConnectedStandardSolanaWallet({wallet:e,account:n}))),[n])}}(),[b,j]=(0,o.useState)("preparing"),[x,P]=(0,o.useState)(),[N,D]=(0,o.useState)(),[L,B]=(0,o.useState)();if(!a?.solanaFundingData)throw Error("Funding config is missing");if(!a.solanaFundingData.sourceWalletData)throw Error("Funding config is missing source wallet data");let{amount:R,asset:k,chain:V,sourceWalletData:z,destinationAddress:K,afterSuccessScreen:Q}=a.solanaFundingData,Y=w.find(e=>e.address===z.address&&(0,M.t)(z.walletClientType)===(0,M.t)(e.standardWallet.name)),G=(0,_.u)()(V),{tokenPrice:H,isTokenPriceLoading:J}=(0,ey.u)("solana");return(0,o.useEffect)(()=>{if("preparing"!==b||J||!Y)return;let e="SOL"===k?eL(R):BigInt(Math.floor(1e6*parseFloat(R)));D({amount:("SOL"===k&&H?(0,ex.g)(e,H):R)??R}),("SOL"===k?async function({solanaClient:e,source:n,destination:t,amountInLamports:a}){let{value:i}=await e.rpc.getLatestBlockhash().send(),s={address:n},r=(0,eF.pipe)((0,eM.createTransactionMessage)({version:0}),e=>(0,eE.setTransactionMessageFeePayerSigner)(s,e),e=>(0,eM.setTransactionMessageLifetimeUsingBlockhash)(i,e),e=>{var n;let i,r,o,c;return(0,eM.appendTransactionMessageInstruction)((i=(void 0)??"11111111111111111111111111111111",r={source:{value:(n={amount:a,source:s,destination:t}).source??null,isWritable:!0},destination:{value:n.destination??null,isWritable:!0}},o={...n},Object.freeze({accounts:[(c=e=>{if(!e.value)return;let n=e.isWritable?eI.AccountRole.WRITABLE:eI.AccountRole.READONLY;return Object.freeze({address:function(e){if(!e)throw Error("Expected a Address.");return"object"==typeof e&&"address"in e?e.address:Array.isArray(e)?e[0]:e}(e.value),role:eU(e.value)?(0,eI.upgradeRoleToSigner)(n):n,...eU(e.value)?{signer:e.value}:{}})})(r.source),c(r.destination)],data:(0,eb.transformEncoder)((0,eT.getStructEncoder)([["discriminator",(0,eS.getU32Encoder)()],["amount",(0,eS.getU64Encoder)()]]),e=>({...e,discriminator:2})).encode(o),programAddress:i})),e)},e=>(0,S.compileTransaction)(e));return new Uint8Array((0,S.getTransactionEncoder)().encode(r))}({solanaClient:G,source:Y.address,destination:K,amountInLamports:e}):async function({solanaClient:e,source:n,destination:t,amountInBaseUnits:a}){let i=(0,eP.g)(e.chain),{value:s}=await e.rpc.getLatestBlockhash().send(),r={address:n},[o]=await (0,e_.findAssociatedTokenPda)({mint:i,owner:n,tokenProgram:ex.T}),[c]=await (0,e_.findAssociatedTokenPda)({mint:i,owner:t,tokenProgram:ex.T}),[l,d]=await Promise.all([e.rpc.getAccountInfo(o,{commitment:"confirmed",encoding:"jsonParsed"}).send().catch(()=>null),e.rpc.getAccountInfo(c,{commitment:"confirmed",encoding:"jsonParsed"}).send().catch(()=>null)]);if(!l?.value)throw Error(`Source token account does not exist for address: ${n}`);let u=(0,e_.getCreateAssociatedTokenIdempotentInstruction)({payer:r,ata:c,owner:t,mint:i}),g=(0,eF.pipe)((0,eM.createTransactionMessage)({version:0}),e=>(0,eE.setTransactionMessageFeePayerSigner)(r,e),e=>(0,eM.setTransactionMessageLifetimeUsingBlockhash)(s,e),e=>d?.value?e:(0,eM.appendTransactionMessageInstruction)(u,e),e=>(0,eM.appendTransactionMessageInstruction)((0,e_.getTransferInstruction)({source:o,destination:c,authority:r,amount:a}),e),e=>(0,S.compileTransaction)(e));return new Uint8Array((0,S.getTransactionEncoder)().encode(g))}({solanaClient:G,source:Y.address,destination:K,amountInBaseUnits:e})).then(P).catch(e=>{j("error"),B(e)})},[b,R,k,V,Y,K,J,H]),(0,o.useEffect)(()=>{"preparing"===b&&x&&ek({tx:x,solanaClient:G,amount:R,asset:k,tokenPrice:H}).then(e=>{j("loaded"),D({amount:e?.amountInUsd??e?.amountInUsdc??e?.amountInSol??R,fee:e?.feeInUsd??e?.feeInSol,total:e?.totalInUsd??e?.totalInSol})}).catch(e=>{j("error"),B(e)})},[x,R,k,b,H]),(0,o.useEffect)(()=>{"error"===b&&L&&(i({errorModalData:{error:L,previousScreen:"FundSolWalletWithExternalSolanaWallet"},solanaFundingData:a.solanaFundingData}),A("ErrorScreen",!1))},[b,A]),(0,o.useEffect)(()=>{if("success"!==b)return;let e=setTimeout(Q?()=>A(Q):n,m.t);return()=>clearTimeout(e)},[b]),(0,s.jsxs)(s.Fragment,"success"===b?{children:[(0,s.jsx)(h.t,{}),(0,s.jsx)(d.b,{}),(0,s.jsxs)(d.c,{children:[(0,s.jsx)(r.default,{color:"var(--privy-color-success)",width:"64px",height:"64px"}),(0,s.jsx)(g.C,{title:"Success!",description:`Youâ€™ve successfully added ${R} ${k} to your ${e.name} wallet. It may take a minute before the funds are available to use.`})]}),(0,s.jsx)(d.R,{}),(0,s.jsx)(u.B,{})]}:"preparing"===b||"loaded"===b||"sending"===b?{children:[(0,s.jsx)(h.t,{}),(0,s.jsx)(d.e,{style:{marginTop:"16px"},children:(0,s.jsx)(p.I,{icon:Y?.standardWallet.icon,name:Y?.standardWallet.name})}),(0,s.jsx)(g.C,{style:{marginTop:"8px",marginBottom:"12px"},title:"sending"===b&&Y?`Confirming with ${Y.standardWallet.name}`:"Confirm transaction"}),(0,s.jsx)(eD,{rows:[{label:"Source",value:(0,c.formatWalletAddress)(z.address)},{label:"Destination",value:(0,c.formatWalletAddress)(K)},{label:"Network",value:(0,eN.g)(V)},{label:"Amount",value:N?.amount,isLoading:"preparing"===b},{label:"Estimated fee",value:N?.fee,isLoading:"preparing"===b},{label:"Total",value:N?.total,isLoading:"preparing"===b}]}),(0,s.jsx)(l.P,{style:{marginTop:"1rem"},loading:"preparing"===b||"sending"===b,onClick:function(){"loaded"===b&&x&&Y&&(j("sending"),(async function({transaction:e,chain:n,sourceWallet:t,solanaClient:a}){var i;let{hasFunds:s}=await (0,_.s)({solanaClient:a,tx:e});if(!s)throw new y.a(`Wallet ${(0,c.formatWalletAddress)(t.address)} does not have enough funds.`,void 0,y.b.INSUFFICIENT_BALANCE);let r=(i=(await t.signAndSendTransaction({transaction:e,chain:n}).catch(e=>{throw new y.a("Transaction was rejected by the user",e,y.b.TRANSACTION_FAILURE)})).signature,(0,T.getBase58Decoder)().decode(i));return await (0,_.w)({rpcSubscriptions:a.rpcSubscriptions,signature:r,timeout:2e4}),r})({solanaClient:G,transaction:x,chain:V,sourceWallet:Y}).then(e=>{j("success"),t({eventName:ev.O,payload:{provider:"external",status:"success",txHash:e,address:Y.address,value:R,chainType:"solana",clusterName:V,token:k,destinationAddress:K,destinationValue:R,destinationChainType:"solana",destinationClusterName:V,destinationToken:k}})}).catch(e=>{j("error"),B(e)}))},children:"Confirm"}),(0,s.jsx)(u.B,{})]}:{children:[(0,s.jsx)(h.t,{}),(0,s.jsx)(f.N,{}),(0,s.jsx)("div",{style:{marginTop:"1rem"}}),(0,s.jsx)(u.B,{})]})}};e.s(["FundSolWalletWithExternalSolanaWallet",()=>eV,"default",()=>eV],926268)}]);