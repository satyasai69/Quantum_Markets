{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/satyasaichava/Quantum_Markets/frontend/node_modules/x402/src/types/shared/evm/config.ts"],"sourcesContent":["import { Address } from \"viem\";\nimport { Address as SolanaAddress } from \"@solana/kit\";\n\nexport const config: Record<string, ChainConfig> = {\n  \"84532\": {\n    usdcAddress: \"0x036CbD53842c5426634e7929541eC2318f3dCF7e\",\n    usdcName: \"USDC\",\n  },\n  \"8453\": {\n    usdcAddress: \"0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913\",\n    usdcName: \"USD Coin\",\n  },\n  \"43113\": {\n    usdcAddress: \"0x5425890298aed601595a70AB815c96711a31Bc65\",\n    usdcName: \"USD Coin\",\n  },\n  \"43114\": {\n    usdcAddress: \"0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E\",\n    usdcName: \"USD Coin\",\n  },\n  \"4689\": {\n    usdcAddress: \"0xcdf79194c6c285077a58da47641d4dbe51f63542\",\n    usdcName: \"Bridged USDC\",\n  },\n  // solana devnet\n  \"103\": {\n    usdcAddress: \"4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU\" as SolanaAddress,\n    usdcName: \"USDC\",\n  },\n  // solana mainnet\n  \"101\": {\n    usdcAddress: \"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\" as SolanaAddress,\n    usdcName: \"USDC\",\n  },\n  \"1328\": {\n    usdcAddress: \"0x4fcf1784b31630811181f670aea7a7bef803eaed\",\n    usdcName: \"USDC\",\n  },\n  \"1329\": {\n    usdcAddress: \"0xe15fc38f6d8c56af07bbcbe3baf5708a2bf42392\",\n    usdcName: \"USDC\",\n  },\n  \"137\": {\n    usdcAddress: \"0x3c499c542cef5e3811e1192ce70d8cc03d5c3359\",\n    usdcName: \"USD Coin\",\n  },\n  \"80002\": {\n    usdcAddress: \"0x41E94Eb019C0762f9Bfcf9Fb1E58725BfB0e7582\",\n    usdcName: \"USDC\",\n  },\n  \"3338\": {\n    usdcAddress: \"0xbbA60da06c2c5424f03f7434542280FCAd453d10\",\n    usdcName: \"USDC\",\n  },\n  \"2741\": {\n    usdcAddress: \"0x84a71ccd554cc1b02749b35d22f684cc8ec987e1\",\n    usdcName: \"Bridged USDC\",\n  },\n  \"11124\": {\n    usdcAddress: \"0xe4C7fBB0a626ed208021ccabA6Be1566905E2dFc\",\n    usdcName: \"Bridged USDC\",\n  },\n  \"1514\": {\n    usdcAddress: \"0xF1815bd50389c46847f0Bda824eC8da914045D14\",\n    usdcName: \"Bridged USDC\",\n  },\n  \"41923\": {\n    usdcAddress: \"0x12a272A581feE5577A5dFa371afEB4b2F3a8C2F8\",\n    usdcName: \"Bridged USDC (Stargate)\",\n  },\n  \"324705682\": {\n    usdcAddress: \"0x2e08028E3C4c2356572E096d8EF835cD5C6030bD\",\n    usdcName: \"Bridged USDC (SKALE Bridge)\",\n  },\n};\n\nexport type ChainConfig = {\n  usdcAddress: Address | SolanaAddress;\n  usdcName: string;\n};\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;AAGO,IAAM,SAAsC;IACjD,SAAS;QACP,aAAa;QACb,UAAU;IACZ;IACA,QAAQ;QACN,aAAa;QACb,UAAU;IACZ;IACA,SAAS;QACP,aAAa;QACb,UAAU;IACZ;IACA,SAAS;QACP,aAAa;QACb,UAAU;IACZ;IACA,QAAQ;QACN,aAAa;QACb,UAAU;IACZ;IAAA,gBAAA;IAEA,OAAO;QACL,aAAa;QACb,UAAU;IACZ;IAAA,iBAAA;IAEA,OAAO;QACL,aAAa;QACb,UAAU;IACZ;IACA,QAAQ;QACN,aAAa;QACb,UAAU;IACZ;IACA,QAAQ;QACN,aAAa;QACb,UAAU;IACZ;IACA,OAAO;QACL,aAAa;QACb,UAAU;IACZ;IACA,SAAS;QACP,aAAa;QACb,UAAU;IACZ;IACA,QAAQ;QACN,aAAa;QACb,UAAU;IACZ;IACA,QAAQ;QACN,aAAa;QACb,UAAU;IACZ;IACA,SAAS;QACP,aAAa;QACb,UAAU;IACZ;IACA,QAAQ;QACN,aAAa;QACb,UAAU;IACZ;IACA,SAAS;QACP,aAAa;QACb,UAAU;IACZ;IACA,aAAa;QACX,aAAa;QACb,UAAU;IACZ;AACF"}},
    {"offset": {"line": 103, "column": 0}, "map": {"version":3,"sources":["file:///Users/satyasaichava/Quantum_Markets/frontend/node_modules/x402/src/types/shared/evm/erc20PermitABI.ts","file:///Users/satyasaichava/Quantum_Markets/frontend/node_modules/x402/src/shared/evm/usdc.ts","file:///Users/satyasaichava/Quantum_Markets/frontend/node_modules/x402/src/shared/evm/erc20.ts"],"sourcesContent":["export const usdcABI = [\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"owner\",\n        type: \"address\",\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"spender\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"value\",\n        type: \"uint256\",\n      },\n    ],\n    name: \"Approval\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"authorizer\",\n        type: \"address\",\n      },\n      {\n        indexed: true,\n        internalType: \"bytes32\",\n        name: \"nonce\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"AuthorizationCanceled\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"authorizer\",\n        type: \"address\",\n      },\n      {\n        indexed: true,\n        internalType: \"bytes32\",\n        name: \"nonce\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"AuthorizationUsed\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"_account\",\n        type: \"address\",\n      },\n    ],\n    name: \"Blacklisted\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"newBlacklister\",\n        type: \"address\",\n      },\n    ],\n    name: \"BlacklisterChanged\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"burner\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"amount\",\n        type: \"uint256\",\n      },\n    ],\n    name: \"Burn\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"newMasterMinter\",\n        type: \"address\",\n      },\n    ],\n    name: \"MasterMinterChanged\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"minter\",\n        type: \"address\",\n      },\n      { indexed: true, internalType: \"address\", name: \"to\", type: \"address\" },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"amount\",\n        type: \"uint256\",\n      },\n    ],\n    name: \"Mint\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"minter\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"minterAllowedAmount\",\n        type: \"uint256\",\n      },\n    ],\n    name: \"MinterConfigured\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"oldMinter\",\n        type: \"address\",\n      },\n    ],\n    name: \"MinterRemoved\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: false,\n        internalType: \"address\",\n        name: \"previousOwner\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"address\",\n        name: \"newOwner\",\n        type: \"address\",\n      },\n    ],\n    name: \"OwnershipTransferred\",\n    type: \"event\",\n  },\n  { anonymous: false, inputs: [], name: \"Pause\", type: \"event\" },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"newAddress\",\n        type: \"address\",\n      },\n    ],\n    name: \"PauserChanged\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"newRescuer\",\n        type: \"address\",\n      },\n    ],\n    name: \"RescuerChanged\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      { indexed: true, internalType: \"address\", name: \"from\", type: \"address\" },\n      { indexed: true, internalType: \"address\", name: \"to\", type: \"address\" },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"value\",\n        type: \"uint256\",\n      },\n    ],\n    name: \"Transfer\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"_account\",\n        type: \"address\",\n      },\n    ],\n    name: \"UnBlacklisted\",\n    type: \"event\",\n  },\n  { anonymous: false, inputs: [], name: \"Unpause\", type: \"event\" },\n  {\n    inputs: [],\n    name: \"CANCEL_AUTHORIZATION_TYPEHASH\",\n    outputs: [{ internalType: \"bytes32\", name: \"\", type: \"bytes32\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"DOMAIN_SEPARATOR\",\n    outputs: [{ internalType: \"bytes32\", name: \"\", type: \"bytes32\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"PERMIT_TYPEHASH\",\n    outputs: [{ internalType: \"bytes32\", name: \"\", type: \"bytes32\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"RECEIVE_WITH_AUTHORIZATION_TYPEHASH\",\n    outputs: [{ internalType: \"bytes32\", name: \"\", type: \"bytes32\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"TRANSFER_WITH_AUTHORIZATION_TYPEHASH\",\n    outputs: [{ internalType: \"bytes32\", name: \"\", type: \"bytes32\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"owner\", type: \"address\" },\n      { internalType: \"address\", name: \"spender\", type: \"address\" },\n    ],\n    name: \"allowance\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"spender\", type: \"address\" },\n      { internalType: \"uint256\", name: \"value\", type: \"uint256\" },\n    ],\n    name: \"approve\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"authorizer\", type: \"address\" },\n      { internalType: \"bytes32\", name: \"nonce\", type: \"bytes32\" },\n    ],\n    name: \"authorizationState\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"account\", type: \"address\" }],\n    name: \"balanceOf\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"_account\", type: \"address\" }],\n    name: \"blacklist\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"blacklister\",\n    outputs: [{ internalType: \"address\", name: \"\", type: \"address\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"uint256\", name: \"_amount\", type: \"uint256\" }],\n    name: \"burn\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"authorizer\", type: \"address\" },\n      { internalType: \"bytes32\", name: \"nonce\", type: \"bytes32\" },\n      { internalType: \"uint8\", name: \"v\", type: \"uint8\" },\n      { internalType: \"bytes32\", name: \"r\", type: \"bytes32\" },\n      { internalType: \"bytes32\", name: \"s\", type: \"bytes32\" },\n    ],\n    name: \"cancelAuthorization\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"authorizer\", type: \"address\" },\n      { internalType: \"bytes32\", name: \"nonce\", type: \"bytes32\" },\n      { internalType: \"bytes\", name: \"signature\", type: \"bytes\" },\n    ],\n    name: \"cancelAuthorization\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"minter\", type: \"address\" },\n      { internalType: \"uint256\", name: \"minterAllowedAmount\", type: \"uint256\" },\n    ],\n    name: \"configureMinter\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"currency\",\n    outputs: [{ internalType: \"string\", name: \"\", type: \"string\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"decimals\",\n    outputs: [{ internalType: \"uint8\", name: \"\", type: \"uint8\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"spender\", type: \"address\" },\n      { internalType: \"uint256\", name: \"decrement\", type: \"uint256\" },\n    ],\n    name: \"decreaseAllowance\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"spender\", type: \"address\" },\n      { internalType: \"uint256\", name: \"increment\", type: \"uint256\" },\n    ],\n    name: \"increaseAllowance\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"string\", name: \"tokenName\", type: \"string\" },\n      { internalType: \"string\", name: \"tokenSymbol\", type: \"string\" },\n      { internalType: \"string\", name: \"tokenCurrency\", type: \"string\" },\n      { internalType: \"uint8\", name: \"tokenDecimals\", type: \"uint8\" },\n      { internalType: \"address\", name: \"newMasterMinter\", type: \"address\" },\n      { internalType: \"address\", name: \"newPauser\", type: \"address\" },\n      { internalType: \"address\", name: \"newBlacklister\", type: \"address\" },\n      { internalType: \"address\", name: \"newOwner\", type: \"address\" },\n    ],\n    name: \"initialize\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"string\", name: \"newName\", type: \"string\" }],\n    name: \"initializeV2\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"lostAndFound\", type: \"address\" }],\n    name: \"initializeV2_1\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address[]\",\n        name: \"accountsToBlacklist\",\n        type: \"address[]\",\n      },\n      { internalType: \"string\", name: \"newSymbol\", type: \"string\" },\n    ],\n    name: \"initializeV2_2\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"_account\", type: \"address\" }],\n    name: \"isBlacklisted\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"account\", type: \"address\" }],\n    name: \"isMinter\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"masterMinter\",\n    outputs: [{ internalType: \"address\", name: \"\", type: \"address\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"_to\", type: \"address\" },\n      { internalType: \"uint256\", name: \"_amount\", type: \"uint256\" },\n    ],\n    name: \"mint\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"minter\", type: \"address\" }],\n    name: \"minterAllowance\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"name\",\n    outputs: [{ internalType: \"string\", name: \"\", type: \"string\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"owner\", type: \"address\" }],\n    name: \"nonces\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"owner\",\n    outputs: [{ internalType: \"address\", name: \"\", type: \"address\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"pause\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"paused\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"pauser\",\n    outputs: [{ internalType: \"address\", name: \"\", type: \"address\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"owner\", type: \"address\" },\n      { internalType: \"address\", name: \"spender\", type: \"address\" },\n      { internalType: \"uint256\", name: \"value\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"deadline\", type: \"uint256\" },\n      { internalType: \"bytes\", name: \"signature\", type: \"bytes\" },\n    ],\n    name: \"permit\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"owner\", type: \"address\" },\n      { internalType: \"address\", name: \"spender\", type: \"address\" },\n      { internalType: \"uint256\", name: \"value\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"deadline\", type: \"uint256\" },\n      { internalType: \"uint8\", name: \"v\", type: \"uint8\" },\n      { internalType: \"bytes32\", name: \"r\", type: \"bytes32\" },\n      { internalType: \"bytes32\", name: \"s\", type: \"bytes32\" },\n    ],\n    name: \"permit\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"from\", type: \"address\" },\n      { internalType: \"address\", name: \"to\", type: \"address\" },\n      { internalType: \"uint256\", name: \"value\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"validAfter\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"validBefore\", type: \"uint256\" },\n      { internalType: \"bytes32\", name: \"nonce\", type: \"bytes32\" },\n      { internalType: \"bytes\", name: \"signature\", type: \"bytes\" },\n    ],\n    name: \"receiveWithAuthorization\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"from\", type: \"address\" },\n      { internalType: \"address\", name: \"to\", type: \"address\" },\n      { internalType: \"uint256\", name: \"value\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"validAfter\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"validBefore\", type: \"uint256\" },\n      { internalType: \"bytes32\", name: \"nonce\", type: \"bytes32\" },\n      { internalType: \"uint8\", name: \"v\", type: \"uint8\" },\n      { internalType: \"bytes32\", name: \"r\", type: \"bytes32\" },\n      { internalType: \"bytes32\", name: \"s\", type: \"bytes32\" },\n    ],\n    name: \"receiveWithAuthorization\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"minter\", type: \"address\" }],\n    name: \"removeMinter\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"contract IERC20\",\n        name: \"tokenContract\",\n        type: \"address\",\n      },\n      { internalType: \"address\", name: \"to\", type: \"address\" },\n      { internalType: \"uint256\", name: \"amount\", type: \"uint256\" },\n    ],\n    name: \"rescueERC20\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"rescuer\",\n    outputs: [{ internalType: \"address\", name: \"\", type: \"address\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"symbol\",\n    outputs: [{ internalType: \"string\", name: \"\", type: \"string\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"totalSupply\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"to\", type: \"address\" },\n      { internalType: \"uint256\", name: \"value\", type: \"uint256\" },\n    ],\n    name: \"transfer\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"from\", type: \"address\" },\n      { internalType: \"address\", name: \"to\", type: \"address\" },\n      { internalType: \"uint256\", name: \"value\", type: \"uint256\" },\n    ],\n    name: \"transferFrom\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"newOwner\", type: \"address\" }],\n    name: \"transferOwnership\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"from\", type: \"address\" },\n      { internalType: \"address\", name: \"to\", type: \"address\" },\n      { internalType: \"uint256\", name: \"value\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"validAfter\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"validBefore\", type: \"uint256\" },\n      { internalType: \"bytes32\", name: \"nonce\", type: \"bytes32\" },\n      { internalType: \"bytes\", name: \"signature\", type: \"bytes\" },\n    ],\n    name: \"transferWithAuthorization\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"from\", type: \"address\" },\n      { internalType: \"address\", name: \"to\", type: \"address\" },\n      { internalType: \"uint256\", name: \"value\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"validAfter\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"validBefore\", type: \"uint256\" },\n      { internalType: \"bytes32\", name: \"nonce\", type: \"bytes32\" },\n      { internalType: \"uint8\", name: \"v\", type: \"uint8\" },\n      { internalType: \"bytes32\", name: \"r\", type: \"bytes32\" },\n      { internalType: \"bytes32\", name: \"s\", type: \"bytes32\" },\n    ],\n    name: \"transferWithAuthorization\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"_account\", type: \"address\" }],\n    name: \"unBlacklist\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"unpause\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"_newBlacklister\", type: \"address\" }],\n    name: \"updateBlacklister\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"_newMasterMinter\", type: \"address\" }],\n    name: \"updateMasterMinter\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"_newPauser\", type: \"address\" }],\n    name: \"updatePauser\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"newRescuer\", type: \"address\" }],\n    name: \"updateRescuer\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"version\",\n    outputs: [{ internalType: \"string\", name: \"\", type: \"string\" }],\n    stateMutability: \"pure\",\n    type: \"function\",\n  },\n] as const;\n","import { Account, Address, Chain, Client, Transport } from \"viem\";\nimport { ChainConfig, config } from \"../../types/shared/evm/config\";\nimport { usdcABI as abi } from \"../../types/shared/evm/erc20PermitABI\";\nimport { ConnectedClient } from \"../../types/shared/evm/wallet\";\n\n/**\n * Gets the USDC contract address for the current chain from the client\n *\n * @param client - The Viem client instance connected to the blockchain\n * @returns The USDC contract address for the current chain\n */\nexport function getUsdcAddress<\n  transport extends Transport,\n  chain extends Chain | undefined = undefined,\n  account extends Account | undefined = undefined,\n>(client: Client<transport, chain, account>): Address {\n  return config[client.chain!.id.toString()].usdcAddress as Address;\n}\n\n/**\n * Gets the USDC contract address for a specific chain ID\n *\n * @deprecated Use `getUsdcChainConfigForChain` instead\n * @param chainId - The chain ID to get the USDC contract address for\n * @returns The USDC contract address for the specified chain\n */\nexport function getUsdcAddressForChain(chainId: number): Address {\n  return config[chainId.toString()].usdcAddress as Address;\n}\n\n/**\n * Gets the USDC address and eip712 domain name for a specific chain ID\n *\n * @param chainId - The chain ID\n * @returns The USDC contract address and eip712 domain name  for the specified chain\n */\nexport function getUsdcChainConfigForChain(chainId: number): ChainConfig | undefined {\n  return config[chainId.toString()];\n}\n\n// Cache for storing the version value\nlet versionCache: string | null = null;\n\n/**\n * Gets the version of the USDC contract, using a cache to avoid repeated calls\n *\n * @param client - The Viem client instance connected to the blockchain\n * @returns A promise that resolves to the USDC contract version string\n */\nexport async function getVersion<\n  transport extends Transport,\n  chain extends Chain,\n  account extends Account | undefined = undefined,\n>(client: ConnectedClient<transport, chain, account>): Promise<string> {\n  // Return cached version if available\n  if (versionCache !== null) {\n    return versionCache;\n  }\n\n  // Fetch and cache version if not available\n  const version = await client.readContract({\n    address: getUsdcAddress(client),\n    abi,\n    functionName: \"version\",\n  });\n  versionCache = version as string;\n  return versionCache;\n}\n\n/**\n * Gets the USDC balance for a specific address\n *\n * @param client - The Viem client instance connected to the blockchain\n * @param address - The address to check the USDC balance for\n * @returns A promise that resolves to the USDC balance as a bigint\n */\nexport async function getUSDCBalance<\n  transport extends Transport,\n  chain extends Chain,\n  account extends Account | undefined = undefined,\n>(client: ConnectedClient<transport, chain, account>, address: Address): Promise<bigint> {\n  const chainId = client.chain!.id;\n  const usdc = getUsdcChainConfigForChain(chainId);\n  if (!usdc) {\n    return 0n;\n  }\n  const balance = await client.readContract({\n    address: usdc.usdcAddress as `0x${string}`,\n    abi,\n    functionName: \"balanceOf\",\n    args: [address],\n  });\n  return balance as bigint;\n}\n","import { Account, Address, Chain, Transport } from \"viem\";\nimport { usdcABI as erc20PermitABI } from \"../../types/shared/evm/erc20PermitABI\";\nimport { ConnectedClient } from \"../../types/shared/evm/wallet\";\n\n/**\n * Gets the USDC balance for a specific address\n *\n * @param client - The Viem client instance connected to the blockchain\n * @param erc20Address - The address of the ERC20 contract\n * @param address - The address to check the USDC balance for\n * @returns A promise that resolves to the USDC balance as a bigint\n */\nexport async function getERC20Balance<\n  transport extends Transport,\n  chain extends Chain,\n  account extends Account | undefined = undefined,\n>(\n  client: ConnectedClient<transport, chain, account>,\n  erc20Address: Address,\n  address: Address,\n): Promise<bigint> {\n  const balance = await client.readContract({\n    address: erc20Address,\n    abi: erc20PermitABI,\n    functionName: \"balanceOf\",\n    args: [address],\n  });\n  return balance as bigint;\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;AAAO,IAAM,UAAU;IACrB;QACE,WAAW;QACX,QAAQ;YACN;gBACE,SAAS;gBACT,cAAc;gBACd,MAAM;gBACN,MAAM;YACR;YACA;gBACE,SAAS;gBACT,cAAc;gBACd,MAAM;gBACN,MAAM;YACR;YACA;gBACE,SAAS;gBACT,cAAc;gBACd,MAAM;gBACN,MAAM;YACR;SACF;QACA,MAAM;QACN,MAAM;IACR;IACA;QACE,WAAW;QACX,QAAQ;YACN;gBACE,SAAS;gBACT,cAAc;gBACd,MAAM;gBACN,MAAM;YACR;YACA;gBACE,SAAS;gBACT,cAAc;gBACd,MAAM;gBACN,MAAM;YACR;SACF;QACA,MAAM;QACN,MAAM;IACR;IACA;QACE,WAAW;QACX,QAAQ;YACN;gBACE,SAAS;gBACT,cAAc;gBACd,MAAM;gBACN,MAAM;YACR;YACA;gBACE,SAAS;gBACT,cAAc;gBACd,MAAM;gBACN,MAAM;YACR;SACF;QACA,MAAM;QACN,MAAM;IACR;IACA;QACE,WAAW;QACX,QAAQ;YACN;gBACE,SAAS;gBACT,cAAc;gBACd,MAAM;gBACN,MAAM;YACR;SACF;QACA,MAAM;QACN,MAAM;IACR;IACA;QACE,WAAW;QACX,QAAQ;YACN;gBACE,SAAS;gBACT,cAAc;gBACd,MAAM;gBACN,MAAM;YACR;SACF;QACA,MAAM;QACN,MAAM;IACR;IACA;QACE,WAAW;QACX,QAAQ;YACN;gBACE,SAAS;gBACT,cAAc;gBACd,MAAM;gBACN,MAAM;YACR;YACA;gBACE,SAAS;gBACT,cAAc;gBACd,MAAM;gBACN,MAAM;YACR;SACF;QACA,MAAM;QACN,MAAM;IACR;IACA;QACE,WAAW;QACX,QAAQ;YACN;gBACE,SAAS;gBACT,cAAc;gBACd,MAAM;gBACN,MAAM;YACR;SACF;QACA,MAAM;QACN,MAAM;IACR;IACA;QACE,WAAW;QACX,QAAQ;YACN;gBACE,SAAS;gBACT,cAAc;gBACd,MAAM;gBACN,MAAM;YACR;YACA;gBAAE,SAAS;gBAAM,cAAc;gBAAW,MAAM;gBAAM,MAAM;YAAU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"}},
    {"offset": {"line": 1567, "column": 0}, "map": {"version":3,"sources":["file:///Users/satyasaichava/Quantum_Markets/frontend/node_modules/x402/src/types/shared/money.ts","file:///Users/satyasaichava/Quantum_Markets/frontend/node_modules/x402/src/types/shared/network.ts","file:///Users/satyasaichava/Quantum_Markets/frontend/node_modules/x402/src/types/shared/evm/wallet.ts","file:///Users/satyasaichava/Quantum_Markets/frontend/node_modules/x402/src/types/shared/custom-chains/eip155-324705682.ts","file:///Users/satyasaichava/Quantum_Markets/frontend/node_modules/x402/src/shared/svm/wallet.ts","file:///Users/satyasaichava/Quantum_Markets/frontend/node_modules/x402/src/shared/svm/rpc.ts","file:///Users/satyasaichava/Quantum_Markets/frontend/node_modules/x402/src/types/shared/wallet.ts","file:///Users/satyasaichava/Quantum_Markets/frontend/node_modules/x402/src/types/shared/evm/index.ts","file:///Users/satyasaichava/Quantum_Markets/frontend/node_modules/x402/src/types/shared/evm/eip3009.ts","file:///Users/satyasaichava/Quantum_Markets/frontend/node_modules/x402/src/types/shared/svm/index.ts","file:///Users/satyasaichava/Quantum_Markets/frontend/node_modules/x402/src/types/shared/svm/regex.ts","file:///Users/satyasaichava/Quantum_Markets/frontend/node_modules/x402/src/types/verify/x402Specs.ts","file:///Users/satyasaichava/Quantum_Markets/frontend/node_modules/x402/src/shared/base64.ts","file:///Users/satyasaichava/Quantum_Markets/frontend/node_modules/x402/src/types/verify/facilitator.ts","file:///Users/satyasaichava/Quantum_Markets/frontend/node_modules/x402/src/shared/json.ts","file:///Users/satyasaichava/Quantum_Markets/frontend/node_modules/x402/src/shared/network.ts","file:///Users/satyasaichava/Quantum_Markets/frontend/node_modules/x402/src/shared/middleware.ts","file:///Users/satyasaichava/Quantum_Markets/frontend/node_modules/x402/src/shared/svm/index.ts","file:///Users/satyasaichava/Quantum_Markets/frontend/node_modules/x402/src/shared/svm/transaction.ts"],"sourcesContent":["import { z } from \"zod\";\n\nexport const moneySchema = z\n  .union([z.string().transform(x => x.replace(/[^0-9.-]+/g, \"\")), z.number()])\n  .pipe(z.coerce.number().min(0.0001).max(999999999));\n\nexport type Money = z.input<typeof moneySchema>;\n","import { z } from \"zod\";\n\nexport const NetworkSchema = z.enum([\n  \"abstract\",\n  \"abstract-testnet\",\n  \"base-sepolia\",\n  \"base\",\n  \"avalanche-fuji\",\n  \"avalanche\",\n  \"iotex\",\n  \"solana-devnet\",\n  \"solana\",\n  \"sei\",\n  \"sei-testnet\",\n  \"polygon\",\n  \"polygon-amoy\",\n  \"peaq\",\n  \"story\",\n  \"educhain\",\n  \"skale-base-sepolia\",\n]);\nexport type Network = z.infer<typeof NetworkSchema>;\n\n// evm\nexport const SupportedEVMNetworks: Network[] = [\n  \"abstract\",\n  \"abstract-testnet\",\n  \"base-sepolia\",\n  \"base\",\n  \"avalanche-fuji\",\n  \"avalanche\",\n  \"iotex\",\n  \"sei\",\n  \"sei-testnet\",\n  \"polygon\",\n  \"polygon-amoy\",\n  \"peaq\",\n  \"story\",\n  \"educhain\",\n  \"skale-base-sepolia\",\n];\nexport const EvmNetworkToChainId = new Map<Network, number>([\n  [\"abstract\", 2741],\n  [\"abstract-testnet\", 11124],\n  [\"base-sepolia\", 84532],\n  [\"base\", 8453],\n  [\"avalanche-fuji\", 43113],\n  [\"avalanche\", 43114],\n  [\"iotex\", 4689],\n  [\"sei\", 1329],\n  [\"sei-testnet\", 1328],\n  [\"polygon\", 137],\n  [\"polygon-amoy\", 80002],\n  [\"peaq\", 3338],\n  [\"story\", 1514],\n  [\"educhain\", 41923],\n  [\"skale-base-sepolia\", 324705682],\n]);\n\n// svm\nexport const SupportedSVMNetworks: Network[] = [\"solana-devnet\", \"solana\"];\nexport const SvmNetworkToChainId = new Map<Network, number>([\n  [\"solana-devnet\", 103],\n  [\"solana\", 101],\n]);\n\nexport const ChainIdToNetwork = Object.fromEntries(\n  [...SupportedEVMNetworks, ...SupportedSVMNetworks].map(network => [\n    EvmNetworkToChainId.get(network),\n    network,\n  ]),\n) as Record<number, Network>;\n","import { createPublicClient, createWalletClient, http, publicActions } from \"viem\";\nimport type {\n  Chain,\n  Transport,\n  Client,\n  Account,\n  RpcSchema,\n  PublicActions,\n  WalletActions,\n  PublicClient,\n  LocalAccount,\n} from \"viem\";\nimport {\n  baseSepolia,\n  avalancheFuji,\n  base,\n  sei,\n  seiTestnet,\n  polygon,\n  polygonAmoy,\n  peaq,\n  avalanche,\n  iotexTestnet,\n  iotex,\n  abstract,\n  abstractTestnet,\n  story,\n  eduChain,\n} from \"viem/chains\";\nimport { skaleBaseSepolia } from \"../custom-chains\";\nimport { privateKeyToAccount } from \"viem/accounts\";\nimport { Hex } from \"viem\";\nimport { eip712WalletActions } from \"viem/zksync\";\n\n// Create a public client for reading data\nexport type SignerWallet<\n  chain extends Chain = Chain,\n  transport extends Transport = Transport,\n  account extends Account = Account,\n> = Client<\n  transport,\n  chain,\n  account,\n  RpcSchema,\n  PublicActions<transport, chain, account> & WalletActions<chain, account>\n>;\n\nexport type ConnectedClient<\n  transport extends Transport = Transport,\n  chain extends Chain | undefined = Chain,\n  account extends Account | undefined = undefined,\n> = PublicClient<transport, chain, account>;\n\nexport type EvmSigner = SignerWallet<Chain, Transport, Account> | LocalAccount;\n\n/**\n * Creates a public client configured for the specified network\n *\n * @param network - The network to connect to\n * @returns A public client instance connected to the specified chain\n */\nexport function createConnectedClient(\n  network: string,\n): ConnectedClient<Transport, Chain, undefined> {\n  const chain = getChainFromNetwork(network);\n\n  return createPublicClient({\n    chain,\n    transport: http(),\n  }).extend(publicActions);\n}\n\n/**\n * Creates a public client configured for the Base Sepolia testnet\n *\n * @deprecated Use `createConnectedClient(\"base-sepolia\")` instead\n * @returns A public client instance connected to Base Sepolia\n */\nexport function createClientSepolia(): ConnectedClient<Transport, typeof baseSepolia, undefined> {\n  return createConnectedClient(\"base-sepolia\") as ConnectedClient<\n    Transport,\n    typeof baseSepolia,\n    undefined\n  >;\n}\n\n/**\n * Creates a public client configured for the Avalanche Fuji testnet\n *\n * @deprecated Use `createConnectedClient(\"avalanche-fuji\")` instead\n * @returns A public client instance connected to Avalanche Fuji\n */\nexport function createClientAvalancheFuji(): ConnectedClient<\n  Transport,\n  typeof avalancheFuji,\n  undefined\n> {\n  return createConnectedClient(\"avalanche-fuji\") as ConnectedClient<\n    Transport,\n    typeof avalancheFuji,\n    undefined\n  >;\n}\n\n/**\n * Creates a wallet client configured for the specified chain with a private key\n *\n * @param network - The network to connect to\n * @param privateKey - The private key to use for signing transactions\n * @returns A wallet client instance connected to the specified chain with the provided private key\n */\nexport function createSigner(network: string, privateKey: Hex): SignerWallet<Chain> {\n  const chain = getChainFromNetwork(network);\n\n  const walletClient = createWalletClient({\n    chain,\n    transport: http(),\n    account: privateKeyToAccount(privateKey),\n  });\n\n  if (isZkStackChain(chain)) {\n    return walletClient.extend(publicActions).extend(eip712WalletActions());\n  }\n\n  return walletClient.extend(publicActions);\n}\n\n/**\n * Creates a wallet client configured for the Base Sepolia testnet with a private key\n *\n * @deprecated Use `createSigner(\"base-sepolia\", privateKey)` instead\n * @param privateKey - The private key to use for signing transactions\n * @returns A wallet client instance connected to Base Sepolia with the provided private key\n */\nexport function createSignerSepolia(privateKey: Hex): SignerWallet<typeof baseSepolia> {\n  return createSigner(\"base-sepolia\", privateKey) as SignerWallet<typeof baseSepolia>;\n}\n\n/**\n * Creates a wallet client configured for the Avalanche Fuji testnet with a private key\n *\n * @deprecated Use `createSigner(\"avalanche-fuji\", privateKey)` instead\n * @param privateKey - The private key to use for signing transactions\n * @returns A wallet client instance connected to Avalanche Fuji with the provided private key\n */\nexport function createSignerAvalancheFuji(privateKey: Hex): SignerWallet<typeof avalancheFuji> {\n  return createSigner(\"avalanche-fuji\", privateKey) as SignerWallet<typeof avalancheFuji>;\n}\n\n/**\n * Checks if a wallet is a signer wallet\n *\n * @param wallet - The wallet to check\n * @returns True if the wallet is a signer wallet, false otherwise\n */\nexport function isSignerWallet<\n  TChain extends Chain = Chain,\n  TTransport extends Transport = Transport,\n  TAccount extends Account = Account,\n>(\n  wallet: SignerWallet<TChain, TTransport, TAccount> | LocalAccount,\n): wallet is SignerWallet<TChain, TTransport, TAccount> {\n  return (\n    typeof wallet === \"object\" && wallet !== null && \"chain\" in wallet && \"transport\" in wallet\n  );\n}\n\n/**\n * Checks if a wallet is an account\n *\n * @param wallet - The wallet to check\n * @returns True if the wallet is an account, false otherwise\n */\nexport function isAccount<\n  TChain extends Chain = Chain,\n  TTransport extends Transport = Transport,\n  TAccount extends Account = Account,\n>(wallet: SignerWallet<TChain, TTransport, TAccount> | LocalAccount): wallet is LocalAccount {\n  const w = wallet as LocalAccount;\n  return (\n    typeof wallet === \"object\" &&\n    wallet !== null &&\n    typeof w.address === \"string\" &&\n    typeof w.type === \"string\" &&\n    // Check for essential signing capabilities\n    typeof w.sign === \"function\" &&\n    typeof w.signMessage === \"function\" &&\n    typeof w.signTypedData === \"function\" &&\n    // Check for transaction signing (required by LocalAccount)\n    typeof w.signTransaction === \"function\"\n  );\n}\n\n/**\n * Maps network strings to Chain objects\n *\n * @param network - The network string to convert to a Chain object\n * @returns The corresponding Chain object\n */\nexport function getChainFromNetwork(network: string | undefined): Chain {\n  if (!network) {\n    throw new Error(\"NETWORK environment variable is not set\");\n  }\n\n  switch (network) {\n    case \"abstract\":\n      return abstract;\n    case \"abstract-testnet\":\n      return abstractTestnet;\n    case \"base\":\n      return base;\n    case \"base-sepolia\":\n      return baseSepolia;\n    case \"avalanche\":\n      return avalanche;\n    case \"avalanche-fuji\":\n      return avalancheFuji;\n    case \"sei\":\n      return sei;\n    case \"sei-testnet\":\n      return seiTestnet;\n    case \"polygon\":\n      return polygon;\n    case \"polygon-amoy\":\n      return polygonAmoy;\n    case \"peaq\":\n      return peaq;\n    case \"story\":\n      return story;\n    case \"educhain\":\n      return eduChain;\n    case \"iotex\":\n      return iotex;\n    case \"iotex-testnet\":\n      return iotexTestnet;\n    case \"skale-base-sepolia\":\n      return skaleBaseSepolia;\n    default:\n      throw new Error(`Unsupported network: ${network}`);\n  }\n}\n\nconst ZKSTACK_CHAIN_IDS = new Set([\n  2741, // Abstract Mainnet\n  11124, // Abstract Sepolia Testnet\n]);\n\n/**\n * Checks whether the given chain is part of the zkstack stack\n *\n * @param chain - The chain to check\n * @returns True if the chain is a ZK stack chain\n */\nexport function isZkStackChain(chain: Chain): boolean {\n  return ZKSTACK_CHAIN_IDS.has(chain.id);\n}\n","import { type Chain } from \"viem\";\n\n// This chain isactive and is waiting for addition to https://github.com/ethereum-lists/chains\n// before it can be added to wevm/viem/chains.\nexport const skaleBaseSepolia = {\n  id: 324705682,\n  name: \"SKALE Base Sepolia\",\n  nativeCurrency: {\n    name: \"Credits\",\n    symbol: \"CREDITS\",\n    decimals: 18,\n  },\n  rpcUrls: {\n    default: {\n      http: [\"https://base-sepolia-testnet.skalenodes.com/v1/jubilant-horrible-ancha\"],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: \"Blockscout\",\n      url: \"https://base-sepolia-testnet-explorer.skalenodes.com\",\n      apiUrl: \"https://base-sepolia-testnet-explorer.skalenodes.com/api\",\n    },\n  },\n} satisfies Chain;\n","import {\n  createKeyPairSignerFromBytes,\n  createKeyPairSignerFromPrivateKeyBytes,\n  type RpcDevnet,\n  type SolanaRpcApiDevnet,\n  type RpcMainnet,\n  type SolanaRpcApiMainnet,\n  type TransactionSigner,\n  isTransactionSigner,\n} from \"@solana/kit\";\nimport { base58 } from \"@scure/base\";\nimport { getRpcClient } from \"./rpc\";\nimport { Network, SupportedSVMNetworks } from \"../../types/shared\";\nexport type { KeyPairSigner } from \"@solana/kit\";\n\nexport type SvmConnectedClient = RpcDevnet<SolanaRpcApiDevnet> | RpcMainnet<SolanaRpcApiMainnet>;\nexport type SvmSigner = TransactionSigner;\n\n/**\n * Creates a public client configured for the specified SVM network\n *\n * @param network - The network to connect to\n * @returns A public client instance connected to the specified chain\n */\nexport function createSvmConnectedClient(network: string): SvmConnectedClient {\n  if (!SupportedSVMNetworks.find(n => n === network)) {\n    throw new Error(`Unsupported SVM network: ${network}`);\n  }\n  return getRpcClient(network as Network);\n}\n\n/**\n * Creates a Solana signer from a private key.\n *\n * @param privateKey - The base58 encoded private key to create a signer from.\n * @returns A Solana signer.\n */\nexport async function createSignerFromBase58(privateKey: string): Promise<TransactionSigner> {\n  // decode the base58 encoded private key\n  const bytes = base58.decode(privateKey);\n\n  // generate a keypair signer from the bytes based on the byte-length\n  // 64 bytes represents concatenated private + public key\n  if (bytes.length === 64) {\n    return await createKeyPairSignerFromBytes(bytes);\n  }\n  // 32 bytes represents only the private key\n  if (bytes.length === 32) {\n    return await createKeyPairSignerFromPrivateKeyBytes(bytes);\n  }\n  throw new Error(`Unexpected key length: ${bytes.length}. Expected 32 or 64 bytes.`);\n}\n\n/**\n * Checks if the given wallet is a Solana transaction signer wallet.\n *\n * @param wallet - The object wallet to check.\n * @returns True if the wallet satisfies the TransactionSigner interface.\n */\nexport function isSignerWallet(wallet: unknown): wallet is SvmSigner {\n  return (\n    typeof wallet === \"object\" &&\n    wallet !== null &&\n    isTransactionSigner(wallet as TransactionSigner)\n  );\n}\n","import {\n  createSolanaRpc,\n  devnet,\n  mainnet,\n  RpcDevnet,\n  SolanaRpcApiDevnet,\n  SolanaRpcApiMainnet,\n  RpcMainnet,\n  createSolanaRpcSubscriptions,\n  RpcSubscriptionsFromTransport,\n  SolanaRpcSubscriptionsApi,\n  RpcSubscriptionsTransportFromClusterUrl,\n  ClusterUrl,\n} from \"@solana/kit\";\nimport { Network } from \"../../types/shared\";\n\n/**\n * Default public RPC endpoint for Solana devnet\n */\nconst DEVNET_RPC_URL = \"https://api.devnet.solana.com\";\n\n/**\n * Default public RPC endpoint for Solana mainnet\n */\nconst MAINNET_RPC_URL = \"https://api.mainnet-beta.solana.com\";\n\n/**\n * Default public WebSocket endpoint for Solana devnet\n */\nconst DEVNET_WS_URL = \"wss://api.devnet.solana.com\";\n\n/**\n * Default public WebSocket endpoint for Solana mainnet\n */\nconst MAINNET_WS_URL = \"wss://api.mainnet-beta.solana.com\";\n\n/**\n * Creates a Solana RPC client for the devnet network.\n *\n * @param url - Optional URL of the devnet network.\n * @returns A Solana RPC client.\n */\nexport function createDevnetRpcClient(url?: string): RpcDevnet<SolanaRpcApiDevnet> {\n  return createSolanaRpc(\n    url ? devnet(url) : devnet(DEVNET_RPC_URL),\n  ) as RpcDevnet<SolanaRpcApiDevnet>;\n}\n\n/**\n * Creates a Solana RPC client for the mainnet network.\n *\n * @param url - Optional URL of the mainnet network.\n * @returns A Solana RPC client.\n */\nexport function createMainnetRpcClient(url?: string): RpcMainnet<SolanaRpcApiMainnet> {\n  return createSolanaRpc(\n    url ? mainnet(url) : mainnet(MAINNET_RPC_URL),\n  ) as RpcMainnet<SolanaRpcApiMainnet>;\n}\n\n/**\n * Gets the RPC client for the given network.\n *\n * @param network - The network to get the RPC client for\n * @param url - Optional URL of the network. If not provided, the default URL will be used.\n * @returns The RPC client for the given network\n */\nexport function getRpcClient(\n  network: Network,\n  url?: string,\n): RpcDevnet<SolanaRpcApiDevnet> | RpcMainnet<SolanaRpcApiMainnet> {\n  // TODO: should the networks be replaced with enum references?\n  if (network === \"solana-devnet\") {\n    return createDevnetRpcClient(url);\n  } else if (network === \"solana\") {\n    return createMainnetRpcClient(url);\n  } else {\n    throw new Error(\"Invalid network\");\n  }\n}\n\n/**\n * Gets the RPC subscriptions for the given network.\n *\n * @param network - The network to get the RPC subscriptions for\n * @param url - Optional URL of the network. If not provided, the default URL will be used.\n * @returns The RPC subscriptions for the given network\n */\nexport function getRpcSubscriptions(\n  network: Network,\n  url?: string,\n): RpcSubscriptionsFromTransport<\n  SolanaRpcSubscriptionsApi,\n  RpcSubscriptionsTransportFromClusterUrl<ClusterUrl>\n> {\n  // TODO: should the networks be replaced with enum references?\n  if (network === \"solana-devnet\") {\n    return createSolanaRpcSubscriptions(devnet(url ? httpToWs(url) : DEVNET_WS_URL));\n  } else if (network === \"solana\") {\n    return createSolanaRpcSubscriptions(mainnet(url ? httpToWs(url) : MAINNET_WS_URL));\n  } else {\n    throw new Error(\"Invalid network\");\n  }\n}\n\n/**\n *\n * Converts an HTTP URL to a WebSocket URL\n *\n * @param url - The URL to convert to a WebSocket URL\n * @returns The WebSocket URL\n */\nfunction httpToWs(url: string): string {\n  if (url.startsWith(\"http\")) {\n    return url.replace(\"http\", \"ws\");\n  }\n  return url;\n}\n","import * as evm from \"./evm/wallet\";\nimport * as svm from \"../../shared/svm/wallet\";\nimport { SupportedEVMNetworks, SupportedSVMNetworks } from \"./network\";\nimport { Hex } from \"viem\";\n\nexport type ConnectedClient = evm.ConnectedClient | svm.SvmConnectedClient;\nexport type Signer = evm.EvmSigner | svm.SvmSigner;\nexport type MultiNetworkSigner = { evm: evm.EvmSigner; svm: svm.SvmSigner };\n\n/**\n * Creates a public client configured for the specified network.\n *\n * @param network - The network to connect to.\n * @returns A public client instance connected to the specified chain.\n */\nexport function createConnectedClient(network: string): ConnectedClient {\n  if (SupportedEVMNetworks.find(n => n === network)) {\n    return evm.createConnectedClient(network);\n  }\n\n  if (SupportedSVMNetworks.find(n => n === network)) {\n    return svm.createSvmConnectedClient(network);\n  }\n\n  throw new Error(`Unsupported network: ${network}`);\n}\n\n/**\n * Creates a wallet client configured for the specified chain with a private key.\n *\n * @param network - The network to connect to.\n * @param privateKey - The private key to use for signing transactions. This should be a hex string for EVM or a base58 encoded string for SVM.\n * @returns A wallet client instance connected to the specified chain with the provided private key.\n */\nexport function createSigner(network: string, privateKey: Hex | string): Promise<Signer> {\n  // evm\n  if (SupportedEVMNetworks.find(n => n === network)) {\n    return Promise.resolve(evm.createSigner(network, privateKey as Hex));\n  }\n\n  // svm\n  if (SupportedSVMNetworks.find(n => n === network)) {\n    return svm.createSignerFromBase58(privateKey as string);\n  }\n\n  throw new Error(`Unsupported network: ${network}`);\n}\n\n/**\n * Checks if the given wallet is an EVM signer wallet.\n *\n * @param wallet - The object wallet to check.\n * @returns True if the wallet is an EVM signer wallet, false otherwise.\n */\nexport function isEvmSignerWallet(wallet: Signer): wallet is evm.EvmSigner {\n  return evm.isSignerWallet(wallet as evm.EvmSigner) || evm.isAccount(wallet as evm.EvmSigner);\n}\n\n/**\n * Checks if the given wallet is an SVM signer wallet\n *\n * @param wallet - The object wallet to check\n * @returns True if the wallet is an SVM signer wallet, false otherwise\n */\nexport function isSvmSignerWallet(wallet: Signer): wallet is svm.SvmSigner {\n  return svm.isSignerWallet(wallet);\n}\n\n/**\n * Checks if the given wallet is a multi network signer wallet\n *\n * @param wallet - The object wallet to check\n * @returns True if the wallet is a multi network signer wallet, false otherwise\n */\nexport function isMultiNetworkSigner(wallet: object): wallet is MultiNetworkSigner {\n  return \"evm\" in wallet && \"svm\" in wallet;\n}\n","export * from \"./config\";\nexport * from \"./eip3009\";\nexport * from \"./erc20PermitABI\";\nexport * from \"./wallet\";\n","export const authorizationTypes = {\n  TransferWithAuthorization: [\n    { name: \"from\", type: \"address\" },\n    { name: \"to\", type: \"address\" },\n    { name: \"value\", type: \"uint256\" },\n    { name: \"validAfter\", type: \"uint256\" },\n    { name: \"validBefore\", type: \"uint256\" },\n    { name: \"nonce\", type: \"bytes32\" },\n  ],\n};\n\nexport const authorizationPrimaryType = \"TransferWithAuthorization\";\n","export * from \"./regex\";\n","export const SvmAddressRegex = /^[1-9A-HJ-NP-Za-km-z]{32,44}$/;\n","import { z } from \"zod\";\nimport { NetworkSchema } from \"../shared\";\nimport { SvmAddressRegex } from \"../shared/svm\";\nimport { Base64EncodedRegex } from \"../../shared/base64\";\n\n// Constants\nconst EvmMaxAtomicUnits = 18;\nconst EvmAddressRegex = /^0x[0-9a-fA-F]{40}$/;\nconst MixedAddressRegex = /^0x[a-fA-F0-9]{40}|[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$/;\nconst HexEncoded64ByteRegex = /^0x[0-9a-fA-F]{64}$/;\nconst EvmSignatureRegex = /^0x[0-9a-fA-F]+$/; // Flexible hex signature validation\n// Enums\nexport const schemes = [\"exact\"] as const;\nexport const x402Versions = [1] as const;\nexport const ErrorReasons = [\n  \"insufficient_funds\",\n  \"invalid_exact_evm_payload_authorization_valid_after\",\n  \"invalid_exact_evm_payload_authorization_valid_before\",\n  \"invalid_exact_evm_payload_authorization_value\",\n  \"invalid_exact_evm_payload_signature\",\n  \"invalid_exact_evm_payload_undeployed_smart_wallet\",\n  \"invalid_exact_evm_payload_recipient_mismatch\",\n  \"invalid_exact_svm_payload_transaction\",\n  \"invalid_exact_svm_payload_transaction_amount_mismatch\",\n  \"invalid_exact_svm_payload_transaction_create_ata_instruction\",\n  \"invalid_exact_svm_payload_transaction_create_ata_instruction_incorrect_payee\",\n  \"invalid_exact_svm_payload_transaction_create_ata_instruction_incorrect_asset\",\n  \"invalid_exact_svm_payload_transaction_instructions\",\n  \"invalid_exact_svm_payload_transaction_instructions_length\",\n  \"invalid_exact_svm_payload_transaction_instructions_compute_limit_instruction\",\n  \"invalid_exact_svm_payload_transaction_instructions_compute_price_instruction\",\n  \"invalid_exact_svm_payload_transaction_instructions_compute_price_instruction_too_high\",\n  \"invalid_exact_svm_payload_transaction_instruction_not_spl_token_transfer_checked\",\n  \"invalid_exact_svm_payload_transaction_instruction_not_token_2022_transfer_checked\",\n  \"invalid_exact_svm_payload_transaction_fee_payer_included_in_instruction_accounts\",\n  \"invalid_exact_svm_payload_transaction_fee_payer_transferring_funds\",\n  \"invalid_exact_svm_payload_transaction_not_a_transfer_instruction\",\n  \"invalid_exact_svm_payload_transaction_receiver_ata_not_found\",\n  \"invalid_exact_svm_payload_transaction_sender_ata_not_found\",\n  \"invalid_exact_svm_payload_transaction_simulation_failed\",\n  \"invalid_exact_svm_payload_transaction_transfer_to_incorrect_ata\",\n  \"invalid_network\",\n  \"invalid_payload\",\n  \"invalid_payment_requirements\",\n  \"invalid_scheme\",\n  \"invalid_payment\",\n  \"payment_expired\",\n  \"unsupported_scheme\",\n  \"invalid_x402_version\",\n  \"invalid_transaction_state\",\n  \"invalid_x402_version\",\n  \"settle_exact_svm_block_height_exceeded\",\n  \"settle_exact_svm_transaction_confirmation_timed_out\",\n  \"unsupported_scheme\",\n  \"unexpected_settle_error\",\n  \"unexpected_verify_error\",\n] as const;\n\n// Refiners\nconst isInteger: (value: string) => boolean = value =>\n  Number.isInteger(Number(value)) && Number(value) >= 0;\nconst hasMaxLength = (maxLength: number) => (value: string) => value.length <= maxLength;\n\n// x402PaymentRequirements\nconst EvmOrSvmAddress = z.string().regex(EvmAddressRegex).or(z.string().regex(SvmAddressRegex));\nconst mixedAddressOrSvmAddress = z\n  .string()\n  .regex(MixedAddressRegex)\n  .or(z.string().regex(SvmAddressRegex));\nexport const PaymentRequirementsSchema = z.object({\n  scheme: z.enum(schemes),\n  network: NetworkSchema,\n  maxAmountRequired: z.string().refine(isInteger),\n  resource: z.string().url(),\n  description: z.string(),\n  mimeType: z.string(),\n  outputSchema: z.record(z.any()).optional(),\n  payTo: EvmOrSvmAddress,\n  maxTimeoutSeconds: z.number().int(),\n  asset: mixedAddressOrSvmAddress,\n  extra: z.record(z.any()).optional(),\n});\nexport type PaymentRequirements = z.infer<typeof PaymentRequirementsSchema>;\n\n// x402ExactEvmPayload\nexport const ExactEvmPayloadAuthorizationSchema = z.object({\n  from: z.string().regex(EvmAddressRegex),\n  to: z.string().regex(EvmAddressRegex),\n  value: z.string().refine(isInteger).refine(hasMaxLength(EvmMaxAtomicUnits)),\n  validAfter: z.string().refine(isInteger),\n  validBefore: z.string().refine(isInteger),\n  nonce: z.string().regex(HexEncoded64ByteRegex),\n});\nexport type ExactEvmPayloadAuthorization = z.infer<typeof ExactEvmPayloadAuthorizationSchema>;\n\nexport const ExactEvmPayloadSchema = z.object({\n  signature: z.string().regex(EvmSignatureRegex),\n  authorization: ExactEvmPayloadAuthorizationSchema,\n});\nexport type ExactEvmPayload = z.infer<typeof ExactEvmPayloadSchema>;\n\n// x402ExactSvmPayload\nexport const ExactSvmPayloadSchema = z.object({\n  transaction: z.string().regex(Base64EncodedRegex),\n});\nexport type ExactSvmPayload = z.infer<typeof ExactSvmPayloadSchema>;\n\n// x402PaymentPayload\nexport const PaymentPayloadSchema = z.object({\n  x402Version: z.number().refine(val => x402Versions.includes(val as 1)),\n  scheme: z.enum(schemes),\n  network: NetworkSchema,\n  payload: z.union([ExactEvmPayloadSchema, ExactSvmPayloadSchema]),\n});\nexport type PaymentPayload = z.infer<typeof PaymentPayloadSchema>;\nexport type UnsignedPaymentPayload = Omit<PaymentPayload, \"payload\"> & {\n  payload: Omit<ExactEvmPayload, \"signature\"> & { signature: undefined };\n};\n\n// x402 Resource Server Response\nexport const x402ResponseSchema = z.object({\n  x402Version: z.number().refine(val => x402Versions.includes(val as 1)),\n  error: z.enum(ErrorReasons).optional(),\n  accepts: z.array(PaymentRequirementsSchema).optional(),\n  payer: z.string().regex(MixedAddressRegex).optional(),\n});\nexport type x402Response = z.infer<typeof x402ResponseSchema>;\n\n// x402RequestStructure\nconst HTTPVerbsSchema = z.enum([\"GET\", \"POST\", \"PUT\", \"DELETE\", \"PATCH\", \"OPTIONS\", \"HEAD\"]);\nexport type HTTPVerbs = z.infer<typeof HTTPVerbsSchema>;\n\nexport const HTTPRequestStructureSchema = z.object({\n  type: z.literal(\"http\"),\n  method: HTTPVerbsSchema,\n  queryParams: z.record(z.string(), z.string()).optional(),\n  bodyType: z.enum([\"json\", \"form-data\", \"multipart-form-data\", \"text\", \"binary\"]).optional(),\n  bodyFields: z.record(z.string(), z.any()).optional(),\n  headerFields: z.record(z.string(), z.any()).optional(),\n});\n\n// export const MCPRequestStructureSchema = z.object({\n//   type: z.literal(\"mcp\"),\n//   sessionIsPayed: z.boolean(),\n//   payedAction: z.object({\n//     kind: z.enum([\"prompts\", \"resources\", \"tools\"]),\n//     name: z.string(),\n//   }).optional(),\n// });\n\n// export const OpenAPIRequestStructureSchema = z.object({\n//   type: z.literal(\"openapi\"),\n//   openApiUrl: z.string().url(),\n//   path: z.string(),\n// });\n\nexport const RequestStructureSchema = z.discriminatedUnion(\"type\", [\n  HTTPRequestStructureSchema,\n  // MCPRequestStructureSchema,\n  // OpenAPIRequestStructureSchema,\n]);\n\nexport type HTTPRequestStructure = z.infer<typeof HTTPRequestStructureSchema>;\n// export type MCPRequestStructure = z.infer<typeof MCPRequestStructureSchema>;\n// export type OpenAPIRequestStructure = z.infer<typeof OpenAPIRequestStructureSchema>;\nexport type RequestStructure = z.infer<typeof RequestStructureSchema>;\n\n// x402DiscoveryResource\nexport const DiscoveredResourceSchema = z.object({\n  resource: z.string(),\n  type: z.enum([\"http\"]),\n  x402Version: z.number().refine(val => x402Versions.includes(val as 1)),\n  accepts: z.array(PaymentRequirementsSchema),\n  lastUpdated: z.date(),\n  metadata: z.record(z.any()).optional(),\n});\nexport type DiscoveredResource = z.infer<typeof DiscoveredResourceSchema>;\n\n// x402SettleRequest\nexport const SettleRequestSchema = z.object({\n  paymentPayload: PaymentPayloadSchema,\n  paymentRequirements: PaymentRequirementsSchema,\n});\nexport type SettleRequest = z.infer<typeof SettleRequestSchema>;\n\n// x402VerifyRequest\nexport const VerifyRequestSchema = z.object({\n  paymentPayload: PaymentPayloadSchema,\n  paymentRequirements: PaymentRequirementsSchema,\n});\nexport type VerifyRequest = z.infer<typeof VerifyRequestSchema>;\n\n// x402VerifyResponse\nexport const VerifyResponseSchema = z.object({\n  isValid: z.boolean(),\n  invalidReason: z.enum(ErrorReasons).optional(),\n  payer: EvmOrSvmAddress.optional(),\n});\nexport type VerifyResponse = z.infer<typeof VerifyResponseSchema>;\n\n// x402SettleResponse\nexport const SettleResponseSchema = z.object({\n  success: z.boolean(),\n  errorReason: z.enum(ErrorReasons).optional(),\n  payer: EvmOrSvmAddress.optional(),\n  transaction: z.string().regex(MixedAddressRegex),\n  network: NetworkSchema,\n});\nexport type SettleResponse = z.infer<typeof SettleResponseSchema>;\n\n// x402DiscoverListRequest\nexport const ListDiscoveryResourcesRequestSchema = z.object({\n  type: z.string().optional(),\n  limit: z.number().optional(),\n  offset: z.number().optional(),\n});\nexport type ListDiscoveryResourcesRequest = z.infer<typeof ListDiscoveryResourcesRequestSchema>;\n\n// x402ListDiscoveryResourcesResponse\nexport const ListDiscoveryResourcesResponseSchema = z.object({\n  x402Version: z.number().refine(val => x402Versions.includes(val as 1)),\n  items: z.array(DiscoveredResourceSchema),\n  pagination: z.object({\n    limit: z.number(),\n    offset: z.number(),\n    total: z.number(),\n  }),\n});\nexport type ListDiscoveryResourcesResponse = z.infer<typeof ListDiscoveryResourcesResponseSchema>;\n\n// x402SupportedPaymentKind\nexport const SupportedPaymentKindSchema = z.object({\n  x402Version: z.number().refine(val => x402Versions.includes(val as 1)),\n  scheme: z.enum(schemes),\n  network: NetworkSchema,\n  extra: z.record(z.any()).optional(),\n});\nexport type SupportedPaymentKind = z.infer<typeof SupportedPaymentKindSchema>;\n\n// x402SupportedPaymentKindsResponse\nexport const SupportedPaymentKindsResponseSchema = z.object({\n  kinds: z.array(SupportedPaymentKindSchema),\n});\nexport type SupportedPaymentKindsResponse = z.infer<typeof SupportedPaymentKindsResponseSchema>;\n","export const Base64EncodedRegex = /^[A-Za-z0-9+/]*={0,2}$/;\n\n/**\n * Encodes a string to base64 format\n *\n * @param data - The string to be encoded to base64\n * @returns The base64 encoded string\n */\nexport function safeBase64Encode(data: string): string {\n  if (typeof globalThis !== \"undefined\" && typeof globalThis.btoa === \"function\") {\n    return globalThis.btoa(data);\n  }\n  return Buffer.from(data).toString(\"base64\");\n}\n\n/**\n * Decodes a base64 string back to its original format\n *\n * @param data - The base64 encoded string to be decoded\n * @returns The decoded string in UTF-8 format\n */\nexport function safeBase64Decode(data: string): string {\n  if (typeof globalThis !== \"undefined\" && typeof globalThis.atob === \"function\") {\n    return globalThis.atob(data);\n  }\n  return Buffer.from(data, \"base64\").toString(\"utf-8\");\n}\n","import { z } from \"zod\";\nimport { safeBase64Decode, safeBase64Encode } from \"../../shared\";\nimport { PaymentRequirementsSchema, SettleResponse } from \"./x402Specs\";\n\nexport const facilitatorRequestSchema = z.object({\n  paymentHeader: z.string(),\n  paymentRequirements: PaymentRequirementsSchema,\n});\n\nexport type FacilitatorRequest = z.infer<typeof facilitatorRequestSchema>;\n\n/**\n * Encodes a settlement response into a base64 header string\n *\n * @param response - The settlement response to encode\n * @returns A base64 encoded string containing the settlement response\n */\nexport function settleResponseHeader(response: SettleResponse): string {\n  return safeBase64Encode(JSON.stringify(response));\n}\n\n/**\n * Decodes a base64 header string back into a settlement response\n *\n * @param header - The base64 encoded settlement response header\n * @returns The decoded settlement response object\n */\nexport function settleResponseFromHeader(header: string): SettleResponse {\n  const decoded = safeBase64Decode(header);\n  return JSON.parse(decoded) as SettleResponse;\n}\n","/**\n * Converts an object to a JSON-safe format by converting bigint values to strings\n * and recursively processing nested objects and arrays\n *\n * @param data - The object to convert to JSON-safe format\n * @returns A new object with all bigint values converted to strings\n */\nexport function toJsonSafe<T extends object>(data: T): object {\n  if (typeof data !== \"object\") {\n    throw new Error(\"Data is not an object\");\n  }\n\n  /**\n   * Recursively converts values to JSON-safe format\n   *\n   * @param value - The value to convert\n   * @returns The converted value with bigints as strings\n   */\n  function convert(value: unknown): unknown {\n    if (value !== null && typeof value === \"object\" && !Array.isArray(value)) {\n      return Object.fromEntries(Object.entries(value).map(([key, val]) => [key, convert(val)]));\n    }\n\n    if (Array.isArray(value)) {\n      return value.map(convert);\n    }\n\n    if (typeof value === \"bigint\") {\n      return value.toString();\n    }\n    return value;\n  }\n\n  return convert(data) as object;\n}\n","import { EvmNetworkToChainId, Network, SvmNetworkToChainId } from \"../types/shared\";\n\n/**\n * Converts a network name to its corresponding chain ID\n *\n * @param network - The network name to convert to a chain ID\n * @returns The chain ID for the specified network\n * @throws Error if the network is not supported\n */\nexport function getNetworkId(network: Network): number {\n  if (EvmNetworkToChainId.has(network)) {\n    return EvmNetworkToChainId.get(network)!;\n  }\n  if (SvmNetworkToChainId.has(network)) {\n    return SvmNetworkToChainId.get(network)!;\n  }\n  throw new Error(`Unsupported network: ${network}`);\n}\n","import { Address, Hex } from \"viem\";\nimport {\n  moneySchema,\n  Network,\n  Price,\n  RouteConfig,\n  RoutePattern,\n  ERC20TokenAmount,\n  PaymentRequirements,\n  PaymentPayload,\n  SPLTokenAmount,\n} from \"../types\";\nimport { RoutesConfig } from \"../types\";\nimport { safeBase64Decode } from \"./base64\";\nimport { getUsdcChainConfigForChain } from \"./evm\";\nimport { getNetworkId } from \"./network\";\n\n/**\n * Computes the route patterns for the given routes config\n *\n * @param routes - The routes config to compute the patterns for\n * @returns The route patterns\n */\nexport function computeRoutePatterns(routes: RoutesConfig): RoutePattern[] {\n  const normalizedRoutes = Object.fromEntries(\n    Object.entries(routes).map(([pattern, value]) => [\n      pattern,\n      typeof value === \"string\" || typeof value === \"number\"\n        ? ({ price: value, network: \"base-sepolia\" } as RouteConfig)\n        : (value as RouteConfig),\n    ]),\n  );\n\n  return Object.entries(normalizedRoutes).map(([pattern, routeConfig]) => {\n    // Split pattern into verb and path, defaulting to \"*\" for verb if not specified\n    const [verb, path] = pattern.includes(\" \") ? pattern.split(/\\s+/) : [\"*\", pattern];\n    if (!path) {\n      throw new Error(`Invalid route pattern: ${pattern}`);\n    }\n    return {\n      verb: verb.toUpperCase(),\n      pattern: new RegExp(\n        `^${\n          path\n            // First escape all special regex characters except * and []\n            .replace(/[$()+.?^{|}]/g, \"\\\\$&\")\n            // Then handle our special pattern characters\n            .replace(/\\*/g, \".*?\") // Make wildcard non-greedy and optional\n            .replace(/\\[([^\\]]+)\\]/g, \"[^/]+\") // Convert [param] to regex capture\n            .replace(/\\//g, \"\\\\/\") // Escape slashes\n        }$`,\n        \"i\",\n      ),\n      config: routeConfig,\n    };\n  });\n}\n\n/**\n * Finds the matching route pattern for the given path and method\n *\n * @param routePatterns - The route patterns to search through\n * @param path - The path to match against\n * @param method - The HTTP method to match against\n * @returns The matching route pattern or undefined if no match is found\n */\nexport function findMatchingRoute(\n  routePatterns: RoutePattern[],\n  path: string,\n  method: string,\n): RoutePattern | undefined {\n  // Normalize the path:\n  // 1. Remove query parameters and hash fragments\n  // 2. Replace backslashes with forward slashes\n  // 3. Replace multiple consecutive slashes with a single slash\n  // 4. Keep trailing slash if path is not root\n  let normalizedPath: string;\n  try {\n    // First split off query parameters and hash fragments\n    const pathWithoutQuery = path.split(/[?#]/)[0];\n\n    // Then decode the path - this needs to happen before any normalization\n    // so encoded characters are properly handled\n    const decodedPath = decodeURIComponent(pathWithoutQuery);\n\n    // Normalize the path (just clean up slashes)\n    normalizedPath = decodedPath\n      .replace(/\\\\/g, \"/\") // replace backslashes\n      .replace(/\\/+/g, \"/\") // collapse slashes\n      .replace(/(.+?)\\/+$/, \"$1\"); // trim trailing slashes\n  } catch {\n    // If decoding fails (e.g., invalid % encoding), return undefined\n    return undefined;\n  }\n\n  // Find matching route pattern\n  const matchingRoutes = routePatterns.filter(({ pattern, verb }) => {\n    const matchesPath = pattern.test(normalizedPath);\n    const upperMethod = method.toUpperCase();\n    const matchesVerb = verb === \"*\" || upperMethod === verb;\n\n    const result = matchesPath && matchesVerb;\n    return result;\n  });\n\n  if (matchingRoutes.length === 0) {\n    return undefined;\n  }\n\n  // Use the most specific route (longest path pattern)\n  const matchingRoute = matchingRoutes.reduce((a, b) =>\n    b.pattern.source.length > a.pattern.source.length ? b : a,\n  );\n\n  return matchingRoute;\n}\n\n/**\n * Gets the default asset (USDC) for the given network\n *\n * @param network - The network to get the default asset for\n * @returns The default asset\n */\nexport function getDefaultAsset(network: Network) {\n  const chainId = getNetworkId(network);\n  const usdc = getUsdcChainConfigForChain(chainId);\n  if (!usdc) {\n    throw new Error(`Unable to get default asset on ${network}`);\n  }\n  return {\n    address: usdc.usdcAddress,\n    decimals: 6,\n    eip712: {\n      name: usdc.usdcName,\n      version: \"2\",\n    },\n  };\n}\n\n/**\n * Parses the amount from the given price\n *\n * @param price - The price to parse\n * @param network - The network to get the default asset for\n * @returns The parsed amount or an error message\n */\nexport function processPriceToAtomicAmount(\n  price: Price,\n  network: Network,\n):\n  | { maxAmountRequired: string; asset: ERC20TokenAmount[\"asset\"] | SPLTokenAmount[\"asset\"] }\n  | { error: string } {\n  // Handle USDC amount (string) or token amount (ERC20TokenAmount)\n  let maxAmountRequired: string;\n  let asset: ERC20TokenAmount[\"asset\"] | SPLTokenAmount[\"asset\"];\n\n  if (typeof price === \"string\" || typeof price === \"number\") {\n    // USDC amount in dollars\n    const parsedAmount = moneySchema.safeParse(price);\n    if (!parsedAmount.success) {\n      return {\n        error: `Invalid price (price: ${price}). Must be in the form \"$3.10\", 0.10, \"0.001\", ${parsedAmount.error}`,\n      };\n    }\n    const parsedUsdAmount = parsedAmount.data;\n    asset = getDefaultAsset(network);\n    maxAmountRequired = (parsedUsdAmount * 10 ** asset.decimals).toString();\n  } else {\n    // Token amount in atomic units\n    maxAmountRequired = price.amount;\n    asset = price.asset;\n  }\n\n  return {\n    maxAmountRequired,\n    asset,\n  };\n}\n\n/**\n * Finds the matching payment requirements for the given payment\n *\n * @param paymentRequirements - The payment requirements to search through\n * @param payment - The payment to match against\n * @returns The matching payment requirements or undefined if no match is found\n */\nexport function findMatchingPaymentRequirements(\n  paymentRequirements: PaymentRequirements[],\n  payment: PaymentPayload,\n) {\n  return paymentRequirements.find(\n    value => value.scheme === payment.scheme && value.network === payment.network,\n  );\n}\n\n/**\n * Decodes the X-PAYMENT-RESPONSE header\n *\n * @param header - The X-PAYMENT-RESPONSE header to decode\n * @returns The decoded payment response\n */\nexport function decodeXPaymentResponse(header: string) {\n  const decoded = safeBase64Decode(header);\n  return JSON.parse(decoded) as {\n    success: boolean;\n    transaction: Hex;\n    network: Network;\n    payer: Address;\n  };\n}\n","export * from \"./rpc\";\nexport * from \"./wallet\";\nexport * from \"./transaction\";\n","import { ExactSvmPayload } from \"../../types/verify/x402Specs\";\nimport {\n  getBase64EncodedWireTransaction,\n  getBase64Encoder,\n  getTransactionDecoder,\n  getCompiledTransactionMessageDecoder,\n  type TransactionSigner,\n  isTransactionModifyingSigner,\n  isTransactionPartialSigner,\n  RpcDevnet,\n  SolanaRpcApiDevnet,\n  RpcMainnet,\n  SolanaRpcApiMainnet,\n  Transaction,\n  CompiledTransactionMessage,\n  TransactionWithLifetime,\n  TransactionWithinSizeLimit,\n  type SignatureDictionary,\n} from \"@solana/kit\";\nimport { TOKEN_PROGRAM_ADDRESS } from \"@solana-program/token\";\nimport { TOKEN_2022_PROGRAM_ADDRESS } from \"@solana-program/token-2022\";\n\n/**\n * Given an object with a base64 encoded transaction, decode the\n * base64 encoded transaction into a solana transaction object.\n *\n * @param svmPayload - The SVM payload to decode\n * @returns The decoded transaction\n */\nexport function decodeTransactionFromPayload(svmPayload: ExactSvmPayload): Transaction {\n  try {\n    const base64Encoder = getBase64Encoder();\n    const transactionBytes = base64Encoder.encode(svmPayload.transaction);\n    const transactionDecoder = getTransactionDecoder();\n    return transactionDecoder.decode(transactionBytes);\n  } catch (error) {\n    console.error(\"error\", error);\n    throw new Error(\"invalid_exact_svm_payload_transaction\");\n  }\n}\n\n/**\n * Extract the token sender (owner of the source token account)\n * from the TransferChecked instruction.\n *\n * @param transaction - The transaction to extract the token payer from\n * @returns The token payer address as a base58 string\n */\nexport function getTokenPayerFromTransaction(transaction: Transaction): string {\n  const compiled = getCompiledTransactionMessageDecoder().decode(\n    transaction.messageBytes,\n  ) as CompiledTransactionMessage;\n  const staticAccounts = compiled.staticAccounts ?? [];\n  const instructions = compiled.instructions ?? [];\n\n  for (const ix of instructions) {\n    const programIndex = ix.programAddressIndex;\n    const programAddress = staticAccounts[programIndex].toString();\n    if (\n      programAddress === TOKEN_PROGRAM_ADDRESS.toString() ||\n      programAddress === TOKEN_2022_PROGRAM_ADDRESS.toString()\n    ) {\n      const accountIndices: number[] = ix.accountIndices ?? [];\n      if (accountIndices.length >= 4) {\n        // TransferChecked account order: [source, mint, destination, owner, ...]\n        const ownerIndex = accountIndices[3];\n        const ownerAddress = staticAccounts[ownerIndex].toString();\n        if (ownerAddress) return ownerAddress;\n      }\n    }\n  }\n\n  return \"\";\n}\n\n/**\n * Sign and simulate a transaction.\n *\n * @param signer - The signer that will sign the transaction\n * @param transaction - The transaction to sign and simulate\n * @param rpc - The RPC client to use to simulate the transaction\n * @returns The transaction simulation result\n */\nexport async function signAndSimulateTransaction(\n  signer: TransactionSigner,\n  transaction: Transaction,\n  rpc: RpcDevnet<SolanaRpcApiDevnet> | RpcMainnet<SolanaRpcApiMainnet>,\n) {\n  const signedTransaction = await signTransactionWithSigner(signer, transaction);\n\n  // serialize the signed transaction into a base64 encoded wire transaction\n  const base64EncodedTransaction = getBase64EncodedWireTransaction(signedTransaction);\n\n  // simulate the transaction and verify that it will succeed\n  const simulateTxConfig = {\n    sigVerify: true,\n    replaceRecentBlockhash: false,\n    commitment: \"confirmed\",\n    encoding: \"base64\",\n    accounts: undefined,\n    innerInstructions: undefined,\n    minContextSlot: undefined,\n  } as const;\n\n  const simulateResult = await rpc\n    .simulateTransaction(base64EncodedTransaction, simulateTxConfig)\n    .send();\n\n  return simulateResult;\n}\n\n/**\n * Signs a transaction using the provided {@link TransactionSigner}.\n *\n * Prefers modifying signers (wallets that can rewrite the transaction) and falls\n * back to partial signers that only append signatures.\n *\n * @param signer - Wallet or signer capable of producing transaction signatures\n * @param transaction - Compiled transaction to sign\n * @returns The transaction including any signatures added by the signer\n */\nexport async function signTransactionWithSigner<TTransaction extends Transaction>(\n  signer: TransactionSigner,\n  transaction: TTransaction,\n): Promise<TTransaction> {\n  if (isTransactionModifyingSigner(signer)) {\n    const [modifiedTransaction] = await signer.modifyAndSignTransactions([transaction]);\n    if (!modifiedTransaction) {\n      throw new Error(\"transaction_signer_failed_to_return_transaction\");\n    }\n    return modifiedTransaction as TTransaction;\n  }\n\n  if (isTransactionPartialSigner(signer)) {\n    const [signatures] = await signer.signTransactions([\n      transaction as Transaction & TransactionWithinSizeLimit & TransactionWithLifetime,\n    ]);\n    if (!signatures) {\n      throw new Error(\"transaction_signer_failed_to_return_signatures\");\n    }\n    return mergeTransactionSignatures(transaction, signatures);\n  }\n\n  throw new Error(\"transaction_signer_must_support_offline_signing\");\n}\n\n/**\n * Returns a copy of `transaction` with additional signatures merged in.\n *\n * @param transaction - Transaction whose signature map should be augmented\n * @param signatures - Map of addresses to new signature bytes\n * @returns A frozen transaction containing the merged signature map\n */\nfunction mergeTransactionSignatures<TTransaction extends Transaction>(\n  transaction: TTransaction,\n  signatures: SignatureDictionary,\n): TTransaction {\n  return Object.freeze({\n    ...transaction,\n    signatures: Object.freeze({\n      ...transaction.signatures,\n      ...signatures,\n    }),\n  }) as TTransaction;\n}\n"],"names":["z","isSignerWallet","createConnectedClient","createSigner","isSignerWallet","z","z","z","svm_exports","isSignerWallet","z"],"mappings":"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"}},
    {"offset": {"line": 2538, "column": 0}, "map": {"version":3,"sources":["file:///Users/satyasaichava/Quantum_Markets/frontend/node_modules/x402/src/schemes/exact/evm/utils/paymentUtils.ts","file:///Users/satyasaichava/Quantum_Markets/frontend/node_modules/x402/src/schemes/exact/evm/sign.ts","file:///Users/satyasaichava/Quantum_Markets/frontend/node_modules/x402/src/schemes/exact/evm/client.ts","file:///Users/satyasaichava/Quantum_Markets/frontend/node_modules/x402/src/schemes/exact/svm/client.ts"],"sourcesContent":["import { safeBase64Encode, safeBase64Decode } from \"../../../../shared\";\nimport { SupportedEVMNetworks, SupportedSVMNetworks } from \"../../../../types\";\nimport {\n  PaymentPayload,\n  PaymentPayloadSchema,\n  ExactEvmPayload,\n  ExactSvmPayload,\n} from \"../../../../types/verify\";\n\n/**\n * Encodes a payment payload into a base64 string, ensuring bigint values are properly stringified\n *\n * @param payment - The payment payload to encode\n * @returns A base64 encoded string representation of the payment payload\n */\nexport function encodePayment(payment: PaymentPayload): string {\n  let safe: PaymentPayload;\n\n  // evm\n  if (SupportedEVMNetworks.includes(payment.network)) {\n    const evmPayload = payment.payload as ExactEvmPayload;\n    safe = {\n      ...payment,\n      payload: {\n        ...evmPayload,\n        authorization: Object.fromEntries(\n          Object.entries(evmPayload.authorization).map(([key, value]) => [\n            key,\n            typeof value === \"bigint\" ? (value as bigint).toString() : value,\n          ]),\n        ) as ExactEvmPayload[\"authorization\"],\n      },\n    };\n    return safeBase64Encode(JSON.stringify(safe));\n  }\n\n  // svm\n  if (SupportedSVMNetworks.includes(payment.network)) {\n    safe = { ...payment, payload: payment.payload as ExactSvmPayload };\n    return safeBase64Encode(JSON.stringify(safe));\n  }\n\n  throw new Error(\"Invalid network\");\n}\n\n/**\n * Decodes a base64 encoded payment string back into a PaymentPayload object\n *\n * @param payment - The base64 encoded payment string to decode\n * @returns The decoded and validated PaymentPayload object\n */\nexport function decodePayment(payment: string): PaymentPayload {\n  const decoded = safeBase64Decode(payment);\n  const parsed = JSON.parse(decoded);\n\n  let obj: PaymentPayload;\n\n  // evm\n  if (SupportedEVMNetworks.includes(parsed.network)) {\n    obj = {\n      ...parsed,\n      payload: parsed.payload as ExactEvmPayload,\n    };\n  }\n\n  // svm\n  else if (SupportedSVMNetworks.includes(parsed.network)) {\n    obj = {\n      ...parsed,\n      payload: parsed.payload as ExactSvmPayload,\n    };\n  } else {\n    throw new Error(\"Invalid network\");\n  }\n\n  const validated = PaymentPayloadSchema.parse(obj);\n  return validated;\n}\n","import { Chain, getAddress, Hex, LocalAccount, toHex, Transport } from \"viem\";\nimport { getNetworkId } from \"../../../shared\";\nimport {\n  authorizationTypes,\n  isAccount,\n  isSignerWallet,\n  SignerWallet,\n} from \"../../../types/shared/evm\";\nimport { ExactEvmPayloadAuthorization, PaymentRequirements } from \"../../../types/verify\";\n\n/**\n * Signs an EIP-3009 authorization for USDC transfer\n *\n * @param walletClient - The wallet client that will sign the authorization\n * @param params - The authorization parameters containing transfer details\n * @param params.from - The address tokens will be transferred from\n * @param params.to - The address tokens will be transferred to\n * @param params.value - The amount of USDC tokens to transfer (in base units)\n * @param params.validAfter - Unix timestamp after which the authorization becomes valid\n * @param params.validBefore - Unix timestamp before which the authorization is valid\n * @param params.nonce - Random 32-byte nonce to prevent replay attacks\n * @param paymentRequirements - The payment requirements containing asset and network information\n * @param paymentRequirements.asset - The address of the USDC contract\n * @param paymentRequirements.network - The network where the USDC contract exists\n * @param paymentRequirements.extra - The extra information containing the name and version of the ERC20 contract\n * @returns The signature for the authorization\n */\nexport async function signAuthorization<transport extends Transport, chain extends Chain>(\n  walletClient: SignerWallet<chain, transport> | LocalAccount,\n  { from, to, value, validAfter, validBefore, nonce }: ExactEvmPayloadAuthorization,\n  { asset, network, extra }: PaymentRequirements,\n): Promise<{ signature: Hex }> {\n  const chainId = getNetworkId(network);\n  const name = extra?.name;\n  const version = extra?.version;\n\n  const data = {\n    types: authorizationTypes,\n    domain: {\n      name,\n      version,\n      chainId,\n      verifyingContract: getAddress(asset),\n    },\n    primaryType: \"TransferWithAuthorization\" as const,\n    message: {\n      from: getAddress(from),\n      to: getAddress(to),\n      value,\n      validAfter,\n      validBefore,\n      nonce: nonce,\n    },\n  };\n\n  if (isSignerWallet(walletClient)) {\n    const signature = await walletClient.signTypedData(data);\n    return {\n      signature,\n    };\n  } else if (isAccount(walletClient) && walletClient.signTypedData) {\n    const signature = await walletClient.signTypedData(data);\n    return {\n      signature,\n    };\n  } else {\n    throw new Error(\"Invalid wallet client provided does not support signTypedData\");\n  }\n}\n\n/**\n * Generates a random 32-byte nonce for use in authorization signatures\n *\n * @returns A random 32-byte nonce as a hex string\n */\nexport function createNonce(): Hex {\n  const cryptoObj =\n    typeof globalThis.crypto !== \"undefined\" &&\n    typeof globalThis.crypto.getRandomValues === \"function\"\n      ? globalThis.crypto\n      : // Dynamic require is needed to support node.js\n        // eslint-disable-next-line @typescript-eslint/no-require-imports\n        require(\"crypto\").webcrypto;\n  return toHex(cryptoObj.getRandomValues(new Uint8Array(32)));\n}\n","import { Address, Chain, LocalAccount, Transport } from \"viem\";\nimport { isSignerWallet, SignerWallet } from \"../../../types/shared/evm\";\nimport { PaymentPayload, PaymentRequirements, UnsignedPaymentPayload } from \"../../../types/verify\";\nimport { createNonce, signAuthorization } from \"./sign\";\nimport { encodePayment } from \"./utils/paymentUtils\";\n\n/**\n * Prepares an unsigned payment header with the given sender address and payment requirements.\n *\n * @param from - The sender's address from which the payment will be made\n * @param x402Version - The version of the X402 protocol to use\n * @param paymentRequirements - The payment requirements containing scheme and network information\n * @returns An unsigned payment payload containing authorization details\n */\nexport function preparePaymentHeader(\n  from: Address,\n  x402Version: number,\n  paymentRequirements: PaymentRequirements,\n): UnsignedPaymentPayload {\n  const nonce = createNonce();\n\n  const validAfter = BigInt(\n    Math.floor(Date.now() / 1000) - 600, // 10 minutes before\n  ).toString();\n  const validBefore = BigInt(\n    Math.floor(Date.now() / 1000 + paymentRequirements.maxTimeoutSeconds),\n  ).toString();\n\n  return {\n    x402Version,\n    scheme: paymentRequirements.scheme,\n    network: paymentRequirements.network,\n    payload: {\n      signature: undefined,\n      authorization: {\n        from,\n        to: paymentRequirements.payTo as Address,\n        value: paymentRequirements.maxAmountRequired,\n        validAfter: validAfter.toString(),\n        validBefore: validBefore.toString(),\n        nonce,\n      },\n    },\n  };\n}\n\n/**\n * Signs a payment header using the provided client and payment requirements.\n *\n * @param client - The signer wallet instance used to sign the payment header\n * @param paymentRequirements - The payment requirements containing scheme and network information\n * @param unsignedPaymentHeader - The unsigned payment payload to be signed\n * @returns A promise that resolves to the signed payment payload\n */\nexport async function signPaymentHeader<transport extends Transport, chain extends Chain>(\n  client: SignerWallet<chain, transport> | LocalAccount,\n  paymentRequirements: PaymentRequirements,\n  unsignedPaymentHeader: UnsignedPaymentPayload,\n): Promise<PaymentPayload> {\n  const { signature } = await signAuthorization(\n    client,\n    unsignedPaymentHeader.payload.authorization,\n    paymentRequirements,\n  );\n\n  return {\n    ...unsignedPaymentHeader,\n    payload: {\n      ...unsignedPaymentHeader.payload,\n      signature,\n    },\n  };\n}\n\n/**\n * Creates a complete payment payload by preparing and signing a payment header.\n *\n * @param client - The signer wallet instance used to create and sign the payment\n * @param x402Version - The version of the X402 protocol to use\n * @param paymentRequirements - The payment requirements containing scheme and network information\n * @returns A promise that resolves to the complete signed payment payload\n */\nexport async function createPayment<transport extends Transport, chain extends Chain>(\n  client: SignerWallet<chain, transport> | LocalAccount,\n  x402Version: number,\n  paymentRequirements: PaymentRequirements,\n): Promise<PaymentPayload> {\n  const from = isSignerWallet(client) ? client.account!.address : client.address;\n  const unsignedPaymentHeader = preparePaymentHeader(from, x402Version, paymentRequirements);\n  return signPaymentHeader(client, paymentRequirements, unsignedPaymentHeader);\n}\n\n/**\n * Creates and encodes a payment header for the given client and payment requirements.\n *\n * @param client - The signer wallet instance used to create the payment header\n * @param x402Version - The version of the X402 protocol to use\n * @param paymentRequirements - The payment requirements containing scheme and network information\n * @returns A promise that resolves to the encoded payment header string\n */\nexport async function createPaymentHeader(\n  client: SignerWallet | LocalAccount,\n  x402Version: number,\n  paymentRequirements: PaymentRequirements,\n): Promise<string> {\n  const payment = await createPayment(client, x402Version, paymentRequirements);\n  return encodePayment(payment);\n}\n","import { encodePayment } from \"../../utils\";\nimport {\n  Address,\n  pipe,\n  createTransactionMessage,\n  setTransactionMessageFeePayer,\n  setTransactionMessageLifetimeUsingBlockhash,\n  appendTransactionMessageInstructions,\n  partiallySignTransactionMessageWithSigners,\n  prependTransactionMessageInstruction,\n  getBase64EncodedWireTransaction,\n  TransactionSigner,\n  Instruction,\n} from \"@solana/kit\";\nimport { PaymentPayload, PaymentRequirements } from \"../../../types/verify\";\nimport { X402Config } from \"../../../types/config\";\nimport {\n  fetchMint,\n  findAssociatedTokenPda,\n  getTransferCheckedInstruction,\n  TOKEN_2022_PROGRAM_ADDRESS,\n} from \"@solana-program/token-2022\";\nimport { TOKEN_PROGRAM_ADDRESS } from \"@solana-program/token\";\nimport {\n  estimateComputeUnitLimitFactory,\n  getSetComputeUnitLimitInstruction,\n  setTransactionMessageComputeUnitPrice,\n} from \"@solana-program/compute-budget\";\nimport { getRpcClient } from \"../../../shared/svm/rpc\";\n\n/**\n * Creates and encodes a payment header for the given client and payment requirements.\n *\n * @param client - The signer instance used to create the payment header\n * @param x402Version - The version of the X402 protocol to use\n * @param paymentRequirements - The payment requirements containing scheme and network information\n * @param config - Optional configuration for X402 operations (e.g., custom RPC URLs)\n * @returns A promise that resolves to a base64 encoded payment header string\n */\nexport async function createPaymentHeader(\n  client: TransactionSigner,\n  x402Version: number,\n  paymentRequirements: PaymentRequirements,\n  config?: X402Config,\n): Promise<string> {\n  const paymentPayload = await createAndSignPayment(\n    client,\n    x402Version,\n    paymentRequirements,\n    config,\n  );\n  return encodePayment(paymentPayload);\n}\n\n/**\n * Creates and signs a payment for the given client and payment requirements.\n *\n * @param client - The signer instance used to create and sign the payment tx\n * @param x402Version - The version of the X402 protocol to use\n * @param paymentRequirements - The payment requirements\n * @param config - Optional configuration for X402 operations (e.g., custom RPC URLs)\n * @returns A promise that resolves to a payment payload containing a base64 encoded solana token transfer tx\n */\nexport async function createAndSignPayment(\n  client: TransactionSigner,\n  x402Version: number,\n  paymentRequirements: PaymentRequirements,\n  config?: X402Config,\n): Promise<PaymentPayload> {\n  const transactionMessage = await createTransferTransactionMessage(\n    client,\n    paymentRequirements,\n    config,\n  );\n  const signedTransaction = await partiallySignTransactionMessageWithSigners(transactionMessage);\n  const base64EncodedWireTransaction = getBase64EncodedWireTransaction(signedTransaction);\n\n  // return payment payload\n  return {\n    scheme: paymentRequirements.scheme,\n    network: paymentRequirements.network,\n    x402Version: x402Version,\n    payload: {\n      transaction: base64EncodedWireTransaction,\n    },\n  } as PaymentPayload;\n}\n\n/**\n * Creates a transfer transaction message for the given client and payment requirements.\n *\n * @param client - The signer instance used to create the transfer transaction message\n * @param paymentRequirements - The payment requirements\n * @param config - Optional configuration for X402 operations (e.g., custom RPC URLs)\n * @returns A promise that resolves to the transaction message with the transfer instruction\n */\nasync function createTransferTransactionMessage(\n  client: TransactionSigner,\n  paymentRequirements: PaymentRequirements,\n  config?: X402Config,\n) {\n  const rpc = getRpcClient(paymentRequirements.network, config?.svmConfig?.rpcUrl);\n\n  // create the transfer instruction\n  const transferInstructions = await createTransferInstructions(\n    client,\n    paymentRequirements,\n    config,\n  );\n\n  // create tx to simulate\n  const feePayer = paymentRequirements.extra?.feePayer as Address;\n  const txToSimulate = pipe(\n    createTransactionMessage({ version: 0 }),\n    tx => setTransactionMessageComputeUnitPrice(1, tx), // 1 microlamport priority fee\n    tx => setTransactionMessageFeePayer(feePayer, tx),\n    tx => appendTransactionMessageInstructions(transferInstructions, tx),\n  );\n\n  // estimate the compute budget limit (gas limit)\n  const estimateComputeUnitLimit = estimateComputeUnitLimitFactory({ rpc });\n  const estimatedUnits = await estimateComputeUnitLimit(txToSimulate);\n\n  // finalize the transaction message by adding the compute budget limit and blockhash\n  const { value: latestBlockhash } = await rpc.getLatestBlockhash().send();\n  const tx = pipe(\n    txToSimulate,\n    tx =>\n      prependTransactionMessageInstruction(\n        getSetComputeUnitLimitInstruction({ units: estimatedUnits }),\n        tx,\n      ),\n    tx => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx),\n  );\n\n  return tx;\n}\n\n/**\n * Creates a transfer instruction for the given client and payment requirements.\n * This function will determine which transfer instruction to create\n * based on the program that created the token (token-2022 or token).\n *\n * @param client - The signer instance used to create the transfer instruction\n * @param paymentRequirements - The payment requirements\n * @param config - Optional configuration for X402 operations (e.g., custom RPC URLs)\n * @returns A promise that resolves to the transfer instruction array\n */\nasync function createTransferInstructions(\n  client: TransactionSigner,\n  paymentRequirements: PaymentRequirements,\n  config?: X402Config,\n): Promise<Instruction[]> {\n  const { asset, maxAmountRequired: amount, payTo } = paymentRequirements;\n\n  const rpc = getRpcClient(paymentRequirements.network, config?.svmConfig?.rpcUrl);\n  const tokenMint = await fetchMint(rpc, asset as Address);\n  const tokenProgramAddress = tokenMint.programAddress;\n\n  // validate that the asset was created by a known token program\n  if (\n    tokenProgramAddress.toString() !== TOKEN_PROGRAM_ADDRESS.toString() &&\n    tokenProgramAddress.toString() !== TOKEN_2022_PROGRAM_ADDRESS.toString()\n  ) {\n    throw new Error(\"Asset was not created by a known token program\");\n  }\n\n  const [sourceATA] = await findAssociatedTokenPda({\n    mint: asset as Address,\n    owner: client.address,\n    tokenProgram: tokenProgramAddress,\n  });\n\n  const [destinationATA] = await findAssociatedTokenPda({\n    mint: asset as Address,\n    owner: payTo as Address,\n    tokenProgram: tokenProgramAddress,\n  });\n\n  const transferIx = getTransferCheckedInstruction(\n    {\n      source: sourceATA,\n      mint: asset as Address,\n      destination: destinationATA,\n      authority: client,\n      amount: BigInt(amount),\n      decimals: tokenMint.data.decimals,\n    },\n    { programAddress: tokenProgramAddress },\n  );\n  return [transferIx];\n}\n"],"names":["createPaymentHeader","tx"],"mappings":"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"}},
    {"offset": {"line": 2778, "column": 0}, "map": {"version":3,"sources":["file:///Users/satyasaichava/Quantum_Markets/frontend/node_modules/x402/src/client/createPaymentHeader.ts","file:///Users/satyasaichava/Quantum_Markets/frontend/node_modules/x402/src/client/preparePaymentHeader.ts","file:///Users/satyasaichava/Quantum_Markets/frontend/node_modules/x402/src/client/selectPaymentRequirements.ts","file:///Users/satyasaichava/Quantum_Markets/frontend/node_modules/x402/src/client/signPaymentHeader.ts"],"sourcesContent":["import { createPaymentHeader as createPaymentHeaderExactEVM } from \"../schemes/exact/evm/client\";\nimport { createPaymentHeader as createPaymentHeaderExactSVM } from \"../schemes/exact/svm/client\";\nimport { isEvmSignerWallet, isMultiNetworkSigner, isSvmSignerWallet, MultiNetworkSigner, Signer, SupportedEVMNetworks, SupportedSVMNetworks } from \"../types/shared\";\nimport { PaymentRequirements } from \"../types/verify\";\nimport { X402Config } from \"../types/config\";\n\n/**\n * Creates a payment header based on the provided client and payment requirements.\n *\n * @param client - The signer wallet instance used to create the payment header\n * @param x402Version - The version of the X402 protocol to use\n * @param paymentRequirements - The payment requirements containing scheme and network information\n * @param config - Optional configuration for X402 operations (e.g., custom RPC URLs)\n * @returns A promise that resolves to the created payment header string\n */\nexport async function createPaymentHeader(\n  client: Signer | MultiNetworkSigner,\n  x402Version: number,\n  paymentRequirements: PaymentRequirements,\n  config?: X402Config,\n): Promise<string> {\n  // exact scheme\n  if (paymentRequirements.scheme === \"exact\") {\n    // evm\n    if (SupportedEVMNetworks.includes(paymentRequirements.network)) {\n      const evmClient = isMultiNetworkSigner(client) ? client.evm : client;\n\n      if (!isEvmSignerWallet(evmClient)) {\n        throw new Error(\"Invalid evm wallet client provided\");\n      }\n\n      return await createPaymentHeaderExactEVM(\n        evmClient,\n        x402Version,\n        paymentRequirements,\n      );\n    }\n    // svm\n    if (SupportedSVMNetworks.includes(paymentRequirements.network)) {\n      const svmClient = isMultiNetworkSigner(client) ? client.svm : client;\n      if (!isSvmSignerWallet(svmClient)) {\n        throw new Error(\"Invalid svm wallet client provided\");\n      }\n\n      return await createPaymentHeaderExactSVM(\n        svmClient,\n        x402Version,\n        paymentRequirements,\n        config,\n      );\n    }\n    throw new Error(\"Unsupported network\");\n  }\n  throw new Error(\"Unsupported scheme\");\n}","import { Address } from \"viem\";\nimport { preparePaymentHeader as preparePaymentHeaderExactEVM } from \"../schemes/exact/evm/client\";\nimport { SupportedEVMNetworks } from \"../types/shared\";\nimport { PaymentRequirements, UnsignedPaymentPayload } from \"../types/verify\";\n\n/**\n * Prepares a payment header with the given sender address and payment requirements.\n *\n * @param from - The sender's address from which the payment will be made\n * @param x402Version - The version of the X402 protocol to use\n * @param paymentRequirements - The payment requirements containing scheme and network information\n * @returns An unsigned payment payload that can be used to create a payment header\n */\nexport function preparePaymentHeader(\n  from: Address,\n  x402Version: number,\n  paymentRequirements: PaymentRequirements,\n): UnsignedPaymentPayload {\n  if (\n    paymentRequirements.scheme === \"exact\" &&\n    SupportedEVMNetworks.includes(paymentRequirements.network)\n  ) {\n    return preparePaymentHeaderExactEVM(from, x402Version, paymentRequirements);\n  }\n\n  throw new Error(\"Unsupported scheme\");\n}\n","import { Network, PaymentRequirements } from \"../types\";\nimport { getUsdcChainConfigForChain } from \"../shared/evm\";\nimport { getNetworkId } from \"../shared/network\";\n\n/**\n * Default selector for payment requirements.\n * Default behavior is to select the first payment requirement that has a USDC asset.\n * If no USDC payment requirement is found, the first payment requirement is selected.\n *\n * @param paymentRequirements - The payment requirements to select from.\n * @param network - The network to check against. If not provided, the network will not be checked.\n * @param scheme - The scheme to check against. If not provided, the scheme will not be checked.\n * @returns The payment requirement that is the most appropriate for the user.\n */\nexport function selectPaymentRequirements(paymentRequirements: PaymentRequirements[], network?: Network | Network[], scheme?: \"exact\"): PaymentRequirements {\n  // Filter down to the scheme/network if provided\n  const broadlyAcceptedPaymentRequirements = paymentRequirements.filter(requirement => {\n    // If the scheme is not provided, we accept any scheme.\n    const isExpectedScheme = !scheme || requirement.scheme === scheme;\n    // If the chain is not provided, we accept any chain.\n    const isExpectedChain = !network || (Array.isArray(network) ? network.includes(requirement.network) : network == requirement.network);\n\n    return isExpectedScheme && isExpectedChain;\n  });\n\n  // Filter down to USDC requirements\n  const usdcRequirements = broadlyAcceptedPaymentRequirements.filter(requirement => {\n    // If the address is a USDC address, we return it.\n    return requirement.asset === getUsdcChainConfigForChain(getNetworkId(requirement.network))?.usdcAddress;\n  });\n\n  // Prioritize USDC requirements if available\n  if (usdcRequirements.length > 0) {\n    return usdcRequirements[0];\n  }\n  // If no USDC requirements are found, return the first broadly accepted requirement.\n  if (broadlyAcceptedPaymentRequirements.length > 0) {\n    return broadlyAcceptedPaymentRequirements[0];\n  }\n  // If no matching requirements are found, return the first requirement.\n  return paymentRequirements[0];\n}\n\n/**\n * Selector for payment requirements.\n *\n * @param paymentRequirements - The payment requirements to select from.\n * @param network - The network to check against. If not provided, the network will not be checked.\n * @param scheme - The scheme to check against. If not provided, the scheme will not be checked.\n * @returns The payment requirement that is the most appropriate for the user.\n */\nexport type PaymentRequirementsSelector = (paymentRequirements: PaymentRequirements[], network?: Network | Network[], scheme?: \"exact\") => PaymentRequirements;\n\n","import { signPaymentHeader as signPaymentHeaderExactEVM } from \"../schemes/exact/evm/client\";\nimport { encodePayment } from \"../schemes/exact/evm/utils/paymentUtils\";\nimport { isEvmSignerWallet, isMultiNetworkSigner, MultiNetworkSigner, Signer, SupportedEVMNetworks } from \"../types/shared\";\nimport { PaymentRequirements, UnsignedPaymentPayload } from \"../types/verify\";\n\n/**\n * Signs a payment header using the provided client and payment requirements.\n * \n * @param client - The signer wallet instance used to sign the payment header\n * @param paymentRequirements - The payment requirements containing scheme and network information\n * @param unsignedPaymentHeader - The unsigned payment payload to be signed\n * @returns A promise that resolves to the encoded signed payment header string\n */\nexport async function signPaymentHeader(\n  client: Signer | MultiNetworkSigner,\n  paymentRequirements: PaymentRequirements,\n  unsignedPaymentHeader: UnsignedPaymentPayload,\n): Promise<string> {\n  if (\n    paymentRequirements.scheme === \"exact\" &&\n    SupportedEVMNetworks.includes(paymentRequirements.network)\n  ) {\n    const evmClient = isMultiNetworkSigner(client) ? client.evm : client;\n\n    if (!isEvmSignerWallet(evmClient)) {\n      throw new Error(\"Invalid evm wallet client provided\");\n    }\n    const signedPaymentHeader = await signPaymentHeaderExactEVM(evmClient, paymentRequirements, unsignedPaymentHeader);\n    return encodePayment(signedPaymentHeader);\n  }\n\n  throw new Error(\"Unsupported scheme\");\n}"],"names":["createPaymentHeader","preparePaymentHeader","signPaymentHeader"],"mappings":";;;;;;;;;;;;;;;;;AAeA,eAAsBA,qBACpB,MAAA,EACA,WAAA,EACA,mBAAA,EACA,MAAA,EACiB;IAEjB,IAAI,oBAAoB,MAAA,KAAW,SAAS;QAE1C,IAAI,iLAAA,CAAqB,QAAA,CAAS,oBAAoB,OAAO,GAAG;YAC9D,MAAM,gBAAY,iLAAA,EAAqB,MAAM,IAAI,OAAO,GAAA,GAAM;YAE9D,IAAI,KAAC,8KAAA,EAAkB,SAAS,GAAG;gBACjC,MAAM,IAAI,MAAM,oCAAoC;YACtD;YAEA,OAAO,UAAM,gLAAA,EACX,WACA,aACA;QAEJ;QAEA,IAAI,iLAAA,CAAqB,QAAA,CAAS,oBAAoB,OAAO,GAAG;YAC9D,MAAM,gBAAY,iLAAA,EAAqB,MAAM,IAAI,OAAO,GAAA,GAAM;YAC9D,IAAI,KAAC,8KAAA,EAAkB,SAAS,GAAG;gBACjC,MAAM,IAAI,MAAM,oCAAoC;YACtD;YAEA,OAAO,UAAMA,iLAAAA,EACX,WACA,aACA,qBACA;QAEJ;QACA,MAAM,IAAI,MAAM,qBAAqB;IACvC;IACA,MAAM,IAAI,MAAM,oBAAoB;AACtC;;ACzCO,SAASC,sBACd,IAAA,EACA,WAAA,EACA,mBAAA,EACwB;IACxB,IACE,oBAAoB,MAAA,KAAW,WAC/B,iLAAA,CAAqB,QAAA,CAAS,oBAAoB,OAAO,GACzD;QACA,WAAO,iLAAA,EAA6B,MAAM,aAAa,mBAAmB;IAC5E;IAEA,MAAM,IAAI,MAAM,oBAAoB;AACtC;;ACZO,SAAS,0BAA0B,mBAAA,EAA4C,OAAA,EAA+B,MAAA,EAAuC;IAE1J,MAAM,qCAAqC,oBAAoB,MAAA,CAAO,CAAA,gBAAe;QAEnF,MAAM,mBAAmB,CAAC,UAAU,YAAY,MAAA,KAAW;QAE3D,MAAM,kBAAkB,CAAC,WAAA,CAAY,MAAM,OAAA,CAAQ,OAAO,IAAI,QAAQ,QAAA,CAAS,YAAY,OAAO,IAAI,WAAW,YAAY,OAAA;QAE7H,OAAO,oBAAoB;IAC7B,CAAC;IAGD,MAAM,mBAAmB,mCAAmC,MAAA,CAAO,CAAA,gBAAe;QAEhF,OAAO,YAAY,KAAA,SAAU,uLAAA,MAA2B,yKAAA,EAAa,YAAY,OAAO,CAAC,GAAG;IAC9F,CAAC;IAGD,IAAI,iBAAiB,MAAA,GAAS,GAAG;QAC/B,OAAO,gBAAA,CAAiB,CAAC,CAAA;IAC3B;IAEA,IAAI,mCAAmC,MAAA,GAAS,GAAG;QACjD,OAAO,kCAAA,CAAmC,CAAC,CAAA;IAC7C;IAEA,OAAO,mBAAA,CAAoB,CAAC,CAAA;AAC9B;;AC5BA,eAAsBC,mBACpB,MAAA,EACA,mBAAA,EACA,qBAAA,EACiB;IACjB,IACE,oBAAoB,MAAA,KAAW,WAC/B,iLAAA,CAAqB,QAAA,CAAS,oBAAoB,OAAO,GACzD;QACA,MAAM,gBAAY,iLAAA,EAAqB,MAAM,IAAI,OAAO,GAAA,GAAM;QAE9D,IAAI,KAAC,8KAAA,EAAkB,SAAS,GAAG;YACjC,MAAM,IAAI,MAAM,oCAAoC;QACtD;QACA,MAAM,sBAAsB,UAAM,8KAAA,EAA0B,WAAW,qBAAqB,qBAAqB;QACjH,WAAO,0KAAA,EAAc,mBAAmB;IAC1C;IAEA,MAAM,IAAI,MAAM,oBAAoB;AACtC"}},
    {"offset": {"line": 2858, "column": 0}, "map": {"version":3,"sources":[],"sourcesContent":[],"names":[],"mappings":""}}]
}