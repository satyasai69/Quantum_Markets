{"version":3,"sources":["../../../../node_modules/idb-keyval/dist/index.js","../../../../node_modules/%40scure/base/index.ts"],"sourcesContent":["function promisifyRequest(request) {\n    return new Promise((resolve, reject) => {\n        // @ts-ignore - file size hacks\n        request.oncomplete = request.onsuccess = () => resolve(request.result);\n        // @ts-ignore - file size hacks\n        request.onabort = request.onerror = () => reject(request.error);\n    });\n}\nfunction createStore(dbName, storeName) {\n    const request = indexedDB.open(dbName);\n    request.onupgradeneeded = () => request.result.createObjectStore(storeName);\n    const dbp = promisifyRequest(request);\n    return (txMode, callback) => dbp.then((db) => callback(db.transaction(storeName, txMode).objectStore(storeName)));\n}\nlet defaultGetStoreFunc;\nfunction defaultGetStore() {\n    if (!defaultGetStoreFunc) {\n        defaultGetStoreFunc = createStore('keyval-store', 'keyval');\n    }\n    return defaultGetStoreFunc;\n}\n/**\n * Get a value by its key.\n *\n * @param key\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction get(key, customStore = defaultGetStore()) {\n    return customStore('readonly', (store) => promisifyRequest(store.get(key)));\n}\n/**\n * Set a value with a key.\n *\n * @param key\n * @param value\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction set(key, value, customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => {\n        store.put(value, key);\n        return promisifyRequest(store.transaction);\n    });\n}\n/**\n * Set multiple values at once. This is faster than calling set() multiple times.\n * It's also atomic â€“ if one of the pairs can't be added, none will be added.\n *\n * @param entries Array of entries, where each entry is an array of `[key, value]`.\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction setMany(entries, customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => {\n        entries.forEach((entry) => store.put(entry[1], entry[0]));\n        return promisifyRequest(store.transaction);\n    });\n}\n/**\n * Get multiple values by their keys\n *\n * @param keys\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction getMany(keys, customStore = defaultGetStore()) {\n    return customStore('readonly', (store) => Promise.all(keys.map((key) => promisifyRequest(store.get(key)))));\n}\n/**\n * Update a value. This lets you see the old value and update it as an atomic operation.\n *\n * @param key\n * @param updater A callback that takes the old value and returns a new value.\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction update(key, updater, customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => \n    // Need to create the promise manually.\n    // If I try to chain promises, the transaction closes in browsers\n    // that use a promise polyfill (IE10/11).\n    new Promise((resolve, reject) => {\n        store.get(key).onsuccess = function () {\n            try {\n                store.put(updater(this.result), key);\n                resolve(promisifyRequest(store.transaction));\n            }\n            catch (err) {\n                reject(err);\n            }\n        };\n    }));\n}\n/**\n * Delete a particular key from the store.\n *\n * @param key\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction del(key, customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => {\n        store.delete(key);\n        return promisifyRequest(store.transaction);\n    });\n}\n/**\n * Delete multiple keys at once.\n *\n * @param keys List of keys to delete.\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction delMany(keys, customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => {\n        keys.forEach((key) => store.delete(key));\n        return promisifyRequest(store.transaction);\n    });\n}\n/**\n * Clear all values in the store.\n *\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction clear(customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => {\n        store.clear();\n        return promisifyRequest(store.transaction);\n    });\n}\nfunction eachCursor(store, callback) {\n    store.openCursor().onsuccess = function () {\n        if (!this.result)\n            return;\n        callback(this.result);\n        this.result.continue();\n    };\n    return promisifyRequest(store.transaction);\n}\n/**\n * Get all keys in the store.\n *\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction keys(customStore = defaultGetStore()) {\n    return customStore('readonly', (store) => {\n        // Fast path for modern browsers\n        if (store.getAllKeys) {\n            return promisifyRequest(store.getAllKeys());\n        }\n        const items = [];\n        return eachCursor(store, (cursor) => items.push(cursor.key)).then(() => items);\n    });\n}\n/**\n * Get all values in the store.\n *\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction values(customStore = defaultGetStore()) {\n    return customStore('readonly', (store) => {\n        // Fast path for modern browsers\n        if (store.getAll) {\n            return promisifyRequest(store.getAll());\n        }\n        const items = [];\n        return eachCursor(store, (cursor) => items.push(cursor.value)).then(() => items);\n    });\n}\n/**\n * Get all entries in the store. Each entry is an array of `[key, value]`.\n *\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction entries(customStore = defaultGetStore()) {\n    return customStore('readonly', (store) => {\n        // Fast path for modern browsers\n        // (although, hopefully we'll get a simpler path some day)\n        if (store.getAll && store.getAllKeys) {\n            return Promise.all([\n                promisifyRequest(store.getAllKeys()),\n                promisifyRequest(store.getAll()),\n            ]).then(([keys, values]) => keys.map((key, i) => [key, values[i]]));\n        }\n        const items = [];\n        return customStore('readonly', (store) => eachCursor(store, (cursor) => items.push([cursor.key, cursor.value])).then(() => items));\n    });\n}\n\nexport { clear, createStore, del, delMany, entries, get, getMany, keys, promisifyRequest, set, setMany, update, values };\n","/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\nexport interface Coder<F, T> {\n  encode(from: F): T;\n  decode(to: T): F;\n}\n\nexport interface BytesCoder extends Coder<Uint8Array, string> {\n  encode: (data: Uint8Array) => string;\n  decode: (str: string) => Uint8Array;\n}\n\nfunction isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n/** Asserts something is Uint8Array. */\nfunction abytes(b: Uint8Array | undefined, ...lengths: number[]): void {\n  if (!isBytes(b)) throw new Error('Uint8Array expected');\n  if (lengths.length > 0 && !lengths.includes(b.length))\n    throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n\nfunction isArrayOf(isString: boolean, arr: any[]) {\n  if (!Array.isArray(arr)) return false;\n  if (arr.length === 0) return true;\n  if (isString) {\n    return arr.every((item) => typeof item === 'string');\n  } else {\n    return arr.every((item) => Number.isSafeInteger(item));\n  }\n}\n\n// no abytes: seems to have 10% slowdown. Why?!\n\nfunction afn(input: Function): input is Function {\n  if (typeof input !== 'function') throw new Error('function expected');\n  return true;\n}\n\nfunction astr(label: string, input: unknown): input is string {\n  if (typeof input !== 'string') throw new Error(`${label}: string expected`);\n  return true;\n}\n\nfunction anumber(n: number): void {\n  if (!Number.isSafeInteger(n)) throw new Error(`invalid integer: ${n}`);\n}\n\nfunction aArr(input: any[]) {\n  if (!Array.isArray(input)) throw new Error('array expected');\n}\nfunction astrArr(label: string, input: string[]) {\n  if (!isArrayOf(true, input)) throw new Error(`${label}: array of strings expected`);\n}\nfunction anumArr(label: string, input: number[]) {\n  if (!isArrayOf(false, input)) throw new Error(`${label}: array of numbers expected`);\n}\n\n// TODO: some recusive type inference so it would check correct order of input/output inside rest?\n// like <string, number>, <number, bytes>, <bytes, float>\ntype Chain = [Coder<any, any>, ...Coder<any, any>[]];\n// Extract info from Coder type\ntype Input<F> = F extends Coder<infer T, any> ? T : never;\ntype Output<F> = F extends Coder<any, infer T> ? T : never;\n// Generic function for arrays\ntype First<T> = T extends [infer U, ...any[]] ? U : never;\ntype Last<T> = T extends [...any[], infer U] ? U : never;\ntype Tail<T> = T extends [any, ...infer U] ? U : never;\n\ntype AsChain<C extends Chain, Rest = Tail<C>> = {\n  // C[K] = Coder<Input<C[K]>, Input<Rest[k]>>\n  [K in keyof C]: Coder<Input<C[K]>, Input<K extends keyof Rest ? Rest[K] : any>>;\n};\n\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction chain<T extends Chain & AsChain<T>>(...args: T): Coder<Input<First<T>>, Output<Last<T>>> {\n  const id = (a: any) => a;\n  // Wrap call in closure so JIT can inline calls\n  const wrap = (a: any, b: any) => (c: any) => a(b(c));\n  // Construct chain of args[-1].encode(args[-2].encode([...]))\n  const encode = args.map((x) => x.encode).reduceRight(wrap, id);\n  // Construct chain of args[0].decode(args[1].decode(...))\n  const decode = args.map((x) => x.decode).reduce(wrap, id);\n  return { encode, decode };\n}\n\n/**\n * Encodes integer radix representation to array of strings using alphabet and back.\n * Could also be array of strings.\n * @__NO_SIDE_EFFECTS__\n */\nfunction alphabet(letters: string | string[]): Coder<number[], string[]> {\n  // mapping 1 to \"b\"\n  const lettersA = typeof letters === 'string' ? letters.split('') : letters;\n  const len = lettersA.length;\n  astrArr('alphabet', lettersA);\n\n  // mapping \"b\" to 1\n  const indexes = new Map(lettersA.map((l, i) => [l, i]));\n  return {\n    encode: (digits: number[]) => {\n      aArr(digits);\n      return digits.map((i) => {\n        if (!Number.isSafeInteger(i) || i < 0 || i >= len)\n          throw new Error(\n            `alphabet.encode: digit index outside alphabet \"${i}\". Allowed: ${letters}`\n          );\n        return lettersA[i]!;\n      });\n    },\n    decode: (input: string[]): number[] => {\n      aArr(input);\n      return input.map((letter) => {\n        astr('alphabet.decode', letter);\n        const i = indexes.get(letter);\n        if (i === undefined) throw new Error(`Unknown letter: \"${letter}\". Allowed: ${letters}`);\n        return i;\n      });\n    },\n  };\n}\n\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction join(separator = ''): Coder<string[], string> {\n  astr('join', separator);\n  return {\n    encode: (from) => {\n      astrArr('join.decode', from);\n      return from.join(separator);\n    },\n    decode: (to) => {\n      astr('join.decode', to);\n      return to.split(separator);\n    },\n  };\n}\n\n/**\n * Pad strings array so it has integer number of bits\n * @__NO_SIDE_EFFECTS__\n */\nfunction padding(bits: number, chr = '='): Coder<string[], string[]> {\n  anumber(bits);\n  astr('padding', chr);\n  return {\n    encode(data: string[]): string[] {\n      astrArr('padding.encode', data);\n      while ((data.length * bits) % 8) data.push(chr);\n      return data;\n    },\n    decode(input: string[]): string[] {\n      astrArr('padding.decode', input);\n      let end = input.length;\n      if ((end * bits) % 8)\n        throw new Error('padding: invalid, string should have whole number of bytes');\n      for (; end > 0 && input[end - 1] === chr; end--) {\n        const last = end - 1;\n        const byte = last * bits;\n        if (byte % 8 === 0) throw new Error('padding: invalid, string has too much padding');\n      }\n      return input.slice(0, end);\n    },\n  };\n}\n\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction normalize<T>(fn: (val: T) => T): Coder<T, T> {\n  afn(fn);\n  return { encode: (from: T) => from, decode: (to: T) => fn(to) };\n}\n\n/**\n * Slow: O(n^2) time complexity\n */\nfunction convertRadix(data: number[], from: number, to: number): number[] {\n  // base 1 is impossible\n  if (from < 2) throw new Error(`convertRadix: invalid from=${from}, base cannot be less than 2`);\n  if (to < 2) throw new Error(`convertRadix: invalid to=${to}, base cannot be less than 2`);\n  aArr(data);\n  if (!data.length) return [];\n  let pos = 0;\n  const res = [];\n  const digits = Array.from(data, (d) => {\n    anumber(d);\n    if (d < 0 || d >= from) throw new Error(`invalid integer: ${d}`);\n    return d;\n  });\n  const dlen = digits.length;\n  while (true) {\n    let carry = 0;\n    let done = true;\n    for (let i = pos; i < dlen; i++) {\n      const digit = digits[i]!;\n      const fromCarry = from * carry;\n      const digitBase = fromCarry + digit;\n      if (\n        !Number.isSafeInteger(digitBase) ||\n        fromCarry / from !== carry ||\n        digitBase - digit !== fromCarry\n      ) {\n        throw new Error('convertRadix: carry overflow');\n      }\n      const div = digitBase / to;\n      carry = digitBase % to;\n      const rounded = Math.floor(div);\n      digits[i] = rounded;\n      if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)\n        throw new Error('convertRadix: carry overflow');\n      if (!done) continue;\n      else if (!rounded) pos = i;\n      else done = false;\n    }\n    res.push(carry);\n    if (done) break;\n  }\n  for (let i = 0; i < data.length - 1 && data[i] === 0; i++) res.push(0);\n  return res.reverse();\n}\n\nconst gcd = (a: number, b: number): number => (b === 0 ? a : gcd(b, a % b));\nconst radix2carry = /* @__NO_SIDE_EFFECTS__ */ (from: number, to: number) =>\n  from + (to - gcd(from, to));\nconst powers: number[] = /* @__PURE__ */ (() => {\n  let res = [];\n  for (let i = 0; i < 40; i++) res.push(2 ** i);\n  return res;\n})();\n/**\n * Implemented with numbers, because BigInt is 5x slower\n */\nfunction convertRadix2(data: number[], from: number, to: number, padding: boolean): number[] {\n  aArr(data);\n  if (from <= 0 || from > 32) throw new Error(`convertRadix2: wrong from=${from}`);\n  if (to <= 0 || to > 32) throw new Error(`convertRadix2: wrong to=${to}`);\n  if (radix2carry(from, to) > 32) {\n    throw new Error(\n      `convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`\n    );\n  }\n  let carry = 0;\n  let pos = 0; // bitwise position in current element\n  const max = powers[from]!;\n  const mask = powers[to]! - 1;\n  const res: number[] = [];\n  for (const n of data) {\n    anumber(n);\n    if (n >= max) throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n    carry = (carry << from) | n;\n    if (pos + from > 32) throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n    pos += from;\n    for (; pos >= to; pos -= to) res.push(((carry >> (pos - to)) & mask) >>> 0);\n    const pow = powers[pos];\n    if (pow === undefined) throw new Error('invalid carry');\n    carry &= pow - 1; // clean carry, otherwise it will cause overflow\n  }\n  carry = (carry << (to - pos)) & mask;\n  if (!padding && pos >= from) throw new Error('Excess padding');\n  if (!padding && carry > 0) throw new Error(`Non-zero padding: ${carry}`);\n  if (padding && pos > 0) res.push(carry >>> 0);\n  return res;\n}\n\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix(num: number): Coder<Uint8Array, number[]> {\n  anumber(num);\n  const _256 = 2 ** 8;\n  return {\n    encode: (bytes: Uint8Array) => {\n      if (!isBytes(bytes)) throw new Error('radix.encode input should be Uint8Array');\n      return convertRadix(Array.from(bytes), _256, num);\n    },\n    decode: (digits: number[]) => {\n      anumArr('radix.decode', digits);\n      return Uint8Array.from(convertRadix(digits, num, _256));\n    },\n  };\n}\n\n/**\n * If both bases are power of same number (like `2**8 <-> 2**64`),\n * there is a linear algorithm. For now we have implementation for power-of-two bases only.\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix2(bits: number, revPadding = false): Coder<Uint8Array, number[]> {\n  anumber(bits);\n  if (bits <= 0 || bits > 32) throw new Error('radix2: bits should be in (0..32]');\n  if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)\n    throw new Error('radix2: carry overflow');\n  return {\n    encode: (bytes: Uint8Array) => {\n      if (!isBytes(bytes)) throw new Error('radix2.encode input should be Uint8Array');\n      return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n    },\n    decode: (digits: number[]) => {\n      anumArr('radix2.decode', digits);\n      return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n    },\n  };\n}\n\ntype ArgumentTypes<F extends Function> = F extends (...args: infer A) => any ? A : never;\nfunction unsafeWrapper<T extends (...args: any) => any>(fn: T) {\n  afn(fn);\n  return function (...args: ArgumentTypes<T>): ReturnType<T> | void {\n    try {\n      return fn.apply(null, args);\n    } catch (e) {}\n  };\n}\n\nfunction checksum(\n  len: number,\n  fn: (data: Uint8Array) => Uint8Array\n): Coder<Uint8Array, Uint8Array> {\n  anumber(len);\n  afn(fn);\n  return {\n    encode(data: Uint8Array) {\n      if (!isBytes(data)) throw new Error('checksum.encode: input should be Uint8Array');\n      const sum = fn(data).slice(0, len);\n      const res = new Uint8Array(data.length + len);\n      res.set(data);\n      res.set(sum, data.length);\n      return res;\n    },\n    decode(data: Uint8Array) {\n      if (!isBytes(data)) throw new Error('checksum.decode: input should be Uint8Array');\n      const payload = data.slice(0, -len);\n      const oldChecksum = data.slice(-len);\n      const newChecksum = fn(payload).slice(0, len);\n      for (let i = 0; i < len; i++)\n        if (newChecksum[i] !== oldChecksum[i]) throw new Error('Invalid checksum');\n      return payload;\n    },\n  };\n}\n\n// prettier-ignore\nexport const utils: { alphabet: typeof alphabet; chain: typeof chain; checksum: typeof checksum; convertRadix: typeof convertRadix; convertRadix2: typeof convertRadix2; radix: typeof radix; radix2: typeof radix2; join: typeof join; padding: typeof padding; } = {\n  alphabet, chain, checksum, convertRadix, convertRadix2, radix, radix2, join, padding,\n};\n\n// RFC 4648 aka RFC 3548\n// ---------------------\n\n/**\n * base16 encoding from RFC 4648.\n * @example\n * ```js\n * base16.encode(Uint8Array.from([0x12, 0xab]));\n * // => '12AB'\n * ```\n */\nexport const base16: BytesCoder = chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));\n\n/**\n * base32 encoding from RFC 4648. Has padding.\n * Use `base32nopad` for unpadded version.\n * Also check out `base32hex`, `base32hexnopad`, `base32crockford`.\n * @example\n * ```js\n * base32.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'CKVQ===='\n * base32.decode('CKVQ====');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32: BytesCoder = chain(\n  radix2(5),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'),\n  padding(5),\n  join('')\n);\n\n/**\n * base32 encoding from RFC 4648. No padding.\n * Use `base32` for padded version.\n * Also check out `base32hex`, `base32hexnopad`, `base32crockford`.\n * @example\n * ```js\n * base32nopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'CKVQ'\n * base32nopad.decode('CKVQ');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32nopad: BytesCoder = chain(\n  radix2(5),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'),\n  join('')\n);\n/**\n * base32 encoding from RFC 4648. Padded. Compared to ordinary `base32`, slightly different alphabet.\n * Use `base32hexnopad` for unpadded version.\n * @example\n * ```js\n * base32hex.encode(Uint8Array.from([0x12, 0xab]));\n * // => '2ALG===='\n * base32hex.decode('2ALG====');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32hex: BytesCoder = chain(\n  radix2(5),\n  alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'),\n  padding(5),\n  join('')\n);\n\n/**\n * base32 encoding from RFC 4648. No padding. Compared to ordinary `base32`, slightly different alphabet.\n * Use `base32hex` for padded version.\n * @example\n * ```js\n * base32hexnopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => '2ALG'\n * base32hexnopad.decode('2ALG');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32hexnopad: BytesCoder = chain(\n  radix2(5),\n  alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'),\n  join('')\n);\n/**\n * base32 encoding from RFC 4648. Doug Crockford's version.\n * https://www.crockford.com/base32.html\n * @example\n * ```js\n * base32crockford.encode(Uint8Array.from([0x12, 0xab]));\n * // => '2ANG'\n * base32crockford.decode('2ANG');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32crockford: BytesCoder = chain(\n  radix2(5),\n  alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'),\n  join(''),\n  normalize((s: string) => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1'))\n);\n\n// Built-in base64 conversion https://caniuse.com/mdn-javascript_builtins_uint8array_frombase64\n// prettier-ignore\nconst hasBase64Builtin: boolean = /* @__PURE__ */ (() =>\n  typeof (Uint8Array as any).from([]).toBase64 === 'function' &&\n  typeof (Uint8Array as any).fromBase64 === 'function')();\n\nconst decodeBase64Builtin = (s: string, isUrl: boolean) => {\n  astr('base64', s);\n  const re = isUrl ? /^[A-Za-z0-9=_-]+$/ : /^[A-Za-z0-9=+/]+$/;\n  const alphabet = isUrl ? 'base64url' : 'base64';\n  if (s.length > 0 && !re.test(s)) throw new Error('invalid base64');\n  return (Uint8Array as any).fromBase64(s, { alphabet, lastChunkHandling: 'strict' });\n};\n\n/**\n * base64 from RFC 4648. Padded.\n * Use `base64nopad` for unpadded version.\n * Also check out `base64url`, `base64urlnopad`.\n * Falls back to built-in function, when available.\n * @example\n * ```js\n * base64.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs='\n * base64.decode('Eqs=');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\n// prettier-ignore\nexport const base64: BytesCoder = hasBase64Builtin ? {\n  encode(b) { abytes(b); return (b as any).toBase64(); },\n  decode(s) { return decodeBase64Builtin(s, false); },\n} : chain(\n  radix2(6),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'),\n  padding(6),\n  join('')\n);\n/**\n * base64 from RFC 4648. No padding.\n * Use `base64` for padded version.\n * @example\n * ```js\n * base64nopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs'\n * base64nopad.decode('Eqs');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base64nopad: BytesCoder = chain(\n  radix2(6),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'),\n  join('')\n);\n\n/**\n * base64 from RFC 4648, using URL-safe alphabet. Padded.\n * Use `base64urlnopad` for unpadded version.\n * Falls back to built-in function, when available.\n * @example\n * ```js\n * base64url.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs='\n * base64url.decode('Eqs=');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\n// prettier-ignore\nexport const base64url: BytesCoder = hasBase64Builtin ? {\n  encode(b) { abytes(b); return (b as any).toBase64({ alphabet: 'base64url' }); },\n  decode(s) { return decodeBase64Builtin(s, true); },\n} : chain(\n  radix2(6),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'),\n  padding(6),\n  join('')\n);\n\n/**\n * base64 from RFC 4648, using URL-safe alphabet. No padding.\n * Use `base64url` for padded version.\n * @example\n * ```js\n * base64urlnopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs'\n * base64urlnopad.decode('Eqs');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base64urlnopad: BytesCoder = chain(\n  radix2(6),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'),\n  join('')\n);\n\n// base58 code\n// -----------\nconst genBase58 = /* @__NO_SIDE_EFFECTS__ */ (abc: string) =>\n  chain(radix(58), alphabet(abc), join(''));\n\n/**\n * base58: base64 without ambigous characters +, /, 0, O, I, l.\n * Quadratic (O(n^2)) - so, can't be used on large inputs.\n * @example\n * ```js\n * base58.decode('01abcdef');\n * // => '3UhJW'\n * ```\n */\nexport const base58: BytesCoder = genBase58(\n  '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n);\n/**\n * base58: flickr version. Check out `base58`.\n */\nexport const base58flickr: BytesCoder = genBase58(\n  '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n);\n/**\n * base58: XRP version. Check out `base58`.\n */\nexport const base58xrp: BytesCoder = genBase58(\n  'rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz'\n);\n\n// Data len (index) -> encoded block len\nconst XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];\n\n/**\n * base58: XMR version. Check out `base58`.\n * Done in 8-byte blocks (which equals 11 chars in decoding). Last (non-full) block padded with '1' to size in XMR_BLOCK_LEN.\n * Block encoding significantly reduces quadratic complexity of base58.\n */\nexport const base58xmr: BytesCoder = {\n  encode(data: Uint8Array) {\n    let res = '';\n    for (let i = 0; i < data.length; i += 8) {\n      const block = data.subarray(i, i + 8);\n      res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length]!, '1');\n    }\n    return res;\n  },\n  decode(str: string) {\n    let res: number[] = [];\n    for (let i = 0; i < str.length; i += 11) {\n      const slice = str.slice(i, i + 11);\n      const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n      const block = base58.decode(slice);\n      for (let j = 0; j < block.length - blockLen; j++) {\n        if (block[j] !== 0) throw new Error('base58xmr: wrong padding');\n      }\n      res = res.concat(Array.from(block.slice(block.length - blockLen)));\n    }\n    return Uint8Array.from(res);\n  },\n};\n\n/**\n * Method, which creates base58check encoder.\n * Requires function, calculating sha256.\n */\nexport const createBase58check = (sha256: (data: Uint8Array) => Uint8Array): BytesCoder =>\n  chain(\n    checksum(4, (data) => sha256(sha256(data))),\n    base58\n  );\n\n/**\n * Use `createBase58check` instead.\n * @deprecated\n */\nexport const base58check: (sha256: (data: Uint8Array) => Uint8Array) => BytesCoder =\n  createBase58check;\n\n// Bech32 code\n// -----------\nexport interface Bech32Decoded<Prefix extends string = string> {\n  prefix: Prefix;\n  words: number[];\n}\nexport interface Bech32DecodedWithArray<Prefix extends string = string> {\n  prefix: Prefix;\n  words: number[];\n  bytes: Uint8Array;\n}\n\nconst BECH_ALPHABET: Coder<number[], string> = chain(\n  alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'),\n  join('')\n);\n\nconst POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\nfunction bech32Polymod(pre: number): number {\n  const b = pre >> 25;\n  let chk = (pre & 0x1ffffff) << 5;\n  for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {\n    if (((b >> i) & 1) === 1) chk ^= POLYMOD_GENERATORS[i]!;\n  }\n  return chk;\n}\n\nfunction bechChecksum(prefix: string, words: number[], encodingConst = 1): string {\n  const len = prefix.length;\n  let chk = 1;\n  for (let i = 0; i < len; i++) {\n    const c = prefix.charCodeAt(i);\n    if (c < 33 || c > 126) throw new Error(`Invalid prefix (${prefix})`);\n    chk = bech32Polymod(chk) ^ (c >> 5);\n  }\n  chk = bech32Polymod(chk);\n  for (let i = 0; i < len; i++) chk = bech32Polymod(chk) ^ (prefix.charCodeAt(i) & 0x1f);\n  for (let v of words) chk = bech32Polymod(chk) ^ v;\n  for (let i = 0; i < 6; i++) chk = bech32Polymod(chk);\n  chk ^= encodingConst;\n  return BECH_ALPHABET.encode(convertRadix2([chk % powers[30]!], 30, 5, false));\n}\n\nexport interface Bech32 {\n  encode<Prefix extends string>(\n    prefix: Prefix,\n    words: number[] | Uint8Array,\n    limit?: number | false\n  ): `${Lowercase<Prefix>}1${string}`;\n  decode<Prefix extends string>(\n    str: `${Prefix}1${string}`,\n    limit?: number | false\n  ): Bech32Decoded<Prefix>;\n  encodeFromBytes(prefix: string, bytes: Uint8Array): string;\n  decodeToBytes(str: string): Bech32DecodedWithArray;\n  decodeUnsafe(str: string, limit?: number | false): void | Bech32Decoded<string>;\n  fromWords(to: number[]): Uint8Array;\n  fromWordsUnsafe(to: number[]): void | Uint8Array;\n  toWords(from: Uint8Array): number[];\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction genBech32(encoding: 'bech32' | 'bech32m'): Bech32 {\n  const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;\n  const _words = radix2(5);\n  const fromWords = _words.decode;\n  const toWords = _words.encode;\n  const fromWordsUnsafe = unsafeWrapper(fromWords);\n\n  function encode<Prefix extends string>(\n    prefix: Prefix,\n    words: number[] | Uint8Array,\n    limit: number | false = 90\n  ): `${Lowercase<Prefix>}1${string}` {\n    astr('bech32.encode prefix', prefix);\n    if (isBytes(words)) words = Array.from(words);\n    anumArr('bech32.encode', words);\n    const plen = prefix.length;\n    if (plen === 0) throw new TypeError(`Invalid prefix length ${plen}`);\n    const actualLength = plen + 7 + words.length;\n    if (limit !== false && actualLength > limit)\n      throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n    const lowered = prefix.toLowerCase();\n    const sum = bechChecksum(lowered, words, ENCODING_CONST);\n    return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}` as `${Lowercase<Prefix>}1${string}`;\n  }\n\n  function decode<Prefix extends string>(\n    str: `${Prefix}1${string}`,\n    limit?: number | false\n  ): Bech32Decoded<Prefix>;\n  function decode(str: string, limit?: number | false): Bech32Decoded;\n  function decode(str: string, limit: number | false = 90): Bech32Decoded {\n    astr('bech32.decode input', str);\n    const slen = str.length;\n    if (slen < 8 || (limit !== false && slen > limit))\n      throw new TypeError(`invalid string length: ${slen} (${str}). Expected (8..${limit})`);\n    // don't allow mixed case\n    const lowered = str.toLowerCase();\n    if (str !== lowered && str !== str.toUpperCase())\n      throw new Error(`String must be lowercase or uppercase`);\n    const sepIndex = lowered.lastIndexOf('1');\n    if (sepIndex === 0 || sepIndex === -1)\n      throw new Error(`Letter \"1\" must be present between prefix and data only`);\n    const prefix = lowered.slice(0, sepIndex);\n    const data = lowered.slice(sepIndex + 1);\n    if (data.length < 6) throw new Error('Data must be at least 6 characters long');\n    const words = BECH_ALPHABET.decode(data).slice(0, -6);\n    const sum = bechChecksum(prefix, words, ENCODING_CONST);\n    if (!data.endsWith(sum)) throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n    return { prefix, words };\n  }\n\n  const decodeUnsafe = unsafeWrapper(decode);\n\n  function decodeToBytes(str: string): Bech32DecodedWithArray {\n    const { prefix, words } = decode(str, false);\n    return { prefix, words, bytes: fromWords(words) };\n  }\n\n  function encodeFromBytes(prefix: string, bytes: Uint8Array) {\n    return encode(prefix, toWords(bytes));\n  }\n\n  return {\n    encode,\n    decode,\n    encodeFromBytes,\n    decodeToBytes,\n    decodeUnsafe,\n    fromWords,\n    fromWordsUnsafe,\n    toWords,\n  };\n}\n\n/**\n * bech32 from BIP 173. Operates on words.\n * For high-level, check out scure-btc-signer:\n * https://github.com/paulmillr/scure-btc-signer.\n */\nexport const bech32: Bech32 = genBech32('bech32');\n\n/**\n * bech32m from BIP 350. Operates on words.\n * It was to mitigate `bech32` weaknesses.\n * For high-level, check out scure-btc-signer:\n * https://github.com/paulmillr/scure-btc-signer.\n */\nexport const bech32m: Bech32 = genBech32('bech32m');\n\ndeclare const TextEncoder: any;\ndeclare const TextDecoder: any;\n\n/**\n * UTF-8-to-byte decoder. Uses built-in TextDecoder / TextEncoder.\n * @example\n * ```js\n * const b = utf8.decode(\"hey\"); // => new Uint8Array([ 104, 101, 121 ])\n * const str = utf8.encode(b); // \"hey\"\n * ```\n */\nexport const utf8: BytesCoder = {\n  encode: (data) => new TextDecoder().decode(data),\n  decode: (str) => new TextEncoder().encode(str),\n};\n\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\n// prettier-ignore\nconst hasHexBuiltin: boolean = /* @__PURE__ */ (() =>\n  typeof (Uint8Array as any).from([]).toHex === 'function' &&\n  typeof (Uint8Array as any).fromHex === 'function')();\n// prettier-ignore\nconst hexBuiltin: BytesCoder = {\n  encode(data) { abytes(data); return (data as any).toHex(); },\n  decode(s) { astr('hex', s); return (Uint8Array as any).fromHex(s); },\n};\n/**\n * hex string decoder. Uses built-in function, when available.\n * @example\n * ```js\n * const b = hex.decode(\"0102ff\"); // => new Uint8Array([ 1, 2, 255 ])\n * const str = hex.encode(b); // \"0102ff\"\n * ```\n */\nexport const hex: BytesCoder = hasHexBuiltin\n  ? hexBuiltin\n  : chain(\n      radix2(4),\n      alphabet('0123456789abcdef'),\n      join(''),\n      normalize((s: string) => {\n        if (typeof s !== 'string' || s.length % 2 !== 0)\n          throw new TypeError(\n            `hex.decode: expected string, got ${typeof s} with length ${s.length}`\n          );\n        return s.toLowerCase();\n      })\n    );\n\nexport type SomeCoders = {\n  utf8: BytesCoder;\n  hex: BytesCoder;\n  base16: BytesCoder;\n  base32: BytesCoder;\n  base64: BytesCoder;\n  base64url: BytesCoder;\n  base58: BytesCoder;\n  base58xmr: BytesCoder;\n};\n// prettier-ignore\nconst CODERS: SomeCoders = {\n  utf8, hex, base16, base32, base64, base64url, base58, base58xmr\n};\ntype CoderType = keyof SomeCoders;\nconst coderTypeError =\n  'Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr';\n\n/** @deprecated */\nexport const bytesToString = (type: CoderType, bytes: Uint8Array): string => {\n  if (typeof type !== 'string' || !CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);\n  if (!isBytes(bytes)) throw new TypeError('bytesToString() expects Uint8Array');\n  return CODERS[type].encode(bytes);\n};\n\n/** @deprecated */\nexport const str: (type: CoderType, bytes: Uint8Array) => string = bytesToString; // as in python, but for bytes only\n\n/** @deprecated */\nexport const stringToBytes = (type: CoderType, str: string): Uint8Array => {\n  if (!CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);\n  if (typeof str !== 'string') throw new TypeError('stringToBytes() expects string');\n  return CODERS[type].decode(str);\n};\n/** @deprecated */\nexport const bytes: (type: CoderType, str: string) => Uint8Array = stringToBytes;\n"],"names":[],"mappings":"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","ignoreList":[0]}