{"version":3,"sources":["../../../../node_modules/%40privy-io/react-auth/dist/esm/FundSolWalletWithExternalSolanaWallet-DVaHCgDh.mjs","../../../../node_modules/%40privy-io/react-auth/dist/esm/useWallets-Cc1ILfGS.mjs","../../../../node_modules/%40solana-program/system/src/generated/types/nonceState.ts","../../../../node_modules/%40solana-program/system/src/generated/types/nonceVersion.ts","../../../../node_modules/%40solana-program/system/src/generated/accounts/nonce.ts","../../../../node_modules/%40solana-program/system/src/generated/programs/system.ts","../../../../node_modules/%40solana-program/system/src/generated/errors/system.ts","../../../../node_modules/%40solana-program/system/src/generated/shared/index.ts","../../../../node_modules/%40solana-program/system/src/generated/instructions/advanceNonceAccount.ts","../../../../node_modules/%40solana-program/system/src/generated/instructions/allocate.ts","../../../../node_modules/%40solana-program/system/src/generated/instructions/allocateWithSeed.ts","../../../../node_modules/%40solana-program/system/src/generated/instructions/assign.ts","../../../../node_modules/%40solana-program/system/src/generated/instructions/assignWithSeed.ts","../../../../node_modules/%40solana-program/system/src/generated/instructions/authorizeNonceAccount.ts","../../../../node_modules/%40solana-program/system/src/generated/instructions/createAccount.ts","../../../../node_modules/%40solana-program/system/src/generated/instructions/createAccountWithSeed.ts","../../../../node_modules/%40solana-program/system/src/generated/instructions/initializeNonceAccount.ts","../../../../node_modules/%40solana-program/system/src/generated/instructions/transferSol.ts","../../../../node_modules/%40solana-program/system/src/generated/instructions/transferSolWithSeed.ts","../../../../node_modules/%40solana-program/system/src/generated/instructions/upgradeNonceAccount.ts","../../../../node_modules/%40solana-program/system/src/generated/instructions/withdrawNonceAccount.ts"],"sourcesContent":["import{jsx as t,jsxs as e,Fragment as a}from\"react/jsx-runtime\";import n from\"@heroicons/react/24/outline/CheckCircleIcon\";import{useState as o,useEffect as r}from\"react\";import{formatWalletAddress as s}from\"@privy-io/js-sdk-core\";import{P as i}from\"./Button-OlK_6fKk.mjs\";import{b as l,c as m,R as c,e as u}from\"./Layouts-Bmf8DxNP.mjs\";import{B as d}from\"./ModalHeader-CxHK1IKF.mjs\";import{C as p}from\"./ScreenHeader-Biz1wq02.mjs\";import{t as f}from\"./FundWalletMethodHeader-RY6-H-Ry.mjs\";import{I as g}from\"./InjectedWalletIcon-DLcYOGDj.mjs\";import{N as h}from\"./index-CJMgUOnw.mjs\";import{L as I,V as w}from\"./Value-B4M62ove.mjs\";import{a as v,R as S}from\"./Row-CG0lSY5Z.mjs\";import{u as j,t as C}from\"./context-B4VZqX5H.mjs\";import{u as y,a as L,b as F}from\"./internal-context-DLZicboG.mjs\";import{a as x}from\"./get-is-unified-wallet-DXko-EzF.mjs\";import{u as k,g as U}from\"./useWallets-Cc1ILfGS.mjs\";import{u as T}from\"./useGetTokenPrice-CnQZmfvQ.mjs\";import{O as A}from\"./analytics-mkkvFRju.mjs\";import{getTransferSolInstruction as W}from\"@solana-program/system\";import{pipe as b,createTransactionMessage as P,setTransactionMessageFeePayerSigner as D,setTransactionMessageLifetimeUsingBlockhash as N,appendTransactionMessageInstruction as M,compileTransaction as O,getTransactionEncoder as B}from\"@solana/kit\";import{findAssociatedTokenPda as E,getCreateAssociatedTokenIdempotentInstruction as $,getTransferInstruction as R}from\"@solana-program/token\";import{T as H,L as G,g as V}from\"./getFormattedUsdFromLamports-B6EqSEho.mjs\";import{g as Q}from\"./getUsdcMintAddress-DFI1hv05.mjs\";import{u as _,f as z,s as X,w as Y}from\"./useSolanaRpcClient-Be5Dd6m5.mjs\";import{g as q}from\"./getChainName-DjpPdUSc.mjs\";import{t as J}from\"./prepareFundingModalData-CndHQFiM.mjs\";import\"styled-components\";import\"./useActiveWallet-Bj-s666H.mjs\";import\"zustand\";import\"react-device-detect\";import\"./events-context-CI0iqAXA.mjs\";import\"viem\";import\"viem/utils\";import\"./getPublicClient-C_l_ocJu.mjs\";import\"./useWallets-DuxHKVvE.mjs\";import\"@heroicons/react/24/outline/ArrowLeftIcon\";import\"@heroicons/react/24/outline/ArrowRightIcon\";import\"@heroicons/react/24/outline/QuestionMarkCircleIcon\";import\"@heroicons/react/24/outline/XMarkIcon\";import\"@heroicons/react/24/outline/WalletIcon\";import\"./LoadingSkeleton-CHdaq3pb.mjs\";import\"tinycolor2\";import\"ofetch\";import\"./usePrivy-BSIhOAz8.mjs\";import\"eventemitter3\";import\"@scure/base\";import\"./use-sign-with-user-signer-J1po7l19.mjs\";import\"./useGetSolPrice-fF6UX0Cj.mjs\";function K({rows:a}){/*#__PURE__*/return t(v,{children:a.filter((t=>!!t)).map(((a,n)=>null!=a.value||a.isLoading?/*#__PURE__*/e(S,{children:[/*#__PURE__*/t(I,{children:a.label}),/*#__PURE__*/t(w,{$isLoading:a.isLoading,children:a.value})]},n):null))})}function Z(t){return BigInt(Math.floor(1e9*parseFloat(t)))}function tt(t){return+et.format(parseFloat(t.toString())/1e9)}let et=Intl.NumberFormat(void 0,{maximumFractionDigits:8});async function at({tx:t,solanaClient:e,amount:a,asset:n,tokenPrice:o}){if(!t)return null;if(\"SOL\"===n&&o){let n=Z(a),r=V(n,o),s=await z({solanaClient:e,tx:t});return{amountInUsd:r,feeInUsd:o?V(s,o):void 0,totalInUsd:V(n+s,o)}}if(\"USDC\"===n&&o){let n=\"$\"+a,r=await z({solanaClient:e,tx:t}),s=function(t,e){let a=parseFloat(t.toString())/G*e;return a<.01?0:a}(r,o);return{amountInUsd:n,feeInUsd:V(r,o),totalInUsd:\"$\"+(parseFloat(a)+s).toFixed(2)}}if(\"SOL\"===n){let n=Z(a),o=await z({solanaClient:e,tx:t});return{amountInSol:a+\" SOL\",feeInSol:tt(o)+\" SOL\",totalInSol:tt(n+o)+\" SOL\"}}return{amountInUsdc:a+\" USDC\",feeInSol:tt(await z({solanaClient:e,tx:t}))+\" SOL\"}}const nt={component:function(){let I=j(),{closePrivyModal:w,createAnalyticsEvent:v}=y(),{data:S,setModalData:G,navigate:z}=x(),{wallets:tt}=k(),[et,nt]=o(\"preparing\"),[ot,rt]=o(),[st,it]=o(),[lt,mt]=o();if(!S?.solanaFundingData)throw Error(\"Funding config is missing\");if(!S.solanaFundingData.sourceWalletData)throw Error(\"Funding config is missing source wallet data\");let{amount:ct,asset:ut,chain:dt,sourceWalletData:pt,destinationAddress:ft,afterSuccessScreen:gt}=S.solanaFundingData,ht=tt.find((t=>t.address===pt.address&&J(pt.walletClientType)===J(t.standardWallet.name))),It=_()(dt),{tokenPrice:wt,isTokenPriceLoading:vt}=T(\"solana\");return r((()=>{if(\"preparing\"!==et||vt||!ht)return;let t=\"SOL\"===ut?Z(ct):function(t){return BigInt(Math.floor(1e6*parseFloat(t)))}(ct);it({amount:(\"SOL\"===ut&&wt?V(t,wt):ct)??ct}),(\"SOL\"===ut?async function({solanaClient:t,source:e,destination:a,amountInLamports:n}){let{value:o}=await t.rpc.getLatestBlockhash().send(),r={address:e},s=b(P({version:0}),(t=>D(r,t)),(t=>N(o,t)),(t=>M(W({amount:n,source:r,destination:a}),t)),(t=>O(t)));return new Uint8Array(B().encode(s))}({solanaClient:It,source:ht.address,destination:ft,amountInLamports:t}):async function({solanaClient:t,source:e,destination:a,amountInBaseUnits:n}){let o=Q(t.chain),{value:r}=await t.rpc.getLatestBlockhash().send(),s={address:e},[i]=await E({mint:o,owner:e,tokenProgram:H}),[l]=await E({mint:o,owner:a,tokenProgram:H}),[m,c]=await Promise.all([t.rpc.getAccountInfo(i,{commitment:\"confirmed\",encoding:\"jsonParsed\"}).send().catch((()=>null)),t.rpc.getAccountInfo(l,{commitment:\"confirmed\",encoding:\"jsonParsed\"}).send().catch((()=>null))]);if(!m?.value)throw Error(`Source token account does not exist for address: ${e}`);let u=$({payer:s,ata:l,owner:a,mint:o}),d=b(P({version:0}),(t=>D(s,t)),(t=>N(r,t)),(t=>c?.value?t:M(u,t)),(t=>M(R({source:i,destination:l,authority:s,amount:n}),t)),(t=>O(t)));return new Uint8Array(B().encode(d))}({solanaClient:It,source:ht.address,destination:ft,amountInBaseUnits:t})).then(rt).catch((t=>{nt(\"error\"),mt(t)}))}),[et,ct,ut,dt,ht,ft,vt,wt]),r((()=>{\"preparing\"===et&&ot&&at({tx:ot,solanaClient:It,amount:ct,asset:ut,tokenPrice:wt}).then((t=>{nt(\"loaded\"),it({amount:t?.amountInUsd??t?.amountInUsdc??t?.amountInSol??ct,fee:t?.feeInUsd??t?.feeInSol,total:t?.totalInUsd??t?.totalInSol})})).catch((t=>{nt(\"error\"),mt(t)}))}),[ot,ct,ut,et,wt]),r((()=>{\"error\"===et&&lt&&(G({errorModalData:{error:lt,previousScreen:\"FundSolWalletWithExternalSolanaWallet\"},solanaFundingData:S.solanaFundingData}),z(\"ErrorScreen\",!1))}),[et,z]),r((()=>{if(\"success\"!==et)return;let t=setTimeout(gt?()=>z(gt):w,C);return()=>clearTimeout(t)}),[et]),/*#__PURE__*/e(a,\"success\"===et?{children:[/*#__PURE__*/t(f,{}),/*#__PURE__*/t(l,{}),/*#__PURE__*/e(m,{children:[/*#__PURE__*/t(n,{color:\"var(--privy-color-success)\",width:\"64px\",height:\"64px\"}),/*#__PURE__*/t(p,{title:\"Success!\",description:`Youâ€™ve successfully added ${ct} ${ut} to your ${I.name} wallet. It may take a minute before the funds are available to use.`})]}),/*#__PURE__*/t(c,{}),/*#__PURE__*/t(d,{})]}:\"preparing\"===et||\"loaded\"===et||\"sending\"===et?{children:[/*#__PURE__*/t(f,{}),/*#__PURE__*/t(u,{style:{marginTop:\"16px\"},children:/*#__PURE__*/t(g,{icon:ht?.standardWallet.icon,name:ht?.standardWallet.name})}),/*#__PURE__*/t(p,{style:{marginTop:\"8px\",marginBottom:\"12px\"},title:\"sending\"===et&&ht?`Confirming with ${ht.standardWallet.name}`:\"Confirm transaction\"}),/*#__PURE__*/t(K,{rows:[{label:\"Source\",value:s(pt.address)},{label:\"Destination\",value:s(ft)},{label:\"Network\",value:q(dt)},{label:\"Amount\",value:st?.amount,isLoading:\"preparing\"===et},{label:\"Estimated fee\",value:st?.fee,isLoading:\"preparing\"===et},{label:\"Total\",value:st?.total,isLoading:\"preparing\"===et}]}),/*#__PURE__*/t(i,{style:{marginTop:\"1rem\"},loading:\"preparing\"===et||\"sending\"===et,onClick:function(){\"loaded\"===et&&ot&&ht&&(nt(\"sending\"),async function({transaction:t,chain:e,sourceWallet:a,solanaClient:n}){let{hasFunds:o}=await X({solanaClient:n,tx:t});if(!o)throw new L(`Wallet ${s(a.address)} does not have enough funds.`,void 0,F.INSUFFICIENT_BALANCE);let r=U((await a.signAndSendTransaction({transaction:t,chain:e}).catch((t=>{throw new L(\"Transaction was rejected by the user\",t,F.TRANSACTION_FAILURE)}))).signature);return await Y({rpcSubscriptions:n.rpcSubscriptions,signature:r,timeout:2e4}),r}({solanaClient:It,transaction:ot,chain:dt,sourceWallet:ht}).then((t=>{nt(\"success\"),v({eventName:A,payload:{provider:\"external\",status:\"success\",txHash:t,address:ht.address,value:ct,chainType:\"solana\",clusterName:dt,token:ut,destinationAddress:ft,destinationValue:ct,destinationChainType:\"solana\",destinationClusterName:dt,destinationToken:ut}})})).catch((t=>{nt(\"error\"),mt(t)})))},children:\"Confirm\"}),/*#__PURE__*/t(d,{})]}:{children:[/*#__PURE__*/t(f,{}),/*#__PURE__*/t(h,{}),/*#__PURE__*/t(\"div\",{style:{marginTop:\"1rem\"}}),/*#__PURE__*/t(d,{})]})}};export{nt as FundSolWalletWithExternalSolanaWallet,nt as default};\n","import{getBase58Decoder as e,getTransactionDecoder as n,address as t,getTransactionEncoder as a}from\"@solana/kit\";import{useMemo as s,useEffect as i,useState as r}from\"react\";import o,{rpc as c,ConnectedStandardSolanaWallet as l}from\"@privy-io/js-sdk-core\";import{u as d,a as u,b as g,k as h}from\"./internal-context-DLZicboG.mjs\";import{a as p,h as f,d as w,o as A,j as y}from\"./get-is-unified-wallet-DXko-EzF.mjs\";import{u as v}from\"./usePrivy-BSIhOAz8.mjs\";import{g as m,u as T}from\"./useWallets-DuxHKVvE.mjs\";import b from\"eventemitter3\";import{base58 as O}from\"@scure/base\";import{u as S}from\"./context-B4VZqX5H.mjs\";import{u as _}from\"./use-sign-with-user-signer-J1po7l19.mjs\";import{g as E,u as I}from\"./prepareFundingModalData-CndHQFiM.mjs\";import{b as j,a as W,u as M}from\"./useSolanaRpcClient-Be5Dd6m5.mjs\";const P=[\"solana:mainnet\",\"solana:devnet\",\"solana:testnet\"];function F(n){return e().decode(n)}function C(e,n){if(!Object.prototype.hasOwnProperty.call(e,n))throw TypeError(\"attempted to use private field on non-instance\");return e}var U=0,D=\"__private_\"+U+++\"__implementation\";function N(e,n){if(!Object.prototype.hasOwnProperty.call(e,n))throw TypeError(\"attempted to use private field on non-instance\");return e}var B=0;function R(e){return\"__private_\"+B+++\"_\"+e}var x=/*#__PURE__*/R(\"_address\"),L=/*#__PURE__*/R(\"_publicKey\"),V=/*#__PURE__*/R(\"_chains\"),Q=/*#__PURE__*/R(\"_features\"),G=/*#__PURE__*/R(\"_label\"),K=/*#__PURE__*/R(\"_icon\");class k{get address(){return N(this,x)[x]}get publicKey(){return N(this,L)[L].slice()}get chains(){return N(this,V)[V].slice()}get features(){return N(this,Q)[Q].slice()}get label(){return N(this,G)[G]}get icon(){return N(this,K)[K]}constructor({address:e,publicKey:n,label:t,icon:a}){Object.defineProperty(this,x,{writable:!0,value:void 0}),Object.defineProperty(this,L,{writable:!0,value:void 0}),Object.defineProperty(this,V,{writable:!0,value:void 0}),Object.defineProperty(this,Q,{writable:!0,value:void 0}),Object.defineProperty(this,G,{writable:!0,value:void 0}),Object.defineProperty(this,K,{writable:!0,value:void 0}),N(this,x)[x]=e,N(this,L)[L]=n,N(this,V)[V]=P,N(this,G)[G]=t,N(this,K)[K]=a,N(this,Q)[Q]=[\"solana:signAndSendTransaction\",\"solana:signTransaction\",\"solana:signMessage\"],new.target===k&&Object.freeze(this)}}function J(e,n){if(!Object.prototype.hasOwnProperty.call(e,n))throw TypeError(\"attempted to use private field on non-instance\");return e}var Y=0;function H(e){return\"__private_\"+Y+++\"_\"+e}var Z=/*#__PURE__*/H(\"_listeners\"),z=/*#__PURE__*/H(\"_version\"),q=/*#__PURE__*/H(\"_name\"),X=/*#__PURE__*/H(\"_icon\"),$=/*#__PURE__*/H(\"_injection\"),ee=/*#__PURE__*/H(\"_isPrivyWallet\"),ne=/*#__PURE__*/H(\"_accounts\"),te=/*#__PURE__*/H(\"_on\"),ae=/*#__PURE__*/H(\"_emit\"),se=/*#__PURE__*/H(\"_off\"),ie=/*#__PURE__*/H(\"_connected\"),re=/*#__PURE__*/H(\"_connect\"),oe=/*#__PURE__*/H(\"_disconnect\"),ce=/*#__PURE__*/H(\"_signMessage\"),le=/*#__PURE__*/H(\"_signAndSendTransaction\"),de=/*#__PURE__*/H(\"_signTransaction\");function ue(e,...n){J(this,Z)[Z][e]?.forEach((e=>e.apply(null,n)))}function ge(e,n){J(this,Z)[Z][e]=J(this,Z)[Z][e]?.filter((e=>n!==e))}function he(e,s,i){let r=structuredClone(n().decode(e)),o=t(s);return o in r.signatures&&(r.signatures[o]=i),new Uint8Array(a().encode(r))}function pe(){let{isHeadlessSigning:e,walletProxy:n,initializeWalletProxy:t,recoverEmbeddedWallet:a,openModal:s,privy:i,client:r}=d(),{user:o}=v(),{setModalData:l}=p(),{signWithUserSigner:h}=_();return{signMessage:({message:d,address:p,options:A})=>new Promise((async(y,v)=>{let T=f(o,p);if(\"privy\"!==T?.walletClientType)return void v(new u(\"Wallet is not a Privy wallet\",void 0,g.EMBEDDED_WALLET_NOT_FOUND));let{entropyId:b,entropyIdVerifier:O}=m(o,T),S=w(T),_=j(d).toString(\"base64\");if(_.length<1)return void v(new u(\"Message must be a non-empty string\",void 0,g.INVALID_MESSAGE));let E=async()=>{let e;if(!o)throw Error(\"User must be authenticated before signing with a Privy wallet\");let s=await r.getAccessToken();if(!s)throw Error(\"User must be authenticated to use their embedded wallet.\");let l=n??await t(15e3);if(!l)throw Error(\"Failed to initialize embedded wallet proxy.\");if(!await a({address:T.address}))throw Error(\"Unable to connect to wallet\");if(S){let n=await c(i,h,{chain_type:\"solana\",method:\"signMessage\",params:{message:_,encoding:\"base64\"},wallet_id:T.id});if(!n.data||!(\"signature\"in n.data))throw Error(\"Failed to sign message\");e=n.data.signature}else{let{response:n}=await l.rpc({accessToken:s,entropyId:b,entropyIdVerifier:O,chainType:\"solana\",hdWalletIndex:T.walletIndex??0,requesterAppId:A?.uiOptions?.requesterAppId,request:{method:\"signMessage\",params:{message:_}}});e=n.data.signature}return e};if(e({showWalletUIs:A?.uiOptions?.showWalletUIs}))try{let e=await E(),n=new Uint8Array(j(e,\"base64\"));y({signature:n})}catch(e){v(e)}else l({signMessage:{method:\"solana_signMessage\",data:_,confirmAndSign:E,onSuccess:e=>{y({signature:new Uint8Array(j(e,\"base64\"))})},onFailure:e=>{v(e)},uiOptions:A?.uiOptions??{}},connectWallet:{recoveryMethod:T.recoveryMethod,connectingWalletAddress:T.address,entropyId:b,entropyIdVerifier:O,isUnifiedWallet:S,onCompleteNavigateTo:\"SignRequestScreen\",onFailure:e=>{v(new u(\"Failed to connect to wallet\",e,g.UNKNOWN_CONNECT_WALLET_ERROR))}}}),s(\"EmbeddedWalletConnectingScreen\")}))}}function fe(){let{isHeadlessSigning:e,openModal:n}=d(),{setModalData:t}=p(),{signMessage:a}=pe(),{user:s}=v();return{signTransaction:async({transaction:i,options:r,chain:o=\"solana:mainnet\",address:c})=>{async function l(e){let{signature:n}=await a({message:W(e),address:c,options:{...r,uiOptions:{...r?.uiOptions,showWalletUIs:!1}}});return{signedTransaction:he(e,c,n)}}return e({showWalletUIs:r?.uiOptions?.showWalletUIs})?l(i):new Promise((async(e,a)=>{let d=f(s,c);if(\"privy\"!==d?.walletClientType)return void a(new u(\"Wallet is not a Privy wallet\",void 0,g.EMBEDDED_WALLET_NOT_FOUND));let{entropyId:h,entropyIdVerifier:p}=m(s,d),A=w(d);function y(e){return n=>{a(n instanceof u?n:new u(\"Failed to connect to wallet\",n,e))}}let v={account:d,transaction:i,chain:o,signOnly:!0,uiOptions:r?.uiOptions||{},onConfirm:l,onSuccess:e,onFailure:y(g.TRANSACTION_FAILURE)};t({connectWallet:{recoveryMethod:d.recoveryMethod,connectingWalletAddress:d.address,entropyId:h,entropyIdVerifier:p,isUnifiedWallet:A,onCompleteNavigateTo:\"StandardSignAndSendTransactionScreen\",onFailure:y(g.UNKNOWN_CONNECT_WALLET_ERROR)},standardSignAndSendTransaction:v}),n(\"EmbeddedWalletConnectingScreen\")}))}}}let we=new class extends b{setImplementation(e){C(this,D)[D]=e}async signMessage(e){return C(this,D)[D].signMessage(e)}async signAndSendTransaction(e){return C(this,D)[D].signAndSendTransaction(e)}async signTransaction(e){return C(this,D)[D].signTransaction(e)}constructor(e){super(),Object.defineProperty(this,D,{writable:!0,value:void 0}),C(this,D)[D]=e}}({signTransaction:h(\"signTransaction was not injected\"),signAndSendTransaction:h(\"signAndSendTransaction was not injected\"),signMessage:h(\"signMessage was not injected\")}),Ae=new class{get version(){return J(this,z)[z]}get name(){return J(this,q)[q]}get icon(){return J(this,X)[X]}get chains(){return P.slice()}get features(){return{\"standard:connect\":{version:\"1.0.0\",connect:J(this,re)[re]},\"standard:disconnect\":{version:\"1.0.0\",disconnect:J(this,oe)[oe]},\"standard:events\":{version:\"1.0.0\",on:J(this,te)[te]},\"solana:signAndSendTransaction\":{version:\"1.0.0\",supportedTransactionVersions:[\"legacy\",0],signAndSendTransaction:J(this,le)[le]},\"solana:signTransaction\":{version:\"1.0.0\",supportedTransactionVersions:[\"legacy\",0],signTransaction:J(this,de)[de]},\"solana:signMessage\":{version:\"1.0.0\",signMessage:J(this,ce)[ce]},\"privy:\":{privy:{signMessage:J(this,$)[$].signMessage,signTransaction:J(this,$)[$].signTransaction,signAndSendTransaction:J(this,$)[$].signAndSendTransaction}}}}get accounts(){return J(this,ne)[ne].slice()}get isPrivyWallet(){return J(this,ee)[ee]}constructor({name:e,icon:n,version:t,injection:a,wallets:s}){Object.defineProperty(this,ae,{value:ue}),Object.defineProperty(this,se,{value:ge}),Object.defineProperty(this,Z,{writable:!0,value:void 0}),Object.defineProperty(this,z,{writable:!0,value:void 0}),Object.defineProperty(this,q,{writable:!0,value:void 0}),Object.defineProperty(this,X,{writable:!0,value:void 0}),Object.defineProperty(this,$,{writable:!0,value:void 0}),Object.defineProperty(this,ee,{writable:!0,value:void 0}),Object.defineProperty(this,ne,{writable:!0,value:void 0}),Object.defineProperty(this,te,{writable:!0,value:void 0}),Object.defineProperty(this,ie,{writable:!0,value:void 0}),Object.defineProperty(this,re,{writable:!0,value:void 0}),Object.defineProperty(this,oe,{writable:!0,value:void 0}),Object.defineProperty(this,ce,{writable:!0,value:void 0}),Object.defineProperty(this,le,{writable:!0,value:void 0}),Object.defineProperty(this,de,{writable:!0,value:void 0}),J(this,Z)[Z]={},J(this,te)[te]=(e,n)=>(J(this,Z)[Z][e]?.push(n)||(J(this,Z)[Z][e]=[n]),()=>J(this,se)[se](e,n)),J(this,ie)[ie]=e=>{null!=e&&(J(this,ne)[ne]=e.map((({address:e})=>new k({address:e,publicKey:O.decode(e)})))),J(this,ae)[ae](\"change\",{accounts:this.accounts})},J(this,re)[re]=async()=>(J(this,ae)[ae](\"change\",{accounts:this.accounts}),{accounts:this.accounts}),J(this,oe)[oe]=async()=>{J(this,ae)[ae](\"change\",{accounts:this.accounts})},J(this,ce)[ce]=async(...e)=>{let n=[];for(let{account:t,...a}of e){let{signature:e}=await J(this,$)[$].signMessage({...a,address:t.address});n.push({signedMessage:a.message,signature:e})}return n},J(this,le)[le]=async(...e)=>{let n=[];for(let t of e){let{signature:e}=await J(this,$)[$].signAndSendTransaction({...t,transaction:t.transaction,address:t.account.address,chain:t.chain||\"solana:mainnet\",options:t.options});n.push({signature:e})}return n},J(this,de)[de]=async(...e)=>{let n=[];for(let{transaction:t,account:a,options:s,chain:i}of e){let{signedTransaction:e}=await J(this,$)[$].signTransaction({transaction:t,address:a.address,chain:i||\"solana:mainnet\",options:s});n.push({signedTransaction:e})}return n},J(this,q)[q]=e,J(this,X)[X]=n,J(this,z)[z]=t,J(this,$)[$]=a,J(this,ne)[ne]=[],J(this,ee)[ee]=!0,a.on(\"accountChanged\",J(this,ie)[ie],this),J(this,ie)[ie](s)}}({name:\"Privy\",version:\"1.0.0\",icon:\"data:image/png;base64,AAABAAEAFBQAAAAAIABlAQAAFgAAAIlQTkcNChoKAAAADUlIRFIAAAAUAAAAFAgGAAAAjYkdDQAAAAlwSFlzAAAOwwAADsMBx2+oZAAAAQVJREFUeJxiYMANZIC4E4ivAPFPIP4FxDeAuB+IlfDowwBMQFwJxF+B+D8O/AOI66Bq8QJGIF6ExyB0vAqImfEZmEeCYTDcgMswPiB+T4aB34FYApuBsWQYBsP52AycToGBK7EZuJECAw9jM3AVBQbuwWZgIwUGTsZmoDkFBnpiMxAEjpJh2FV8iVsbiD+TYBgoDVrgMgwGnID4HRGGgTKBGyHDYEAaiBdCSxh0g/5AU4Q8sYYhAzEgjoGmABBOgFo2eACowFABYn0oVgViAVINkQTiZUD8DIj/ATF6GILEXgLxCiCWIsZAbiAuBeKtQHwHiEHJ6C8UfwHie0C8E4jLoWpRAAAAAP//rcbhsQAAAAZJREFUAwBYFs3VKJ0cuQAAAABJRU5ErkJggg==\",wallets:[],injection:we});function ye(){let{ready:e}=T(),{user:n}=v(),{signMessage:t}=pe(),{signTransaction:a}=fe(),{signAndSendTransaction:r}=function(){let e=S(),{isHeadlessSigning:n,openModal:t}=d(),{setModalData:a}=p(),{signTransaction:s}=fe(),i=M(),{user:r}=v(),{signWithUserSigner:l}=_();return{signAndSendTransaction:async({transaction:d,address:h,chain:p=\"solana:mainnet\",options:A})=>{let y=f(r,h);if(\"privy\"!==y?.walletClientType)throw new u(\"Wallet is not a Privy wallet\",void 0,g.EMBEDDED_WALLET_NOT_FOUND);let v=w(y);async function T(n){if(A?.sponsor)return await(async n=>{if(!v)throw new u(\"Sponsoring transactions is only supported for wallets on the TEE stack\",g.INVALID_DATA);let t=new o({appId:e.id,clientId:e.appClientId,storage:I}),a=await c(t,l,{chain_type:\"solana\",method:\"signAndSendTransaction\",sponsor:!0,params:{transaction:j(n).toString(\"base64\"),encoding:\"base64\"},caip2:`solana:${(await i(p).rpc.getGenesisHash().send()).substring(0,32)}`,wallet_id:y.id});if(a.data&&\"hash\"in a.data)return{signature:O.decode(a.data.hash)};throw Error(\"Failed to sign and send transaction\")})(n);let{signedTransaction:t}=await s({transaction:n,address:h,chain:p,options:{...A,uiOptions:{...A?.uiOptions,showWalletUIs:!1}}}),{signature:a}=await i(p).sendAndConfirmTransaction(t);return{signature:a}}return n({showWalletUIs:A?.uiOptions?.showWalletUIs})?T(d):new Promise((async(n,s)=>{let i,o,{entropyId:c,entropyIdVerifier:l}=m(r,y);function f(e){return n=>{s(n instanceof u?n:new u(\"Failed to connect to wallet\",n,e))}}let w={account:y,transaction:d,chain:p,signOnly:!1,uiOptions:A?.uiOptions||{},onConfirm:T,onSuccess:n,onFailure:f(g.TRANSACTION_FAILURE),isSponsored:!!A?.sponsor},b={recoveryMethod:y.recoveryMethod,connectingWalletAddress:y.address,entropyId:c,entropyIdVerifier:l,isUnifiedWallet:v,onCompleteNavigateTo:\"StandardSignAndSendTransactionScreen\",onFailure:f(g.UNKNOWN_CONNECT_WALLET_ERROR)};e.fundingConfig&&(i=E({address:h,appConfig:e,methodScreen:\"FundingMethodSelectionScreen\",fundWalletConfig:{...A,asset:\"native-currency\",chain:p},externalSolanaFundingScreen:\"FundSolWalletWithExternalSolanaWallet\"}),o={amount:e.fundingConfig.defaultRecommendedAmount,asset:\"SOL\",chain:p,destinationAddress:h,afterSuccessScreen:\"StandardSignAndSendTransactionScreen\",sourceWalletData:void 0}),a({connectWallet:b,standardSignAndSendTransaction:w,funding:i,solanaFundingData:o}),t(\"EmbeddedWalletConnectingScreen\")}))}}}(),l=s((()=>{let e=[...A(n).sort(((e,n)=>(e.walletIndex??0)-(n.walletIndex??0)))],t=y(n);return t.length?[...e,...t]:e}),[n]),h=s((()=>({signMessage:async({message:e,address:n,options:a})=>await t({message:e,address:n,options:a}),signTransaction:async({transaction:e,address:n,chain:t,options:s})=>await a({transaction:e,address:n,chain:t,options:s}),async signAndSendTransaction({transaction:e,address:n,chain:t,options:a}){let{signature:s}=await r({transaction:e,address:n,chain:t,options:a});return{signature:s}}})),[t,a,r]);return i((()=>{we?.setImplementation(h)}),[h]),i((()=>{var n;!e||(n=Ae.accounts).length===l.length&&n.every(((e,n)=>e.address===l[n]?.address))||we?.emit(\"accountChanged\",l)}),[e,l]),{ready:e,wallet:Ae}}function ve(){let{client:e}=d(),{ready:n,wallet:t}=ye(),[a,s]=r([]),[o,c]=r([]);return i((()=>{let e=[t,...a.filter((e=>\"solana\"===e.chainType&&!!e.wallet.features)).map((e=>e.wallet))];c(e);let n=a.flatMap((n=>{let t=()=>c([...e]);return n.on(\"walletsUpdated\",t),{connector:n,off:t}})),s=e.map((n=>n.features[\"standard:events\"]?.on(\"change\",(()=>{c([...e])}))));return()=>{s.forEach((e=>e?.())),n.forEach((({connector:e,off:n})=>e.off(\"walletsUpdated\",n)))}}),[a]),i((()=>{s(e.connectors?.walletConnectors.filter((e=>\"solana\"===e.chainType))??[]);let n=()=>{s(e.connectors?.walletConnectors.filter((e=>\"solana\"===e.chainType))??[])};return e.connectors?.on(\"connectorInitialized\",n),()=>{e.connectors?.off(\"connectorInitialized\",n)}}),[n,e.connectors]),{ready:n,wallets:o}}function me(){let{ready:e,wallets:n}=ve();return{ready:e,wallets:s((()=>n.flatMap((e=>e.accounts.map((n=>new l({wallet:e,account:n})))))),[n])}}export{P as S,ve as a,F as g,me as u};\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getEnumDecoder,\n  getEnumEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n} from '@solana/kit';\n\nexport enum NonceState {\n  Uninitialized,\n  Initialized,\n}\n\nexport type NonceStateArgs = NonceState;\n\nexport function getNonceStateEncoder(): FixedSizeEncoder<NonceStateArgs> {\n  return getEnumEncoder(NonceState, { size: getU32Encoder() });\n}\n\nexport function getNonceStateDecoder(): FixedSizeDecoder<NonceState> {\n  return getEnumDecoder(NonceState, { size: getU32Decoder() });\n}\n\nexport function getNonceStateCodec(): FixedSizeCodec<\n  NonceStateArgs,\n  NonceState\n> {\n  return combineCodec(getNonceStateEncoder(), getNonceStateDecoder());\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getEnumDecoder,\n  getEnumEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n} from '@solana/kit';\n\nexport enum NonceVersion {\n  Legacy,\n  Current,\n}\n\nexport type NonceVersionArgs = NonceVersion;\n\nexport function getNonceVersionEncoder(): FixedSizeEncoder<NonceVersionArgs> {\n  return getEnumEncoder(NonceVersion, { size: getU32Encoder() });\n}\n\nexport function getNonceVersionDecoder(): FixedSizeDecoder<NonceVersion> {\n  return getEnumDecoder(NonceVersion, { size: getU32Decoder() });\n}\n\nexport function getNonceVersionCodec(): FixedSizeCodec<\n  NonceVersionArgs,\n  NonceVersion\n> {\n  return combineCodec(getNonceVersionEncoder(), getNonceVersionDecoder());\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  assertAccountExists,\n  assertAccountsExist,\n  combineCodec,\n  decodeAccount,\n  fetchEncodedAccount,\n  fetchEncodedAccounts,\n  getAddressDecoder,\n  getAddressEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  type Account,\n  type Address,\n  type EncodedAccount,\n  type FetchAccountConfig,\n  type FetchAccountsConfig,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type MaybeAccount,\n  type MaybeEncodedAccount,\n} from '@solana/kit';\nimport {\n  getNonceStateDecoder,\n  getNonceStateEncoder,\n  getNonceVersionDecoder,\n  getNonceVersionEncoder,\n  type NonceState,\n  type NonceStateArgs,\n  type NonceVersion,\n  type NonceVersionArgs,\n} from '../types';\n\nexport type Nonce = {\n  version: NonceVersion;\n  state: NonceState;\n  authority: Address;\n  blockhash: Address;\n  lamportsPerSignature: bigint;\n};\n\nexport type NonceArgs = {\n  version: NonceVersionArgs;\n  state: NonceStateArgs;\n  authority: Address;\n  blockhash: Address;\n  lamportsPerSignature: number | bigint;\n};\n\nexport function getNonceEncoder(): FixedSizeEncoder<NonceArgs> {\n  return getStructEncoder([\n    ['version', getNonceVersionEncoder()],\n    ['state', getNonceStateEncoder()],\n    ['authority', getAddressEncoder()],\n    ['blockhash', getAddressEncoder()],\n    ['lamportsPerSignature', getU64Encoder()],\n  ]);\n}\n\nexport function getNonceDecoder(): FixedSizeDecoder<Nonce> {\n  return getStructDecoder([\n    ['version', getNonceVersionDecoder()],\n    ['state', getNonceStateDecoder()],\n    ['authority', getAddressDecoder()],\n    ['blockhash', getAddressDecoder()],\n    ['lamportsPerSignature', getU64Decoder()],\n  ]);\n}\n\nexport function getNonceCodec(): FixedSizeCodec<NonceArgs, Nonce> {\n  return combineCodec(getNonceEncoder(), getNonceDecoder());\n}\n\nexport function decodeNonce<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress>\n): Account<Nonce, TAddress>;\nexport function decodeNonce<TAddress extends string = string>(\n  encodedAccount: MaybeEncodedAccount<TAddress>\n): MaybeAccount<Nonce, TAddress>;\nexport function decodeNonce<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>\n): Account<Nonce, TAddress> | MaybeAccount<Nonce, TAddress> {\n  return decodeAccount(\n    encodedAccount as MaybeEncodedAccount<TAddress>,\n    getNonceDecoder()\n  );\n}\n\nexport async function fetchNonce<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<Account<Nonce, TAddress>> {\n  const maybeAccount = await fetchMaybeNonce(rpc, address, config);\n  assertAccountExists(maybeAccount);\n  return maybeAccount;\n}\n\nexport async function fetchMaybeNonce<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<MaybeAccount<Nonce, TAddress>> {\n  const maybeAccount = await fetchEncodedAccount(rpc, address, config);\n  return decodeNonce(maybeAccount);\n}\n\nexport async function fetchAllNonce(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<Account<Nonce>[]> {\n  const maybeAccounts = await fetchAllMaybeNonce(rpc, addresses, config);\n  assertAccountsExist(maybeAccounts);\n  return maybeAccounts;\n}\n\nexport async function fetchAllMaybeNonce(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<MaybeAccount<Nonce>[]> {\n  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);\n  return maybeAccounts.map((maybeAccount) => decodeNonce(maybeAccount));\n}\n\nexport function getNonceSize(): number {\n  return 80;\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  containsBytes,\n  getU32Encoder,\n  type Address,\n  type ReadonlyUint8Array,\n} from '@solana/kit';\nimport {\n  type ParsedAdvanceNonceAccountInstruction,\n  type ParsedAllocateInstruction,\n  type ParsedAllocateWithSeedInstruction,\n  type ParsedAssignInstruction,\n  type ParsedAssignWithSeedInstruction,\n  type ParsedAuthorizeNonceAccountInstruction,\n  type ParsedCreateAccountInstruction,\n  type ParsedCreateAccountWithSeedInstruction,\n  type ParsedInitializeNonceAccountInstruction,\n  type ParsedTransferSolInstruction,\n  type ParsedTransferSolWithSeedInstruction,\n  type ParsedUpgradeNonceAccountInstruction,\n  type ParsedWithdrawNonceAccountInstruction,\n} from '../instructions';\n\nexport const SYSTEM_PROGRAM_ADDRESS =\n  '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n\nexport enum SystemAccount {\n  Nonce,\n}\n\nexport enum SystemInstruction {\n  CreateAccount,\n  Assign,\n  TransferSol,\n  CreateAccountWithSeed,\n  AdvanceNonceAccount,\n  WithdrawNonceAccount,\n  InitializeNonceAccount,\n  AuthorizeNonceAccount,\n  Allocate,\n  AllocateWithSeed,\n  AssignWithSeed,\n  TransferSolWithSeed,\n  UpgradeNonceAccount,\n}\n\nexport function identifySystemInstruction(\n  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array\n): SystemInstruction {\n  const data = 'data' in instruction ? instruction.data : instruction;\n  if (containsBytes(data, getU32Encoder().encode(0), 0)) {\n    return SystemInstruction.CreateAccount;\n  }\n  if (containsBytes(data, getU32Encoder().encode(1), 0)) {\n    return SystemInstruction.Assign;\n  }\n  if (containsBytes(data, getU32Encoder().encode(2), 0)) {\n    return SystemInstruction.TransferSol;\n  }\n  if (containsBytes(data, getU32Encoder().encode(3), 0)) {\n    return SystemInstruction.CreateAccountWithSeed;\n  }\n  if (containsBytes(data, getU32Encoder().encode(4), 0)) {\n    return SystemInstruction.AdvanceNonceAccount;\n  }\n  if (containsBytes(data, getU32Encoder().encode(5), 0)) {\n    return SystemInstruction.WithdrawNonceAccount;\n  }\n  if (containsBytes(data, getU32Encoder().encode(6), 0)) {\n    return SystemInstruction.InitializeNonceAccount;\n  }\n  if (containsBytes(data, getU32Encoder().encode(7), 0)) {\n    return SystemInstruction.AuthorizeNonceAccount;\n  }\n  if (containsBytes(data, getU32Encoder().encode(8), 0)) {\n    return SystemInstruction.Allocate;\n  }\n  if (containsBytes(data, getU32Encoder().encode(9), 0)) {\n    return SystemInstruction.AllocateWithSeed;\n  }\n  if (containsBytes(data, getU32Encoder().encode(10), 0)) {\n    return SystemInstruction.AssignWithSeed;\n  }\n  if (containsBytes(data, getU32Encoder().encode(11), 0)) {\n    return SystemInstruction.TransferSolWithSeed;\n  }\n  if (containsBytes(data, getU32Encoder().encode(12), 0)) {\n    return SystemInstruction.UpgradeNonceAccount;\n  }\n  throw new Error(\n    'The provided instruction could not be identified as a system instruction.'\n  );\n}\n\nexport type ParsedSystemInstruction<\n  TProgram extends string = '11111111111111111111111111111111',\n> =\n  | ({\n      instructionType: SystemInstruction.CreateAccount;\n    } & ParsedCreateAccountInstruction<TProgram>)\n  | ({\n      instructionType: SystemInstruction.Assign;\n    } & ParsedAssignInstruction<TProgram>)\n  | ({\n      instructionType: SystemInstruction.TransferSol;\n    } & ParsedTransferSolInstruction<TProgram>)\n  | ({\n      instructionType: SystemInstruction.CreateAccountWithSeed;\n    } & ParsedCreateAccountWithSeedInstruction<TProgram>)\n  | ({\n      instructionType: SystemInstruction.AdvanceNonceAccount;\n    } & ParsedAdvanceNonceAccountInstruction<TProgram>)\n  | ({\n      instructionType: SystemInstruction.WithdrawNonceAccount;\n    } & ParsedWithdrawNonceAccountInstruction<TProgram>)\n  | ({\n      instructionType: SystemInstruction.InitializeNonceAccount;\n    } & ParsedInitializeNonceAccountInstruction<TProgram>)\n  | ({\n      instructionType: SystemInstruction.AuthorizeNonceAccount;\n    } & ParsedAuthorizeNonceAccountInstruction<TProgram>)\n  | ({\n      instructionType: SystemInstruction.Allocate;\n    } & ParsedAllocateInstruction<TProgram>)\n  | ({\n      instructionType: SystemInstruction.AllocateWithSeed;\n    } & ParsedAllocateWithSeedInstruction<TProgram>)\n  | ({\n      instructionType: SystemInstruction.AssignWithSeed;\n    } & ParsedAssignWithSeedInstruction<TProgram>)\n  | ({\n      instructionType: SystemInstruction.TransferSolWithSeed;\n    } & ParsedTransferSolWithSeedInstruction<TProgram>)\n  | ({\n      instructionType: SystemInstruction.UpgradeNonceAccount;\n    } & ParsedUpgradeNonceAccountInstruction<TProgram>);\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  isProgramError,\n  type Address,\n  type SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM,\n  type SolanaError,\n} from '@solana/kit';\nimport { SYSTEM_PROGRAM_ADDRESS } from '../programs';\n\n/** AccountAlreadyInUse: an account with the same address already exists */\nexport const SYSTEM_ERROR__ACCOUNT_ALREADY_IN_USE = 0x0; // 0\n/** ResultWithNegativeLamports: account does not have enough SOL to perform the operation */\nexport const SYSTEM_ERROR__RESULT_WITH_NEGATIVE_LAMPORTS = 0x1; // 1\n/** InvalidProgramId: cannot assign account to this program id */\nexport const SYSTEM_ERROR__INVALID_PROGRAM_ID = 0x2; // 2\n/** InvalidAccountDataLength: cannot allocate account data of this length */\nexport const SYSTEM_ERROR__INVALID_ACCOUNT_DATA_LENGTH = 0x3; // 3\n/** MaxSeedLengthExceeded: length of requested seed is too long */\nexport const SYSTEM_ERROR__MAX_SEED_LENGTH_EXCEEDED = 0x4; // 4\n/** AddressWithSeedMismatch: provided address does not match addressed derived from seed */\nexport const SYSTEM_ERROR__ADDRESS_WITH_SEED_MISMATCH = 0x5; // 5\n/** NonceNoRecentBlockhashes: advancing stored nonce requires a populated RecentBlockhashes sysvar */\nexport const SYSTEM_ERROR__NONCE_NO_RECENT_BLOCKHASHES = 0x6; // 6\n/** NonceBlockhashNotExpired: stored nonce is still in recent_blockhashes */\nexport const SYSTEM_ERROR__NONCE_BLOCKHASH_NOT_EXPIRED = 0x7; // 7\n/** NonceUnexpectedBlockhashValue: specified nonce does not match stored nonce */\nexport const SYSTEM_ERROR__NONCE_UNEXPECTED_BLOCKHASH_VALUE = 0x8; // 8\n\nexport type SystemError =\n  | typeof SYSTEM_ERROR__ACCOUNT_ALREADY_IN_USE\n  | typeof SYSTEM_ERROR__ADDRESS_WITH_SEED_MISMATCH\n  | typeof SYSTEM_ERROR__INVALID_ACCOUNT_DATA_LENGTH\n  | typeof SYSTEM_ERROR__INVALID_PROGRAM_ID\n  | typeof SYSTEM_ERROR__MAX_SEED_LENGTH_EXCEEDED\n  | typeof SYSTEM_ERROR__NONCE_BLOCKHASH_NOT_EXPIRED\n  | typeof SYSTEM_ERROR__NONCE_NO_RECENT_BLOCKHASHES\n  | typeof SYSTEM_ERROR__NONCE_UNEXPECTED_BLOCKHASH_VALUE\n  | typeof SYSTEM_ERROR__RESULT_WITH_NEGATIVE_LAMPORTS;\n\nlet systemErrorMessages: Record<SystemError, string> | undefined;\nif (process.env.NODE_ENV !== 'production') {\n  systemErrorMessages = {\n    [SYSTEM_ERROR__ACCOUNT_ALREADY_IN_USE]: `an account with the same address already exists`,\n    [SYSTEM_ERROR__ADDRESS_WITH_SEED_MISMATCH]: `provided address does not match addressed derived from seed`,\n    [SYSTEM_ERROR__INVALID_ACCOUNT_DATA_LENGTH]: `cannot allocate account data of this length`,\n    [SYSTEM_ERROR__INVALID_PROGRAM_ID]: `cannot assign account to this program id`,\n    [SYSTEM_ERROR__MAX_SEED_LENGTH_EXCEEDED]: `length of requested seed is too long`,\n    [SYSTEM_ERROR__NONCE_BLOCKHASH_NOT_EXPIRED]: `stored nonce is still in recent_blockhashes`,\n    [SYSTEM_ERROR__NONCE_NO_RECENT_BLOCKHASHES]: `advancing stored nonce requires a populated RecentBlockhashes sysvar`,\n    [SYSTEM_ERROR__NONCE_UNEXPECTED_BLOCKHASH_VALUE]: `specified nonce does not match stored nonce`,\n    [SYSTEM_ERROR__RESULT_WITH_NEGATIVE_LAMPORTS]: `account does not have enough SOL to perform the operation`,\n  };\n}\n\nexport function getSystemErrorMessage(code: SystemError): string {\n  if (process.env.NODE_ENV !== 'production') {\n    return (systemErrorMessages as Record<SystemError, string>)[code];\n  }\n\n  return 'Error message not available in production bundles.';\n}\n\nexport function isSystemError<TProgramErrorCode extends SystemError>(\n  error: unknown,\n  transactionMessage: {\n    instructions: Record<number, { programAddress: Address }>;\n  },\n  code?: TProgramErrorCode\n): error is SolanaError<typeof SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM> &\n  Readonly<{ context: Readonly<{ code: TProgramErrorCode }> }> {\n  return isProgramError<TProgramErrorCode>(\n    error,\n    transactionMessage,\n    SYSTEM_PROGRAM_ADDRESS,\n    code\n  );\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  isProgramDerivedAddress,\n  isTransactionSigner as kitIsTransactionSigner,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type ProgramDerivedAddress,\n  type TransactionSigner,\n  upgradeRoleToSigner,\n} from '@solana/kit';\n\n/**\n * Asserts that the given value is not null or undefined.\n * @internal\n */\nexport function expectSome<T>(value: T | null | undefined): T {\n  if (value === null || value === undefined) {\n    throw new Error('Expected a value but received null or undefined.');\n  }\n  return value;\n}\n\n/**\n * Asserts that the given value is a PublicKey.\n * @internal\n */\nexport function expectAddress<T extends string = string>(\n  value:\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null\n    | undefined\n): Address<T> {\n  if (!value) {\n    throw new Error('Expected a Address.');\n  }\n  if (typeof value === 'object' && 'address' in value) {\n    return value.address;\n  }\n  if (Array.isArray(value)) {\n    return value[0] as Address<T>;\n  }\n  return value as Address<T>;\n}\n\n/**\n * Asserts that the given value is a PDA.\n * @internal\n */\nexport function expectProgramDerivedAddress<T extends string = string>(\n  value:\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null\n    | undefined\n): ProgramDerivedAddress<T> {\n  if (!value || !Array.isArray(value) || !isProgramDerivedAddress(value)) {\n    throw new Error('Expected a ProgramDerivedAddress.');\n  }\n  return value;\n}\n\n/**\n * Asserts that the given value is a TransactionSigner.\n * @internal\n */\nexport function expectTransactionSigner<T extends string = string>(\n  value:\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null\n    | undefined\n): TransactionSigner<T> {\n  if (!value || !isTransactionSigner(value)) {\n    throw new Error('Expected a TransactionSigner.');\n  }\n  return value;\n}\n\n/**\n * Defines an instruction account to resolve.\n * @internal\n */\nexport type ResolvedAccount<\n  T extends string = string,\n  U extends\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null =\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null,\n> = {\n  isWritable: boolean;\n  value: U;\n};\n\n/**\n * Defines an instruction that stores additional bytes on-chain.\n * @internal\n */\nexport type InstructionWithByteDelta = {\n  byteDelta: number;\n};\n\n/**\n * Get account metas and signers from resolved accounts.\n * @internal\n */\nexport function getAccountMetaFactory(\n  programAddress: Address,\n  optionalAccountStrategy: 'omitted' | 'programId'\n) {\n  return (\n    account: ResolvedAccount\n  ): AccountMeta | AccountSignerMeta | undefined => {\n    if (!account.value) {\n      if (optionalAccountStrategy === 'omitted') return;\n      return Object.freeze({\n        address: programAddress,\n        role: AccountRole.READONLY,\n      });\n    }\n\n    const writableRole = account.isWritable\n      ? AccountRole.WRITABLE\n      : AccountRole.READONLY;\n    return Object.freeze({\n      address: expectAddress(account.value),\n      role: isTransactionSigner(account.value)\n        ? upgradeRoleToSigner(writableRole)\n        : writableRole,\n      ...(isTransactionSigner(account.value) ? { signer: account.value } : {}),\n    });\n  };\n}\n\nexport function isTransactionSigner<TAddress extends string = string>(\n  value:\n    | Address<TAddress>\n    | ProgramDerivedAddress<TAddress>\n    | TransactionSigner<TAddress>\n): value is TransactionSigner<TAddress> {\n  return (\n    !!value &&\n    typeof value === 'object' &&\n    'address' in value &&\n    kitIsTransactionSigner(value)\n  );\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { SYSTEM_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const ADVANCE_NONCE_ACCOUNT_DISCRIMINATOR = 4;\n\nexport function getAdvanceNonceAccountDiscriminatorBytes() {\n  return getU32Encoder().encode(ADVANCE_NONCE_ACCOUNT_DISCRIMINATOR);\n}\n\nexport type AdvanceNonceAccountInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountNonceAccount extends string | AccountMeta<string> = string,\n  TAccountRecentBlockhashesSysvar extends\n    | string\n    | AccountMeta<string> = 'SysvarRecentB1ockHashes11111111111111111111',\n  TAccountNonceAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountNonceAccount extends string\n        ? WritableAccount<TAccountNonceAccount>\n        : TAccountNonceAccount,\n      TAccountRecentBlockhashesSysvar extends string\n        ? ReadonlyAccount<TAccountRecentBlockhashesSysvar>\n        : TAccountRecentBlockhashesSysvar,\n      TAccountNonceAuthority extends string\n        ? ReadonlySignerAccount<TAccountNonceAuthority> &\n            AccountSignerMeta<TAccountNonceAuthority>\n        : TAccountNonceAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type AdvanceNonceAccountInstructionData = { discriminator: number };\n\nexport type AdvanceNonceAccountInstructionDataArgs = {};\n\nexport function getAdvanceNonceAccountInstructionDataEncoder(): FixedSizeEncoder<AdvanceNonceAccountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU32Encoder()]]),\n    (value) => ({\n      ...value,\n      discriminator: ADVANCE_NONCE_ACCOUNT_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getAdvanceNonceAccountInstructionDataDecoder(): FixedSizeDecoder<AdvanceNonceAccountInstructionData> {\n  return getStructDecoder([['discriminator', getU32Decoder()]]);\n}\n\nexport function getAdvanceNonceAccountInstructionDataCodec(): FixedSizeCodec<\n  AdvanceNonceAccountInstructionDataArgs,\n  AdvanceNonceAccountInstructionData\n> {\n  return combineCodec(\n    getAdvanceNonceAccountInstructionDataEncoder(),\n    getAdvanceNonceAccountInstructionDataDecoder()\n  );\n}\n\nexport type AdvanceNonceAccountInput<\n  TAccountNonceAccount extends string = string,\n  TAccountRecentBlockhashesSysvar extends string = string,\n  TAccountNonceAuthority extends string = string,\n> = {\n  nonceAccount: Address<TAccountNonceAccount>;\n  recentBlockhashesSysvar?: Address<TAccountRecentBlockhashesSysvar>;\n  nonceAuthority: TransactionSigner<TAccountNonceAuthority>;\n};\n\nexport function getAdvanceNonceAccountInstruction<\n  TAccountNonceAccount extends string,\n  TAccountRecentBlockhashesSysvar extends string,\n  TAccountNonceAuthority extends string,\n  TProgramAddress extends Address = typeof SYSTEM_PROGRAM_ADDRESS,\n>(\n  input: AdvanceNonceAccountInput<\n    TAccountNonceAccount,\n    TAccountRecentBlockhashesSysvar,\n    TAccountNonceAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): AdvanceNonceAccountInstruction<\n  TProgramAddress,\n  TAccountNonceAccount,\n  TAccountRecentBlockhashesSysvar,\n  TAccountNonceAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? SYSTEM_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    nonceAccount: { value: input.nonceAccount ?? null, isWritable: true },\n    recentBlockhashesSysvar: {\n      value: input.recentBlockhashesSysvar ?? null,\n      isWritable: false,\n    },\n    nonceAuthority: { value: input.nonceAuthority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Resolve default values.\n  if (!accounts.recentBlockhashesSysvar.value) {\n    accounts.recentBlockhashesSysvar.value =\n      'SysvarRecentB1ockHashes11111111111111111111' as Address<'SysvarRecentB1ockHashes11111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'omitted');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.nonceAccount),\n      getAccountMeta(accounts.recentBlockhashesSysvar),\n      getAccountMeta(accounts.nonceAuthority),\n    ],\n    data: getAdvanceNonceAccountInstructionDataEncoder().encode({}),\n    programAddress,\n  } as AdvanceNonceAccountInstruction<\n    TProgramAddress,\n    TAccountNonceAccount,\n    TAccountRecentBlockhashesSysvar,\n    TAccountNonceAuthority\n  >);\n}\n\nexport type ParsedAdvanceNonceAccountInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    nonceAccount: TAccountMetas[0];\n    recentBlockhashesSysvar: TAccountMetas[1];\n    nonceAuthority: TAccountMetas[2];\n  };\n  data: AdvanceNonceAccountInstructionData;\n};\n\nexport function parseAdvanceNonceAccountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedAdvanceNonceAccountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      nonceAccount: getNextAccount(),\n      recentBlockhashesSysvar: getNextAccount(),\n      nonceAuthority: getNextAccount(),\n    },\n    data: getAdvanceNonceAccountInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { SYSTEM_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const ALLOCATE_DISCRIMINATOR = 8;\n\nexport function getAllocateDiscriminatorBytes() {\n  return getU32Encoder().encode(ALLOCATE_DISCRIMINATOR);\n}\n\nexport type AllocateInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountNewAccount extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountNewAccount extends string\n        ? WritableSignerAccount<TAccountNewAccount> &\n            AccountSignerMeta<TAccountNewAccount>\n        : TAccountNewAccount,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type AllocateInstructionData = { discriminator: number; space: bigint };\n\nexport type AllocateInstructionDataArgs = { space: number | bigint };\n\nexport function getAllocateInstructionDataEncoder(): FixedSizeEncoder<AllocateInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU32Encoder()],\n      ['space', getU64Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: ALLOCATE_DISCRIMINATOR })\n  );\n}\n\nexport function getAllocateInstructionDataDecoder(): FixedSizeDecoder<AllocateInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU32Decoder()],\n    ['space', getU64Decoder()],\n  ]);\n}\n\nexport function getAllocateInstructionDataCodec(): FixedSizeCodec<\n  AllocateInstructionDataArgs,\n  AllocateInstructionData\n> {\n  return combineCodec(\n    getAllocateInstructionDataEncoder(),\n    getAllocateInstructionDataDecoder()\n  );\n}\n\nexport type AllocateInput<TAccountNewAccount extends string = string> = {\n  newAccount: TransactionSigner<TAccountNewAccount>;\n  space: AllocateInstructionDataArgs['space'];\n};\n\nexport function getAllocateInstruction<\n  TAccountNewAccount extends string,\n  TProgramAddress extends Address = typeof SYSTEM_PROGRAM_ADDRESS,\n>(\n  input: AllocateInput<TAccountNewAccount>,\n  config?: { programAddress?: TProgramAddress }\n): AllocateInstruction<TProgramAddress, TAccountNewAccount> {\n  // Program address.\n  const programAddress = config?.programAddress ?? SYSTEM_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    newAccount: { value: input.newAccount ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'omitted');\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.newAccount)],\n    data: getAllocateInstructionDataEncoder().encode(\n      args as AllocateInstructionDataArgs\n    ),\n    programAddress,\n  } as AllocateInstruction<TProgramAddress, TAccountNewAccount>);\n}\n\nexport type ParsedAllocateInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    newAccount: TAccountMetas[0];\n  };\n  data: AllocateInstructionData;\n};\n\nexport function parseAllocateInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedAllocateInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { newAccount: getNextAccount() },\n    data: getAllocateInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  addDecoderSizePrefix,\n  addEncoderSizePrefix,\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  getUtf8Decoder,\n  getUtf8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { SYSTEM_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const ALLOCATE_WITH_SEED_DISCRIMINATOR = 9;\n\nexport function getAllocateWithSeedDiscriminatorBytes() {\n  return getU32Encoder().encode(ALLOCATE_WITH_SEED_DISCRIMINATOR);\n}\n\nexport type AllocateWithSeedInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountNewAccount extends string | AccountMeta<string> = string,\n  TAccountBaseAccount extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountNewAccount extends string\n        ? WritableAccount<TAccountNewAccount>\n        : TAccountNewAccount,\n      TAccountBaseAccount extends string\n        ? ReadonlySignerAccount<TAccountBaseAccount> &\n            AccountSignerMeta<TAccountBaseAccount>\n        : TAccountBaseAccount,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type AllocateWithSeedInstructionData = {\n  discriminator: number;\n  base: Address;\n  seed: string;\n  space: bigint;\n  programAddress: Address;\n};\n\nexport type AllocateWithSeedInstructionDataArgs = {\n  base: Address;\n  seed: string;\n  space: number | bigint;\n  programAddress: Address;\n};\n\nexport function getAllocateWithSeedInstructionDataEncoder(): Encoder<AllocateWithSeedInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU32Encoder()],\n      ['base', getAddressEncoder()],\n      ['seed', addEncoderSizePrefix(getUtf8Encoder(), getU64Encoder())],\n      ['space', getU64Encoder()],\n      ['programAddress', getAddressEncoder()],\n    ]),\n    (value) => ({ ...value, discriminator: ALLOCATE_WITH_SEED_DISCRIMINATOR })\n  );\n}\n\nexport function getAllocateWithSeedInstructionDataDecoder(): Decoder<AllocateWithSeedInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU32Decoder()],\n    ['base', getAddressDecoder()],\n    ['seed', addDecoderSizePrefix(getUtf8Decoder(), getU64Decoder())],\n    ['space', getU64Decoder()],\n    ['programAddress', getAddressDecoder()],\n  ]);\n}\n\nexport function getAllocateWithSeedInstructionDataCodec(): Codec<\n  AllocateWithSeedInstructionDataArgs,\n  AllocateWithSeedInstructionData\n> {\n  return combineCodec(\n    getAllocateWithSeedInstructionDataEncoder(),\n    getAllocateWithSeedInstructionDataDecoder()\n  );\n}\n\nexport type AllocateWithSeedInput<\n  TAccountNewAccount extends string = string,\n  TAccountBaseAccount extends string = string,\n> = {\n  newAccount: Address<TAccountNewAccount>;\n  baseAccount: TransactionSigner<TAccountBaseAccount>;\n  base: AllocateWithSeedInstructionDataArgs['base'];\n  seed: AllocateWithSeedInstructionDataArgs['seed'];\n  space: AllocateWithSeedInstructionDataArgs['space'];\n  programAddress: AllocateWithSeedInstructionDataArgs['programAddress'];\n};\n\nexport function getAllocateWithSeedInstruction<\n  TAccountNewAccount extends string,\n  TAccountBaseAccount extends string,\n  TProgramAddress extends Address = typeof SYSTEM_PROGRAM_ADDRESS,\n>(\n  input: AllocateWithSeedInput<TAccountNewAccount, TAccountBaseAccount>,\n  config?: { programAddress?: TProgramAddress }\n): AllocateWithSeedInstruction<\n  TProgramAddress,\n  TAccountNewAccount,\n  TAccountBaseAccount\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? SYSTEM_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    newAccount: { value: input.newAccount ?? null, isWritable: true },\n    baseAccount: { value: input.baseAccount ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'omitted');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.newAccount),\n      getAccountMeta(accounts.baseAccount),\n    ],\n    data: getAllocateWithSeedInstructionDataEncoder().encode(\n      args as AllocateWithSeedInstructionDataArgs\n    ),\n    programAddress,\n  } as AllocateWithSeedInstruction<\n    TProgramAddress,\n    TAccountNewAccount,\n    TAccountBaseAccount\n  >);\n}\n\nexport type ParsedAllocateWithSeedInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    newAccount: TAccountMetas[0];\n    baseAccount: TAccountMetas[1];\n  };\n  data: AllocateWithSeedInstructionData;\n};\n\nexport function parseAllocateWithSeedInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedAllocateWithSeedInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { newAccount: getNextAccount(), baseAccount: getNextAccount() },\n    data: getAllocateWithSeedInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { SYSTEM_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const ASSIGN_DISCRIMINATOR = 1;\n\nexport function getAssignDiscriminatorBytes() {\n  return getU32Encoder().encode(ASSIGN_DISCRIMINATOR);\n}\n\nexport type AssignInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountAccount extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableSignerAccount<TAccountAccount> &\n            AccountSignerMeta<TAccountAccount>\n        : TAccountAccount,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type AssignInstructionData = {\n  discriminator: number;\n  programAddress: Address;\n};\n\nexport type AssignInstructionDataArgs = { programAddress: Address };\n\nexport function getAssignInstructionDataEncoder(): FixedSizeEncoder<AssignInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU32Encoder()],\n      ['programAddress', getAddressEncoder()],\n    ]),\n    (value) => ({ ...value, discriminator: ASSIGN_DISCRIMINATOR })\n  );\n}\n\nexport function getAssignInstructionDataDecoder(): FixedSizeDecoder<AssignInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU32Decoder()],\n    ['programAddress', getAddressDecoder()],\n  ]);\n}\n\nexport function getAssignInstructionDataCodec(): FixedSizeCodec<\n  AssignInstructionDataArgs,\n  AssignInstructionData\n> {\n  return combineCodec(\n    getAssignInstructionDataEncoder(),\n    getAssignInstructionDataDecoder()\n  );\n}\n\nexport type AssignInput<TAccountAccount extends string = string> = {\n  account: TransactionSigner<TAccountAccount>;\n  programAddress: AssignInstructionDataArgs['programAddress'];\n};\n\nexport function getAssignInstruction<\n  TAccountAccount extends string,\n  TProgramAddress extends Address = typeof SYSTEM_PROGRAM_ADDRESS,\n>(\n  input: AssignInput<TAccountAccount>,\n  config?: { programAddress?: TProgramAddress }\n): AssignInstruction<TProgramAddress, TAccountAccount> {\n  // Program address.\n  const programAddress = config?.programAddress ?? SYSTEM_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'omitted');\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.account)],\n    data: getAssignInstructionDataEncoder().encode(\n      args as AssignInstructionDataArgs\n    ),\n    programAddress,\n  } as AssignInstruction<TProgramAddress, TAccountAccount>);\n}\n\nexport type ParsedAssignInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    account: TAccountMetas[0];\n  };\n  data: AssignInstructionData;\n};\n\nexport function parseAssignInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedAssignInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { account: getNextAccount() },\n    data: getAssignInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  addDecoderSizePrefix,\n  addEncoderSizePrefix,\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  getUtf8Decoder,\n  getUtf8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { SYSTEM_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const ASSIGN_WITH_SEED_DISCRIMINATOR = 10;\n\nexport function getAssignWithSeedDiscriminatorBytes() {\n  return getU32Encoder().encode(ASSIGN_WITH_SEED_DISCRIMINATOR);\n}\n\nexport type AssignWithSeedInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountAccount extends string | AccountMeta<string> = string,\n  TAccountBaseAccount extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      TAccountBaseAccount extends string\n        ? ReadonlySignerAccount<TAccountBaseAccount> &\n            AccountSignerMeta<TAccountBaseAccount>\n        : TAccountBaseAccount,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type AssignWithSeedInstructionData = {\n  discriminator: number;\n  base: Address;\n  seed: string;\n  programAddress: Address;\n};\n\nexport type AssignWithSeedInstructionDataArgs = {\n  base: Address;\n  seed: string;\n  programAddress: Address;\n};\n\nexport function getAssignWithSeedInstructionDataEncoder(): Encoder<AssignWithSeedInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU32Encoder()],\n      ['base', getAddressEncoder()],\n      ['seed', addEncoderSizePrefix(getUtf8Encoder(), getU64Encoder())],\n      ['programAddress', getAddressEncoder()],\n    ]),\n    (value) => ({ ...value, discriminator: ASSIGN_WITH_SEED_DISCRIMINATOR })\n  );\n}\n\nexport function getAssignWithSeedInstructionDataDecoder(): Decoder<AssignWithSeedInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU32Decoder()],\n    ['base', getAddressDecoder()],\n    ['seed', addDecoderSizePrefix(getUtf8Decoder(), getU64Decoder())],\n    ['programAddress', getAddressDecoder()],\n  ]);\n}\n\nexport function getAssignWithSeedInstructionDataCodec(): Codec<\n  AssignWithSeedInstructionDataArgs,\n  AssignWithSeedInstructionData\n> {\n  return combineCodec(\n    getAssignWithSeedInstructionDataEncoder(),\n    getAssignWithSeedInstructionDataDecoder()\n  );\n}\n\nexport type AssignWithSeedInput<\n  TAccountAccount extends string = string,\n  TAccountBaseAccount extends string = string,\n> = {\n  account: Address<TAccountAccount>;\n  baseAccount: TransactionSigner<TAccountBaseAccount>;\n  base: AssignWithSeedInstructionDataArgs['base'];\n  seed: AssignWithSeedInstructionDataArgs['seed'];\n  programAddress: AssignWithSeedInstructionDataArgs['programAddress'];\n};\n\nexport function getAssignWithSeedInstruction<\n  TAccountAccount extends string,\n  TAccountBaseAccount extends string,\n  TProgramAddress extends Address = typeof SYSTEM_PROGRAM_ADDRESS,\n>(\n  input: AssignWithSeedInput<TAccountAccount, TAccountBaseAccount>,\n  config?: { programAddress?: TProgramAddress }\n): AssignWithSeedInstruction<\n  TProgramAddress,\n  TAccountAccount,\n  TAccountBaseAccount\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? SYSTEM_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n    baseAccount: { value: input.baseAccount ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'omitted');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.account),\n      getAccountMeta(accounts.baseAccount),\n    ],\n    data: getAssignWithSeedInstructionDataEncoder().encode(\n      args as AssignWithSeedInstructionDataArgs\n    ),\n    programAddress,\n  } as AssignWithSeedInstruction<\n    TProgramAddress,\n    TAccountAccount,\n    TAccountBaseAccount\n  >);\n}\n\nexport type ParsedAssignWithSeedInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    account: TAccountMetas[0];\n    baseAccount: TAccountMetas[1];\n  };\n  data: AssignWithSeedInstructionData;\n};\n\nexport function parseAssignWithSeedInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedAssignWithSeedInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { account: getNextAccount(), baseAccount: getNextAccount() },\n    data: getAssignWithSeedInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { SYSTEM_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const AUTHORIZE_NONCE_ACCOUNT_DISCRIMINATOR = 7;\n\nexport function getAuthorizeNonceAccountDiscriminatorBytes() {\n  return getU32Encoder().encode(AUTHORIZE_NONCE_ACCOUNT_DISCRIMINATOR);\n}\n\nexport type AuthorizeNonceAccountInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountNonceAccount extends string | AccountMeta<string> = string,\n  TAccountNonceAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountNonceAccount extends string\n        ? WritableAccount<TAccountNonceAccount>\n        : TAccountNonceAccount,\n      TAccountNonceAuthority extends string\n        ? ReadonlySignerAccount<TAccountNonceAuthority> &\n            AccountSignerMeta<TAccountNonceAuthority>\n        : TAccountNonceAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type AuthorizeNonceAccountInstructionData = {\n  discriminator: number;\n  newNonceAuthority: Address;\n};\n\nexport type AuthorizeNonceAccountInstructionDataArgs = {\n  newNonceAuthority: Address;\n};\n\nexport function getAuthorizeNonceAccountInstructionDataEncoder(): FixedSizeEncoder<AuthorizeNonceAccountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU32Encoder()],\n      ['newNonceAuthority', getAddressEncoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: AUTHORIZE_NONCE_ACCOUNT_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getAuthorizeNonceAccountInstructionDataDecoder(): FixedSizeDecoder<AuthorizeNonceAccountInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU32Decoder()],\n    ['newNonceAuthority', getAddressDecoder()],\n  ]);\n}\n\nexport function getAuthorizeNonceAccountInstructionDataCodec(): FixedSizeCodec<\n  AuthorizeNonceAccountInstructionDataArgs,\n  AuthorizeNonceAccountInstructionData\n> {\n  return combineCodec(\n    getAuthorizeNonceAccountInstructionDataEncoder(),\n    getAuthorizeNonceAccountInstructionDataDecoder()\n  );\n}\n\nexport type AuthorizeNonceAccountInput<\n  TAccountNonceAccount extends string = string,\n  TAccountNonceAuthority extends string = string,\n> = {\n  nonceAccount: Address<TAccountNonceAccount>;\n  nonceAuthority: TransactionSigner<TAccountNonceAuthority>;\n  newNonceAuthority: AuthorizeNonceAccountInstructionDataArgs['newNonceAuthority'];\n};\n\nexport function getAuthorizeNonceAccountInstruction<\n  TAccountNonceAccount extends string,\n  TAccountNonceAuthority extends string,\n  TProgramAddress extends Address = typeof SYSTEM_PROGRAM_ADDRESS,\n>(\n  input: AuthorizeNonceAccountInput<\n    TAccountNonceAccount,\n    TAccountNonceAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): AuthorizeNonceAccountInstruction<\n  TProgramAddress,\n  TAccountNonceAccount,\n  TAccountNonceAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? SYSTEM_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    nonceAccount: { value: input.nonceAccount ?? null, isWritable: true },\n    nonceAuthority: { value: input.nonceAuthority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'omitted');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.nonceAccount),\n      getAccountMeta(accounts.nonceAuthority),\n    ],\n    data: getAuthorizeNonceAccountInstructionDataEncoder().encode(\n      args as AuthorizeNonceAccountInstructionDataArgs\n    ),\n    programAddress,\n  } as AuthorizeNonceAccountInstruction<\n    TProgramAddress,\n    TAccountNonceAccount,\n    TAccountNonceAuthority\n  >);\n}\n\nexport type ParsedAuthorizeNonceAccountInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    nonceAccount: TAccountMetas[0];\n    nonceAuthority: TAccountMetas[1];\n  };\n  data: AuthorizeNonceAccountInstructionData;\n};\n\nexport function parseAuthorizeNonceAccountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedAuthorizeNonceAccountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      nonceAccount: getNextAccount(),\n      nonceAuthority: getNextAccount(),\n    },\n    data: getAuthorizeNonceAccountInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  BASE_ACCOUNT_SIZE,\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { SYSTEM_PROGRAM_ADDRESS } from '../programs';\nimport {\n  getAccountMetaFactory,\n  type InstructionWithByteDelta,\n  type ResolvedAccount,\n} from '../shared';\n\nexport const CREATE_ACCOUNT_DISCRIMINATOR = 0;\n\nexport function getCreateAccountDiscriminatorBytes() {\n  return getU32Encoder().encode(CREATE_ACCOUNT_DISCRIMINATOR);\n}\n\nexport type CreateAccountInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountPayer extends string | AccountMeta<string> = string,\n  TAccountNewAccount extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountPayer extends string\n        ? WritableSignerAccount<TAccountPayer> &\n            AccountSignerMeta<TAccountPayer>\n        : TAccountPayer,\n      TAccountNewAccount extends string\n        ? WritableSignerAccount<TAccountNewAccount> &\n            AccountSignerMeta<TAccountNewAccount>\n        : TAccountNewAccount,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type CreateAccountInstructionData = {\n  discriminator: number;\n  lamports: bigint;\n  space: bigint;\n  programAddress: Address;\n};\n\nexport type CreateAccountInstructionDataArgs = {\n  lamports: number | bigint;\n  space: number | bigint;\n  programAddress: Address;\n};\n\nexport function getCreateAccountInstructionDataEncoder(): FixedSizeEncoder<CreateAccountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU32Encoder()],\n      ['lamports', getU64Encoder()],\n      ['space', getU64Encoder()],\n      ['programAddress', getAddressEncoder()],\n    ]),\n    (value) => ({ ...value, discriminator: CREATE_ACCOUNT_DISCRIMINATOR })\n  );\n}\n\nexport function getCreateAccountInstructionDataDecoder(): FixedSizeDecoder<CreateAccountInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU32Decoder()],\n    ['lamports', getU64Decoder()],\n    ['space', getU64Decoder()],\n    ['programAddress', getAddressDecoder()],\n  ]);\n}\n\nexport function getCreateAccountInstructionDataCodec(): FixedSizeCodec<\n  CreateAccountInstructionDataArgs,\n  CreateAccountInstructionData\n> {\n  return combineCodec(\n    getCreateAccountInstructionDataEncoder(),\n    getCreateAccountInstructionDataDecoder()\n  );\n}\n\nexport type CreateAccountInput<\n  TAccountPayer extends string = string,\n  TAccountNewAccount extends string = string,\n> = {\n  payer: TransactionSigner<TAccountPayer>;\n  newAccount: TransactionSigner<TAccountNewAccount>;\n  lamports: CreateAccountInstructionDataArgs['lamports'];\n  space: CreateAccountInstructionDataArgs['space'];\n  programAddress: CreateAccountInstructionDataArgs['programAddress'];\n};\n\nexport function getCreateAccountInstruction<\n  TAccountPayer extends string,\n  TAccountNewAccount extends string,\n  TProgramAddress extends Address = typeof SYSTEM_PROGRAM_ADDRESS,\n>(\n  input: CreateAccountInput<TAccountPayer, TAccountNewAccount>,\n  config?: { programAddress?: TProgramAddress }\n): CreateAccountInstruction<\n  TProgramAddress,\n  TAccountPayer,\n  TAccountNewAccount\n> &\n  InstructionWithByteDelta {\n  // Program address.\n  const programAddress = config?.programAddress ?? SYSTEM_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    payer: { value: input.payer ?? null, isWritable: true },\n    newAccount: { value: input.newAccount ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Bytes created or reallocated by the instruction.\n  const byteDelta: number = [Number(args.space) + BASE_ACCOUNT_SIZE].reduce(\n    (a, b) => a + b,\n    0\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'omitted');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.payer),\n      getAccountMeta(accounts.newAccount),\n    ],\n    byteDelta,\n    data: getCreateAccountInstructionDataEncoder().encode(\n      args as CreateAccountInstructionDataArgs\n    ),\n    programAddress,\n  } as CreateAccountInstruction<\n    TProgramAddress,\n    TAccountPayer,\n    TAccountNewAccount\n  > &\n    InstructionWithByteDelta);\n}\n\nexport type ParsedCreateAccountInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    payer: TAccountMetas[0];\n    newAccount: TAccountMetas[1];\n  };\n  data: CreateAccountInstructionData;\n};\n\nexport function parseCreateAccountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedCreateAccountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { payer: getNextAccount(), newAccount: getNextAccount() },\n    data: getCreateAccountInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  addDecoderSizePrefix,\n  addEncoderSizePrefix,\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  getUtf8Decoder,\n  getUtf8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { SYSTEM_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const CREATE_ACCOUNT_WITH_SEED_DISCRIMINATOR = 3;\n\nexport function getCreateAccountWithSeedDiscriminatorBytes() {\n  return getU32Encoder().encode(CREATE_ACCOUNT_WITH_SEED_DISCRIMINATOR);\n}\n\nexport type CreateAccountWithSeedInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountPayer extends string | AccountMeta<string> = string,\n  TAccountNewAccount extends string | AccountMeta<string> = string,\n  TAccountBaseAccount extends\n    | string\n    | AccountMeta<string>\n    | undefined = undefined,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountPayer extends string\n        ? WritableSignerAccount<TAccountPayer> &\n            AccountSignerMeta<TAccountPayer>\n        : TAccountPayer,\n      TAccountNewAccount extends string\n        ? WritableAccount<TAccountNewAccount>\n        : TAccountNewAccount,\n      ...(TAccountBaseAccount extends undefined\n        ? []\n        : [\n            TAccountBaseAccount extends string\n              ? ReadonlySignerAccount<TAccountBaseAccount> &\n                  AccountSignerMeta<TAccountBaseAccount>\n              : TAccountBaseAccount,\n          ]),\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type CreateAccountWithSeedInstructionData = {\n  discriminator: number;\n  base: Address;\n  seed: string;\n  amount: bigint;\n  space: bigint;\n  programAddress: Address;\n};\n\nexport type CreateAccountWithSeedInstructionDataArgs = {\n  base: Address;\n  seed: string;\n  amount: number | bigint;\n  space: number | bigint;\n  programAddress: Address;\n};\n\nexport function getCreateAccountWithSeedInstructionDataEncoder(): Encoder<CreateAccountWithSeedInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU32Encoder()],\n      ['base', getAddressEncoder()],\n      ['seed', addEncoderSizePrefix(getUtf8Encoder(), getU64Encoder())],\n      ['amount', getU64Encoder()],\n      ['space', getU64Encoder()],\n      ['programAddress', getAddressEncoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: CREATE_ACCOUNT_WITH_SEED_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getCreateAccountWithSeedInstructionDataDecoder(): Decoder<CreateAccountWithSeedInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU32Decoder()],\n    ['base', getAddressDecoder()],\n    ['seed', addDecoderSizePrefix(getUtf8Decoder(), getU64Decoder())],\n    ['amount', getU64Decoder()],\n    ['space', getU64Decoder()],\n    ['programAddress', getAddressDecoder()],\n  ]);\n}\n\nexport function getCreateAccountWithSeedInstructionDataCodec(): Codec<\n  CreateAccountWithSeedInstructionDataArgs,\n  CreateAccountWithSeedInstructionData\n> {\n  return combineCodec(\n    getCreateAccountWithSeedInstructionDataEncoder(),\n    getCreateAccountWithSeedInstructionDataDecoder()\n  );\n}\n\nexport type CreateAccountWithSeedInput<\n  TAccountPayer extends string = string,\n  TAccountNewAccount extends string = string,\n  TAccountBaseAccount extends string = string,\n> = {\n  payer: TransactionSigner<TAccountPayer>;\n  newAccount: Address<TAccountNewAccount>;\n  baseAccount?: TransactionSigner<TAccountBaseAccount>;\n  base: CreateAccountWithSeedInstructionDataArgs['base'];\n  seed: CreateAccountWithSeedInstructionDataArgs['seed'];\n  amount: CreateAccountWithSeedInstructionDataArgs['amount'];\n  space: CreateAccountWithSeedInstructionDataArgs['space'];\n  programAddress: CreateAccountWithSeedInstructionDataArgs['programAddress'];\n};\n\nexport function getCreateAccountWithSeedInstruction<\n  TAccountPayer extends string,\n  TAccountNewAccount extends string,\n  TAccountBaseAccount extends string,\n  TProgramAddress extends Address = typeof SYSTEM_PROGRAM_ADDRESS,\n>(\n  input: CreateAccountWithSeedInput<\n    TAccountPayer,\n    TAccountNewAccount,\n    TAccountBaseAccount\n  >,\n  config?: { programAddress?: TProgramAddress }\n): CreateAccountWithSeedInstruction<\n  TProgramAddress,\n  TAccountPayer,\n  TAccountNewAccount,\n  TAccountBaseAccount\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? SYSTEM_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    payer: { value: input.payer ?? null, isWritable: true },\n    newAccount: { value: input.newAccount ?? null, isWritable: true },\n    baseAccount: { value: input.baseAccount ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'omitted');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.payer),\n      getAccountMeta(accounts.newAccount),\n      getAccountMeta(accounts.baseAccount),\n    ].filter(<T>(x: T | undefined): x is T => x !== undefined),\n    data: getCreateAccountWithSeedInstructionDataEncoder().encode(\n      args as CreateAccountWithSeedInstructionDataArgs\n    ),\n    programAddress,\n  } as CreateAccountWithSeedInstruction<\n    TProgramAddress,\n    TAccountPayer,\n    TAccountNewAccount,\n    TAccountBaseAccount\n  >);\n}\n\nexport type ParsedCreateAccountWithSeedInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    payer: TAccountMetas[0];\n    newAccount: TAccountMetas[1];\n    baseAccount?: TAccountMetas[2] | undefined;\n  };\n  data: CreateAccountWithSeedInstructionData;\n};\n\nexport function parseCreateAccountWithSeedInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedCreateAccountWithSeedInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  let optionalAccountsRemaining = instruction.accounts.length - 2;\n  const getNextOptionalAccount = () => {\n    if (optionalAccountsRemaining === 0) return undefined;\n    optionalAccountsRemaining -= 1;\n    return getNextAccount();\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      payer: getNextAccount(),\n      newAccount: getNextAccount(),\n      baseAccount: getNextOptionalAccount(),\n    },\n    data: getCreateAccountWithSeedInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { SYSTEM_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_NONCE_ACCOUNT_DISCRIMINATOR = 6;\n\nexport function getInitializeNonceAccountDiscriminatorBytes() {\n  return getU32Encoder().encode(INITIALIZE_NONCE_ACCOUNT_DISCRIMINATOR);\n}\n\nexport type InitializeNonceAccountInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountNonceAccount extends string | AccountMeta<string> = string,\n  TAccountRecentBlockhashesSysvar extends\n    | string\n    | AccountMeta<string> = 'SysvarRecentB1ockHashes11111111111111111111',\n  TAccountRentSysvar extends\n    | string\n    | AccountMeta<string> = 'SysvarRent111111111111111111111111111111111',\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountNonceAccount extends string\n        ? WritableAccount<TAccountNonceAccount>\n        : TAccountNonceAccount,\n      TAccountRecentBlockhashesSysvar extends string\n        ? ReadonlyAccount<TAccountRecentBlockhashesSysvar>\n        : TAccountRecentBlockhashesSysvar,\n      TAccountRentSysvar extends string\n        ? ReadonlyAccount<TAccountRentSysvar>\n        : TAccountRentSysvar,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeNonceAccountInstructionData = {\n  discriminator: number;\n  nonceAuthority: Address;\n};\n\nexport type InitializeNonceAccountInstructionDataArgs = {\n  nonceAuthority: Address;\n};\n\nexport function getInitializeNonceAccountInstructionDataEncoder(): FixedSizeEncoder<InitializeNonceAccountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU32Encoder()],\n      ['nonceAuthority', getAddressEncoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_NONCE_ACCOUNT_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeNonceAccountInstructionDataDecoder(): FixedSizeDecoder<InitializeNonceAccountInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU32Decoder()],\n    ['nonceAuthority', getAddressDecoder()],\n  ]);\n}\n\nexport function getInitializeNonceAccountInstructionDataCodec(): FixedSizeCodec<\n  InitializeNonceAccountInstructionDataArgs,\n  InitializeNonceAccountInstructionData\n> {\n  return combineCodec(\n    getInitializeNonceAccountInstructionDataEncoder(),\n    getInitializeNonceAccountInstructionDataDecoder()\n  );\n}\n\nexport type InitializeNonceAccountInput<\n  TAccountNonceAccount extends string = string,\n  TAccountRecentBlockhashesSysvar extends string = string,\n  TAccountRentSysvar extends string = string,\n> = {\n  nonceAccount: Address<TAccountNonceAccount>;\n  recentBlockhashesSysvar?: Address<TAccountRecentBlockhashesSysvar>;\n  rentSysvar?: Address<TAccountRentSysvar>;\n  nonceAuthority: InitializeNonceAccountInstructionDataArgs['nonceAuthority'];\n};\n\nexport function getInitializeNonceAccountInstruction<\n  TAccountNonceAccount extends string,\n  TAccountRecentBlockhashesSysvar extends string,\n  TAccountRentSysvar extends string,\n  TProgramAddress extends Address = typeof SYSTEM_PROGRAM_ADDRESS,\n>(\n  input: InitializeNonceAccountInput<\n    TAccountNonceAccount,\n    TAccountRecentBlockhashesSysvar,\n    TAccountRentSysvar\n  >,\n  config?: { programAddress?: TProgramAddress }\n): InitializeNonceAccountInstruction<\n  TProgramAddress,\n  TAccountNonceAccount,\n  TAccountRecentBlockhashesSysvar,\n  TAccountRentSysvar\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? SYSTEM_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    nonceAccount: { value: input.nonceAccount ?? null, isWritable: true },\n    recentBlockhashesSysvar: {\n      value: input.recentBlockhashesSysvar ?? null,\n      isWritable: false,\n    },\n    rentSysvar: { value: input.rentSysvar ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.recentBlockhashesSysvar.value) {\n    accounts.recentBlockhashesSysvar.value =\n      'SysvarRecentB1ockHashes11111111111111111111' as Address<'SysvarRecentB1ockHashes11111111111111111111'>;\n  }\n  if (!accounts.rentSysvar.value) {\n    accounts.rentSysvar.value =\n      'SysvarRent111111111111111111111111111111111' as Address<'SysvarRent111111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'omitted');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.nonceAccount),\n      getAccountMeta(accounts.recentBlockhashesSysvar),\n      getAccountMeta(accounts.rentSysvar),\n    ],\n    data: getInitializeNonceAccountInstructionDataEncoder().encode(\n      args as InitializeNonceAccountInstructionDataArgs\n    ),\n    programAddress,\n  } as InitializeNonceAccountInstruction<\n    TProgramAddress,\n    TAccountNonceAccount,\n    TAccountRecentBlockhashesSysvar,\n    TAccountRentSysvar\n  >);\n}\n\nexport type ParsedInitializeNonceAccountInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    nonceAccount: TAccountMetas[0];\n    recentBlockhashesSysvar: TAccountMetas[1];\n    rentSysvar: TAccountMetas[2];\n  };\n  data: InitializeNonceAccountInstructionData;\n};\n\nexport function parseInitializeNonceAccountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedInitializeNonceAccountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      nonceAccount: getNextAccount(),\n      recentBlockhashesSysvar: getNextAccount(),\n      rentSysvar: getNextAccount(),\n    },\n    data: getInitializeNonceAccountInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { SYSTEM_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const TRANSFER_SOL_DISCRIMINATOR = 2;\n\nexport function getTransferSolDiscriminatorBytes() {\n  return getU32Encoder().encode(TRANSFER_SOL_DISCRIMINATOR);\n}\n\nexport type TransferSolInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountSource extends string | AccountMeta<string> = string,\n  TAccountDestination extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountSource extends string\n        ? WritableSignerAccount<TAccountSource> &\n            AccountSignerMeta<TAccountSource>\n        : TAccountSource,\n      TAccountDestination extends string\n        ? WritableAccount<TAccountDestination>\n        : TAccountDestination,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type TransferSolInstructionData = {\n  discriminator: number;\n  amount: bigint;\n};\n\nexport type TransferSolInstructionDataArgs = { amount: number | bigint };\n\nexport function getTransferSolInstructionDataEncoder(): FixedSizeEncoder<TransferSolInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU32Encoder()],\n      ['amount', getU64Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: TRANSFER_SOL_DISCRIMINATOR })\n  );\n}\n\nexport function getTransferSolInstructionDataDecoder(): FixedSizeDecoder<TransferSolInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU32Decoder()],\n    ['amount', getU64Decoder()],\n  ]);\n}\n\nexport function getTransferSolInstructionDataCodec(): FixedSizeCodec<\n  TransferSolInstructionDataArgs,\n  TransferSolInstructionData\n> {\n  return combineCodec(\n    getTransferSolInstructionDataEncoder(),\n    getTransferSolInstructionDataDecoder()\n  );\n}\n\nexport type TransferSolInput<\n  TAccountSource extends string = string,\n  TAccountDestination extends string = string,\n> = {\n  source: TransactionSigner<TAccountSource>;\n  destination: Address<TAccountDestination>;\n  amount: TransferSolInstructionDataArgs['amount'];\n};\n\nexport function getTransferSolInstruction<\n  TAccountSource extends string,\n  TAccountDestination extends string,\n  TProgramAddress extends Address = typeof SYSTEM_PROGRAM_ADDRESS,\n>(\n  input: TransferSolInput<TAccountSource, TAccountDestination>,\n  config?: { programAddress?: TProgramAddress }\n): TransferSolInstruction<\n  TProgramAddress,\n  TAccountSource,\n  TAccountDestination\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? SYSTEM_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    source: { value: input.source ?? null, isWritable: true },\n    destination: { value: input.destination ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'omitted');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.source),\n      getAccountMeta(accounts.destination),\n    ],\n    data: getTransferSolInstructionDataEncoder().encode(\n      args as TransferSolInstructionDataArgs\n    ),\n    programAddress,\n  } as TransferSolInstruction<\n    TProgramAddress,\n    TAccountSource,\n    TAccountDestination\n  >);\n}\n\nexport type ParsedTransferSolInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    source: TAccountMetas[0];\n    destination: TAccountMetas[1];\n  };\n  data: TransferSolInstructionData;\n};\n\nexport function parseTransferSolInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedTransferSolInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { source: getNextAccount(), destination: getNextAccount() },\n    data: getTransferSolInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  addDecoderSizePrefix,\n  addEncoderSizePrefix,\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  getUtf8Decoder,\n  getUtf8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { SYSTEM_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const TRANSFER_SOL_WITH_SEED_DISCRIMINATOR = 11;\n\nexport function getTransferSolWithSeedDiscriminatorBytes() {\n  return getU32Encoder().encode(TRANSFER_SOL_WITH_SEED_DISCRIMINATOR);\n}\n\nexport type TransferSolWithSeedInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountSource extends string | AccountMeta<string> = string,\n  TAccountBaseAccount extends string | AccountMeta<string> = string,\n  TAccountDestination extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountSource extends string\n        ? WritableAccount<TAccountSource>\n        : TAccountSource,\n      TAccountBaseAccount extends string\n        ? ReadonlySignerAccount<TAccountBaseAccount> &\n            AccountSignerMeta<TAccountBaseAccount>\n        : TAccountBaseAccount,\n      TAccountDestination extends string\n        ? WritableAccount<TAccountDestination>\n        : TAccountDestination,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type TransferSolWithSeedInstructionData = {\n  discriminator: number;\n  amount: bigint;\n  fromSeed: string;\n  fromOwner: Address;\n};\n\nexport type TransferSolWithSeedInstructionDataArgs = {\n  amount: number | bigint;\n  fromSeed: string;\n  fromOwner: Address;\n};\n\nexport function getTransferSolWithSeedInstructionDataEncoder(): Encoder<TransferSolWithSeedInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU32Encoder()],\n      ['amount', getU64Encoder()],\n      ['fromSeed', addEncoderSizePrefix(getUtf8Encoder(), getU64Encoder())],\n      ['fromOwner', getAddressEncoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: TRANSFER_SOL_WITH_SEED_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getTransferSolWithSeedInstructionDataDecoder(): Decoder<TransferSolWithSeedInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU32Decoder()],\n    ['amount', getU64Decoder()],\n    ['fromSeed', addDecoderSizePrefix(getUtf8Decoder(), getU64Decoder())],\n    ['fromOwner', getAddressDecoder()],\n  ]);\n}\n\nexport function getTransferSolWithSeedInstructionDataCodec(): Codec<\n  TransferSolWithSeedInstructionDataArgs,\n  TransferSolWithSeedInstructionData\n> {\n  return combineCodec(\n    getTransferSolWithSeedInstructionDataEncoder(),\n    getTransferSolWithSeedInstructionDataDecoder()\n  );\n}\n\nexport type TransferSolWithSeedInput<\n  TAccountSource extends string = string,\n  TAccountBaseAccount extends string = string,\n  TAccountDestination extends string = string,\n> = {\n  source: Address<TAccountSource>;\n  baseAccount: TransactionSigner<TAccountBaseAccount>;\n  destination: Address<TAccountDestination>;\n  amount: TransferSolWithSeedInstructionDataArgs['amount'];\n  fromSeed: TransferSolWithSeedInstructionDataArgs['fromSeed'];\n  fromOwner: TransferSolWithSeedInstructionDataArgs['fromOwner'];\n};\n\nexport function getTransferSolWithSeedInstruction<\n  TAccountSource extends string,\n  TAccountBaseAccount extends string,\n  TAccountDestination extends string,\n  TProgramAddress extends Address = typeof SYSTEM_PROGRAM_ADDRESS,\n>(\n  input: TransferSolWithSeedInput<\n    TAccountSource,\n    TAccountBaseAccount,\n    TAccountDestination\n  >,\n  config?: { programAddress?: TProgramAddress }\n): TransferSolWithSeedInstruction<\n  TProgramAddress,\n  TAccountSource,\n  TAccountBaseAccount,\n  TAccountDestination\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? SYSTEM_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    source: { value: input.source ?? null, isWritable: true },\n    baseAccount: { value: input.baseAccount ?? null, isWritable: false },\n    destination: { value: input.destination ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'omitted');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.source),\n      getAccountMeta(accounts.baseAccount),\n      getAccountMeta(accounts.destination),\n    ],\n    data: getTransferSolWithSeedInstructionDataEncoder().encode(\n      args as TransferSolWithSeedInstructionDataArgs\n    ),\n    programAddress,\n  } as TransferSolWithSeedInstruction<\n    TProgramAddress,\n    TAccountSource,\n    TAccountBaseAccount,\n    TAccountDestination\n  >);\n}\n\nexport type ParsedTransferSolWithSeedInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    source: TAccountMetas[0];\n    baseAccount: TAccountMetas[1];\n    destination: TAccountMetas[2];\n  };\n  data: TransferSolWithSeedInstructionData;\n};\n\nexport function parseTransferSolWithSeedInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedTransferSolWithSeedInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      source: getNextAccount(),\n      baseAccount: getNextAccount(),\n      destination: getNextAccount(),\n    },\n    data: getTransferSolWithSeedInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { SYSTEM_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const UPGRADE_NONCE_ACCOUNT_DISCRIMINATOR = 12;\n\nexport function getUpgradeNonceAccountDiscriminatorBytes() {\n  return getU32Encoder().encode(UPGRADE_NONCE_ACCOUNT_DISCRIMINATOR);\n}\n\nexport type UpgradeNonceAccountInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountNonceAccount extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountNonceAccount extends string\n        ? WritableAccount<TAccountNonceAccount>\n        : TAccountNonceAccount,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type UpgradeNonceAccountInstructionData = { discriminator: number };\n\nexport type UpgradeNonceAccountInstructionDataArgs = {};\n\nexport function getUpgradeNonceAccountInstructionDataEncoder(): FixedSizeEncoder<UpgradeNonceAccountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU32Encoder()]]),\n    (value) => ({\n      ...value,\n      discriminator: UPGRADE_NONCE_ACCOUNT_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getUpgradeNonceAccountInstructionDataDecoder(): FixedSizeDecoder<UpgradeNonceAccountInstructionData> {\n  return getStructDecoder([['discriminator', getU32Decoder()]]);\n}\n\nexport function getUpgradeNonceAccountInstructionDataCodec(): FixedSizeCodec<\n  UpgradeNonceAccountInstructionDataArgs,\n  UpgradeNonceAccountInstructionData\n> {\n  return combineCodec(\n    getUpgradeNonceAccountInstructionDataEncoder(),\n    getUpgradeNonceAccountInstructionDataDecoder()\n  );\n}\n\nexport type UpgradeNonceAccountInput<\n  TAccountNonceAccount extends string = string,\n> = {\n  nonceAccount: Address<TAccountNonceAccount>;\n};\n\nexport function getUpgradeNonceAccountInstruction<\n  TAccountNonceAccount extends string,\n  TProgramAddress extends Address = typeof SYSTEM_PROGRAM_ADDRESS,\n>(\n  input: UpgradeNonceAccountInput<TAccountNonceAccount>,\n  config?: { programAddress?: TProgramAddress }\n): UpgradeNonceAccountInstruction<TProgramAddress, TAccountNonceAccount> {\n  // Program address.\n  const programAddress = config?.programAddress ?? SYSTEM_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    nonceAccount: { value: input.nonceAccount ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'omitted');\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.nonceAccount)],\n    data: getUpgradeNonceAccountInstructionDataEncoder().encode({}),\n    programAddress,\n  } as UpgradeNonceAccountInstruction<TProgramAddress, TAccountNonceAccount>);\n}\n\nexport type ParsedUpgradeNonceAccountInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    nonceAccount: TAccountMetas[0];\n  };\n  data: UpgradeNonceAccountInstructionData;\n};\n\nexport function parseUpgradeNonceAccountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedUpgradeNonceAccountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { nonceAccount: getNextAccount() },\n    data: getUpgradeNonceAccountInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { SYSTEM_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const WITHDRAW_NONCE_ACCOUNT_DISCRIMINATOR = 5;\n\nexport function getWithdrawNonceAccountDiscriminatorBytes() {\n  return getU32Encoder().encode(WITHDRAW_NONCE_ACCOUNT_DISCRIMINATOR);\n}\n\nexport type WithdrawNonceAccountInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountNonceAccount extends string | AccountMeta<string> = string,\n  TAccountRecipientAccount extends string | AccountMeta<string> = string,\n  TAccountRecentBlockhashesSysvar extends\n    | string\n    | AccountMeta<string> = 'SysvarRecentB1ockHashes11111111111111111111',\n  TAccountRentSysvar extends\n    | string\n    | AccountMeta<string> = 'SysvarRent111111111111111111111111111111111',\n  TAccountNonceAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountNonceAccount extends string\n        ? WritableAccount<TAccountNonceAccount>\n        : TAccountNonceAccount,\n      TAccountRecipientAccount extends string\n        ? WritableAccount<TAccountRecipientAccount>\n        : TAccountRecipientAccount,\n      TAccountRecentBlockhashesSysvar extends string\n        ? ReadonlyAccount<TAccountRecentBlockhashesSysvar>\n        : TAccountRecentBlockhashesSysvar,\n      TAccountRentSysvar extends string\n        ? ReadonlyAccount<TAccountRentSysvar>\n        : TAccountRentSysvar,\n      TAccountNonceAuthority extends string\n        ? ReadonlySignerAccount<TAccountNonceAuthority> &\n            AccountSignerMeta<TAccountNonceAuthority>\n        : TAccountNonceAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type WithdrawNonceAccountInstructionData = {\n  discriminator: number;\n  withdrawAmount: bigint;\n};\n\nexport type WithdrawNonceAccountInstructionDataArgs = {\n  withdrawAmount: number | bigint;\n};\n\nexport function getWithdrawNonceAccountInstructionDataEncoder(): FixedSizeEncoder<WithdrawNonceAccountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU32Encoder()],\n      ['withdrawAmount', getU64Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: WITHDRAW_NONCE_ACCOUNT_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getWithdrawNonceAccountInstructionDataDecoder(): FixedSizeDecoder<WithdrawNonceAccountInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU32Decoder()],\n    ['withdrawAmount', getU64Decoder()],\n  ]);\n}\n\nexport function getWithdrawNonceAccountInstructionDataCodec(): FixedSizeCodec<\n  WithdrawNonceAccountInstructionDataArgs,\n  WithdrawNonceAccountInstructionData\n> {\n  return combineCodec(\n    getWithdrawNonceAccountInstructionDataEncoder(),\n    getWithdrawNonceAccountInstructionDataDecoder()\n  );\n}\n\nexport type WithdrawNonceAccountInput<\n  TAccountNonceAccount extends string = string,\n  TAccountRecipientAccount extends string = string,\n  TAccountRecentBlockhashesSysvar extends string = string,\n  TAccountRentSysvar extends string = string,\n  TAccountNonceAuthority extends string = string,\n> = {\n  nonceAccount: Address<TAccountNonceAccount>;\n  recipientAccount: Address<TAccountRecipientAccount>;\n  recentBlockhashesSysvar?: Address<TAccountRecentBlockhashesSysvar>;\n  rentSysvar?: Address<TAccountRentSysvar>;\n  nonceAuthority: TransactionSigner<TAccountNonceAuthority>;\n  withdrawAmount: WithdrawNonceAccountInstructionDataArgs['withdrawAmount'];\n};\n\nexport function getWithdrawNonceAccountInstruction<\n  TAccountNonceAccount extends string,\n  TAccountRecipientAccount extends string,\n  TAccountRecentBlockhashesSysvar extends string,\n  TAccountRentSysvar extends string,\n  TAccountNonceAuthority extends string,\n  TProgramAddress extends Address = typeof SYSTEM_PROGRAM_ADDRESS,\n>(\n  input: WithdrawNonceAccountInput<\n    TAccountNonceAccount,\n    TAccountRecipientAccount,\n    TAccountRecentBlockhashesSysvar,\n    TAccountRentSysvar,\n    TAccountNonceAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): WithdrawNonceAccountInstruction<\n  TProgramAddress,\n  TAccountNonceAccount,\n  TAccountRecipientAccount,\n  TAccountRecentBlockhashesSysvar,\n  TAccountRentSysvar,\n  TAccountNonceAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? SYSTEM_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    nonceAccount: { value: input.nonceAccount ?? null, isWritable: true },\n    recipientAccount: {\n      value: input.recipientAccount ?? null,\n      isWritable: true,\n    },\n    recentBlockhashesSysvar: {\n      value: input.recentBlockhashesSysvar ?? null,\n      isWritable: false,\n    },\n    rentSysvar: { value: input.rentSysvar ?? null, isWritable: false },\n    nonceAuthority: { value: input.nonceAuthority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.recentBlockhashesSysvar.value) {\n    accounts.recentBlockhashesSysvar.value =\n      'SysvarRecentB1ockHashes11111111111111111111' as Address<'SysvarRecentB1ockHashes11111111111111111111'>;\n  }\n  if (!accounts.rentSysvar.value) {\n    accounts.rentSysvar.value =\n      'SysvarRent111111111111111111111111111111111' as Address<'SysvarRent111111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'omitted');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.nonceAccount),\n      getAccountMeta(accounts.recipientAccount),\n      getAccountMeta(accounts.recentBlockhashesSysvar),\n      getAccountMeta(accounts.rentSysvar),\n      getAccountMeta(accounts.nonceAuthority),\n    ],\n    data: getWithdrawNonceAccountInstructionDataEncoder().encode(\n      args as WithdrawNonceAccountInstructionDataArgs\n    ),\n    programAddress,\n  } as WithdrawNonceAccountInstruction<\n    TProgramAddress,\n    TAccountNonceAccount,\n    TAccountRecipientAccount,\n    TAccountRecentBlockhashesSysvar,\n    TAccountRentSysvar,\n    TAccountNonceAuthority\n  >);\n}\n\nexport type ParsedWithdrawNonceAccountInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    nonceAccount: TAccountMetas[0];\n    recipientAccount: TAccountMetas[1];\n    recentBlockhashesSysvar: TAccountMetas[2];\n    rentSysvar: TAccountMetas[3];\n    nonceAuthority: TAccountMetas[4];\n  };\n  data: WithdrawNonceAccountInstructionData;\n};\n\nexport function parseWithdrawNonceAccountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedWithdrawNonceAccountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 5) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      nonceAccount: getNextAccount(),\n      recipientAccount: getNextAccount(),\n      recentBlockhashesSysvar: getNextAccount(),\n      rentSysvar: getNextAccount(),\n      nonceAuthority: getNextAccount(),\n    },\n    data: getWithdrawNonceAccountInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n"],"names":["NonceState","NonceVersion","getEnumEncoder","getU32Encoder","getEnumDecoder","getU32Decoder","combineCodec","SystemAccount","SystemInstruction","kitIsTransactionSigner","getStructEncoder","getStructDecoder","transformEncoder","getU64Encoder","getU64Decoder","getAddressEncoder","getAddressDecoder","addEncoderSizePrefix","getUtf8Encoder","addDecoderSizePrefix","getUtf8Decoder"],"mappings":"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","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]}