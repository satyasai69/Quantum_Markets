{"version":3,"sources":["../../../../node_modules/%40simplewebauthn/browser/esm/helpers/bufferToBase64URLString.js","../../../../node_modules/%40simplewebauthn/browser/esm/helpers/base64URLStringToBuffer.js","../../../../node_modules/%40simplewebauthn/browser/esm/helpers/browserSupportsWebAuthn.js","../../../../node_modules/%40simplewebauthn/browser/esm/helpers/toPublicKeyCredentialDescriptor.js","../../../../node_modules/%40simplewebauthn/browser/esm/helpers/isValidDomain.js","../../../../node_modules/%40simplewebauthn/browser/esm/helpers/webAuthnError.js","../../../../node_modules/%40simplewebauthn/browser/esm/helpers/identifyRegistrationError.js","../../../../node_modules/%40simplewebauthn/browser/esm/helpers/webAuthnAbortService.js","../../../../node_modules/%40simplewebauthn/browser/esm/helpers/toAuthenticatorAttachment.js","../../../../node_modules/%40simplewebauthn/browser/esm/methods/startRegistration.js","../../../../node_modules/%40simplewebauthn/browser/esm/helpers/browserSupportsWebAuthnAutofill.js","../../../../node_modules/%40simplewebauthn/browser/esm/helpers/identifyAuthenticationError.js","../../../../node_modules/%40simplewebauthn/browser/esm/methods/startAuthentication.js","../../../../node_modules/%40simplewebauthn/browser/esm/helpers/platformAuthenticatorIsAvailable.js"],"sourcesContent":["/**\n * Convert the given array buffer into a Base64URL-encoded string. Ideal for converting various\n * credential response ArrayBuffers to string for sending back to the server as JSON.\n *\n * Helper method to compliment `base64URLStringToBuffer`\n */\nexport function bufferToBase64URLString(buffer) {\n    const bytes = new Uint8Array(buffer);\n    let str = '';\n    for (const charCode of bytes) {\n        str += String.fromCharCode(charCode);\n    }\n    const base64String = btoa(str);\n    return base64String.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n}\n","/**\n * Convert from a Base64URL-encoded string to an Array Buffer. Best used when converting a\n * credential ID from a JSON string to an ArrayBuffer, like in allowCredentials or\n * excludeCredentials\n *\n * Helper method to compliment `bufferToBase64URLString`\n */\nexport function base64URLStringToBuffer(base64URLString) {\n    // Convert from Base64URL to Base64\n    const base64 = base64URLString.replace(/-/g, '+').replace(/_/g, '/');\n    /**\n     * Pad with '=' until it's a multiple of four\n     * (4 - (85 % 4 = 1) = 3) % 4 = 3 padding\n     * (4 - (86 % 4 = 2) = 2) % 4 = 2 padding\n     * (4 - (87 % 4 = 3) = 1) % 4 = 1 padding\n     * (4 - (88 % 4 = 0) = 4) % 4 = 0 padding\n     */\n    const padLength = (4 - (base64.length % 4)) % 4;\n    const padded = base64.padEnd(base64.length + padLength, '=');\n    // Convert to a binary string\n    const binary = atob(padded);\n    // Convert binary string to buffer\n    const buffer = new ArrayBuffer(binary.length);\n    const bytes = new Uint8Array(buffer);\n    for (let i = 0; i < binary.length; i++) {\n        bytes[i] = binary.charCodeAt(i);\n    }\n    return buffer;\n}\n","/**\n * Determine if the browser is capable of Webauthn\n */\nexport function browserSupportsWebAuthn() {\n    return _browserSupportsWebAuthnInternals.stubThis(globalThis?.PublicKeyCredential !== undefined &&\n        typeof globalThis.PublicKeyCredential === 'function');\n}\n/**\n * Make it possible to stub the return value during testing\n * @ignore Don't include this in docs output\n */\nexport const _browserSupportsWebAuthnInternals = {\n    stubThis: (value) => value,\n};\n","import { base64URLStringToBuffer } from './base64URLStringToBuffer.js';\nexport function toPublicKeyCredentialDescriptor(descriptor) {\n    const { id } = descriptor;\n    return {\n        ...descriptor,\n        id: base64URLStringToBuffer(id),\n        /**\n         * `descriptor.transports` is an array of our `AuthenticatorTransportFuture` that includes newer\n         * transports that TypeScript's DOM lib is ignorant of. Convince TS that our list of transports\n         * are fine to pass to WebAuthn since browsers will recognize the new value.\n         */\n        transports: descriptor.transports,\n    };\n}\n","/**\n * A simple test to determine if a hostname is a properly-formatted domain name\n *\n * A \"valid domain\" is defined here: https://url.spec.whatwg.org/#valid-domain\n *\n * Regex sourced from here:\n * https://www.oreilly.com/library/view/regular-expressions-cookbook/9781449327453/ch08s15.html\n */\nexport function isValidDomain(hostname) {\n    return (\n    // Consider localhost valid as well since it's okay wrt Secure Contexts\n    hostname === 'localhost' ||\n        /^([a-z0-9]+(-[a-z0-9]+)*\\.)+[a-z]{2,}$/i.test(hostname));\n}\n","/**\n * A custom Error used to return a more nuanced error detailing _why_ one of the eight documented\n * errors in the spec was raised after calling `navigator.credentials.create()` or\n * `navigator.credentials.get()`:\n *\n * - `AbortError`\n * - `ConstraintError`\n * - `InvalidStateError`\n * - `NotAllowedError`\n * - `NotSupportedError`\n * - `SecurityError`\n * - `TypeError`\n * - `UnknownError`\n *\n * Error messages were determined through investigation of the spec to determine under which\n * scenarios a given error would be raised.\n */\nexport class WebAuthnError extends Error {\n    constructor({ message, code, cause, name, }) {\n        // @ts-ignore: help Rollup understand that `cause` is okay to set\n        super(message, { cause });\n        Object.defineProperty(this, \"code\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.name = name ?? cause.name;\n        this.code = code;\n    }\n}\n","import { isValidDomain } from './isValidDomain.js';\nimport { WebAuthnError } from './webAuthnError.js';\n/**\n * Attempt to intuit _why_ an error was raised after calling `navigator.credentials.create()`\n */\nexport function identifyRegistrationError({ error, options, }) {\n    const { publicKey } = options;\n    if (!publicKey) {\n        throw Error('options was missing required publicKey property');\n    }\n    if (error.name === 'AbortError') {\n        if (options.signal instanceof AbortSignal) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 16)\n            return new WebAuthnError({\n                message: 'Registration ceremony was sent an abort signal',\n                code: 'ERROR_CEREMONY_ABORTED',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'ConstraintError') {\n        if (publicKey.authenticatorSelection?.requireResidentKey === true) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-op-make-cred (Step 4)\n            return new WebAuthnError({\n                message: 'Discoverable credentials were required but no available authenticator supported it',\n                code: 'ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT',\n                cause: error,\n            });\n        }\n        else if (\n        // @ts-ignore: `mediation` doesn't yet exist on CredentialCreationOptions but it's possible as of Sept 2024\n        options.mediation === 'conditional' &&\n            publicKey.authenticatorSelection?.userVerification === 'required') {\n            // https://w3c.github.io/webauthn/#sctn-createCredential (Step 22.4)\n            return new WebAuthnError({\n                message: 'User verification was required during automatic registration but it could not be performed',\n                code: 'ERROR_AUTO_REGISTER_USER_VERIFICATION_FAILURE',\n                cause: error,\n            });\n        }\n        else if (publicKey.authenticatorSelection?.userVerification === 'required') {\n            // https://www.w3.org/TR/webauthn-2/#sctn-op-make-cred (Step 5)\n            return new WebAuthnError({\n                message: 'User verification was required but no available authenticator supported it',\n                code: 'ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'InvalidStateError') {\n        // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 20)\n        // https://www.w3.org/TR/webauthn-2/#sctn-op-make-cred (Step 3)\n        return new WebAuthnError({\n            message: 'The authenticator was previously registered',\n            code: 'ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED',\n            cause: error,\n        });\n    }\n    else if (error.name === 'NotAllowedError') {\n        /**\n         * Pass the error directly through. Platforms are overloading this error beyond what the spec\n         * defines and we don't want to overwrite potentially useful error messages.\n         */\n        return new WebAuthnError({\n            message: error.message,\n            code: 'ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY',\n            cause: error,\n        });\n    }\n    else if (error.name === 'NotSupportedError') {\n        const validPubKeyCredParams = publicKey.pubKeyCredParams.filter((param) => param.type === 'public-key');\n        if (validPubKeyCredParams.length === 0) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 10)\n            return new WebAuthnError({\n                message: 'No entry in pubKeyCredParams was of type \"public-key\"',\n                code: 'ERROR_MALFORMED_PUBKEYCREDPARAMS',\n                cause: error,\n            });\n        }\n        // https://www.w3.org/TR/webauthn-2/#sctn-op-make-cred (Step 2)\n        return new WebAuthnError({\n            message: 'No available authenticator supported any of the specified pubKeyCredParams algorithms',\n            code: 'ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG',\n            cause: error,\n        });\n    }\n    else if (error.name === 'SecurityError') {\n        const effectiveDomain = globalThis.location.hostname;\n        if (!isValidDomain(effectiveDomain)) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 7)\n            return new WebAuthnError({\n                message: `${globalThis.location.hostname} is an invalid domain`,\n                code: 'ERROR_INVALID_DOMAIN',\n                cause: error,\n            });\n        }\n        else if (publicKey.rp.id !== effectiveDomain) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 8)\n            return new WebAuthnError({\n                message: `The RP ID \"${publicKey.rp.id}\" is invalid for this domain`,\n                code: 'ERROR_INVALID_RP_ID',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'TypeError') {\n        if (publicKey.user.id.byteLength < 1 || publicKey.user.id.byteLength > 64) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 5)\n            return new WebAuthnError({\n                message: 'User ID was not between 1 and 64 characters',\n                code: 'ERROR_INVALID_USER_ID_LENGTH',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'UnknownError') {\n        // https://www.w3.org/TR/webauthn-2/#sctn-op-make-cred (Step 1)\n        // https://www.w3.org/TR/webauthn-2/#sctn-op-make-cred (Step 8)\n        return new WebAuthnError({\n            message: 'The authenticator was unable to process the specified options, or could not create a new credential',\n            code: 'ERROR_AUTHENTICATOR_GENERAL_ERROR',\n            cause: error,\n        });\n    }\n    return error;\n}\n","class BaseWebAuthnAbortService {\n    constructor() {\n        Object.defineProperty(this, \"controller\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n    }\n    createNewAbortSignal() {\n        // Abort any existing calls to navigator.credentials.create() or navigator.credentials.get()\n        if (this.controller) {\n            const abortError = new Error('Cancelling existing WebAuthn API call for new one');\n            abortError.name = 'AbortError';\n            this.controller.abort(abortError);\n        }\n        const newController = new AbortController();\n        this.controller = newController;\n        return newController.signal;\n    }\n    cancelCeremony() {\n        if (this.controller) {\n            const abortError = new Error('Manually cancelling existing WebAuthn API call');\n            abortError.name = 'AbortError';\n            this.controller.abort(abortError);\n            this.controller = undefined;\n        }\n    }\n}\n/**\n * A service singleton to help ensure that only a single WebAuthn ceremony is active at a time.\n *\n * Users of **@simplewebauthn/browser** shouldn't typically need to use this, but it can help e.g.\n * developers building projects that use client-side routing to better control the behavior of\n * their UX in response to router navigation events.\n */\nexport const WebAuthnAbortService = new BaseWebAuthnAbortService();\n","const attachments = ['cross-platform', 'platform'];\n/**\n * If possible coerce a `string` value into a known `AuthenticatorAttachment`\n */\nexport function toAuthenticatorAttachment(attachment) {\n    if (!attachment) {\n        return;\n    }\n    if (attachments.indexOf(attachment) < 0) {\n        return;\n    }\n    return attachment;\n}\n","import { bufferToBase64URLString } from '../helpers/bufferToBase64URLString.js';\nimport { base64URLStringToBuffer } from '../helpers/base64URLStringToBuffer.js';\nimport { browserSupportsWebAuthn } from '../helpers/browserSupportsWebAuthn.js';\nimport { toPublicKeyCredentialDescriptor } from '../helpers/toPublicKeyCredentialDescriptor.js';\nimport { identifyRegistrationError } from '../helpers/identifyRegistrationError.js';\nimport { WebAuthnAbortService } from '../helpers/webAuthnAbortService.js';\nimport { toAuthenticatorAttachment } from '../helpers/toAuthenticatorAttachment.js';\n/**\n * Begin authenticator \"registration\" via WebAuthn attestation\n *\n * @param optionsJSON Output from **@simplewebauthn/server**'s `generateRegistrationOptions()`\n * @param useAutoRegister (Optional) Try to silently create a passkey with the password manager that the user just signed in with. Defaults to `false`.\n */\nexport async function startRegistration(options) {\n    // @ts-ignore: Intentionally check for old call structure to warn about improper API call\n    if (!options.optionsJSON && options.challenge) {\n        console.warn('startRegistration() was not called correctly. It will try to continue with the provided options, but this call should be refactored to use the expected call structure instead. See https://simplewebauthn.dev/docs/packages/browser#typeerror-cannot-read-properties-of-undefined-reading-challenge for more information.');\n        // @ts-ignore: Reassign the options, passed in as a positional argument, to the expected variable\n        options = { optionsJSON: options };\n    }\n    const { optionsJSON, useAutoRegister = false } = options;\n    if (!browserSupportsWebAuthn()) {\n        throw new Error('WebAuthn is not supported in this browser');\n    }\n    // We need to convert some values to Uint8Arrays before passing the credentials to the navigator\n    const publicKey = {\n        ...optionsJSON,\n        challenge: base64URLStringToBuffer(optionsJSON.challenge),\n        user: {\n            ...optionsJSON.user,\n            id: base64URLStringToBuffer(optionsJSON.user.id),\n        },\n        excludeCredentials: optionsJSON.excludeCredentials?.map(toPublicKeyCredentialDescriptor),\n    };\n    // Prepare options for `.create()`\n    const createOptions = {};\n    /**\n     * Try to use conditional create to register a passkey for the user with the password manager\n     * the user just used to authenticate with. The user won't be shown any prominent UI by the\n     * browser.\n     */\n    if (useAutoRegister) {\n        // @ts-ignore: `mediation` doesn't yet exist on CredentialCreationOptions but it's possible as of Sept 2024\n        createOptions.mediation = 'conditional';\n    }\n    // Finalize options\n    createOptions.publicKey = publicKey;\n    // Set up the ability to cancel this request if the user attempts another\n    createOptions.signal = WebAuthnAbortService.createNewAbortSignal();\n    // Wait for the user to complete attestation\n    let credential;\n    try {\n        credential = (await navigator.credentials.create(createOptions));\n    }\n    catch (err) {\n        throw identifyRegistrationError({ error: err, options: createOptions });\n    }\n    if (!credential) {\n        throw new Error('Registration was not completed');\n    }\n    const { id, rawId, response, type } = credential;\n    // Continue to play it safe with `getTransports()` for now, even when L3 types say it's required\n    let transports = undefined;\n    if (typeof response.getTransports === 'function') {\n        transports = response.getTransports();\n    }\n    // L3 says this is required, but browser and webview support are still not guaranteed.\n    let responsePublicKeyAlgorithm = undefined;\n    if (typeof response.getPublicKeyAlgorithm === 'function') {\n        try {\n            responsePublicKeyAlgorithm = response.getPublicKeyAlgorithm();\n        }\n        catch (error) {\n            warnOnBrokenImplementation('getPublicKeyAlgorithm()', error);\n        }\n    }\n    let responsePublicKey = undefined;\n    if (typeof response.getPublicKey === 'function') {\n        try {\n            const _publicKey = response.getPublicKey();\n            if (_publicKey !== null) {\n                responsePublicKey = bufferToBase64URLString(_publicKey);\n            }\n        }\n        catch (error) {\n            warnOnBrokenImplementation('getPublicKey()', error);\n        }\n    }\n    // L3 says this is required, but browser and webview support are still not guaranteed.\n    let responseAuthenticatorData;\n    if (typeof response.getAuthenticatorData === 'function') {\n        try {\n            responseAuthenticatorData = bufferToBase64URLString(response.getAuthenticatorData());\n        }\n        catch (error) {\n            warnOnBrokenImplementation('getAuthenticatorData()', error);\n        }\n    }\n    return {\n        id,\n        rawId: bufferToBase64URLString(rawId),\n        response: {\n            attestationObject: bufferToBase64URLString(response.attestationObject),\n            clientDataJSON: bufferToBase64URLString(response.clientDataJSON),\n            transports,\n            publicKeyAlgorithm: responsePublicKeyAlgorithm,\n            publicKey: responsePublicKey,\n            authenticatorData: responseAuthenticatorData,\n        },\n        type,\n        clientExtensionResults: credential.getClientExtensionResults(),\n        authenticatorAttachment: toAuthenticatorAttachment(credential.authenticatorAttachment),\n    };\n}\n/**\n * Visibly warn when we detect an issue related to a passkey provider intercepting WebAuthn API\n * calls\n */\nfunction warnOnBrokenImplementation(methodName, cause) {\n    console.warn(`The browser extension that intercepted this WebAuthn API call incorrectly implemented ${methodName}. You should report this error to them.\\n`, cause);\n}\n","import { browserSupportsWebAuthn } from './browserSupportsWebAuthn.js';\n/**\n * Determine if the browser supports conditional UI, so that WebAuthn credentials can\n * be shown to the user in the browser's typical password autofill popup.\n */\nexport function browserSupportsWebAuthnAutofill() {\n    if (!browserSupportsWebAuthn()) {\n        return _browserSupportsWebAuthnAutofillInternals.stubThis(new Promise((resolve) => resolve(false)));\n    }\n    /**\n     * I don't like the `as unknown` here but there's a `declare var PublicKeyCredential` in\n     * TS' DOM lib that's making it difficult for me to just go `as PublicKeyCredentialFuture` as I\n     * want. I think I'm fine with this for now since it's _supposed_ to be temporary, until TS types\n     * have a chance to catch up.\n     */\n    const globalPublicKeyCredential = globalThis\n        .PublicKeyCredential;\n    if (globalPublicKeyCredential?.isConditionalMediationAvailable === undefined) {\n        return _browserSupportsWebAuthnAutofillInternals.stubThis(new Promise((resolve) => resolve(false)));\n    }\n    return _browserSupportsWebAuthnAutofillInternals.stubThis(globalPublicKeyCredential.isConditionalMediationAvailable());\n}\n// Make it possible to stub the return value during testing\nexport const _browserSupportsWebAuthnAutofillInternals = {\n    stubThis: (value) => value,\n};\n","import { isValidDomain } from './isValidDomain.js';\nimport { WebAuthnError } from './webAuthnError.js';\n/**\n * Attempt to intuit _why_ an error was raised after calling `navigator.credentials.get()`\n */\nexport function identifyAuthenticationError({ error, options, }) {\n    const { publicKey } = options;\n    if (!publicKey) {\n        throw Error('options was missing required publicKey property');\n    }\n    if (error.name === 'AbortError') {\n        if (options.signal instanceof AbortSignal) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 16)\n            return new WebAuthnError({\n                message: 'Authentication ceremony was sent an abort signal',\n                code: 'ERROR_CEREMONY_ABORTED',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'NotAllowedError') {\n        /**\n         * Pass the error directly through. Platforms are overloading this error beyond what the spec\n         * defines and we don't want to overwrite potentially useful error messages.\n         */\n        return new WebAuthnError({\n            message: error.message,\n            code: 'ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY',\n            cause: error,\n        });\n    }\n    else if (error.name === 'SecurityError') {\n        const effectiveDomain = globalThis.location.hostname;\n        if (!isValidDomain(effectiveDomain)) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-discover-from-external-source (Step 5)\n            return new WebAuthnError({\n                message: `${globalThis.location.hostname} is an invalid domain`,\n                code: 'ERROR_INVALID_DOMAIN',\n                cause: error,\n            });\n        }\n        else if (publicKey.rpId !== effectiveDomain) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-discover-from-external-source (Step 6)\n            return new WebAuthnError({\n                message: `The RP ID \"${publicKey.rpId}\" is invalid for this domain`,\n                code: 'ERROR_INVALID_RP_ID',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'UnknownError') {\n        // https://www.w3.org/TR/webauthn-2/#sctn-op-get-assertion (Step 1)\n        // https://www.w3.org/TR/webauthn-2/#sctn-op-get-assertion (Step 12)\n        return new WebAuthnError({\n            message: 'The authenticator was unable to process the specified options, or could not create a new assertion signature',\n            code: 'ERROR_AUTHENTICATOR_GENERAL_ERROR',\n            cause: error,\n        });\n    }\n    return error;\n}\n","import { bufferToBase64URLString } from '../helpers/bufferToBase64URLString.js';\nimport { base64URLStringToBuffer } from '../helpers/base64URLStringToBuffer.js';\nimport { browserSupportsWebAuthn } from '../helpers/browserSupportsWebAuthn.js';\nimport { browserSupportsWebAuthnAutofill } from '../helpers/browserSupportsWebAuthnAutofill.js';\nimport { toPublicKeyCredentialDescriptor } from '../helpers/toPublicKeyCredentialDescriptor.js';\nimport { identifyAuthenticationError } from '../helpers/identifyAuthenticationError.js';\nimport { WebAuthnAbortService } from '../helpers/webAuthnAbortService.js';\nimport { toAuthenticatorAttachment } from '../helpers/toAuthenticatorAttachment.js';\n/**\n * Begin authenticator \"login\" via WebAuthn assertion\n *\n * @param optionsJSON Output from **@simplewebauthn/server**'s `generateAuthenticationOptions()`\n * @param useBrowserAutofill (Optional) Initialize conditional UI to enable logging in via browser autofill prompts. Defaults to `false`.\n * @param verifyBrowserAutofillInput (Optional) Ensure a suitable `<input>` element is present when `useBrowserAutofill` is `true`. Defaults to `true`.\n */\nexport async function startAuthentication(options) {\n    // @ts-ignore: Intentionally check for old call structure to warn about improper API call\n    if (!options.optionsJSON && options.challenge) {\n        console.warn('startAuthentication() was not called correctly. It will try to continue with the provided options, but this call should be refactored to use the expected call structure instead. See https://simplewebauthn.dev/docs/packages/browser#typeerror-cannot-read-properties-of-undefined-reading-challenge for more information.');\n        // @ts-ignore: Reassign the options, passed in as a positional argument, to the expected variable\n        options = { optionsJSON: options };\n    }\n    const { optionsJSON, useBrowserAutofill = false, verifyBrowserAutofillInput = true, } = options;\n    if (!browserSupportsWebAuthn()) {\n        throw new Error('WebAuthn is not supported in this browser');\n    }\n    // We need to avoid passing empty array to avoid blocking retrieval\n    // of public key\n    let allowCredentials;\n    if (optionsJSON.allowCredentials?.length !== 0) {\n        allowCredentials = optionsJSON.allowCredentials?.map(toPublicKeyCredentialDescriptor);\n    }\n    // We need to convert some values to Uint8Arrays before passing the credentials to the navigator\n    const publicKey = {\n        ...optionsJSON,\n        challenge: base64URLStringToBuffer(optionsJSON.challenge),\n        allowCredentials,\n    };\n    // Prepare options for `.get()`\n    const getOptions = {};\n    /**\n     * Set up the page to prompt the user to select a credential for authentication via the browser's\n     * input autofill mechanism.\n     */\n    if (useBrowserAutofill) {\n        if (!(await browserSupportsWebAuthnAutofill())) {\n            throw Error('Browser does not support WebAuthn autofill');\n        }\n        // Check for an <input> with \"webauthn\" in its `autocomplete` attribute\n        const eligibleInputs = document.querySelectorAll(\"input[autocomplete$='webauthn']\");\n        // WebAuthn autofill requires at least one valid input\n        if (eligibleInputs.length < 1 && verifyBrowserAutofillInput) {\n            throw Error('No <input> with \"webauthn\" as the only or last value in its `autocomplete` attribute was detected');\n        }\n        // `CredentialMediationRequirement` doesn't know about \"conditional\" yet as of\n        // typescript@4.6.3\n        getOptions.mediation = 'conditional';\n        // Conditional UI requires an empty allow list\n        publicKey.allowCredentials = [];\n    }\n    // Finalize options\n    getOptions.publicKey = publicKey;\n    // Set up the ability to cancel this request if the user attempts another\n    getOptions.signal = WebAuthnAbortService.createNewAbortSignal();\n    // Wait for the user to complete assertion\n    let credential;\n    try {\n        credential = (await navigator.credentials.get(getOptions));\n    }\n    catch (err) {\n        throw identifyAuthenticationError({ error: err, options: getOptions });\n    }\n    if (!credential) {\n        throw new Error('Authentication was not completed');\n    }\n    const { id, rawId, response, type } = credential;\n    let userHandle = undefined;\n    if (response.userHandle) {\n        userHandle = bufferToBase64URLString(response.userHandle);\n    }\n    // Convert values to base64 to make it easier to send back to the server\n    return {\n        id,\n        rawId: bufferToBase64URLString(rawId),\n        response: {\n            authenticatorData: bufferToBase64URLString(response.authenticatorData),\n            clientDataJSON: bufferToBase64URLString(response.clientDataJSON),\n            signature: bufferToBase64URLString(response.signature),\n            userHandle,\n        },\n        type,\n        clientExtensionResults: credential.getClientExtensionResults(),\n        authenticatorAttachment: toAuthenticatorAttachment(credential.authenticatorAttachment),\n    };\n}\n","import { browserSupportsWebAuthn } from './browserSupportsWebAuthn.js';\n/**\n * Determine whether the browser can communicate with a built-in authenticator, like\n * Touch ID, Android fingerprint scanner, or Windows Hello.\n *\n * This method will _not_ be able to tell you the name of the platform authenticator.\n */\nexport function platformAuthenticatorIsAvailable() {\n    if (!browserSupportsWebAuthn()) {\n        return new Promise((resolve) => resolve(false));\n    }\n    return PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();\n}\n"],"names":[],"mappings":"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","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13]}