module.exports=[692519,a=>{"use strict";function b(a){let b=new Uint8Array(a),c="";for(let a of b)c+=String.fromCharCode(a);return btoa(c).replace(/\+/g,"-").replace(/\//g,"_").replace(/=/g,"")}function c(a){let b=a.replace(/-/g,"+").replace(/_/g,"/"),c=(4-b.length%4)%4,d=atob(b.padEnd(b.length+c,"=")),e=new ArrayBuffer(d.length),f=new Uint8Array(e);for(let a=0;a<d.length;a++)f[a]=d.charCodeAt(a);return e}function d(){return e.stubThis(globalThis?.PublicKeyCredential!==void 0&&"function"==typeof globalThis.PublicKeyCredential)}a.s(["bufferToBase64URLString",()=>b],802642),a.s(["base64URLStringToBuffer",()=>c],86517);let e={stubThis:a=>a};function f(a){let{id:b}=a;return{...a,id:c(b),transports:a.transports}}function g(a){return"localhost"===a||/^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i.test(a)}a.s(["_browserSupportsWebAuthnInternals",0,e,"browserSupportsWebAuthn",()=>d],341190);class h extends Error{constructor({message:a,code:b,cause:c,name:d}){super(a,{cause:c}),Object.defineProperty(this,"code",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.name=d??c.name,this.code=b}}a.s(["WebAuthnError",()=>h],498953);let i=new class{constructor(){Object.defineProperty(this,"controller",{enumerable:!0,configurable:!0,writable:!0,value:void 0})}createNewAbortSignal(){if(this.controller){let a=Error("Cancelling existing WebAuthn API call for new one");a.name="AbortError",this.controller.abort(a)}let a=new AbortController;return this.controller=a,a.signal}cancelCeremony(){if(this.controller){let a=Error("Manually cancelling existing WebAuthn API call");a.name="AbortError",this.controller.abort(a),this.controller=void 0}}};a.s(["WebAuthnAbortService",0,i],932101);let j=["cross-platform","platform"];function k(a){if(a&&!(0>j.indexOf(a)))return a}async function l(a){let e,j,l,n,o;!a.optionsJSON&&a.challenge&&(console.warn("startRegistration() was not called correctly. It will try to continue with the provided options, but this call should be refactored to use the expected call structure instead. See https://simplewebauthn.dev/docs/packages/browser#typeerror-cannot-read-properties-of-undefined-reading-challenge for more information."),a={optionsJSON:a});let{optionsJSON:p,useAutoRegister:q=!1}=a;if(!d())throw Error("WebAuthn is not supported in this browser");let r={...p,challenge:c(p.challenge),user:{...p.user,id:c(p.user.id)},excludeCredentials:p.excludeCredentials?.map(f)},s={};q&&(s.mediation="conditional"),s.publicKey=r,s.signal=i.createNewAbortSignal();try{e=await navigator.credentials.create(s)}catch(a){throw function({error:a,options:b}){let{publicKey:c}=b;if(!c)throw Error("options was missing required publicKey property");if("AbortError"===a.name){if(b.signal instanceof AbortSignal)return new h({message:"Registration ceremony was sent an abort signal",code:"ERROR_CEREMONY_ABORTED",cause:a})}else if("ConstraintError"===a.name){if(c.authenticatorSelection?.requireResidentKey===!0)return new h({message:"Discoverable credentials were required but no available authenticator supported it",code:"ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT",cause:a});else if("conditional"===b.mediation&&c.authenticatorSelection?.userVerification==="required")return new h({message:"User verification was required during automatic registration but it could not be performed",code:"ERROR_AUTO_REGISTER_USER_VERIFICATION_FAILURE",cause:a});else if(c.authenticatorSelection?.userVerification==="required")return new h({message:"User verification was required but no available authenticator supported it",code:"ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT",cause:a})}else if("InvalidStateError"===a.name)return new h({message:"The authenticator was previously registered",code:"ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED",cause:a});else if("NotAllowedError"===a.name)return new h({message:a.message,code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:a});else if("NotSupportedError"===a.name)return new h(0===c.pubKeyCredParams.filter(a=>"public-key"===a.type).length?{message:'No entry in pubKeyCredParams was of type "public-key"',code:"ERROR_MALFORMED_PUBKEYCREDPARAMS",cause:a}:{message:"No available authenticator supported any of the specified pubKeyCredParams algorithms",code:"ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG",cause:a});else if("SecurityError"===a.name){let b=globalThis.location.hostname;if(!g(b))return new h({message:`${globalThis.location.hostname} is an invalid domain`,code:"ERROR_INVALID_DOMAIN",cause:a});if(c.rp.id!==b)return new h({message:`The RP ID "${c.rp.id}" is invalid for this domain`,code:"ERROR_INVALID_RP_ID",cause:a})}else if("TypeError"===a.name){if(c.user.id.byteLength<1||c.user.id.byteLength>64)return new h({message:"User ID was not between 1 and 64 characters",code:"ERROR_INVALID_USER_ID_LENGTH",cause:a})}else if("UnknownError"===a.name)return new h({message:"The authenticator was unable to process the specified options, or could not create a new credential",code:"ERROR_AUTHENTICATOR_GENERAL_ERROR",cause:a});return a}({error:a,options:s})}if(!e)throw Error("Registration was not completed");let{id:t,rawId:u,response:v,type:w}=e;if("function"==typeof v.getTransports&&(l=v.getTransports()),"function"==typeof v.getPublicKeyAlgorithm)try{n=v.getPublicKeyAlgorithm()}catch(a){m("getPublicKeyAlgorithm()",a)}if("function"==typeof v.getPublicKey)try{let a=v.getPublicKey();null!==a&&(o=b(a))}catch(a){m("getPublicKey()",a)}if("function"==typeof v.getAuthenticatorData)try{j=b(v.getAuthenticatorData())}catch(a){m("getAuthenticatorData()",a)}return{id:t,rawId:b(u),response:{attestationObject:b(v.attestationObject),clientDataJSON:b(v.clientDataJSON),transports:l,publicKeyAlgorithm:n,publicKey:o,authenticatorData:j},type:w,clientExtensionResults:e.getClientExtensionResults(),authenticatorAttachment:k(e.authenticatorAttachment)}}function m(a,b){console.warn(`The browser extension that intercepted this WebAuthn API call incorrectly implemented ${a}. You should report this error to them.
`,b)}function n(){if(!d())return o.stubThis(new Promise(a=>a(!1)));let a=globalThis.PublicKeyCredential;return a?.isConditionalMediationAvailable===void 0?o.stubThis(new Promise(a=>a(!1))):o.stubThis(a.isConditionalMediationAvailable())}a.s(["startRegistration",()=>l],468533);let o={stubThis:a=>a};async function p(a){let e,j,l;!a.optionsJSON&&a.challenge&&(console.warn("startAuthentication() was not called correctly. It will try to continue with the provided options, but this call should be refactored to use the expected call structure instead. See https://simplewebauthn.dev/docs/packages/browser#typeerror-cannot-read-properties-of-undefined-reading-challenge for more information."),a={optionsJSON:a});let{optionsJSON:m,useBrowserAutofill:o=!1,verifyBrowserAutofillInput:p=!0}=a;if(!d())throw Error("WebAuthn is not supported in this browser");m.allowCredentials?.length!==0&&(e=m.allowCredentials?.map(f));let q={...m,challenge:c(m.challenge),allowCredentials:e},r={};if(o){if(!await n())throw Error("Browser does not support WebAuthn autofill");if(document.querySelectorAll("input[autocomplete$='webauthn']").length<1&&p)throw Error('No <input> with "webauthn" as the only or last value in its `autocomplete` attribute was detected');r.mediation="conditional",q.allowCredentials=[]}r.publicKey=q,r.signal=i.createNewAbortSignal();try{j=await navigator.credentials.get(r)}catch(a){throw function({error:a,options:b}){let{publicKey:c}=b;if(!c)throw Error("options was missing required publicKey property");if("AbortError"===a.name){if(b.signal instanceof AbortSignal)return new h({message:"Authentication ceremony was sent an abort signal",code:"ERROR_CEREMONY_ABORTED",cause:a})}else if("NotAllowedError"===a.name)return new h({message:a.message,code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:a});else if("SecurityError"===a.name){let b=globalThis.location.hostname;if(!g(b))return new h({message:`${globalThis.location.hostname} is an invalid domain`,code:"ERROR_INVALID_DOMAIN",cause:a});if(c.rpId!==b)return new h({message:`The RP ID "${c.rpId}" is invalid for this domain`,code:"ERROR_INVALID_RP_ID",cause:a})}else if("UnknownError"===a.name)return new h({message:"The authenticator was unable to process the specified options, or could not create a new assertion signature",code:"ERROR_AUTHENTICATOR_GENERAL_ERROR",cause:a});return a}({error:a,options:r})}if(!j)throw Error("Authentication was not completed");let{id:s,rawId:t,response:u,type:v}=j;return u.userHandle&&(l=b(u.userHandle)),{id:s,rawId:b(t),response:{authenticatorData:b(u.authenticatorData),clientDataJSON:b(u.clientDataJSON),signature:b(u.signature),userHandle:l},type:v,clientExtensionResults:j.getClientExtensionResults(),authenticatorAttachment:k(j.authenticatorAttachment)}}function q(){return d()?PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable():new Promise(a=>a(!1))}a.s(["_browserSupportsWebAuthnAutofillInternals",0,o,"browserSupportsWebAuthnAutofill",()=>n],354951),a.s(["startAuthentication",()=>p],774270),a.s(["platformAuthenticatorIsAvailable",()=>q],782923),a.s([],817323),a.s([],385850),a.i(385850),a.i(468533),a.i(774270),a.i(341190),a.i(782923),a.i(354951),a.i(86517),a.i(802642),a.i(932101),a.i(498953),a.i(817323),a.s(["WebAuthnAbortService",0,i,"WebAuthnError",()=>h,"_browserSupportsWebAuthnAutofillInternals",0,o,"_browserSupportsWebAuthnInternals",0,e,"base64URLStringToBuffer",()=>c,"browserSupportsWebAuthn",()=>d,"browserSupportsWebAuthnAutofill",()=>n,"bufferToBase64URLString",()=>b,"platformAuthenticatorIsAvailable",()=>q,"startAuthentication",()=>p,"startRegistration",()=>l],692519)}];

//# sourceMappingURL=node_modules_%40simplewebauthn_browser_esm_index_5ca71b14.js.map