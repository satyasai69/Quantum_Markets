module.exports=[164381,a=>{"use strict";var b,c,d,e,f=a.i(187924),g=a.i(324633),h=a.i(572131),i=a.i(596758),j=a.i(919544),k=a.i(529408),l=a.i(769745),m=a.i(602420),n=a.i(296250),o=a.i(566056),p=a.i(944769),q=a.i(299389),r=a.i(427437),s=a.i(267954),t=a.i(360228),u=a.i(248191),v=a.i(527394),w=a.i(168617),x=a.i(683402),y=a.i(278223),z=a.i(595549),A=a.i(922669),B=a.i(575600),C=a.i(421663),D=a.i(562724),E=a.i(501060),F=a.i(238363),G=a.i(256291),H=a.i(213264);let I=["solana:mainnet","solana:devnet","solana:testnet"];function J(a,b){if(!Object.prototype.hasOwnProperty.call(a,b))throw TypeError("attempted to use private field on non-instance");return a}var K=0,L="__private_"+K+++"__implementation";function M(a,b){if(!Object.prototype.hasOwnProperty.call(a,b))throw TypeError("attempted to use private field on non-instance");return a}var N=0;function O(a){return"__private_"+N+++"_"+a}var P=O("_address"),Q=O("_publicKey"),R=O("_chains"),S=O("_features"),T=O("_label"),U=O("_icon");class V{get address(){return M(this,P)[P]}get publicKey(){return M(this,Q)[Q].slice()}get chains(){return M(this,R)[R].slice()}get features(){return M(this,S)[S].slice()}get label(){return M(this,T)[T]}get icon(){return M(this,U)[U]}constructor({address:a,publicKey:b,label:c,icon:d}){Object.defineProperty(this,P,{writable:!0,value:void 0}),Object.defineProperty(this,Q,{writable:!0,value:void 0}),Object.defineProperty(this,R,{writable:!0,value:void 0}),Object.defineProperty(this,S,{writable:!0,value:void 0}),Object.defineProperty(this,T,{writable:!0,value:void 0}),Object.defineProperty(this,U,{writable:!0,value:void 0}),M(this,P)[P]=a,M(this,Q)[Q]=b,M(this,R)[R]=I,M(this,T)[T]=c,M(this,U)[U]=d,M(this,S)[S]=["solana:signAndSendTransaction","solana:signTransaction","solana:signMessage"],new.target===V&&Object.freeze(this)}}function W(a,b){if(!Object.prototype.hasOwnProperty.call(a,b))throw TypeError("attempted to use private field on non-instance");return a}var X=0;function Y(a){return"__private_"+X+++"_"+a}var Z=Y("_listeners"),$=Y("_version"),_=Y("_name"),aa=Y("_icon"),ab=Y("_injection"),ac=Y("_isPrivyWallet"),ad=Y("_accounts"),ae=Y("_on"),af=Y("_emit"),ag=Y("_off"),ah=Y("_connected"),ai=Y("_connect"),aj=Y("_disconnect"),ak=Y("_signMessage"),al=Y("_signAndSendTransaction"),am=Y("_signTransaction");function an(a,...b){W(this,Z)[Z][a]?.forEach(a=>a.apply(null,b))}function ao(a,b){W(this,Z)[Z][a]=W(this,Z)[Z][a]?.filter(a=>b!==a)}function ap(){let{isHeadlessSigning:a,walletProxy:b,initializeWalletProxy:c,recoverEmbeddedWallet:d,openModal:e,privy:f,client:g}=(0,t.u)(),{user:h}=(0,B.u)(),{setModalData:i}=(0,u.a)(),{signWithUserSigner:j}=(0,F.u)();return{signMessage:({message:k,address:l,options:m})=>new Promise(async(n,o)=>{let p=(0,u.h)(h,l);if("privy"!==p?.walletClientType)return void o(new t.a("Wallet is not a Privy wallet",void 0,t.b.EMBEDDED_WALLET_NOT_FOUND));let{entropyId:q,entropyIdVerifier:r}=(0,C.g)(h,p),s=(0,u.d)(p),v=(0,H.b)(k).toString("base64");if(v.length<1)return void o(new t.a("Message must be a non-empty string",void 0,t.b.INVALID_MESSAGE));let w=async()=>{let a;if(!h)throw Error("User must be authenticated before signing with a Privy wallet");let e=await g.getAccessToken();if(!e)throw Error("User must be authenticated to use their embedded wallet.");let i=b??await c(15e3);if(!i)throw Error("Failed to initialize embedded wallet proxy.");if(!await d({address:p.address}))throw Error("Unable to connect to wallet");if(s){let b=await (0,z.rpc)(f,j,{chain_type:"solana",method:"signMessage",params:{message:v,encoding:"base64"},wallet_id:p.id});if(!b.data||!("signature"in b.data))throw Error("Failed to sign message");a=b.data.signature}else{let{response:b}=await i.rpc({accessToken:e,entropyId:q,entropyIdVerifier:r,chainType:"solana",hdWalletIndex:p.walletIndex??0,requesterAppId:m?.uiOptions?.requesterAppId,request:{method:"signMessage",params:{message:v}}});a=b.data.signature}return a};if(a({showWalletUIs:m?.uiOptions?.showWalletUIs}))try{let a=await w(),b=new Uint8Array((0,H.b)(a,"base64"));n({signature:b})}catch(a){o(a)}else i({signMessage:{method:"solana_signMessage",data:v,confirmAndSign:w,onSuccess:a=>{n({signature:new Uint8Array((0,H.b)(a,"base64"))})},onFailure:a=>{o(a)},uiOptions:m?.uiOptions??{}},connectWallet:{recoveryMethod:p.recoveryMethod,connectingWalletAddress:p.address,entropyId:q,entropyIdVerifier:r,isUnifiedWallet:s,onCompleteNavigateTo:"SignRequestScreen",onFailure:a=>{o(new t.a("Failed to connect to wallet",a,t.b.UNKNOWN_CONNECT_WALLET_ERROR))}}}),e("EmbeddedWalletConnectingScreen")})}}function aq(){let{isHeadlessSigning:a,openModal:b}=(0,t.u)(),{setModalData:c}=(0,u.a)(),{signMessage:d}=ap(),{user:e}=(0,B.u)();return{signTransaction:async({transaction:f,options:g,chain:h="solana:mainnet",address:i})=>{async function j(a){let b,c,{signature:e}=await d({message:(0,H.a)(a),address:i,options:{...g,uiOptions:{...g?.uiOptions,showWalletUIs:!1}}});return{signedTransaction:(b=structuredClone((0,w.getTransactionDecoder)().decode(a)),(c=(0,x.address)(i))in b.signatures&&(b.signatures[c]=e),new Uint8Array((0,w.getTransactionEncoder)().encode(b)))}}return a({showWalletUIs:g?.uiOptions?.showWalletUIs})?j(f):new Promise(async(a,d)=>{let k=(0,u.h)(e,i);if("privy"!==k?.walletClientType)return void d(new t.a("Wallet is not a Privy wallet",void 0,t.b.EMBEDDED_WALLET_NOT_FOUND));let{entropyId:l,entropyIdVerifier:m}=(0,C.g)(e,k),n=(0,u.d)(k);function o(a){return b=>{d(b instanceof t.a?b:new t.a("Failed to connect to wallet",b,a))}}let p={account:k,transaction:f,chain:h,signOnly:!0,uiOptions:g?.uiOptions||{},onConfirm:j,onSuccess:a,onFailure:o(t.b.TRANSACTION_FAILURE)};c({connectWallet:{recoveryMethod:k.recoveryMethod,connectingWalletAddress:k.address,entropyId:l,entropyIdVerifier:m,isUnifiedWallet:n,onCompleteNavigateTo:"StandardSignAndSendTransactionScreen",onFailure:o(t.b.UNKNOWN_CONNECT_WALLET_ERROR)},standardSignAndSendTransaction:p}),b("EmbeddedWalletConnectingScreen")})}}}let ar=new class extends D.default{setImplementation(a){J(this,L)[L]=a}async signMessage(a){return J(this,L)[L].signMessage(a)}async signAndSendTransaction(a){return J(this,L)[L].signAndSendTransaction(a)}async signTransaction(a){return J(this,L)[L].signTransaction(a)}constructor(a){super(),Object.defineProperty(this,L,{writable:!0,value:void 0}),J(this,L)[L]=a}}({signTransaction:(0,t.k)("signTransaction was not injected"),signAndSendTransaction:(0,t.k)("signAndSendTransaction was not injected"),signMessage:(0,t.k)("signMessage was not injected")}),as=new class{get version(){return W(this,$)[$]}get name(){return W(this,_)[_]}get icon(){return W(this,aa)[aa]}get chains(){return I.slice()}get features(){return{"standard:connect":{version:"1.0.0",connect:W(this,ai)[ai]},"standard:disconnect":{version:"1.0.0",disconnect:W(this,aj)[aj]},"standard:events":{version:"1.0.0",on:W(this,ae)[ae]},"solana:signAndSendTransaction":{version:"1.0.0",supportedTransactionVersions:["legacy",0],signAndSendTransaction:W(this,al)[al]},"solana:signTransaction":{version:"1.0.0",supportedTransactionVersions:["legacy",0],signTransaction:W(this,am)[am]},"solana:signMessage":{version:"1.0.0",signMessage:W(this,ak)[ak]},"privy:":{privy:{signMessage:W(this,ab)[ab].signMessage,signTransaction:W(this,ab)[ab].signTransaction,signAndSendTransaction:W(this,ab)[ab].signAndSendTransaction}}}}get accounts(){return W(this,ad)[ad].slice()}get isPrivyWallet(){return W(this,ac)[ac]}constructor({name:a,icon:b,version:c,injection:d,wallets:e}){Object.defineProperty(this,af,{value:an}),Object.defineProperty(this,ag,{value:ao}),Object.defineProperty(this,Z,{writable:!0,value:void 0}),Object.defineProperty(this,$,{writable:!0,value:void 0}),Object.defineProperty(this,_,{writable:!0,value:void 0}),Object.defineProperty(this,aa,{writable:!0,value:void 0}),Object.defineProperty(this,ab,{writable:!0,value:void 0}),Object.defineProperty(this,ac,{writable:!0,value:void 0}),Object.defineProperty(this,ad,{writable:!0,value:void 0}),Object.defineProperty(this,ae,{writable:!0,value:void 0}),Object.defineProperty(this,ah,{writable:!0,value:void 0}),Object.defineProperty(this,ai,{writable:!0,value:void 0}),Object.defineProperty(this,aj,{writable:!0,value:void 0}),Object.defineProperty(this,ak,{writable:!0,value:void 0}),Object.defineProperty(this,al,{writable:!0,value:void 0}),Object.defineProperty(this,am,{writable:!0,value:void 0}),W(this,Z)[Z]={},W(this,ae)[ae]=(a,b)=>(W(this,Z)[Z][a]?.push(b)||(W(this,Z)[Z][a]=[b]),()=>W(this,ag)[ag](a,b)),W(this,ah)[ah]=a=>{null!=a&&(W(this,ad)[ad]=a.map(({address:a})=>new V({address:a,publicKey:E.base58.decode(a)}))),W(this,af)[af]("change",{accounts:this.accounts})},W(this,ai)[ai]=async()=>(W(this,af)[af]("change",{accounts:this.accounts}),{accounts:this.accounts}),W(this,aj)[aj]=async()=>{W(this,af)[af]("change",{accounts:this.accounts})},W(this,ak)[ak]=async(...a)=>{let b=[];for(let{account:c,...d}of a){let{signature:a}=await W(this,ab)[ab].signMessage({...d,address:c.address});b.push({signedMessage:d.message,signature:a})}return b},W(this,al)[al]=async(...a)=>{let b=[];for(let c of a){let{signature:a}=await W(this,ab)[ab].signAndSendTransaction({...c,transaction:c.transaction,address:c.account.address,chain:c.chain||"solana:mainnet",options:c.options});b.push({signature:a})}return b},W(this,am)[am]=async(...a)=>{let b=[];for(let{transaction:c,account:d,options:e,chain:f}of a){let{signedTransaction:a}=await W(this,ab)[ab].signTransaction({transaction:c,address:d.address,chain:f||"solana:mainnet",options:e});b.push({signedTransaction:a})}return b},W(this,_)[_]=a,W(this,aa)[aa]=b,W(this,$)[$]=c,W(this,ab)[ab]=d,W(this,ad)[ad]=[],W(this,ac)[ac]=!0,d.on("accountChanged",W(this,ah)[ah],this),W(this,ah)[ah](e)}}({name:"Privy",version:"1.0.0",icon:"data:image/png;base64,AAABAAEAFBQAAAAAIABlAQAAFgAAAIlQTkcNChoKAAAADUlIRFIAAAAUAAAAFAgGAAAAjYkdDQAAAAlwSFlzAAAOwwAADsMBx2+oZAAAAQVJREFUeJxiYMANZIC4E4ivAPFPIP4FxDeAuB+IlfDowwBMQFwJxF+B+D8O/AOI66Bq8QJGIF6ExyB0vAqImfEZmEeCYTDcgMswPiB+T4aB34FYApuBsWQYBsP52AycToGBK7EZuJECAw9jM3AVBQbuwWZgIwUGTsZmoDkFBnpiMxAEjpJh2FV8iVsbiD+TYBgoDVrgMgwGnID4HRGGgTKBGyHDYEAaiBdCSxh0g/5AU4Q8sYYhAzEgjoGmABBOgFo2eACowFABYn0oVgViAVINkQTiZUD8DIj/ATF6GILEXgLxCiCWIsZAbiAuBeKtQHwHiEHJ6C8UfwHie0C8E4jLoWpRAAAAAP//rcbhsQAAAAZJREFUAwBYFs3VKJ0cuQAAAABJRU5ErkJggg==",wallets:[],injection:ar});var at=a.i(547613),au=a.i(175284),av=a.i(84235),aw=a.i(727229),ax=a.i(941342);a.i(847675),a.i(278475);var ay=a.i(865177),az=a.i(447213),aA=((b=aA||{})[b.Uninitialized=0]="Uninitialized",b[b.Initialized=1]="Initialized",b),aB=((c=aB||{})[c.Legacy=0]="Legacy",c[c.Current=1]="Current",c),aC=((d=aC||{})[d.Nonce=0]="Nonce",d),aD=((e=aD||{})[e.CreateAccount=0]="CreateAccount",e[e.Assign=1]="Assign",e[e.TransferSol=2]="TransferSol",e[e.CreateAccountWithSeed=3]="CreateAccountWithSeed",e[e.AdvanceNonceAccount=4]="AdvanceNonceAccount",e[e.WithdrawNonceAccount=5]="WithdrawNonceAccount",e[e.InitializeNonceAccount=6]="InitializeNonceAccount",e[e.AuthorizeNonceAccount=7]="AuthorizeNonceAccount",e[e.Allocate=8]="Allocate",e[e.AllocateWithSeed=9]="AllocateWithSeed",e[e.AssignWithSeed=10]="AssignWithSeed",e[e.TransferSolWithSeed=11]="TransferSolWithSeed",e[e.UpgradeNonceAccount=12]="UpgradeNonceAccount",e);function aE(a){return!!a&&"object"==typeof a&&"address"in a&&(0,az.isTransactionSigner)(a)}var aF=a.i(29943),aG=a.i(587437),aH=a.i(895769),aI=a.i(970601),aJ=a.i(813616),aK=a.i(25078);function aL({rows:a}){return(0,f.jsx)(r.a,{children:a.filter(a=>!!a).map((a,b)=>null!=a.value||a.isLoading?(0,f.jsxs)(r.R,{children:[(0,f.jsx)(q.L,{children:a.label}),(0,f.jsx)(q.V,{$isLoading:a.isLoading,children:a.value})]},b):null)})}function aM(a){return BigInt(Math.floor(1e9*parseFloat(a)))}function aN(a){return+aO.format(parseFloat(a.toString())/1e9)}a.i(906301),a.i(366962);let aO=Intl.NumberFormat(void 0,{maximumFractionDigits:8});async function aP({tx:a,solanaClient:b,amount:c,asset:d,tokenPrice:e}){if(!a)return null;if("SOL"===d&&e){let d=aM(c),f=(0,aI.g)(d,e),g=await (0,H.f)({solanaClient:b,tx:a});return{amountInUsd:f,feeInUsd:e?(0,aI.g)(g,e):void 0,totalInUsd:(0,aI.g)(d+g,e)}}if("USDC"===d&&e){let d,f="$"+c,g=await (0,H.f)({solanaClient:b,tx:a}),h=(d=parseFloat(g.toString())/aI.L*e)<.01?0:d;return{amountInUsd:f,feeInUsd:(0,aI.g)(g,e),totalInUsd:"$"+(parseFloat(c)+h).toFixed(2)}}if("SOL"===d){let d=aM(c),e=await (0,H.f)({solanaClient:b,tx:a});return{amountInSol:c+" SOL",feeInSol:aN(e)+" SOL",totalInSol:aN(d+e)+" SOL"}}return{amountInUsdc:c+" USDC",feeInSol:aN(await (0,H.f)({solanaClient:b,tx:a}))+" SOL"}}let aQ={component:function(){let a=(0,s.u)(),{closePrivyModal:b,createAnalyticsEvent:c}=(0,t.u)(),{data:d,setModalData:e,navigate:q}=(0,u.a)(),{wallets:r}=function(){let{ready:a,wallets:b}=function(){let{client:a}=(0,t.u)(),{ready:b,wallet:c}=function(){let{ready:a}=(0,C.u)(),{user:b}=(0,B.u)(),{signMessage:c}=ap(),{signTransaction:d}=aq(),{signAndSendTransaction:e}=function(){let a=(0,s.u)(),{isHeadlessSigning:b,openModal:c}=(0,t.u)(),{setModalData:d}=(0,u.a)(),{signTransaction:e}=aq(),f=(0,H.u)(),{user:g}=(0,B.u)(),{signWithUserSigner:h}=(0,F.u)();return{signAndSendTransaction:async({transaction:i,address:j,chain:k="solana:mainnet",options:l})=>{let m=(0,u.h)(g,j);if("privy"!==m?.walletClientType)throw new t.a("Wallet is not a Privy wallet",void 0,t.b.EMBEDDED_WALLET_NOT_FOUND);let n=(0,u.d)(m);async function o(b){if(l?.sponsor)return await (async b=>{if(!n)throw new t.a("Sponsoring transactions is only supported for wallets on the TEE stack",t.b.INVALID_DATA);let c=new y.default({appId:a.id,clientId:a.appClientId,storage:G.u}),d=await (0,z.rpc)(c,h,{chain_type:"solana",method:"signAndSendTransaction",sponsor:!0,params:{transaction:(0,H.b)(b).toString("base64"),encoding:"base64"},caip2:`solana:${(await f(k).rpc.getGenesisHash().send()).substring(0,32)}`,wallet_id:m.id});if(d.data&&"hash"in d.data)return{signature:E.base58.decode(d.data.hash)};throw Error("Failed to sign and send transaction")})(b);let{signedTransaction:c}=await e({transaction:b,address:j,chain:k,options:{...l,uiOptions:{...l?.uiOptions,showWalletUIs:!1}}}),{signature:d}=await f(k).sendAndConfirmTransaction(c);return{signature:d}}return b({showWalletUIs:l?.uiOptions?.showWalletUIs})?o(i):new Promise(async(b,e)=>{let f,h,{entropyId:p,entropyIdVerifier:q}=(0,C.g)(g,m);function r(a){return b=>{e(b instanceof t.a?b:new t.a("Failed to connect to wallet",b,a))}}let s={account:m,transaction:i,chain:k,signOnly:!1,uiOptions:l?.uiOptions||{},onConfirm:o,onSuccess:b,onFailure:r(t.b.TRANSACTION_FAILURE),isSponsored:!!l?.sponsor},u={recoveryMethod:m.recoveryMethod,connectingWalletAddress:m.address,entropyId:p,entropyIdVerifier:q,isUnifiedWallet:n,onCompleteNavigateTo:"StandardSignAndSendTransactionScreen",onFailure:r(t.b.UNKNOWN_CONNECT_WALLET_ERROR)};a.fundingConfig&&(f=(0,G.g)({address:j,appConfig:a,methodScreen:"FundingMethodSelectionScreen",fundWalletConfig:{...l,asset:"native-currency",chain:k},externalSolanaFundingScreen:"FundSolWalletWithExternalSolanaWallet"}),h={amount:a.fundingConfig.defaultRecommendedAmount,asset:"SOL",chain:k,destinationAddress:j,afterSuccessScreen:"StandardSignAndSendTransactionScreen",sourceWalletData:void 0}),d({connectWallet:u,standardSignAndSendTransaction:s,funding:f,solanaFundingData:h}),c("EmbeddedWalletConnectingScreen")})}}}(),f=(0,h.useMemo)(()=>{let a=[...(0,u.o)(b).sort((a,b)=>(a.walletIndex??0)-(b.walletIndex??0))],c=(0,u.j)(b);return c.length?[...a,...c]:a},[b]),g=(0,h.useMemo)(()=>({signMessage:async({message:a,address:b,options:d})=>await c({message:a,address:b,options:d}),signTransaction:async({transaction:a,address:b,chain:c,options:e})=>await d({transaction:a,address:b,chain:c,options:e}),async signAndSendTransaction({transaction:a,address:b,chain:c,options:d}){let{signature:f}=await e({transaction:a,address:b,chain:c,options:d});return{signature:f}}}),[c,d,e]);return(0,h.useEffect)(()=>{ar?.setImplementation(g)},[g]),(0,h.useEffect)(()=>{var b;!a||(b=as.accounts).length===f.length&&b.every((a,b)=>a.address===f[b]?.address)||ar?.emit("accountChanged",f)},[a,f]),{ready:a,wallet:as}}(),[d,e]=(0,h.useState)([]),[f,g]=(0,h.useState)([]);return(0,h.useEffect)(()=>{let a=[c,...d.filter(a=>"solana"===a.chainType&&!!a.wallet.features).map(a=>a.wallet)];g(a);let b=d.flatMap(b=>{let c=()=>g([...a]);return b.on("walletsUpdated",c),{connector:b,off:c}}),e=a.map(b=>b.features["standard:events"]?.on("change",()=>{g([...a])}));return()=>{e.forEach(a=>a?.()),b.forEach(({connector:a,off:b})=>a.off("walletsUpdated",b))}},[d]),(0,h.useEffect)(()=>{e(a.connectors?.walletConnectors.filter(a=>"solana"===a.chainType)??[]);let b=()=>{e(a.connectors?.walletConnectors.filter(a=>"solana"===a.chainType)??[])};return a.connectors?.on("connectorInitialized",b),()=>{a.connectors?.off("connectorInitialized",b)}},[b,a.connectors]),{ready:b,wallets:f}}();return{ready:a,wallets:(0,h.useMemo)(()=>b.flatMap(a=>a.accounts.map(b=>new A.ConnectedStandardSolanaWallet({wallet:a,account:b}))),[b])}}(),[x,D]=(0,h.useState)("preparing"),[I,J]=(0,h.useState)(),[K,L]=(0,h.useState)(),[M,N]=(0,h.useState)();if(!d?.solanaFundingData)throw Error("Funding config is missing");if(!d.solanaFundingData.sourceWalletData)throw Error("Funding config is missing source wallet data");let{amount:O,asset:P,chain:Q,sourceWalletData:R,destinationAddress:S,afterSuccessScreen:T}=d.solanaFundingData,U=r.find(a=>a.address===R.address&&(0,G.t)(R.walletClientType)===(0,G.t)(a.standardWallet.name)),V=(0,H.u)()(Q),{tokenPrice:W,isTokenPriceLoading:X}=(0,at.u)("solana");return(0,h.useEffect)(()=>{if("preparing"!==x||X||!U)return;let a="SOL"===P?aM(O):BigInt(Math.floor(1e6*parseFloat(O)));L({amount:("SOL"===P&&W?(0,aI.g)(a,W):O)??O}),("SOL"===P?async function({solanaClient:a,source:b,destination:c,amountInLamports:d}){let{value:e}=await a.rpc.getLatestBlockhash().send(),f={address:b},g=(0,aF.pipe)((0,aG.createTransactionMessage)({version:0}),a=>(0,az.setTransactionMessageFeePayerSigner)(f,a),a=>(0,aG.setTransactionMessageLifetimeUsingBlockhash)(e,a),a=>{var b;let e,g,h,i;return(0,aG.appendTransactionMessageInstruction)((e=(void 0)??"11111111111111111111111111111111",g={source:{value:(b={amount:d,source:f,destination:c}).source??null,isWritable:!0},destination:{value:b.destination??null,isWritable:!0}},h={...b},Object.freeze({accounts:[(i=a=>{if(!a.value)return;let b=a.isWritable?ay.AccountRole.WRITABLE:ay.AccountRole.READONLY;return Object.freeze({address:function(a){if(!a)throw Error("Expected a Address.");return"object"==typeof a&&"address"in a?a.address:Array.isArray(a)?a[0]:a}(a.value),role:aE(a.value)?(0,ay.upgradeRoleToSigner)(b):b,...aE(a.value)?{signer:a.value}:{}})})(g.source),i(g.destination)],data:(0,ax.transformEncoder)((0,av.getStructEncoder)([["discriminator",(0,aw.getU32Encoder)()],["amount",(0,aw.getU64Encoder)()]]),a=>({...a,discriminator:2})).encode(h),programAddress:e})),a)},a=>(0,w.compileTransaction)(a));return new Uint8Array((0,w.getTransactionEncoder)().encode(g))}({solanaClient:V,source:U.address,destination:S,amountInLamports:a}):async function({solanaClient:a,source:b,destination:c,amountInBaseUnits:d}){let e=(0,aJ.g)(a.chain),{value:f}=await a.rpc.getLatestBlockhash().send(),g={address:b},[h]=await (0,aH.findAssociatedTokenPda)({mint:e,owner:b,tokenProgram:aI.T}),[i]=await (0,aH.findAssociatedTokenPda)({mint:e,owner:c,tokenProgram:aI.T}),[j,k]=await Promise.all([a.rpc.getAccountInfo(h,{commitment:"confirmed",encoding:"jsonParsed"}).send().catch(()=>null),a.rpc.getAccountInfo(i,{commitment:"confirmed",encoding:"jsonParsed"}).send().catch(()=>null)]);if(!j?.value)throw Error(`Source token account does not exist for address: ${b}`);let l=(0,aH.getCreateAssociatedTokenIdempotentInstruction)({payer:g,ata:i,owner:c,mint:e}),m=(0,aF.pipe)((0,aG.createTransactionMessage)({version:0}),a=>(0,az.setTransactionMessageFeePayerSigner)(g,a),a=>(0,aG.setTransactionMessageLifetimeUsingBlockhash)(f,a),a=>k?.value?a:(0,aG.appendTransactionMessageInstruction)(l,a),a=>(0,aG.appendTransactionMessageInstruction)((0,aH.getTransferInstruction)({source:h,destination:i,authority:g,amount:d}),a),a=>(0,w.compileTransaction)(a));return new Uint8Array((0,w.getTransactionEncoder)().encode(m))}({solanaClient:V,source:U.address,destination:S,amountInBaseUnits:a})).then(J).catch(a=>{D("error"),N(a)})},[x,O,P,Q,U,S,X,W]),(0,h.useEffect)(()=>{"preparing"===x&&I&&aP({tx:I,solanaClient:V,amount:O,asset:P,tokenPrice:W}).then(a=>{D("loaded"),L({amount:a?.amountInUsd??a?.amountInUsdc??a?.amountInSol??O,fee:a?.feeInUsd??a?.feeInSol,total:a?.totalInUsd??a?.totalInSol})}).catch(a=>{D("error"),N(a)})},[I,O,P,x,W]),(0,h.useEffect)(()=>{"error"===x&&M&&(e({errorModalData:{error:M,previousScreen:"FundSolWalletWithExternalSolanaWallet"},solanaFundingData:d.solanaFundingData}),q("ErrorScreen",!1))},[x,q]),(0,h.useEffect)(()=>{if("success"!==x)return;let a=setTimeout(T?()=>q(T):b,s.t);return()=>clearTimeout(a)},[x]),(0,f.jsxs)(f.Fragment,"success"===x?{children:[(0,f.jsx)(n.t,{}),(0,f.jsx)(k.b,{}),(0,f.jsxs)(k.c,{children:[(0,f.jsx)(g.default,{color:"var(--privy-color-success)",width:"64px",height:"64px"}),(0,f.jsx)(m.C,{title:"Success!",description:`Youâ€™ve successfully added ${O} ${P} to your ${a.name} wallet. It may take a minute before the funds are available to use.`})]}),(0,f.jsx)(k.R,{}),(0,f.jsx)(l.B,{})]}:"preparing"===x||"loaded"===x||"sending"===x?{children:[(0,f.jsx)(n.t,{}),(0,f.jsx)(k.e,{style:{marginTop:"16px"},children:(0,f.jsx)(o.I,{icon:U?.standardWallet.icon,name:U?.standardWallet.name})}),(0,f.jsx)(m.C,{style:{marginTop:"8px",marginBottom:"12px"},title:"sending"===x&&U?`Confirming with ${U.standardWallet.name}`:"Confirm transaction"}),(0,f.jsx)(aL,{rows:[{label:"Source",value:(0,i.formatWalletAddress)(R.address)},{label:"Destination",value:(0,i.formatWalletAddress)(S)},{label:"Network",value:(0,aK.g)(Q)},{label:"Amount",value:K?.amount,isLoading:"preparing"===x},{label:"Estimated fee",value:K?.fee,isLoading:"preparing"===x},{label:"Total",value:K?.total,isLoading:"preparing"===x}]}),(0,f.jsx)(j.P,{style:{marginTop:"1rem"},loading:"preparing"===x||"sending"===x,onClick:function(){"loaded"===x&&I&&U&&(D("sending"),(async function({transaction:a,chain:b,sourceWallet:c,solanaClient:d}){var e;let{hasFunds:f}=await (0,H.s)({solanaClient:d,tx:a});if(!f)throw new t.a(`Wallet ${(0,i.formatWalletAddress)(c.address)} does not have enough funds.`,void 0,t.b.INSUFFICIENT_BALANCE);let g=(e=(await c.signAndSendTransaction({transaction:a,chain:b}).catch(a=>{throw new t.a("Transaction was rejected by the user",a,t.b.TRANSACTION_FAILURE)})).signature,(0,v.getBase58Decoder)().decode(e));return await (0,H.w)({rpcSubscriptions:d.rpcSubscriptions,signature:g,timeout:2e4}),g})({solanaClient:V,transaction:I,chain:Q,sourceWallet:U}).then(a=>{D("success"),c({eventName:au.O,payload:{provider:"external",status:"success",txHash:a,address:U.address,value:O,chainType:"solana",clusterName:Q,token:P,destinationAddress:S,destinationValue:O,destinationChainType:"solana",destinationClusterName:Q,destinationToken:P}})}).catch(a=>{D("error"),N(a)}))},children:"Confirm"}),(0,f.jsx)(l.B,{})]}:{children:[(0,f.jsx)(n.t,{}),(0,f.jsx)(p.N,{}),(0,f.jsx)("div",{style:{marginTop:"1rem"}}),(0,f.jsx)(l.B,{})]})}};a.s(["FundSolWalletWithExternalSolanaWallet",()=>aQ,"default",()=>aQ],164381)}];

//# sourceMappingURL=91eee_react-auth_dist_esm_FundSolWalletWithExternalSolanaWallet-DVaHCgDh_mjs_31a89ab7._.js.map