{"version":3,"sources":["../../../../node_modules/%40privy-io/routes/dist/esm/smart-wallets.mjs","../../../../node_modules/%40privy-io/js-sdk-core/dist/esm/client/AppApi.mjs","../../../../node_modules/%40privy-io/routes/dist/esm/cross-app.mjs","../../../../node_modules/jose/dist/node/esm/runtime/base64url.js","../../../../node_modules/jose/dist/node/esm/runtime/digest.js","../../../../node_modules/jose/dist/node/esm/lib/buffer_utils.js","../../../../node_modules/jose/dist/node/esm/util/base64url.js","../../../../node_modules/jose/dist/node/esm/lib/is_object.js","../../../../node_modules/jose/dist/node/esm/util/errors.js","../../../../node_modules/jose/dist/node/esm/util/decode_jwt.js","../../../../node_modules/%40privy-io/js-sdk-core/dist/esm/Token.mjs","../../../../node_modules/%40privy-io/js-sdk-core/dist/esm/client/CrossAppApi.mjs","../../../../node_modules/%40privy-io/js-sdk-core/dist/esm/client/DelegatedWalletsApi.mjs","../../../../node_modules/%40privy-io/js-sdk-core/dist/esm/Error.mjs","../../../../node_modules/%40privy-io/js-sdk-core/dist/esm/wallet-api/unified-wallet.mjs","../../../../node_modules/%40privy-io/js-sdk-core/dist/esm/embedded/EmbeddedBitcoinWalletProvider.mjs","../../../../node_modules/%40privy-io/js-sdk-core/dist/esm/embedded/stack/walletCreate.mjs","../../../../node_modules/%40privy-io/js-sdk-core/dist/esm/embedded/utils/index.mjs","../../../../node_modules/%40privy-io/js-sdk-core/node_modules/eventemitter3/index.js","../../../../node_modules/canonicalize/lib/canonicalize.js","../../../../node_modules/fetch-retry/index.js","../../../../node_modules/%40privy-io/js-sdk-core/dist/esm/client/Privy.mjs","../../../../node_modules/%40privy-io/js-sdk-core/dist/esm/client/EmbeddedWalletApi.mjs","../../../../node_modules/%40privy-io/js-sdk-core/dist/esm/utils/sleep.mjs","../../../../node_modules/%40privy-io/js-sdk-core/dist/esm/embedded/EventCallbackQueue.mjs","../../../../node_modules/%40privy-io/js-sdk-core/dist/esm/embedded/withMfa.mjs","../../../../node_modules/%40privy-io/js-sdk-core/dist/esm/embedded/EmbeddedWalletProxy.mjs","../../../../node_modules/%40privy-io/js-sdk-core/node_modules/eventemitter3/index.mjs","../../../../node_modules/%40privy-io/js-sdk-core/dist/esm/embedded/EmbeddedWalletProvider.mjs","../../../../node_modules/%40privy-io/ethereum/dist/esm/to-viem-transaction-serializable.mjs","../../../../node_modules/%40privy-io/js-sdk-core/dist/esm/utils/encodings.mjs","../../../../node_modules/%40privy-io/js-sdk-core/dist/esm/wallet-api/rpc.mjs","../../../../node_modules/%40privy-io/js-sdk-core/dist/esm/wallet-api/generate-authorization-signature.mjs","../../../../node_modules/%40privy-io/js-sdk-core/dist/esm/embedded/stack/wallet-api-eth-transaction.mjs","../../../../node_modules/%40privy-io/js-sdk-core/dist/esm/embedded/stack/wallet-api-eth-typed-data.mjs","../../../../node_modules/%40privy-io/js-sdk-core/dist/esm/embedded/stack/walletRpc.mjs","../../../../node_modules/%40privy-io/js-sdk-core/dist/esm/solana/isVersionedTransaction.mjs","../../../../node_modules/%40privy-io/js-sdk-core/dist/esm/solana/getWalletPublicKeyFromTransaction.mjs","../../../../node_modules/%40privy-io/js-sdk-core/dist/esm/embedded/EmbeddedSolanaWalletProvider.mjs","../../../../node_modules/%40privy-io/js-sdk-core/dist/esm/client/MfaPromises.mjs","../../../../node_modules/%40privy-io/js-sdk-core/dist/esm/client/PrivyInternal.mjs","../../../../node_modules/uuid/dist/esm-node/native.js","../../../../node_modules/uuid/dist/esm-node/rng.js","../../../../node_modules/uuid/dist/esm-node/regex.js","../../../../node_modules/uuid/dist/esm-node/validate.js","../../../../node_modules/uuid/dist/esm-node/stringify.js","../../../../node_modules/uuid/dist/esm-node/v4.js","../../../../node_modules/%40privy-io/api-base/dist/esm/constants/error-codes.mjs","../../../../node_modules/%40privy-io/routes/dist/esm/types.mjs","../../../../node_modules/%40privy-io/routes/dist/esm/apps.mjs","../../../../node_modules/%40privy-io/routes/dist/esm/analytics-events.mjs","../../../../node_modules/%40privy-io/routes/dist/esm/sessions.mjs","../../../../node_modules/js-cookie/dist/js.cookie.mjs","../../../../node_modules/%40privy-io/js-sdk-core/dist/esm/Session.mjs","../../../../node_modules/%40privy-io/js-sdk-core/dist/esm/utils/allSettled.mjs","../../../../node_modules/%40privy-io/js-sdk-core/dist/esm/toAbortSignalTimeout.mjs","../../../../node_modules/%40privy-io/js-sdk-core/dist/esm/utils/toSearchParams.mjs","../../../../node_modules/%40privy-io/js-sdk-core/dist/esm/utils/noop.mjs","../../../../node_modules/%40privy-io/js-sdk-core/dist/esm/client/logger.mjs","../../../../node_modules/%40privy-io/routes/dist/esm/terms.mjs","../../../../node_modules/%40privy-io/js-sdk-core/dist/esm/client/UserApi.mjs","../../../../node_modules/%40privy-io/routes/dist/esm/custom-jwt-account.mjs","../../../../node_modules/%40privy-io/js-sdk-core/dist/esm/utils/embedded-wallets.mjs","../../../../node_modules/%40privy-io/js-sdk-core/dist/esm/utils/getAllUserEmbeddedEthereumWallets.mjs","../../../../node_modules/%40privy-io/js-sdk-core/dist/esm/utils/getUserEmbeddedEthereumWallet.mjs","../../../../node_modules/%40privy-io/js-sdk-core/dist/esm/utils/getAllUserEmbeddedSolanaWallets.mjs","../../../../node_modules/%40privy-io/js-sdk-core/dist/esm/utils/getUserEmbeddedSolanaWallet.mjs","../../../../node_modules/%40privy-io/js-sdk-core/dist/esm/utils/shouldCreateEmbeddedEthWallet.mjs","../../../../node_modules/%40privy-io/js-sdk-core/dist/esm/utils/shouldCreateEmbeddedSolWallet.mjs","../../../../node_modules/%40privy-io/js-sdk-core/dist/esm/client/auth/maybeCreateWalletOnLogin.mjs","../../../../node_modules/%40privy-io/js-sdk-core/dist/esm/client/auth/CustomProviderApi.mjs","../../../../node_modules/%40privy-io/routes/dist/esm/passwordless.mjs","../../../../node_modules/%40privy-io/js-sdk-core/dist/esm/client/auth/EmailApi.mjs","../../../../node_modules/%40privy-io/routes/dist/esm/farcaster.mjs","../../../../node_modules/%40privy-io/js-sdk-core/dist/esm/client/auth/FarcasterApi.mjs","../../../../node_modules/%40privy-io/js-sdk-core/dist/esm/client/auth/FarcasterV2Api.mjs","../../../../node_modules/%40privy-io/routes/dist/esm/guest.mjs","../../../../node_modules/%40privy-io/js-sdk-core/dist/esm/client/auth/GuestApi.mjs","../../../../node_modules/%40privy-io/routes/dist/esm/oauth.mjs","../../../../node_modules/%40privy-io/js-sdk-core/dist/esm/pkce.mjs","../../../../node_modules/%40privy-io/js-sdk-core/dist/esm/client/auth/OAuthApi.mjs","../../../../node_modules/%40privy-io/routes/dist/esm/passkey.mjs","../../../../node_modules/%40privy-io/js-sdk-core/dist/esm/client/auth/PasskeyApi.mjs","../../../../node_modules/%40privy-io/routes/dist/esm/passwordless-sms.mjs","../../../../node_modules/%40privy-io/js-sdk-core/dist/esm/client/auth/PhoneApi.mjs","../../../../node_modules/%40privy-io/routes/dist/esm/siwe.mjs","../../../../node_modules/%40privy-io/js-sdk-core/dist/esm/client/auth/SiweApi.mjs","../../../../node_modules/%40privy-io/routes/dist/esm/siws.mjs","../../../../node_modules/%40privy-io/js-sdk-core/dist/esm/client/auth/SiwsApi.mjs","../../../../node_modules/%40privy-io/js-sdk-core/dist/esm/client/auth/SmartWalletApi.mjs","../../../../node_modules/%40privy-io/js-sdk-core/dist/esm/client/auth/AuthApi.mjs","../../../../node_modules/%40privy-io/routes/dist/esm/coinbase.mjs","../../../../node_modules/%40privy-io/js-sdk-core/dist/esm/client/funding/CoinbaseOnRampApi.mjs","../../../../node_modules/%40privy-io/routes/dist/esm/moonpay.mjs","../../../../node_modules/%40privy-io/js-sdk-core/dist/esm/client/funding/MoonpayOnRampApi.mjs","../../../../node_modules/%40privy-io/js-sdk-core/dist/esm/client/funding/FundingApi.mjs","../../../../node_modules/%40privy-io/routes/dist/esm/mfa-passkey.mjs","../../../../node_modules/%40privy-io/js-sdk-core/dist/esm/client/mfa/MfaPasskeyApi.mjs","../../../../node_modules/%40privy-io/routes/dist/esm/mfa-passwordless-sms.mjs","../../../../node_modules/%40privy-io/js-sdk-core/dist/esm/client/mfa/MfaSmsApi.mjs","../../../../node_modules/%40privy-io/js-sdk-core/dist/esm/client/mfa/MfaApi.mjs","../../../../node_modules/%40privy-io/routes/dist/esm/recovery.mjs","../../../../node_modules/%40privy-io/js-sdk-core/dist/esm/client/recovery/RecoveryICloudApi.mjs","../../../../node_modules/%40privy-io/js-sdk-core/dist/esm/client/recovery/RecoveryOAuthApi.mjs","../../../../node_modules/%40privy-io/js-sdk-core/dist/esm/client/recovery/RecoveryApi.mjs","../../../../node_modules/%40solana/errors/src/codes.ts","../../../../node_modules/%40solana/errors/src/context.ts","../../../../node_modules/%40solana/errors/src/messages.ts","../../../../node_modules/%40solana/errors/src/message-formatter.ts","../../../../node_modules/%40solana/errors/src/error.ts","../../../../node_modules/%40solana/errors/src/stack-trace.ts","../../../../node_modules/%40solana/errors/src/rpc-enum-errors.ts","../../../../node_modules/%40solana/errors/src/instruction-error.ts","../../../../node_modules/%40solana/errors/src/transaction-error.ts","../../../../node_modules/%40solana/errors/src/json-rpc-error.ts","../../../../node_modules/%40solana/instructions/src/instruction.ts","../../../../node_modules/%40solana/instructions/src/roles.ts","../../../../node_modules/%40solana/assertions/src/crypto.ts","../../../../node_modules/%40solana/codecs-strings/src/assertions.ts","../../../../node_modules/%40solana/codecs-core/src/bytes.ts","../../../../node_modules/%40solana/addresses/src/address.ts","../../../../node_modules/%40solana/assertions/src/subtle-crypto.ts","../../../../node_modules/%40solana/codecs-strings/src/baseX.ts","../../../../node_modules/%40solana/codecs-core/src/codec.ts","../../../../node_modules/%40solana/addresses/src/vendor/noble/ed25519.ts","../../../../node_modules/%40solana/codecs-core/src/combine-codec.ts","../../../../node_modules/%40solana/codecs-strings/src/base10.ts","../../../../node_modules/%40solana/codecs-strings/src/base16.ts","../../../../node_modules/%40solana/codecs-core/src/add-codec-sentinel.ts","../../../../node_modules/%40solana/codecs-strings/src/base58.ts","../../../../node_modules/%40solana/codecs-strings/src/baseX-reslice.ts","../../../../node_modules/%40solana/addresses/src/curve-internal.ts","../../../../node_modules/%40solana/addresses/src/curve.ts","../../../../node_modules/%40solana/codecs-core/src/assertions.ts","../../../../node_modules/%40solana/addresses/src/program-derived-address.ts","../../../../node_modules/%40solana/codecs-strings/src/base64.ts","../../../../node_modules/%40solana/codecs-core/src/add-codec-size-prefix.ts","../../../../node_modules/%40solana/codecs-strings/src/null-characters.ts","../../../../node_modules/%40solana/text-encoding-impl/src/index.node.ts","../../../../node_modules/%40solana/codecs-strings/src/utf8.ts","../../../../node_modules/%40solana/codecs-core/src/decoder-entire-byte-array.ts","../../../../node_modules/%40solana/codecs-core/src/fix-codec-size.ts","../../../../node_modules/%40solana/codecs-core/src/offset-codec.ts","../../../../node_modules/%40solana/addresses/src/public-key.ts","../../../../node_modules/%40solana/codecs-core/src/resize-codec.ts","../../../../node_modules/%40solana/codecs-core/src/pad-codec.ts","../../../../node_modules/%40solana/codecs-core/src/reverse-codec.ts","../../../../node_modules/%40solana/codecs-core/src/transform-codec.ts","../../../../node_modules/%40solana/keys/src/algorithm.ts","../../../../node_modules/%40solana/keys/src/private-key.ts","../../../../node_modules/%40solana/keys/src/public-key.ts","../../../../node_modules/%40solana/keys/src/signatures.ts","../../../../node_modules/%40solana/keys/src/key-pair.ts","../../../../node_modules/%40solana/codecs-numbers/src/assertions.ts","../../../../node_modules/%40solana/codecs-data-structures/src/assertions.ts","../../../../node_modules/%40solana/rpc-types/src/blockhash.ts","../../../../node_modules/%40solana/codecs-data-structures/src/utils.ts","../../../../node_modules/%40solana/codecs-numbers/src/common.ts","../../../../node_modules/%40solana/codecs-numbers/src/utils.ts","../../../../node_modules/%40solana/codecs-data-structures/src/array.ts","../../../../node_modules/%40solana/rpc-types/src/cluster-url.ts","../../../../node_modules/%40solana/codecs-numbers/src/f32.ts","../../../../node_modules/%40solana/rpc-types/src/commitment.ts","../../../../node_modules/%40solana/codecs-numbers/src/f64.ts","../../../../node_modules/%40solana/codecs-numbers/src/i128.ts","../../../../node_modules/%40solana/rpc-types/src/lamports.ts","../../../../node_modules/%40solana/codecs-data-structures/src/bit-array.ts","../../../../node_modules/%40solana/codecs-numbers/src/i16.ts","../../../../node_modules/%40solana/codecs-numbers/src/i32.ts","../../../../node_modules/%40solana/rpc-types/src/stringified-bigint.ts","../../../../node_modules/%40solana/codecs-numbers/src/i64.ts","../../../../node_modules/%40solana/rpc-types/src/stringified-number.ts","../../../../node_modules/%40solana/codecs-data-structures/src/boolean.ts","../../../../node_modules/%40solana/codecs-numbers/src/i8.ts","../../../../node_modules/%40solana/codecs-data-structures/src/bytes.ts","../../../../node_modules/%40solana/rpc-types/src/unix-timestamp.ts","../../../../node_modules/%40solana/codecs-numbers/src/short-u16.ts","../../../../node_modules/%40solana/codecs-data-structures/src/constant.ts","../../../../node_modules/%40solana/codecs-numbers/src/u128.ts","../../../../node_modules/%40solana/codecs-data-structures/src/tuple.ts","../../../../node_modules/%40solana/codecs-numbers/src/u16.ts","../../../../node_modules/%40solana/codecs-numbers/src/u32.ts","../../../../node_modules/%40solana/codecs-data-structures/src/union.ts","../../../../node_modules/%40solana/codecs-numbers/src/u64.ts","../../../../node_modules/%40solana/codecs-numbers/src/u8.ts","../../../../node_modules/%40solana/codecs-data-structures/src/discriminated-union.ts","../../../../node_modules/%40solana/codecs-data-structures/src/enum-helpers.ts","../../../../node_modules/%40solana/codecs-data-structures/src/enum.ts","../../../../node_modules/%40solana/codecs-data-structures/src/hidden-prefix.ts","../../../../node_modules/%40solana/codecs-data-structures/src/hidden-suffix.ts","../../../../node_modules/%40solana/codecs-data-structures/src/literal-union.ts","../../../../node_modules/%40solana/codecs-data-structures/src/map.ts","../../../../node_modules/%40solana/codecs-data-structures/src/unit.ts","../../../../node_modules/%40solana/codecs-data-structures/src/nullable.ts","../../../../node_modules/%40solana/codecs-data-structures/src/set.ts","../../../../node_modules/%40solana/codecs-data-structures/src/struct.ts","../../../../node_modules/%40solana/functional/src/pipe.ts","../../../../node_modules/%40solana/transaction-messages/src/blockhash.ts","../../../../node_modules/%40solana/transaction-messages/src/codecs/address-table-lookup.ts","../../../../node_modules/%40solana/transaction-messages/src/codecs/header.ts","../../../../node_modules/%40solana/transaction-messages/src/codecs/instruction.ts","../../../../node_modules/%40solana/transaction-messages/src/transaction-message.ts","../../../../node_modules/%40solana/transaction-messages/src/codecs/transaction-version.ts","../../../../node_modules/%40solana/transaction-messages/src/codecs/message.ts","../../../../node_modules/%40solana/transaction-messages/src/compile/accounts.ts","../../../../node_modules/%40solana/transaction-messages/src/compile/address-table-lookups.ts","../../../../node_modules/%40solana/transaction-messages/src/compile/header.ts","../../../../node_modules/%40solana/transaction-messages/src/compile/instructions.ts","../../../../node_modules/%40solana/transaction-messages/src/compile/lifetime-token.ts","../../../../node_modules/%40solana/transaction-messages/src/compile/static-accounts.ts","../../../../node_modules/%40solana/transaction-messages/src/compile/message.ts","../../../../node_modules/%40solana/transaction-messages/src/compress-transaction-message.ts","../../../../node_modules/%40solana/transaction-messages/src/create-transaction-message.ts","../../../../node_modules/%40solana/transaction-messages/src/durable-nonce-instruction.ts","../../../../node_modules/%40solana/transaction-messages/src/durable-nonce.ts","../../../../node_modules/%40solana/transaction-messages/src/fee-payer.ts","../../../../node_modules/%40solana/transaction-messages/src/instructions.ts","../../../../node_modules/%40solana/transaction-messages/src/decompile-message.ts","../../../../node_modules/%40solana/transactions/src/codecs/signatures-encoder.ts","../../../../node_modules/%40solana/transactions/src/codecs/transaction-codec.ts","../../../../node_modules/%40solana/transactions/src/lifetime.ts","../../../../node_modules/%40solana/transactions/src/compile-transaction.ts","../../../../node_modules/%40solana/transactions/src/signatures.ts","../../../../node_modules/%40solana/transactions/src/wire-transaction.ts","../../../../node_modules/%40solana/transactions/src/transaction-size.ts","../../../../node_modules/%40solana/transactions/src/sendable-transaction.ts","../../../../node_modules/%40solana/transactions/src/transaction-message-size.ts","../../../../node_modules/%40solana/signers/src/deduplicate-signers.ts","../../../../node_modules/%40solana/signers/src/transaction-modifying-signer.ts","../../../../node_modules/%40solana/signers/src/transaction-partial-signer.ts","../../../../node_modules/%40solana/signers/src/transaction-sending-signer.ts","../../../../node_modules/%40solana/signers/src/transaction-signer.ts","../../../../node_modules/%40solana/signers/src/account-signer-meta.ts","../../../../node_modules/%40solana/signers/src/add-signers.ts","../../../../node_modules/%40solana/signers/src/fee-payer-signer.ts","../../../../node_modules/%40solana/signers/src/message-partial-signer.ts","../../../../node_modules/%40solana/signers/src/keypair-signer.ts","../../../../node_modules/%40solana/signers/src/message-modifying-signer.ts","../../../../node_modules/%40solana/signers/src/message-signer.ts","../../../../node_modules/%40solana/signers/src/noop-signer.ts","../../../../node_modules/%40solana/signers/src/transaction-with-single-sending-signer.ts","../../../../node_modules/%40solana/signers/src/sign-transaction.ts","../../../../node_modules/%40solana/signers/src/signable-message.ts","../../../../node_modules/%40solana/promises/src/race.ts","../../../../node_modules/%40solana/promises/src/abortable.ts","../../../../node_modules/%40solana/options/src/option.ts","../../../../node_modules/%40solana/options/src/unwrap-option.ts","../../../../node_modules/%40solana/options/src/option-codec.ts","../../../../node_modules/%40solana/options/src/unwrap-option-recursively.ts","../../../../node_modules/%40solana/programs/src/program-error.ts","../../../../node_modules/%40solana/accounts/src/account.ts","../../../../node_modules/%40solana/accounts/src/decode-account.ts","../../../../node_modules/%40solana/accounts/src/parse-account.ts","../../../../node_modules/%40solana/accounts/src/fetch-account.ts","../../../../node_modules/%40solana/accounts/src/maybe-account.ts","../../../../node_modules/%40solana-program/token/src/generated/accounts/mint.ts","../../../../node_modules/%40solana/instruction-plans/src/instruction-plan.ts","../../../../node_modules/%40solana-program/token/src/generated/accounts/multisig.ts","../../../../node_modules/%40solana/instruction-plans/src/transaction-plan-result.ts","../../../../node_modules/%40solana-program/token/src/generated/types/accountState.ts","../../../../node_modules/%40solana-program/token/src/generated/types/authorityType.ts","../../../../node_modules/%40solana/instruction-plans/src/transaction-plan-executor.ts","../../../../node_modules/%40solana-program/token/src/generated/accounts/token.ts","../../../../node_modules/%40solana/instruction-plans/src/transaction-plan.ts","../../../../node_modules/%40solana-program/token/src/generated/programs/associatedToken.ts","../../../../node_modules/%40solana/instruction-plans/src/transaction-planner.ts","../../../../node_modules/%40solana-program/token/src/generated/programs/token.ts","../../../../node_modules/%40solana-program/token/src/generated/errors/associatedToken.ts","../../../../node_modules/%40solana-program/token/src/generated/errors/token.ts","../../../../node_modules/%40solana-program/token/src/generated/shared/index.ts","../../../../node_modules/%40solana-program/token/src/generated/instructions/amountToUiAmount.ts","../../../../node_modules/%40solana-program/token/src/generated/instructions/approve.ts","../../../../node_modules/%40solana-program/token/src/generated/instructions/approveChecked.ts","../../../../node_modules/%40solana-program/token/src/generated/instructions/burn.ts","../../../../node_modules/%40solana-program/token/src/generated/instructions/burnChecked.ts","../../../../node_modules/%40solana-program/token/src/generated/instructions/closeAccount.ts","../../../../node_modules/%40solana-program/token/src/generated/pdas/associatedToken.ts","../../../../node_modules/%40solana-program/token/src/generated/instructions/createAssociatedToken.ts","../../../../node_modules/%40solana-program/token/src/generated/instructions/createAssociatedTokenIdempotent.ts","../../../../node_modules/%40solana-program/token/src/generated/instructions/freezeAccount.ts","../../../../node_modules/%40solana-program/token/src/generated/instructions/getAccountDataSize.ts","../../../../node_modules/%40solana-program/token/src/generated/instructions/initializeAccount.ts","../../../../node_modules/%40solana-program/token/src/generated/instructions/initializeAccount2.ts","../../../../node_modules/%40solana-program/token/src/generated/instructions/initializeAccount3.ts","../../../../node_modules/%40solana-program/token/src/generated/instructions/initializeImmutableOwner.ts","../../../../node_modules/%40solana-program/token/src/generated/instructions/initializeMint.ts","../../../../node_modules/%40solana-program/token/src/generated/instructions/initializeMint2.ts","../../../../node_modules/%40solana-program/token/src/generated/instructions/initializeMultisig.ts","../../../../node_modules/%40solana-program/token/src/generated/instructions/initializeMultisig2.ts","../../../../node_modules/%40solana-program/token/src/generated/instructions/mintTo.ts","../../../../node_modules/%40solana-program/token/src/generated/instructions/mintToChecked.ts","../../../../node_modules/%40solana-program/token/src/generated/instructions/recoverNestedAssociatedToken.ts","../../../../node_modules/%40solana-program/token/src/generated/instructions/revoke.ts","../../../../node_modules/%40solana-program/token/src/generated/instructions/setAuthority.ts","../../../../node_modules/%40solana-program/token/src/generated/instructions/syncNative.ts","../../../../node_modules/%40solana-program/token/src/generated/instructions/thawAccount.ts","../../../../node_modules/%40solana-program/token/src/generated/instructions/transfer.ts","../../../../node_modules/%40solana-program/token/src/generated/instructions/transferChecked.ts","../../../../node_modules/%40solana-program/token/src/generated/instructions/uiAmountToAmount.ts","../../../../node_modules/%40solana-program/token/node_modules/.pnpm/%40solana-program%2Bsystem%400.9.0_%40solana%2Bkit%405.0.0_fastestsmallesttextencoderdecoder%401.0.22_typescript%405.5.3_ws%408.17.0_/node_modules/%40solana-program/system/src/generated/programs/system.ts","../../../../node_modules/%40solana-program/token/node_modules/.pnpm/%40solana-program%2Bsystem%400.9.0_%40solana%2Bkit%405.0.0_fastestsmallesttextencoderdecoder%401.0.22_typescript%405.5.3_ws%408.17.0_/node_modules/%40solana-program/system/src/generated/errors/system.ts","../../../../node_modules/%40solana-program/token/node_modules/.pnpm/%40solana-program%2Bsystem%400.9.0_%40solana%2Bkit%405.0.0_fastestsmallesttextencoderdecoder%401.0.22_typescript%405.5.3_ws%408.17.0_/node_modules/%40solana-program/system/src/generated/shared/index.ts","../../../../node_modules/%40solana-program/token/node_modules/.pnpm/%40solana-program%2Bsystem%400.9.0_%40solana%2Bkit%405.0.0_fastestsmallesttextencoderdecoder%401.0.22_typescript%405.5.3_ws%408.17.0_/node_modules/%40solana-program/system/src/generated/instructions/createAccount.ts","../../../../node_modules/%40solana-program/token/src/createMint.ts","../../../../node_modules/%40solana-program/token/src/mintToATA.ts","../../../../node_modules/%40solana-program/token/src/transferToATA.ts","../../../../node_modules/%40privy-io/react-auth/dist/esm/use-sign-with-user-signer-J1po7l19.mjs"],"sourcesContent":["const p={path:\"/api/v1/apps/:app_id/smart_wallets\",method:\"GET\"},a={path:\"/api/v1/apps/:app_id/smart_wallets\",method:\"POST\"};export{p as GetSmartWalletConfig,a as PostSmartWalletConfig};\n","import{GetSmartWalletConfig as t}from\"@privy-io/routes\";class r{getConfig(){return this._privyInternal.config}async getSmartWalletConfig(){return this._smartWalletConfig||(this._smartWalletConfig=await this._privyInternal.fetch(t,{params:{app_id:this.appId}})),this._smartWalletConfig}get appId(){return this._privyInternal.appId}constructor(t){this._privyInternal=t}}export{r as default};\n","const p={path:\"/api/v1/apps/:app_id/cross-app/connections\",method:\"GET\"};export{p as GetCrossAppConnections};\n","import { Buffer } from 'buffer';\nimport { decoder } from '../lib/buffer_utils.js';\nlet encode;\nfunction normalize(input) {\n    let encoded = input;\n    if (encoded instanceof Uint8Array) {\n        encoded = decoder.decode(encoded);\n    }\n    return encoded;\n}\nif (Buffer.isEncoding('base64url')) {\n    encode = (input) => Buffer.from(input).toString('base64url');\n}\nelse {\n    encode = (input) => Buffer.from(input).toString('base64').replace(/=/g, '').replace(/\\+/g, '-').replace(/\\//g, '_');\n}\nexport const decodeBase64 = (input) => Buffer.from(input, 'base64');\nexport const encodeBase64 = (input) => Buffer.from(input).toString('base64');\nexport { encode };\nexport const decode = (input) => Buffer.from(normalize(input), 'base64');\n","import { createHash } from 'crypto';\nconst digest = (algorithm, data) => createHash(algorithm).update(data).digest();\nexport default digest;\n","import digest from '../runtime/digest.js';\nexport const encoder = new TextEncoder();\nexport const decoder = new TextDecoder();\nconst MAX_INT32 = 2 ** 32;\nexport function concat(...buffers) {\n    const size = buffers.reduce((acc, { length }) => acc + length, 0);\n    const buf = new Uint8Array(size);\n    let i = 0;\n    buffers.forEach((buffer) => {\n        buf.set(buffer, i);\n        i += buffer.length;\n    });\n    return buf;\n}\nexport function p2s(alg, p2sInput) {\n    return concat(encoder.encode(alg), new Uint8Array([0]), p2sInput);\n}\nfunction writeUInt32BE(buf, value, offset) {\n    if (value < 0 || value >= MAX_INT32) {\n        throw new RangeError(`value must be >= 0 and <= ${MAX_INT32 - 1}. Received ${value}`);\n    }\n    buf.set([value >>> 24, value >>> 16, value >>> 8, value & 0xff], offset);\n}\nexport function uint64be(value) {\n    const high = Math.floor(value / MAX_INT32);\n    const low = value % MAX_INT32;\n    const buf = new Uint8Array(8);\n    writeUInt32BE(buf, high, 0);\n    writeUInt32BE(buf, low, 4);\n    return buf;\n}\nexport function uint32be(value) {\n    const buf = new Uint8Array(4);\n    writeUInt32BE(buf, value);\n    return buf;\n}\nexport function lengthAndInput(input) {\n    return concat(uint32be(input.length), input);\n}\nexport async function concatKdf(secret, bits, value) {\n    const iterations = Math.ceil((bits >> 3) / 32);\n    const res = new Uint8Array(iterations * 32);\n    for (let iter = 0; iter < iterations; iter++) {\n        const buf = new Uint8Array(4 + secret.length + value.length);\n        buf.set(uint32be(iter + 1));\n        buf.set(secret, 4);\n        buf.set(value, 4 + secret.length);\n        res.set(await digest('sha256', buf), iter * 32);\n    }\n    return res.slice(0, bits >> 3);\n}\n","import * as base64url from '../runtime/base64url.js';\nexport const encode = base64url.encode;\nexport const decode = base64url.decode;\n","function isObjectLike(value) {\n    return typeof value === 'object' && value !== null;\n}\nexport default function isObject(input) {\n    if (!isObjectLike(input) || Object.prototype.toString.call(input) !== '[object Object]') {\n        return false;\n    }\n    if (Object.getPrototypeOf(input) === null) {\n        return true;\n    }\n    let proto = input;\n    while (Object.getPrototypeOf(proto) !== null) {\n        proto = Object.getPrototypeOf(proto);\n    }\n    return Object.getPrototypeOf(input) === proto;\n}\n","export class JOSEError extends Error {\n    static get code() {\n        return 'ERR_JOSE_GENERIC';\n    }\n    constructor(message) {\n        var _a;\n        super(message);\n        this.code = 'ERR_JOSE_GENERIC';\n        this.name = this.constructor.name;\n        (_a = Error.captureStackTrace) === null || _a === void 0 ? void 0 : _a.call(Error, this, this.constructor);\n    }\n}\nexport class JWTClaimValidationFailed extends JOSEError {\n    static get code() {\n        return 'ERR_JWT_CLAIM_VALIDATION_FAILED';\n    }\n    constructor(message, claim = 'unspecified', reason = 'unspecified') {\n        super(message);\n        this.code = 'ERR_JWT_CLAIM_VALIDATION_FAILED';\n        this.claim = claim;\n        this.reason = reason;\n    }\n}\nexport class JWTExpired extends JOSEError {\n    static get code() {\n        return 'ERR_JWT_EXPIRED';\n    }\n    constructor(message, claim = 'unspecified', reason = 'unspecified') {\n        super(message);\n        this.code = 'ERR_JWT_EXPIRED';\n        this.claim = claim;\n        this.reason = reason;\n    }\n}\nexport class JOSEAlgNotAllowed extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JOSE_ALG_NOT_ALLOWED';\n    }\n    static get code() {\n        return 'ERR_JOSE_ALG_NOT_ALLOWED';\n    }\n}\nexport class JOSENotSupported extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JOSE_NOT_SUPPORTED';\n    }\n    static get code() {\n        return 'ERR_JOSE_NOT_SUPPORTED';\n    }\n}\nexport class JWEDecryptionFailed extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWE_DECRYPTION_FAILED';\n        this.message = 'decryption operation failed';\n    }\n    static get code() {\n        return 'ERR_JWE_DECRYPTION_FAILED';\n    }\n}\nexport class JWEDecompressionFailed extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWE_DECOMPRESSION_FAILED';\n        this.message = 'decompression operation failed';\n    }\n    static get code() {\n        return 'ERR_JWE_DECOMPRESSION_FAILED';\n    }\n}\nexport class JWEInvalid extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWE_INVALID';\n    }\n    static get code() {\n        return 'ERR_JWE_INVALID';\n    }\n}\nexport class JWSInvalid extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWS_INVALID';\n    }\n    static get code() {\n        return 'ERR_JWS_INVALID';\n    }\n}\nexport class JWTInvalid extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWT_INVALID';\n    }\n    static get code() {\n        return 'ERR_JWT_INVALID';\n    }\n}\nexport class JWKInvalid extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWK_INVALID';\n    }\n    static get code() {\n        return 'ERR_JWK_INVALID';\n    }\n}\nexport class JWKSInvalid extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWKS_INVALID';\n    }\n    static get code() {\n        return 'ERR_JWKS_INVALID';\n    }\n}\nexport class JWKSNoMatchingKey extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWKS_NO_MATCHING_KEY';\n        this.message = 'no applicable key found in the JSON Web Key Set';\n    }\n    static get code() {\n        return 'ERR_JWKS_NO_MATCHING_KEY';\n    }\n}\nexport class JWKSMultipleMatchingKeys extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWKS_MULTIPLE_MATCHING_KEYS';\n        this.message = 'multiple matching keys found in the JSON Web Key Set';\n    }\n    static get code() {\n        return 'ERR_JWKS_MULTIPLE_MATCHING_KEYS';\n    }\n}\nSymbol.asyncIterator;\nexport class JWKSTimeout extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWKS_TIMEOUT';\n        this.message = 'request timed out';\n    }\n    static get code() {\n        return 'ERR_JWKS_TIMEOUT';\n    }\n}\nexport class JWSSignatureVerificationFailed extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWS_SIGNATURE_VERIFICATION_FAILED';\n        this.message = 'signature verification failed';\n    }\n    static get code() {\n        return 'ERR_JWS_SIGNATURE_VERIFICATION_FAILED';\n    }\n}\n","import { decode as base64url } from './base64url.js';\nimport { decoder } from '../lib/buffer_utils.js';\nimport isObject from '../lib/is_object.js';\nimport { JWTInvalid } from './errors.js';\nexport function decodeJwt(jwt) {\n    if (typeof jwt !== 'string')\n        throw new JWTInvalid('JWTs must use Compact JWS serialization, JWT must be a string');\n    const { 1: payload, length } = jwt.split('.');\n    if (length === 5)\n        throw new JWTInvalid('Only JWTs using Compact JWS serialization can be decoded');\n    if (length !== 3)\n        throw new JWTInvalid('Invalid JWT');\n    if (!payload)\n        throw new JWTInvalid('JWTs must contain a payload');\n    let decoded;\n    try {\n        decoded = base64url(payload);\n    }\n    catch {\n        throw new JWTInvalid('Failed to base64url decode the payload');\n    }\n    let result;\n    try {\n        result = JSON.parse(decoder.decode(decoded));\n    }\n    catch {\n        throw new JWTInvalid('Failed to parse the decoded payload as JSON');\n    }\n    if (!isObject(result))\n        throw new JWTInvalid('Invalid JWT Claims Set');\n    return result;\n}\n","import*as e from\"jose\";class t{static parse(e){try{return new t(e)}catch(e){return null}}get subject(){return this._decoded.sub}get expiration(){return this._decoded.exp}get issuer(){return this._decoded.iss}get audience(){return this._decoded.aud}isExpired(e=0){return Date.now()>=1e3*(this.expiration-e)}constructor(t){this.value=t,this._decoded=e.decodeJwt(t)}}export{t as Token};\n","import{GetCrossAppConnections as r}from\"@privy-io/routes\";import{Token as e}from\"../Token.mjs\";import\"jose\";class t{async updateOnCrossAppAuthentication(r,e){let s=e.access_token,o=t.providerAccessTokenStorageKey(r);await this._storage.put(o,s)}async getProviderAccessToken(r){let s=t.providerAccessTokenStorageKey(r),o=await this._storage.get(s);if(\"string\"!=typeof o)return null;try{if(new e(o).isExpired())throw Error(\"JWT is expired\");return o}catch{return await this._storage.del(s),null}}async getCrossAppConnections(){return await this._privyInternal.fetch(r,{params:{app_id:this._privyInternal.appId}})}constructor(r,e){this._privyInternal=r,this._storage=e}}t.providerAccessTokenStorageKey=r=>`privy:cross-app:${r}`;export{t as default};\n","import{WalletsRevoke as r}from\"@privy-io/routes\";class t{async revoke(){await this._privyInternal.fetch(r,{})}constructor(r){this._privyInternal=r}}export{t as default};\n","class r extends Error{constructor({error:r,code:e}){super(r),this.error=r,this.code=e}}class e extends Error{constructor({error:r,code:e}){super(r),this.code=e,this.error=r}}class o extends Error{constructor({error:r,code:e,response:o}){super(r),this.code=e,this.error=r,this.response=o}}const s=o=>s=>o[s instanceof r||s instanceof e?s.code:\"unknown_error\"]??o.default;function c(r){return r&&\"object\"==typeof r&&\"code\"in r&&\"mfa_canceled\"===r.code}export{o as MoonpayApiError,r as PrivyApiError,e as PrivyClientError,s as createErrorFormatter,c as errorIndicatesMfaCanceled};\n","const e=e=>!!e.id&&\"privy-v2\"===e.recovery_method;export{e as isUnifiedWallet};\n","import{PrivyClientError as e}from\"../Error.mjs\";import{isUnifiedWallet as t}from\"../wallet-api/unified-wallet.mjs\";class r{async sign({message:e}){return await this.request({method:\"sign\",params:{message:new TextDecoder(\"utf8\").decode(e)}})}async signTransaction({psbt:e}){return await this.request({method:\"signTransaction\",params:{psbt:e}})}async request(r){if(t(this._account))throw new e({code:\"unsupported_wallet_type\",error:\"Bitcoin wallet providers are only supported for on-device execution and this app uses TEE execution. Use the useSignRawHash hook from @privy-io/expo/extended-chains to sign over a hash with this wallet. Learn more at https://docs.privy.io/recipes/tee-wallet-migration-guide\"});if(!await this._privyInternal.getAccessTokenInternal())throw new e({error:\"Missing access token\",code:\"attempted_rpc_call_before_logged_in\"});return this.handleIFrameRpc(r)}async handleIFrameRpc(t){try{let e=await this._privyInternal.getAccessTokenInternal();if(!e)throw Error(\"Missing access token. User must be authenticated.\");return this._privyInternal.createAnalyticsEvent(\"embedded_wallet_sdk_rpc_started\",{method:t.method,address:this._account.address}),(await this._proxy.rpcWallet({accessToken:e,request:t,entropyId:this._entropyId,entropyIdVerifier:this._entropyIdVerifier,hdWalletIndex:this._account.wallet_index,chainType:this._account.chain_type})).response.data}catch(r){console.error(r);let s=r instanceof Error?r.message:\"Unable to make wallet request\";throw this._privyInternal.createAnalyticsEvent(\"embedded_wallet_sdk_rpc_failed\",{method:t.method,address:this._account.address,error:s}),new e({code:\"embedded_wallet_request_error\",error:s})}}toJSON(){return`PrivyEmbeddedBitcoinProvider { address: '${this._account.address}', request: [Function] }`}constructor({proxy:e,privyInternal:t,account:r,entropyId:s,entropyIdVerifier:a}){this._proxy=e,this._privyInternal=t,this._account=r,this._entropyId=s,this._entropyIdVerifier=a}}export{r as EmbeddedBitcoinWalletProvider};\n","import{create as t}from\"../../wallet-api/create.mjs\";import\"@privy-io/routes\";async function e({context:e,chainType:i}){return{wallet:await t(e,{request:{chain_type:i,owner_id:void 0}})}}export{e as walletCreate};\n","import{createPublicClient as r,http as e}from\"viem\";import{PrivyConnectorError as t}from\"../errors.mjs\";import\"../types.mjs\";const p=(p,i,c,s)=>{let l=Number(p),n=i.find((r=>r.id===l));if(!n)throw new t(`Unsupported chainId ${p}`,4901);return r({transport:e(o(n,c,s.appId)),chain:n})},o=(r,e,p)=>{let o,i=r.id,c=Number(r.id);if(r.rpcUrls.privyWalletOverride&&r.rpcUrls.privyWalletOverride.http[0])o=r.rpcUrls.privyWalletOverride.http[0];else if(e.rpcUrls&&e.rpcUrls[c])o=e.rpcUrls[c];else if(r.rpcUrls.privy?.http[0]){let e=new URL(r.rpcUrls.privy.http[0]);e.searchParams.append(\"privyAppId\",p),o=e.toString()}else o=r.rpcUrls.public?.http[0]?r.rpcUrls.public.http[0]:r.rpcUrls.default?.http[0];if(!o)throw new t(`No RPC url found for ${i}`);return o};function i({currentRecoveryMethod:r,upgradeToRecoveryMethod:e}){switch(r){case\"privy\":case\"user-passcode\":case\"recovery-encryption-key\":return!0;case\"icloud\":case\"google-drive\":if(r===e)throw Error(\"Cannot upgrade to the existing cloud platform\");return!0;default:throw Error(\"Unknown recovery method\")}}export{o as getJsonRpcEndpointFromChain,p as getPublicClient,i as throwIfInvalidRecoveryUpgradePath};\n","'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n","/* jshint esversion: 6 */\n/* jslint node: true */\n'use strict';\n\nmodule.exports = function serialize (object) {\n  if (typeof object === 'number' && isNaN(object)) {\n    throw new Error('NaN is not allowed');\n  }\n\n  if (typeof object === 'number' && !isFinite(object)) {\n    throw new Error('Infinity is not allowed');\n  }\n\n  if (object === null || typeof object !== 'object') {\n    return JSON.stringify(object);\n  }\n\n  if (object.toJSON instanceof Function) {\n    return serialize(object.toJSON());\n  }\n\n  if (Array.isArray(object)) {\n    const values = object.reduce((t, cv, ci) => {\n      const comma = ci === 0 ? '' : ',';\n      const value = cv === undefined || typeof cv === 'symbol' ? null : cv;\n      return `${t}${comma}${serialize(value)}`;\n    }, '');\n    return `[${values}]`;\n  }\n\n  const values = Object.keys(object).sort().reduce((t, cv) => {\n    if (object[cv] === undefined ||\n        typeof object[cv] === 'symbol') {\n      return t;\n    }\n    const comma = t.length === 0 ? '' : ',';\n    return `${t}${comma}${serialize(cv)}:${serialize(object[cv])}`;\n  }, '');\n  return `{${values}}`;\n};\n","'use strict';\n\nmodule.exports = function (fetch, defaults) {\n  defaults = defaults || {};\n  if (typeof fetch !== 'function') {\n    throw new ArgumentError('fetch must be a function');\n  }\n\n  if (typeof defaults !== 'object') {\n    throw new ArgumentError('defaults must be an object');\n  }\n\n  if (defaults.retries !== undefined && !isPositiveInteger(defaults.retries)) {\n    throw new ArgumentError('retries must be a positive integer');\n  }\n\n  if (defaults.retryDelay !== undefined && !isPositiveInteger(defaults.retryDelay) && typeof defaults.retryDelay !== 'function') {\n    throw new ArgumentError('retryDelay must be a positive integer or a function returning a positive integer');\n  }\n\n  if (defaults.retryOn !== undefined && !Array.isArray(defaults.retryOn) && typeof defaults.retryOn !== 'function') {\n    throw new ArgumentError('retryOn property expects an array or function');\n  }\n\n  var baseDefaults = {\n    retries: 3,\n    retryDelay: 1000,\n    retryOn: [],\n  };\n\n  defaults = Object.assign(baseDefaults, defaults);\n\n  return function fetchRetry(input, init) {\n    var retries = defaults.retries;\n    var retryDelay = defaults.retryDelay;\n    var retryOn = defaults.retryOn;\n\n    if (init && init.retries !== undefined) {\n      if (isPositiveInteger(init.retries)) {\n        retries = init.retries;\n      } else {\n        throw new ArgumentError('retries must be a positive integer');\n      }\n    }\n\n    if (init && init.retryDelay !== undefined) {\n      if (isPositiveInteger(init.retryDelay) || (typeof init.retryDelay === 'function')) {\n        retryDelay = init.retryDelay;\n      } else {\n        throw new ArgumentError('retryDelay must be a positive integer or a function returning a positive integer');\n      }\n    }\n\n    if (init && init.retryOn) {\n      if (Array.isArray(init.retryOn) || (typeof init.retryOn === 'function')) {\n        retryOn = init.retryOn;\n      } else {\n        throw new ArgumentError('retryOn property expects an array or function');\n      }\n    }\n\n    // eslint-disable-next-line no-undef\n    return new Promise(function (resolve, reject) {\n      var wrappedFetch = function (attempt) {\n        // As of node 18, this is no longer needed since node comes with native support for fetch:\n        /* istanbul ignore next */\n        var _input =\n          typeof Request !== 'undefined' && input instanceof Request\n            ? input.clone()\n            : input;\n        fetch(_input, init)\n          .then(function (response) {\n            if (Array.isArray(retryOn) && retryOn.indexOf(response.status) === -1) {\n              resolve(response);\n            } else if (typeof retryOn === 'function') {\n              try {\n                // eslint-disable-next-line no-undef\n                return Promise.resolve(retryOn(attempt, null, response))\n                  .then(function (retryOnResponse) {\n                    if(retryOnResponse) {\n                      retry(attempt, null, response);\n                    } else {\n                      resolve(response);\n                    }\n                  }).catch(reject);\n              } catch (error) {\n                reject(error);\n              }\n            } else {\n              if (attempt < retries) {\n                retry(attempt, null, response);\n              } else {\n                resolve(response);\n              }\n            }\n          })\n          .catch(function (error) {\n            if (typeof retryOn === 'function') {\n              try {\n                // eslint-disable-next-line no-undef\n                Promise.resolve(retryOn(attempt, error, null))\n                  .then(function (retryOnResponse) {\n                    if(retryOnResponse) {\n                      retry(attempt, error, null);\n                    } else {\n                      reject(error);\n                    }\n                  })\n                  .catch(function(error) {\n                    reject(error);\n                  });\n              } catch(error) {\n                reject(error);\n              }\n            } else if (attempt < retries) {\n              retry(attempt, error, null);\n            } else {\n              reject(error);\n            }\n          });\n      };\n\n      function retry(attempt, error, response) {\n        var delay = (typeof retryDelay === 'function') ?\n          retryDelay(attempt, error, response) : retryDelay;\n        setTimeout(function () {\n          wrappedFetch(++attempt);\n        }, delay);\n      }\n\n      wrappedFetch(0);\n    });\n  };\n};\n\nfunction isPositiveInteger(value) {\n  return Number.isInteger(value) && value >= 0;\n}\n\nfunction ArgumentError(message) {\n  this.name = 'ArgumentError';\n  this.message = message;\n}\n","import e from\"./AppApi.mjs\";import t from\"./CrossAppApi.mjs\";import i from\"./DelegatedWalletsApi.mjs\";import r from\"./EmbeddedWalletApi.mjs\";import s from\"./MfaPromises.mjs\";import{PrivyInternal as m}from\"./PrivyInternal.mjs\";import o from\"./UserApi.mjs\";import a from\"./auth/AuthApi.mjs\";import p from\"./funding/FundingApi.mjs\";import n from\"./mfa/MfaApi.mjs\";import l from\"./recovery/RecoveryApi.mjs\";import\"@privy-io/routes\";import\"../Token.mjs\";import\"jose\";import\"@privy-io/chains\";import\"../Error.mjs\";import\"../embedded/EmbeddedBitcoinWalletProvider.mjs\";import\"../wallet-api/unified-wallet.mjs\";import\"../embedded/errors.mjs\";import\"../embedded/types.mjs\";import\"../embedded/stack/walletCreate.mjs\";import\"../wallet-api/create.mjs\";import\"../embedded/utils/index.mjs\";import\"viem\";import\"../embedded/EmbeddedWalletProxy.mjs\";import\"../utils/sleep.mjs\";import\"../embedded/EventCallbackQueue.mjs\";import\"../embedded/withMfa.mjs\";import\"../embedded/EmbeddedWalletProvider.mjs\";import\"eventemitter3\";import\"@privy-io/ethereum\";import\"../embedded/stack/walletRpc.mjs\";import\"../utils/encodings.mjs\";import\"../wallet-api/rpc.mjs\";import\"../wallet-api/generate-authorization-signature.mjs\";import\"canonicalize\";import\"../embedded/stack/wallet-api-eth-transaction.mjs\";import\"../embedded/stack/wallet-api-eth-typed-data.mjs\";import\"../embedded/EmbeddedSolanaWalletProvider.mjs\";import\"../solana/getWalletPublicKeyFromTransaction.mjs\";import\"../solana/isVersionedTransaction.mjs\";import\"fetch-retry\";import\"uuid\";import\"@privy-io/api-base\";import\"../Session.mjs\";import\"js-cookie\";import\"../utils/allSettled.mjs\";import\"../toAbortSignalTimeout.mjs\";import\"../utils/toSearchParams.mjs\";import\"./logger.mjs\";import\"../utils/noop.mjs\";import\"./auth/CustomProviderApi.mjs\";import\"./auth/maybeCreateWalletOnLogin.mjs\";import\"../utils/getUserEmbeddedEthereumWallet.mjs\";import\"../utils/getAllUserEmbeddedEthereumWallets.mjs\";import\"../utils/embedded-wallets.mjs\";import\"../utils/getUserEmbeddedSolanaWallet.mjs\";import\"../utils/getAllUserEmbeddedSolanaWallets.mjs\";import\"../utils/shouldCreateEmbeddedEthWallet.mjs\";import\"../utils/shouldCreateEmbeddedSolWallet.mjs\";import\"./auth/EmailApi.mjs\";import\"./auth/FarcasterApi.mjs\";import\"./auth/FarcasterV2Api.mjs\";import\"./auth/GuestApi.mjs\";import\"./auth/OAuthApi.mjs\";import\"../pkce.mjs\";import\"./auth/PasskeyApi.mjs\";import\"./auth/PhoneApi.mjs\";import\"./auth/SiweApi.mjs\";import\"./auth/SiwsApi.mjs\";import\"./auth/SmartWalletApi.mjs\";import\"./funding/CoinbaseOnRampApi.mjs\";import\"./funding/MoonpayOnRampApi.mjs\";import\"../funding/moonpay.mjs\";import\"./mfa/MfaPasskeyApi.mjs\";import\"./mfa/MfaSmsApi.mjs\";import\"./recovery/RecoveryICloudApi.mjs\";import\"./recovery/RecoveryOAuthApi.mjs\";class d{async initialize(){await this._privyInternal._initialize()}setMessagePoster(e){this.embeddedWallet.setMessagePoster(e)}addOAuthTokensListener(e){return this._privyInternal.session.on(\"oauth_tokens_granted\",e),{unsubscribe:()=>{this._privyInternal.session.removeListener(\"oauth_tokens_granted\",e)}}}setCallbacks(e){this._privyInternal.setCallbacks(e)}getAccessToken(){return this._privyInternal.getAccessToken()}getIdentityToken(){return this._privyInternal.getIdentityToken()}getCompiledPath(e,t){return this._privyInternal.getPath(e,t)}async fetchPrivyRoute(e,t){return this._privyInternal.fetch(e,t)}get logger(){return this._privyInternal.logger}constructor({clientId:d,...h}){this._privyInternal=new m({...h,appClientId:d}),this.mfa=new n(this._privyInternal),this.mfaPromises=new s,this.app=new e(this._privyInternal),this.embeddedWallet=new r(this._privyInternal,h.embeddedWalletMessagePoster,h.supportedChains,this.mfa,this.mfaPromises,this.app),this.user=new o(this._privyInternal),this.auth=new a(this._privyInternal,this.embeddedWallet,h.storage,h.crypto,this.mfa),this.recovery=new l(this._privyInternal,h.storage,h.crypto),this.funding=new p(this._privyInternal),this.delegated=new i(this._privyInternal),this.crossApp=new t(this._privyInternal,h.storage)}}export{d as default};\n","import{DEFAULT_SUPPORTED_CHAINS as e,dedupeSupportedChains as r}from\"@privy-io/chains\";import{PrivyClientError as t}from\"../Error.mjs\";import{EmbeddedBitcoinWalletProvider as o}from\"../embedded/EmbeddedBitcoinWalletProvider.mjs\";import{errorIndicatesRecoveryIsNeeded as i}from\"../embedded/errors.mjs\";import{walletCreate as d}from\"../embedded/stack/walletCreate.mjs\";import{throwIfInvalidRecoveryUpgradePath as a}from\"../embedded/utils/index.mjs\";import{isUnifiedWallet as s}from\"../wallet-api/unified-wallet.mjs\";import{EmbeddedWalletProxy as n}from\"../embedded/EmbeddedWalletProxy.mjs\";import{EmbeddedWalletProvider as c}from\"../embedded/EmbeddedWalletProvider.mjs\";import{EmbeddedSolanaWalletProvider as l}from\"../embedded/EmbeddedSolanaWalletProvider.mjs\";import\"../embedded/types.mjs\";import\"../wallet-api/create.mjs\";import\"@privy-io/routes\";import\"viem\";import\"../utils/sleep.mjs\";import\"../embedded/EventCallbackQueue.mjs\";import\"../embedded/withMfa.mjs\";import\"eventemitter3\";import\"@privy-io/ethereum\";import\"../embedded/stack/walletRpc.mjs\";import\"../utils/encodings.mjs\";import\"../wallet-api/rpc.mjs\";import\"../wallet-api/generate-authorization-signature.mjs\";import\"canonicalize\";import\"../embedded/stack/wallet-api-eth-transaction.mjs\";import\"../embedded/stack/wallet-api-eth-typed-data.mjs\";import\"../solana/getWalletPublicKeyFromTransaction.mjs\";import\"../solana/isVersionedTransaction.mjs\";class y{setMessagePoster(e){this._proxy=new n(e,this._mfaPromises),this._mfa.setProxy(this._proxy)}async signWithUserSigner(e){if(!this._proxy)throw Error(\"Embedded wallet proxy not initialized\");let r=await this._privyInternal.getAccessTokenInternal();if(!r)throw new t({error:\"User must be logged in to sign a message with the user signer\",code:\"user_signer_sign_error\"});let{signature:o}=await this._proxy.signWithUserSigner({accessToken:r,message:e.message});return{signature:o}}async add(e){if(!this._proxy)throw Error(\"Embedded wallet proxy not initialized\");if(\"user-controlled-server-wallets-only\"===this._privyInternal.config?.embedded_wallet_config.mode)await d({context:{app:this._appApi,fetchPrivyRoute:(...e)=>this._privyInternal.fetch(...e),getCompiledPath:(...e)=>this._privyInternal.getPath(...e)},chainType:e.chainType});else{let r=await this._privyInternal.getAccessTokenInternal();if(!r)throw new t({error:\"User must be logged in to create an embedded wallet\",code:\"embedded_wallet_creation_error\"});await this._proxy.addWallet({accessToken:r,...e})}let{user:r}=await this._privyInternal.refreshSession();return{user:r}}async getBitcoinProvider({wallet:e,entropyId:r,entropyIdVerifier:t,recoveryPassword:i,recoveryAccessToken:d,recoverySecretOverride:a}){if(!this._proxy)throw Error(\"Embedded wallet proxy not initialized\");if(!await this._privyInternal.getAccessTokenInternal())throw Error(\"User must be logged in to create an embedded wallet\");return s(e)||await this._load({entropyId:r,entropyIdVerifier:t,wallet:e,recoveryPassword:i,recoveryAccessToken:d,recoverySecretOverride:a}),new o({account:e,privyInternal:this._privyInternal,proxy:this._proxy,entropyId:r,entropyIdVerifier:t})}async create({password:e,recoveryMethod:r,recoveryToken:o,recoveryKey:i,recoverySecretOverride:a,iCloudRecordNameOverride:s,solanaAccount:n,skipCallbacks:c}){if(!this._proxy)throw Error(\"Embedded wallet proxy not initialized\");if(\"user-controlled-server-wallets-only\"===this._privyInternal.config?.embedded_wallet_config.mode){if(r&&!r.startsWith(\"privy\"))throw new t({error:\"User-controlled server wallets do not support custom recovery methods\",code:\"embedded_wallet_creation_error\"});await d({context:{app:this._appApi,fetchPrivyRoute:(...e)=>this._privyInternal.fetch(...e),getCompiledPath:(...e)=>this._privyInternal.getPath(...e)},chainType:\"ethereum\"})}else{let t;if(t=r||(e?\"user-passcode\":\"privy\"),e&&\"string\"!=typeof e)throw Error(\"Invalid recovery password, must be a string\");if(\"privy\"===t&&this._privyInternal.config?.embedded_wallet_config.require_user_password_on_create)throw Error(\"Password not provided yet is required by App configuration\");let d=await this._privyInternal.getAccessTokenInternal();if(!d)throw Error(\"User must be logged in to create an embedded wallet\");let{address:c}=await this._proxy.create({accessToken:d,recoveryMethod:t,recoveryKey:i,recoveryPassword:e,recoveryAccessToken:o,recoverySecretOverride:a,iCloudRecordNameOverride:s,solanaAddress:n?.address});if(!c)throw Error(\"Failed to create wallet\")}return await this._privyInternal.refreshSession(c)}async createSolana(e){if(!this._proxy)throw new t({error:\"Embedded wallet proxy not initialized\",code:\"embedded_wallet_creation_error\"});if(\"user-controlled-server-wallets-only\"===this._privyInternal.config?.embedded_wallet_config.mode)await d({context:{app:this._appApi,fetchPrivyRoute:(...e)=>this._privyInternal.fetch(...e),getCompiledPath:(...e)=>this._privyInternal.getPath(...e)},chainType:\"solana\"});else{let r=await this._privyInternal.getAccessTokenInternal();if(!r)throw new t({error:\"User must be logged in to create an embedded wallet\",code:\"embedded_wallet_creation_error\"});e?.ethereumAccount&&await this.getProvider(e.ethereumAccount);let{publicKey:o}=await this._proxy.createSolana({accessToken:r,ethereumAddress:e?.ethereumAccount?.address});if(!o)throw new t({error:\"Failed to create wallet\",code:\"embedded_wallet_creation_error\"})}return await this._privyInternal.refreshSession()}async delegateWallets({delegatedWallets:e,rootWallet:r}){if(!this._proxy)throw new t({error:\"Embedded wallet proxy not initialized\",code:\"embedded_wallet_creation_error\"});let o=await this._privyInternal.getAccessTokenInternal();if(!o)throw new t({error:\"User must be logged in to create an embedded wallet\",code:\"embedded_wallet_creation_error\"});await this._proxy.delegateWallets({accessToken:o,delegatedWallets:e,rootWallet:r})}async getProvider(e,r,t,o,i){if(!this._proxy)throw Error(\"Embedded wallet proxy not initialized\");return s(e)||await this._load({wallet:e,entropyId:e.address,entropyIdVerifier:\"ethereum-address-verifier\",recoveryPassword:r,recoveryKey:i,recoveryAccessToken:t,recoverySecretOverride:o}),new c({account:e,entropyId:e.address,entropyIdVerifier:\"ethereum-address-verifier\",privyInternal:this._privyInternal,chains:this._chains,walletProxy:this._proxy,appApi:this._appApi})}async getEthereumProvider({wallet:e,entropyId:r,entropyIdVerifier:t,recoveryPassword:o,recoveryAccessToken:i,recoverySecretOverride:d,recoveryKey:a,onNeedsRecovery:n}){if(!this._proxy)throw Error(\"Embedded wallet proxy not initialized\");if(!await this._privyInternal.getAccessTokenInternal())throw Error(\"User must be logged in to create an embedded wallet\");return s(e)||(!n||o||i||d||a)&&await this._load({entropyId:r,entropyIdVerifier:t,wallet:e,recoveryPassword:o,recoveryAccessToken:i,recoverySecretOverride:d,recoveryKey:a}),new c({account:e,entropyId:r,entropyIdVerifier:\"ethereum-address-verifier\",privyInternal:this._privyInternal,chains:this._chains,walletProxy:this._proxy,onNeedsRecovery:n,appApi:this._appApi})}async getSolanaProvider(e,r,o,i,d,a,n){if(!this._proxy)throw new t({error:\"Embedded wallet proxy not initialized\",code:\"embedded_wallet_webview_not_loaded\"});return s(e)||(!n||i||d||a)&&await this._load({wallet:e,entropyId:r,entropyIdVerifier:o,recoveryPassword:i,recoveryAccessToken:d,recoverySecretOverride:a}),new l({account:e,privyInternal:this._privyInternal,proxy:this._proxy,entropyId:r,entropyIdVerifier:o,onNeedsRecovery:n,app:this._appApi})}async setRecovery(e){let{wallet:r,...o}=e;if(!this._proxy)throw Error(\"Embedded wallet proxy not initialized\");if(s(r))throw new t({error:\"This wallet does not support setting recovery methods\",code:\"unsupported_recovery_method\"});a({currentRecoveryMethod:r.recovery_method,upgradeToRecoveryMethod:\"icloud-native\"===o.recoveryMethod?\"icloud\":o.recoveryMethod}),await this._load(\"solana\"===r.chain_type?{wallet:r,entropyId:r.address,entropyIdVerifier:\"solana-address-verifier\"}:{wallet:r,entropyId:r.address,entropyIdVerifier:\"ethereum-address-verifier\"});let i=await this._privyInternal.getAccessTokenInternal();if(!i)throw Error(\"User must be logged in to interact with embedded wallets\");let d=r.recovery_method;this._privyInternal.createAnalyticsEvent(\"embedded_wallet_sdk_set_recovery_started\",{address:r.address,target_recovery_method:o.recoveryMethod,existing_recovery_method:d});try{let e;if(\"user-passcode\"===o.recoveryMethod)e={recoveryMethod:\"user-passcode\",recoveryPassword:o.password};else if(\"google-drive\"===o.recoveryMethod)e={recoveryMethod:\"google-drive\",recoveryAccessToken:o.recoveryAccessToken};else if(\"icloud\"===o.recoveryMethod)e={recoveryMethod:\"icloud\",recoveryAccessToken:o.recoveryAccessToken};else if(\"icloud-native\"===o.recoveryMethod)e={recoveryMethod:\"icloud-native\",iCloudRecordNameOverride:o.iCloudRecordNameOverride,recoverySecretOverride:o.recoverySecretOverride};else if(\"recovery-encryption-key\"===o.recoveryMethod)e={recoveryMethod:\"recovery-encryption-key\",recoveryKey:o.recoveryKey};else{if(\"privy\"!==o.recoveryMethod)throw Error(`Unknown recovery method: ${o.recoveryMethod}`);e={recoveryMethod:\"privy\"}}await this._proxy.setRecovery({accessToken:i,entropyId:r.address,entropyIdVerifier:\"solana\"===r.chain_type?\"solana-address-verifier\":\"ethereum-address-verifier\",...e}),this._privyInternal.createAnalyticsEvent(\"embedded_wallet_sdk_set_recovery_completed\",{address:r.address,target_recovery_method:o.recoveryMethod,existing_recovery_method:d});let{user:t}=await this._privyInternal.refreshSession();return{user:t,provider:\"ethereum\"!==r.chain_type?null:new c({account:r,entropyId:r.address,entropyIdVerifier:\"ethereum-address-verifier\",privyInternal:this._privyInternal,chains:this._chains,walletProxy:this._proxy,appApi:this._appApi})}}catch(e){throw this._privyInternal.createAnalyticsEvent(\"embedded_wallet_sdk_set_recovery_failed\",{address:r.address,recovery_method:r.recovery_method,error:e instanceof Error?e.message:\"Unable to recover wallet\"}),e}}getURL(){let e=new URL(`${this._privyInternal.baseUrl}/apps/${this._privyInternal.appId}/embedded-wallets`);return this._privyInternal.caid&&e.searchParams.append(\"caid\",this._privyInternal.caid),this._privyInternal.appClientId&&e.searchParams.append(\"client_id\",this._privyInternal.appClientId),e.href}get chains(){return this._chains}onMessage(e){if(!this._proxy)throw Error(\"Embedded wallet proxy not initialized\");return this._proxy.handleEmbeddedWalletMessages(e)}reload(){this._proxy?this._proxy.reload():console.warn(\"Attempted to reload proxy before initialized\")}async ping(e){try{if(!this._proxy)throw Error(\"Embedded wallet proxy not initialized\");return await this._proxy.ping(e),!0}catch(e){return console.error(e),!1}}async _load({entropyId:e,entropyIdVerifier:r,wallet:t,recoveryPassword:o,recoveryKey:d,recoveryAccessToken:a,recoverySecretOverride:s}){if(!this._proxy)throw Error(\"Embedded wallet proxy not initialized\");let n=await this._privyInternal.getAccessTokenInternal();if(!n)throw Error(\"User must be logged in to interact with embedded wallets\");try{return await this._proxy.connect({accessToken:n,entropyId:e,entropyIdVerifier:r}),e}catch(c){if(i(c))try{if(\"privy\"===t.recovery_method){this._privyInternal.createAnalyticsEvent(\"embedded_wallet_sdk_recovery_started\",{address:t.address,recovery_method:t.recovery_method});let o=await this._proxy.recover({accessToken:n,entropyId:e,entropyIdVerifier:r});return this._privyInternal.createAnalyticsEvent(\"embedded_wallet_sdk_recovery_completed\",{address:t.address,recovery_method:t.recovery_method}),o.entropyId}if(\"user-passcode\"===t.recovery_method&&o){this._privyInternal.createAnalyticsEvent(\"embedded_wallet_sdk_recovery_started\",{address:t.address,recovery_method:t.recovery_method});let i=await this._proxy.recover({accessToken:n,recoveryPassword:o,entropyId:e,entropyIdVerifier:r});return this._privyInternal.createAnalyticsEvent(\"embedded_wallet_sdk_recovery_completed\",{address:t.address,recovery_method:t.recovery_method}),i.entropyId}if([\"google-drive\",\"icloud\"].includes(t.recovery_method)&&a){this._privyInternal.createAnalyticsEvent(\"embedded_wallet_sdk_recovery_started\",{address:t.address,recovery_method:t.recovery_method});let o=await this._proxy.recover({accessToken:n,recoveryAccessToken:a,entropyId:e,entropyIdVerifier:r});return this._privyInternal.createAnalyticsEvent(\"embedded_wallet_sdk_recovery_completed\",{address:t.address,recovery_method:t.recovery_method}),o.entropyId}if(\"icloud\"===t.recovery_method&&s){this._privyInternal.createAnalyticsEvent(\"embedded_wallet_sdk_recovery_started\",{address:t.address,recovery_method:\"icloud-native\"});let o=await this._proxy.recover({accessToken:n,recoverySecretOverride:s,entropyId:e,entropyIdVerifier:r});return this._privyInternal.createAnalyticsEvent(\"embedded_wallet_sdk_recovery_completed\",{address:t.address,recovery_method:\"icloud-native\"}),o.entropyId}if(\"recovery-encryption-key\"===t.recovery_method&&d){this._privyInternal.createAnalyticsEvent(\"embedded_wallet_sdk_recovery_started\",{address:t.address,recovery_method:t.recovery_method});let o=await this._proxy.recover({accessToken:n,recoveryKey:d,entropyId:e,entropyIdVerifier:r});return this._privyInternal.createAnalyticsEvent(\"embedded_wallet_sdk_recovery_completed\",{address:t.address,recovery_method:t.recovery_method}),o.entropyId}}catch(r){throw this._privyInternal.createAnalyticsEvent(\"embedded_wallet_sdk_recovery_failed\",{address:t.address,recovery_method:t.recovery_method,error:r instanceof Error?r.message:`Unable to recover wallet: ${e}`}),r}throw c}}constructor(t,o,i,d,a,s){if(this._chains=Array.from(e),this._privyInternal=t,o&&(this._proxy=new n(o,a),d.setProxy(this._proxy)),i){let e=r(i);this._chains=e}this._mfa=d,this._mfaPromises=a,this._appApi=s}}export{y as default};\n","function e(e){return new Promise((t=>{setTimeout((()=>{t()}),e)}))}export{e as sleep};\n","class e{enqueue(e,a){this.callbacks[e]=a}dequeue(e,a){let r=this.callbacks[a];if(!r)throw Error(`cannot dequeue ${e} event: no event found for id ${a}`);switch(delete this.callbacks[a],e){case\"privy:iframe:ready\":case\"privy:wallets:create\":case\"privy:user-signer:sign\":case\"privy:wallets:add\":case\"privy:wallets:set-recovery\":case\"privy:wallets:connect\":case\"privy:wallets:recover\":case\"privy:wallets:rpc\":case\"privy:wallet:create\":case\"privy:wallet:connect\":case\"privy:wallet:recover\":case\"privy:wallet:rpc\":case\"privy:solana-wallet:create\":case\"privy:solana-wallet:create-additional\":case\"privy:solana-wallet:connect\":case\"privy:solana-wallet:recover\":case\"privy:solana-wallet:rpc\":case\"privy:delegated-actions:consent\":case\"privy:mfa:verify\":case\"privy:mfa:init-enrollment\":case\"privy:mfa:submit-enrollment\":case\"privy:mfa:unenroll\":case\"privy:mfa:clear\":return r;default:throw Error(`invalid wallet event type ${e}`)}}constructor(){this.callbacks={}}}export{e as EventCallbacksQueue};\n","import{PrivyIframeError as e}from\"./errors.mjs\";import\"./types.mjs\";async function r(r,t,i,a,n=!1,o,c){let m=n,s=async o=>{if(m){o===(n?0:1)?a():i.current?.reject(new e(\"missing_or_invalid_mfa\",\"MFA verification failed, retry.\"));let m=await new Promise(((r,a)=>{t.current={resolve:r,reject:a},setTimeout((()=>{let r=new e(\"mfa_timeout\",\"Timed out waiting for MFA code\");i.current?.reject(r),a(r)}),c)}));return await r(m)}return await r()},f=null;for(let e=0;e<o;e++)try{f=await s(e),i.current?.resolve(void 0);break}catch(e){if(\"missing_or_invalid_mfa\"!==e.type)throw i.current?.resolve(void 0),e;m=!0}if(null===f){let r=new e(\"mfa_verification_max_attempts_reached\",\"Max MFA verification attempts reached\");throw i.current?.reject(r),r}return f}export{r as withMfa};\n","import{sleep as e}from\"../utils/sleep.mjs\";import{EventCallbacksQueue as t}from\"./EventCallbackQueue.mjs\";import{PrivyIframeError as i}from\"./errors.mjs\";import{withMfa as r}from\"./withMfa.mjs\";import\"./types.mjs\";var a;const o=15e3;let s=(a=0,()=>\"id-\"+a++),n=(e,t)=>\"bigint\"==typeof t?t.toString():t,l=async(e,{ms:t,msg:i})=>{let r,a=new Promise(((e,a)=>{r=setTimeout((()=>{a(Error(i))}),t??15e3)}));try{return await Promise.race([e,a])}finally{void 0!==r&&clearTimeout(r)}},m=new t;class h{invokeWithMfa(e,t){return l(r((i=>l(this.waitForReady().then((()=>e(i))),{msg:t.timeoutMsg,ms:t.timeoutMs})),this.mfa.rootPromise,this.mfa.submitPromise,(()=>this.mfa.emit(\"mfaRequired\")),t.mfaAlwaysRequired??!1,4,3e5),{msg:\"Operation reached timeout: MFA verification\",ms:126e4})}reload(){return this.ready=!1,this._embeddedWalletMessagePoster.reload()}ping(e=15e3){return l(this.invoke(\"privy:iframe:ready\",{}),{msg:\"Ping reached timeout\",ms:e})}create(e){return l(this.waitForReady().then((()=>this.invoke(\"privy:wallet:create\",e))),{msg:\"Operation reached timeout: create\"})}rpc(e){return this.invokeWithMfa((t=>this.invoke(\"privy:wallet:rpc\",{...t,...e})),{timeoutMsg:\"Operation reached timeout: rpc\"})}createSolana(e){return this.invokeWithMfa((t=>this.invoke(\"privy:solana-wallet:create\",{...t,...e})),{timeoutMsg:\"Operation reached timeout: create\",timeoutMs:6e4})}createAdditionalSolana(e){return l(this.waitForReady().then((()=>this.invoke(\"privy:solana-wallet:create-additional\",e))),{msg:\"Operation reached timeout: create\"})}solanaRpc(e){return this.invokeWithMfa((t=>this.invoke(\"privy:solana-wallet:rpc\",{...t,...e})),{timeoutMsg:\"Operation reached timeout: solana-rpc\"})}delegateWallets(e){return this.invokeWithMfa((t=>this.invoke(\"privy:delegated-actions:consent\",{...t,...e})),{timeoutMsg:\"Operation reached timeout: delegated-actions:consent\"})}verifyMfa(e){return this.invokeWithMfa((t=>this.invoke(\"privy:mfa:verify\",{...t,...e})),{timeoutMsg:\"Operation reached timeout: mfa:verify\",mfaAlwaysRequired:!0})}initEnrollMfa(e){return this.invokeWithMfa((t=>this.invoke(\"privy:mfa:init-enrollment\",{...t,...e})),{timeoutMsg:\"Operation reached timeout: mfa:init-enrollment\"})}submitEnrollMfa(e){return this.invokeWithMfa((t=>this.invoke(\"privy:mfa:submit-enrollment\",{...t,...e})),{timeoutMsg:\"Operation reached timeout: mfa:submit-enrollment\"})}unenrollMfa(e){return this.invokeWithMfa((t=>this.invoke(\"privy:mfa:unenroll\",{...t,...e})),{timeoutMsg:\"Operation reached timeout: mfa:unenroll\",mfaAlwaysRequired:!0})}clearMfa(e){return l(this.waitForReady().then((()=>this.invoke(\"privy:mfa:clear\",e))),{msg:\"Operation reached timeout: mfa:clear\"})}createWallet(e){return this.invokeWithMfa((t=>this.invoke(\"privy:wallets:create\",{...t,...e})),{timeoutMsg:\"Operation reached timeout: create\",timeoutMs:6e4})}signWithUserSigner(e){return this.invokeWithMfa((t=>this.invoke(\"privy:user-signer:sign\",{...t,...e})),{timeoutMsg:\"Operation reached timeout: user-signer:sign\"})}addWallet(e){return l(this.waitForReady().then((()=>this.invoke(\"privy:wallets:add\",e))),{msg:\"Operation reached timeout: wallets:add\"})}setRecovery(e){return this.invokeWithMfa((t=>this.invoke(\"privy:wallets:set-recovery\",{...t,...e})),{timeoutMsg:\"Operation reached timeout: wallets:set-recovery\",timeoutMs:6e4})}connect(e){return l(this.waitForReady().then((()=>this.invoke(\"privy:wallets:connect\",e))),{msg:\"Operation reached timeout: wallets:connect\"})}recover(e){return this.invokeWithMfa((t=>this.invoke(\"privy:wallets:recover\",{...t,...e})),{timeoutMsg:\"Operation reached timeout: wallets:recover\",timeoutMs:6e4})}rpcWallet(e){return this.invokeWithMfa((t=>this.invoke(\"privy:wallets:rpc\",{...t,...e})),{timeoutMsg:\"Operation reached timeout: wallets:rpc\"})}handleEmbeddedWalletMessages(e){if(!e.event.startsWith(\"privy:\"))return void console.warn(`Unsupported event type: ${e.event}`);let{reject:t,resolve:r}=m.dequeue(e.event,e.id);return void 0!==e.error?t(new i(e.error.type,e.error.message)):r(e.data)}waitForReady(){return this.ready?Promise.resolve():new Promise((async(t,i)=>{for(;!this.ready;)this.invoke(\"privy:iframe:ready\",{}).then((()=>{this.ready=!0,t()})).catch(i),await e(150)}))}invoke(e,t){let i=((e,t)=>`${e}${JSON.stringify(t,n)}`)(e,t);if(\"privy:wallet:create\"===e||\"privy:solana-wallet:create\"===e){let e=this.cache.get(i);if(e)return e}let r=new Promise(((i,r)=>{let a=s();m.enqueue(a,{resolve:i,reject:r}),this._embeddedWalletMessagePoster.postMessage(JSON.stringify({id:a,event:e,data:t}),\"*\")})).finally((()=>{this.cache.delete(i)}));return this.cache.set(i,r),r}constructor(e,t){this.ready=!1,this.cache=new Map,this._embeddedWalletMessagePoster=e,this.mfa=t}}export{o as DEFAULT_WALLET_PROXY_TIMEOUT_MS,h as EmbeddedWalletProxy};\n","import EventEmitter from './index.js'\n\nexport { EventEmitter }\nexport default EventEmitter\n","import e from\"eventemitter3\";import{toHex as t}from\"viem\";import{toViemTransactionSerializable as r,STRING_TO_NUMBER_TXN_TYPE as a}from\"@privy-io/ethereum\";import{PrivyClientError as i}from\"../Error.mjs\";import{isUnifiedWallet as s}from\"../wallet-api/unified-wallet.mjs\";import{EmbeddedProviderError as n,errorIndicatesRecoveryIsNeeded as o}from\"./errors.mjs\";import{walletRpc as h}from\"./stack/walletRpc.mjs\";import{getPublicClient as c}from\"./utils/index.mjs\";import\"./types.mjs\";import\"../utils/encodings.mjs\";import\"../wallet-api/rpc.mjs\";import\"@privy-io/routes\";import\"../wallet-api/generate-authorization-signature.mjs\";import\"canonicalize\";import\"./stack/wallet-api-eth-transaction.mjs\";import\"./stack/wallet-api-eth-typed-data.mjs\";let d=new Set([\"eth_sign\",\"personal_sign\",\"eth_signTypedData_v4\",\"csw_signUserOperation\",\"secp256k1_sign\"]);class l extends e{async request(e){if(d.has(e.method))return this.handleIFrameRpc(e);switch(e.method){case\"eth_accounts\":case\"eth_requestAccounts\":return this._account.address?[this._account.address]:[];case\"eth_chainId\":return`0x${this._chainId.toString(16)}`;case\"wallet_switchEthereumChain\":return this.handleSwitchEthereumChain(e);case\"eth_estimateGas\":return this.handleEstimateGas(e);case\"eth_signTransaction\":{let t=e.params?.[0];return this.handleSignTransaction(t)}case\"eth_sendTransaction\":{let t=e.params?.[0];return this.handleSendTransaction(t)}case\"eth_populateTransactionRequest\":{let t=e.params?.[0];return this.handlePopulateTransaction(t)}default:return this.handleJsonRpc(e)}}ensureChainId(e){let t={chainId:this._chainId,...e};return this.internalSwitchEthereumChain(t.chainId),t}internalSwitchEthereumChain(e){e&&Number(e)!==this._chainId&&(this._chainId=Number(e),this._client=c(this._chainId,this._chains,{rpcUrls:[]},{appId:this._privyInternal.appId}),this.emit(\"chainChanged\",e))}async handlePopulateTransaction(e){let t=this.ensureChainId(e),i=r(t),{type:s,...n}=await this._client.prepareTransactionRequest({account:t.from??this._account.address,...i});return{...n,type:a[s]}}async handleSignTransaction(e){let r={...e};for(let e of Object.keys(r)){let a=r[e];a&&\"bigint\"==typeof a&&(r[e]=t(a))}return await this.handleIFrameRpc({method:\"eth_signTransaction\",params:[r]})}async handleSendTransaction(e){let t=await this.handlePopulateTransaction(e),r=await this.handleSignTransaction(t);return await this.handleJsonRpc({method:\"eth_sendRawTransaction\",params:[r]})}async handleEstimateGas(e){if(!e.params||!Array.isArray(e.params))throw Error(\"Invalid params for eth_estimateGas\");let t=e.params?.[0],a=this.ensureChainId(t),i=r(a);return await this._client.estimateGas({account:a.from??this._account.address,...i})}handleSwitchEthereumChain(e){let t;if(!e.params||!Array.isArray(e.params))throw new n(`Invalid params for ${e.method}`,4200);if(\"string\"==typeof e.params[0])t=e.params[0];else{if(!(\"chainId\"in e.params[0])||\"string\"!=typeof e.params[0].chainId)throw new n(`Invalid params for ${e.method}`,4200);t=e.params[0].chainId}this.internalSwitchEthereumChain(t)}async handleIFrameRpc(e){try{let t=await this._privyInternal.getAccessTokenInternal();if(!t)throw Error(\"Missing privy token. User must be logged in\");this._privyInternal.createAnalyticsEvent(\"embedded_wallet_sdk_rpc_started\",{method:e.method,address:this._account.address});let r=this._account;if(s(r)){let{data:a}=await h({context:{app:this._appApi,fetchPrivyRoute:(...e)=>this._privyInternal.fetch(...e),getCompiledPath:(...e)=>this._privyInternal.getPath(...e),signRequest:({message:e})=>this._walletProxy.signWithUserSigner({accessToken:t,message:e})},account:r,rpcRequest:{chainType:\"ethereum\",request:e}});return a}try{await this._walletProxy.connect({entropyId:this._entropyId,entropyIdVerifier:this._entropyIdVerifier,accessToken:t})}catch(e){let r=o(e);if(r&&\"privy\"===this._account.recovery_method)await this._walletProxy.recover({entropyId:this._entropyId,entropyIdVerifier:this._entropyIdVerifier,accessToken:t});else{if(!r||!this._onNeedsRecovery)throw e;{let e;await new Promise((async(t,r)=>{e=setTimeout((()=>r(new i({code:\"embedded_wallet_recovery_error\",error:\"User-owned recovery timed out\"}))),12e4),await(this._onNeedsRecovery?.({recoveryMethod:this._account.recovery_method,onRecovered:()=>t(!0)}))})).finally((()=>clearTimeout(e)))}}}return(await this._walletProxy.rpcWallet({accessToken:t,request:e,entropyId:this._entropyId,entropyIdVerifier:this._entropyIdVerifier,hdWalletIndex:this._account.wallet_index,chainType:\"ethereum\"})).response.data}catch(t){console.error(t);let r=t instanceof Error?t.message:\"Unable to make wallet request\";throw this._privyInternal.createAnalyticsEvent(\"embedded_wallet_sdk_rpc_failed\",{method:e.method,address:this._account.address,error:r}),new i({code:\"embedded_wallet_request_error\",error:r})}}async handleJsonRpc(e){return this._client.request(e)}toJSON(){return`PrivyEIP1193Provider { address: '${this._account.address}', chainId: ${this._chainId}, request: [Function] }`}constructor({walletProxy:e,privyInternal:t,account:r,entropyId:a,entropyIdVerifier:i,chains:s,onNeedsRecovery:n,chainId:o=s[0].id,appApi:h}){super(),this._walletProxy=e,this._privyInternal=t,this._account=r,this._entropyId=a,this._entropyIdVerifier=i,this._chainId=o,this._chains=s,this._onNeedsRecovery=n,this._client=c(o,s,{rpcUrls:[]},{appId:h.appId}),this._appApi=h}}export{l as EmbeddedWalletProvider};\n","import{isHex as e,toHex as a}from\"viem\";let r={0:\"legacy\",1:\"eip2930\",2:\"eip1559\",3:\"eip4844\",4:\"eip7702\"};const i={legacy:0,eip2930:1,eip1559:2,eip4844:3,eip7702:4};let s=e=>void 0!==e?BigInt(e):void 0;function t(i){let t,{type:c=2,...o}=\"string\"==typeof i?JSON.parse(i):i;o.accessList&&Array.isArray(o.accessList)?t=o.accessList.map((e=>Array.isArray(e)?{address:e[0],storageKeys:e[1]}:e)):o.accessList&&(t=Object.entries(o.accessList).map((e=>({address:e[0],storageKeys:e[1]}))));let d=Number(o.chainId??1),n=e(o.data)?o.data:o.data?a(Uint8Array.from(o.data)):void 0,p=o.nonce?Number(o.nonce):void 0,m={chainId:d,data:n,nonce:p,value:s(o.value),gas:s(o.gas??o.gasLimit)},y=Number(c);if(0===y)return{...o,type:r[y],...m,gasPrice:s(o.gasPrice),accessList:void 0,maxFeePerGas:void 0,maxPriorityFeePerGas:void 0};if(1===y)return{...o,type:r[y],...m,gasPrice:s(o.gasPrice),accessList:t,maxFeePerGas:void 0,maxPriorityFeePerGas:void 0};if(2===y)return{...o,type:r[y],...m,nonce:p,accessList:t,maxFeePerGas:s(o.maxFeePerGas),maxPriorityFeePerGas:s(o.maxPriorityFeePerGas),gasPrice:void 0,maxFeePerBlobGas:void 0};throw Error(`Unsupported transaction type: ${c}`)}export{i as STRING_TO_NUMBER_TXN_TYPE,t as toViemTransactionSerializable};\n","const t=t=>/^0x[0-9a-fA-F]*$/.test(t),f=t=>Buffer.from(t,\"utf8\"),e=t=>`0x${t.toString(\"hex\")}`;export{e as bytesToHex,t as isHexEncoded,f as utf8ToBytes};\n","import{WalletRpc as r}from\"@privy-io/routes\";import{generateAuthorizationSignature as a}from\"./generate-authorization-signature.mjs\";import\"canonicalize\";import\"../Error.mjs\";async function t(t,i,{wallet_id:e,...o}){let p={version:1,url:t.getCompiledPath(r,{params:{wallet_id:e}}),method:r.method,headers:{\"privy-app-id\":t.app.appId},body:{...o}},{signature:m}=await a(i,p);return await t.fetchPrivyRoute(r,{body:o,params:{wallet_id:e},headers:{\"privy-authorization-signature\":m}})}export{t as rpc};\n","import r from\"canonicalize\";import{PrivyClientError as e}from\"../Error.mjs\";async function i(i,o){let t=r(o);if(void 0===t)throw new e({error:\"Failed to prepare the payload for signing\",code:\"invalid_input\"});let a=Buffer.from(t).toString(\"base64\"),{signature:n}=await i({message:a});return{signature:n}}export{i as generateAuthorizationSignature};\n","import{bytesToHex as e,isHexEncoded as r,utf8ToBytes as i}from\"../../utils/encodings.mjs\";function t(t){return{from:t.from,to:t.to??void 0,nonce:n(t.nonce),chain_id:n(t.chainId),data:function(t){if(void 0!==t)return\"string\"==typeof t?r(t)?t:e(i(t)):e(Buffer.from(Uint8Array.from(t)))}(t.data),value:n(t.value),type:t.type,gas_limit:n(t.gasLimit),gas_price:n(t.gasPrice),max_fee_per_gas:n(t.maxFeePerGas),max_priority_fee_per_gas:n(t.maxPriorityFeePerGas)}}function n(t){if(\"number\"==typeof t||\"bigint\"==typeof t){return`0x${BigInt(t).toString(16)}`}if(\"string\"==typeof t)return r(t)?t:e(i(t))}export{t as toWalletApiUnsignedEthTransaction};\n","function e(e){return\"string\"==typeof e&&(e=JSON.parse(e)),{types:e.types,primary_type:String(e.primaryType),domain:e.domain,message:e.message}}export{e as toWalletApiTypedData};\n","import{isHexEncoded as e,bytesToHex as t,utf8ToBytes as a}from\"../../utils/encodings.mjs\";import{rpc as s}from\"../../wallet-api/rpc.mjs\";import{toWalletApiUnsignedEthTransaction as n}from\"./wallet-api-eth-transaction.mjs\";import{toWalletApiTypedData as r}from\"./wallet-api-eth-typed-data.mjs\";import\"@privy-io/routes\";import\"../../wallet-api/generate-authorization-signature.mjs\";import\"canonicalize\";import\"../../Error.mjs\";async function i({context:i,account:o,rpcRequest:c}){switch(c.chainType){case\"ethereum\":return async function({context:i,account:o,rpcRequest:c}){switch(c.method){case\"personal_sign\":{let[e]=c.params,t=await s(i,i.signRequest,{chain_type:\"ethereum\",method:\"personal_sign\",wallet_id:o.id,params:e.startsWith(\"0x\")?{message:e.slice(2),encoding:\"hex\"}:{message:e,encoding:\"utf-8\"}});if(\"personal_sign\"!==t.method)throw Error(\"Unable to sign message\");return{data:t.data.signature}}case\"eth_signTransaction\":{let[e]=c.params,t=await s(i,i.signRequest,{chain_type:\"ethereum\",method:\"eth_signTransaction\",wallet_id:o.id,params:{transaction:n(e)}});if(\"eth_signTransaction\"!==t.method)throw Error(\"Unable to sign transaction\");return{data:t.data.signed_transaction}}case\"eth_signTypedData_v4\":{let[,e]=c.params,t=await s(i,i.signRequest,{chain_type:\"ethereum\",method:c.method,wallet_id:o.id,params:{typed_data:r(e)}});if(\"eth_signTypedData_v4\"!==t.method)throw Error(\"Unable to sign typed data\");return{data:t.data.signature}}case\"eth_sign\":{let[,n]=c.params,r=await s(i,i.signRequest,{chain_type:\"ethereum\",method:\"secp256k1_sign\",wallet_id:o.id,params:{hash:e(n)?n:t(a(n))}});if(\"secp256k1_sign\"!==r.method)throw Error(\"Unable to sign message\");return{data:r.data.signature}}case\"secp256k1_sign\":{let[n]=c.params,r=await s(i,i.signRequest,{chain_type:\"ethereum\",method:\"secp256k1_sign\",wallet_id:o.id,params:{hash:e(n)?n:t(a(n))}});if(\"secp256k1_sign\"!==r.method)throw Error(\"Unable to sign message\");return{data:r.data.signature}}case\"csw_signUserOperation\":case\"eth_sendTransaction\":case\"eth_populateTransactionRequest\":throw Error(`This wallet does not support the method: ${c.method}`)}}({context:i,account:o,rpcRequest:c.request});case\"solana\":return async function({context:e,account:t,rpcRequest:a}){if(\"signMessage\"===a.method){let{message:n}=a.params,r=await s(e,e.signRequest,{chain_type:\"solana\",method:\"signMessage\",wallet_id:t.id,params:{message:n,encoding:\"base64\"}});if(\"signMessage\"!==r.method)throw Error(\"Unable to sign message\");return{data:r.data.signature}}}({context:i,account:o,rpcRequest:c.request})}}export{i as walletRpc};\n","function n(n){return\"version\"in n}export{n as isVersionedTransaction};\n","import{isVersionedTransaction as o}from\"./isVersionedTransaction.mjs\";function e(e,t){let n=(o(e)?e.message:e.compileMessage()).staticAccountKeys.find((o=>o.toBase58()===t));if(!n)throw Error(`Transaction does not contain public key ${t}`);return n}export{e as getWalletPublicKeyFromTransaction};\n","import{PrivyClientError as e}from\"../Error.mjs\";import{getWalletPublicKeyFromTransaction as t}from\"../solana/getWalletPublicKeyFromTransaction.mjs\";import{isVersionedTransaction as r}from\"../solana/isVersionedTransaction.mjs\";import{isUnifiedWallet as a}from\"../wallet-api/unified-wallet.mjs\";import{errorIndicatesRecoveryIsNeeded as s}from\"./errors.mjs\";import{walletRpc as n}from\"./stack/walletRpc.mjs\";import\"./types.mjs\";import\"../utils/encodings.mjs\";import\"../wallet-api/rpc.mjs\";import\"@privy-io/routes\";import\"../wallet-api/generate-authorization-signature.mjs\";import\"canonicalize\";import\"./stack/wallet-api-eth-transaction.mjs\";import\"./stack/wallet-api-eth-typed-data.mjs\";class i{async request(t){if(!await this._privyInternal.getAccessTokenInternal())throw new e({error:\"Missing access token\",code:\"attempted_rpc_call_before_logged_in\"});switch(t.method){case\"signAndSendTransaction\":return await this.handleSignAndSendTransaction(t);case\"signTransaction\":return await this.handleSignTransaction(t);default:return await this.handleIFrameRpc(t)}}get _publicKey(){return this._account.address}async connectAndRecover(t){if(\"privy-v2\"!==this._account.recovery_method)try{await this._proxy.connect({entropyId:this._entropyId,entropyIdVerifier:this._entropyIdVerifier,accessToken:t})}catch(r){let a=s(r);if(a&&\"privy\"===this._account.recovery_method)await this._proxy.recover({entropyId:this._entropyId,entropyIdVerifier:this._entropyIdVerifier,accessToken:t});else{if(!a||!this._onNeedsRecovery)throw r;{let t;await new Promise((async(r,a)=>{t=setTimeout((()=>a(new e({code:\"embedded_wallet_recovery_error\",error:\"User-owned recovery timed out\"}))),12e4),await(this._onNeedsRecovery?.({recoveryMethod:this._account.recovery_method,onRecovered:()=>r(!0)}))})).finally((()=>clearTimeout(t)))}}}}async signMessageRpc(e,t){let r=this._account;if(!a(r))return(await this._proxy.rpcWallet({accessToken:t,request:e,chainType:\"solana\",hdWalletIndex:this._account.wallet_index,entropyId:this._entropyId,entropyIdVerifier:this._entropyIdVerifier})).response.data;{let{data:a}=await n({context:{app:this._app,fetchPrivyRoute:(...e)=>this._privyInternal.fetch(...e),getCompiledPath:(...e)=>this._privyInternal.getPath(...e),signRequest:({message:e})=>this._proxy.signWithUserSigner({accessToken:t,message:e})},account:r,rpcRequest:{chainType:\"solana\",request:e}});return{signature:a}}}async handleIFrameRpc(t){try{let e=await this._privyInternal.getAccessTokenInternal();if(!e)throw Error(\"Missing privy token. User must be logged in\");return this._privyInternal.createAnalyticsEvent(\"embedded_wallet_sdk_rpc_started\",{method:t.method,address:this._account.address}),await this.connectAndRecover(e),await this.signMessageRpc(t,e)}catch(r){console.error(r);let a=r instanceof Error?r.message:\"Unable to make wallet request\";throw this._privyInternal.createAnalyticsEvent(\"embedded_wallet_sdk_rpc_failed\",{method:t.method,address:this._account.address,error:a}),new e({code:\"embedded_wallet_request_error\",error:a})}}async handleSignAndSendTransaction(a){try{let e=await this._privyInternal.getAccessTokenInternal();if(!e)throw Error(\"Missing privy token. User must be logged in\");this._privyInternal.createAnalyticsEvent(\"embedded_wallet_sdk_rpc_started\",{method:a.method,address:this._account.address}),await this.connectAndRecover(e);let{transaction:s,connection:n,options:i}=a.params,o=t(s,this._account.address),c=r(s)?Buffer.from(s.message.serialize()):s.serializeMessage(),{signature:d}=await this.signMessageRpc({method:\"signMessage\",params:{message:c.toString(\"base64\")}},e);return s.addSignature(o,Buffer.from(d,\"base64\")),{signature:await n.sendRawTransaction(s.serialize(),i)}}catch(t){console.error(t);let r=t instanceof Error?t.message:\"Unable to make wallet request\";throw this._privyInternal.createAnalyticsEvent(\"embedded_wallet_sdk_rpc_failed\",{method:a.method,address:this._account.address,error:r}),new e({code:\"embedded_wallet_request_error\",error:r})}}async handleSignTransaction(a){try{let e=await this._privyInternal.getAccessTokenInternal();if(!e)throw Error(\"Missing privy token. User must be logged in\");this._privyInternal.createAnalyticsEvent(\"embedded_wallet_sdk_rpc_started\",{method:a.method,address:this._account.address}),await this.connectAndRecover(e);let{transaction:s}=a.params,n=t(s,this._account.address),i=r(s)?Buffer.from(s.message.serialize()):s.serializeMessage(),{signature:o}=await this.signMessageRpc({method:\"signMessage\",params:{message:i.toString(\"base64\")}},e);return s.addSignature(n,Buffer.from(o,\"base64\")),{signedTransaction:s}}catch(t){console.error(t);let r=t instanceof Error?t.message:\"Unable to make wallet request\";throw this._privyInternal.createAnalyticsEvent(\"embedded_wallet_sdk_rpc_failed\",{method:a.method,address:this._account.wallet_index,error:r}),new e({code:\"embedded_wallet_request_error\",error:r})}}toJSON(){return`PrivyEmbeddedSolanaProvider { address: '${this._account.address}', request: [Function] }`}constructor({proxy:e,privyInternal:t,account:r,entropyId:a,entropyIdVerifier:s,onNeedsRecovery:n,app:i}){this._proxy=e,this._privyInternal=t,this._account=r,this._entropyId=a,this._entropyIdVerifier=s,this._onNeedsRecovery=n,this._app=i}}export{i as EmbeddedSolanaWalletProvider};\n","import t from\"eventemitter3\";class r extends t{constructor(){super(),this.rootPromise={current:null},this.submitPromise={current:null}}}export{r as default};\n","import e from\"fetch-retry\";import{v4 as t}from\"uuid\";import{PrivyErrorCode as s}from\"@privy-io/api-base\";import{getPathWithParams as i,AppConfig as r,AnalyticsEvent as a,RefreshSession as n}from\"@privy-io/routes\";import{PrivyClientError as o,PrivyApiError as h}from\"../Error.mjs\";import{Session as c}from\"../Session.mjs\";import l from\"../toAbortSignalTimeout.mjs\";import{toSearchParams as g}from\"../utils/toSearchParams.mjs\";import{toConsoleLogger as d}from\"./logger.mjs\";import\"eventemitter3\";import\"jose\";import\"js-cookie\";import\"../Token.mjs\";import\"../utils/allSettled.mjs\";import\"../utils/noop.mjs\";let p=\"privy:caid\";class u{setCallbacks(e){this.callbacks={...this.callbacks,...e}}get isReady(){return!!this._config}get config(){return this._config}get caid(){return this._analyticsId}async _initialize(){if(this.isReady)this.callbacks?.setIsReady?.(!0);else{if(!await this.isStorageAccessible())throw new o({code:\"storage_error\",error:\"Unable to access storage\"});this._config=await this.getAppConfig(),this._config?.custom_api_url&&(this.baseUrl=this._config.custom_api_url,this.session.isUsingServerCookies=!0),this.callbacks?.setIsReady?.(!0),this._sdkVersion.startsWith(\"react-auth:\")||this.createAnalyticsEvent(\"sdk_initialize\",{})}}getPath(e,{params:t,query:s}){return`${this.baseUrl}${i(e.path,t)}${g(s)}`}async fetch(e,{body:t,params:s,query:i,headers:r,onRequest:a=this._beforeRequest.bind(this)}){let n=new Request(this.getPath(e,{params:s,query:i}),{method:e.method,body:JSON.stringify(t),headers:r}),o=await a(n),c=await this._fetch(n,o),l=await c.json();if(c.status>299)throw new h(l);return l}async _beforeRequestWithoutInitialize(e){let t=await this.session.getPrivyAccessToken()??await this.session.getCustomerAccessToken(),s=new Headers(e.headers);s.set(\"privy-app-id\",this.appId),this.appClientId&&s.set(\"privy-client-id\",this.appClientId),s.set(\"privy-client\",this._sdkVersion),t&&s.set(\"Authorization\",`Bearer ${t}`),s.set(\"Content-Type\",\"application/json\"),s.set(\"Accept\",\"application/json\");let i=await this._getOrGenerateClientAnalyticsId();return i&&s.set(\"privy-ca-id\",i),this.nativeAppIdentifier&&s.set(\"x-native-app-identifier\",this.nativeAppIdentifier),{signal:l(2e4),headers:s,credentials:\"include\"}}async beforeRequestWithoutRefresh(e){return await this._initialize(),this._beforeRequestWithoutInitialize(e)}async _beforeRequest(e){return await this._initialize(),await this.getAccessTokenInternal(),this.beforeRequestWithoutRefresh(e)}async getAppConfig(){return await this.fetch(r,{params:{app_id:this.appId},onRequest:this._beforeRequestWithoutInitialize.bind(this)})}async _getOrGenerateClientAnalyticsId(){if(this._analyticsId)return this._analyticsId;try{let e=await this._storage.get(p);if(\"string\"==typeof e&&e.length>0)return this._analyticsId=e,e}catch(e){this.logger.error(\"Unable to load clientId\",e)}try{this._analyticsId=t()}catch(e){this.logger.error(\"Unable to generate uuidv4\",e)}if(this._analyticsId){try{await this._storage.put(p,this._analyticsId)}catch(e){this.logger.error(`Unable to store clientId: ${this._analyticsId}`,e)}return this._analyticsId}}async destroyClientAnalyticsId(){try{return await this._storage.del(p)}catch(e){this.logger.error(\"Unable to delete clientId\",e)}}async createAnalyticsEvent(e,t){try{await this.fetch(a,{body:{event_name:e,client_id:await this._getOrGenerateClientAnalyticsId(),payload:t},onRequest:this.beforeRequestWithoutRefresh.bind(this)})}catch(e){}}async refreshSession(e=!1){if(!await this.isStorageAccessible())throw new o({code:\"storage_error\",error:\"Unable to access storage\"});let t=await this.session.getRefreshToken()??void 0,s=t??\"key\",i=this._cache.get(s);if(i)return this.logger.debug(\"[privy:refresh] found in-flight session refresh request, deduping\"),await i;let r=this._refreshSession(t,e);this._cache.set(s,r);try{return await r}finally{this._cache.delete(s)}}async _refreshSession(e,t){let i=await this.session.getCustomerAccessToken();if(!this.session.hasRefreshCredentials(i,e??null))throw this.logger.debug(\"[privy:refresh] missing tokens, skipping request\"),await this._initialize(),new h({code:s.MISSING_OR_INVALID_TOKEN,error:\"No tokens found in storage\"});try{this.logger.debug(`[privy:refresh] fetching: ${n.path}`);let s=await this.fetch(n,{body:{refresh_token:e},onRequest:this.beforeRequestWithoutRefresh.bind(this)}),i=s.session_update_action;return this.logger.debug(`[privy:refresh] response: ${i}`),t||this.callbacks?.setUser?.(s.user),\"set\"===i&&(await this.session.updateWithTokensResponse(s),this.logger.debug(\"[privy:refresh] tokens stored\")),\"clear\"===i&&(await this.session.destroyLocalState(),this.logger.debug(\"[privy:refresh] tokens cleared\"),t||this.callbacks?.setUser?.(null)),\"ignore\"===i&&s.token&&(await this.session.storeCustomerAccessToken(s.token),await this.session.storePrivyAccessToken(s.privy_access_token),this.logger.debug(\"[privy:refresh] access token stored\"),s.identity_token&&(this.logger.debug(\"[privy:refresh] identity token stored\"),await this.session.storeIdentityToken(s.identity_token))),this.logger.debug(\"[privy:refresh] returning response\"),s}catch(e){throw this.logger.debug(`[privy:refresh] error: ${e.message??\"unknown error\"}`),e instanceof h&&e.code===s.MISSING_OR_INVALID_TOKEN&&(await this.session.destroyLocalState(),t||this.callbacks?.setUser?.(null)),e}}async getAccessToken(){let[e,t]=await Promise.all([this.session.getCustomerAccessToken(),this.session.getRefreshToken()]);if(!this.session.tokenIsActive(e)&&this.session.hasRefreshCredentials(e,t)){let t=await this.refreshSession(),s=await this.session.getCustomerAccessToken();return t.token||this.logger.debug(\"[privy:getAccessToken] expected token received null\"),t.token===e&&this.logger.debug(\"[privy:getAccessToken] expected new token in response received existing\"),s===e&&this.logger.debug(\"[privy:getAccessToken] expected new token in storage received existing\"),t.token??s}return e}async getAccessTokenInternal(){let e=await this.getAccessToken();return await this.session.getPrivyAccessToken()??e}async getIdentityToken(){return await this.session.getIdentityToken()}async isStorageAccessible(){try{let e=`privy:__storage__test-${t()}`,s=\"blobby\";await this._storage.put(e,s);let i=await this._storage.get(e);return await this._storage.del(e),i===s}catch(e){return this.logger.error(e),!1}}constructor(t){this._sdkVersion=\"js-sdk-core:0.58.2\",this._cache=new Map,this.logger=d({level:t.logLevel??\"ERROR\"}),this._storage=t.storage,this._analyticsId=null,this._getOrGenerateClientAnalyticsId(),this.baseUrl=t.baseUrl??\"https://auth.privy.io\",this.appId=t.appId,this.appClientId=t.appClientId,this._sdkVersion=t.sdkVersion??this._sdkVersion,this.callbacks=t.callbacks,this.nativeAppIdentifier=t.nativeAppIdentifier,this.session=new c({storage:this._storage,isUsingServerCookies:!1,appId:t.appId}),this._fetch=e(globalThis.fetch,{retries:3,retryDelay:e=>3**e*500,retryOn:[408,409,425,500,502,503,504]}),this.session.on(\"error_storing_tokens\",(e=>{this.createAnalyticsEvent(\"error_updating_tokens_in_storage\",{reason:e})}))}}export{u as PrivyInternal};\n","import crypto from 'crypto';\nexport default {\n  randomUUID: crypto.randomUUID\n};","import crypto from 'crypto';\nconst rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate\n\nlet poolPtr = rnds8Pool.length;\nexport default function rng() {\n  if (poolPtr > rnds8Pool.length - 16) {\n    crypto.randomFillSync(rnds8Pool);\n    poolPtr = 0;\n  }\n\n  return rnds8Pool.slice(poolPtr, poolPtr += 16);\n}","export default /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;","import REGEX from './regex.js';\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && REGEX.test(uuid);\n}\n\nexport default validate;","import validate from './validate.js';\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\n\nexport function unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];\n}\n\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nexport default stringify;","import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\n\nfunction v4(options, buf, offset) {\n  if (native.randomUUID && !buf && !options) {\n    return native.randomUUID();\n  }\n\n  options = options || {};\n  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return unsafeStringify(rnds);\n}\n\nexport default v4;","var _,e=((_={}).OAUTH_ACCOUNT_SUSPENDED=\"oauth_account_suspended\",_.MISSING_OR_INVALID_PRIVY_APP_ID=\"missing_or_invalid_privy_app_id\",_.MISSING_OR_INVALID_PRIVY_CLIENT_ID=\"missing_or_invalid_privy_client_id\",_.MISSING_OR_INVALID_PRIVY_ACCOUNT_ID=\"missing_or_invalid_privy_account_id\",_.MISSING_OR_INVALID_TOKEN=\"missing_or_invalid_token\",_.MISSING_MFA_ENROLLMENT=\"missing_mfa_enrollment\",_.MISSING_OR_INVALID_MFA=\"missing_or_invalid_mfa\",_.EXPIRED_OR_INVALID_MFA_TOKEN=\"expired_or_invalid_mfa_token\",_.INVALID_DATA=\"invalid_data\",_.INVALID_CREDENTIALS=\"invalid_credentials\",_.INVALID_CAPTCHA=\"invalid_captcha\",_.LINKED_TO_ANOTHER_USER=\"linked_to_another_user\",_.ALLOWLIST_REJECTED=\"allowlist_rejected\",_.CANNOT_UNLINK_EMBEDDED_WALLET=\"cannot_unlink_embedded_wallet\",_.CANNOT_UNLINK_SOLE_ACCOUNT=\"cannot_unlink_sole_account\",_.CANNOT_LINK_MORE_OF_TYPE=\"cannot_link_more_of_type\",_.LINKED_ACCOUNT_NOT_FOUND=\"linked_account_not_found\",_.TOO_MANY_REQUESTS=\"too_many_requests\",_.RESOURCE_CONFLICT=\"resource_conflict\",_.INVALID_ORIGIN=\"invalid_origin\",_.MISSING_ORIGIN=\"missing_origin\",_.INVALID_NATIVE_APP_ID=\"invalid_native_app_id\",_.TOKEN_ALREADY_USED=\"token_already_used\",_.ALREADY_LOGGED_OUT=\"already_logged_out\",_.NOT_SUPPORTED=\"not_supported\",_.USER_UNSUBSCRIBED=\"user_unsubscribed\",_.MAX_APPS_REACHED=\"max_apps_reached\",_.USER_LIMIT_REACHED=\"max_accounts_reached\",_.DEVICE_REVOKED=\"device_revoked\",_.WALLET_PASSWORD_EXISTS=\"wallet_password_exists\",_.OAUTH_STATE_MISMATCH=\"oauth_state_mismatch\",_.MAX_DENYLIST_ENTRIES_REACHED=\"max_denylist_entries_reached\",_.MAX_TEST_ACCOUNTS_REACHED=\"max_test_accounts_reached\",_.DISALLOWED_LOGIN_METHOD=\"disallowed_login_method\",_.DISALLOWED_PLUS_EMAIL=\"disallowed_plus_email\",_.DISALLOWED_RECOVERY_METHOD=\"disallowed_recovery_method\",_.LEGACY_DASHBOARD_LOGIN_CONFIGURATION=\"legacy_dashboard_login_configuration\",_.CANNOT_SET_PASSWORD=\"cannot_set_password\",_.INVALID_PKCE_PARAMETERS=\"invalid_pkce_parameters\",_.INVALID_APP_URL_SCHEME_CONFIGURATION=\"invalid_app_url_scheme_configuration\",_.CROSS_APP_CONNECTION_NOT_ALLOWED=\"cross_app_connection_not_allowed\",_.USER_DOES_NOT_EXIST=\"user_does_not_exist\",_.ALREADY_EXISTS=\"resource_already_exists\",_.ACCOUNT_TRANSFER_REQUIRED=\"account_transfer_required\",_.USER_HAS_NOT_DELEGATED_WALLET=\"user_has_not_delegated_wallet\",_.FEATURE_NOT_ENABLED=\"feature_not_enabled\",_.INSUFFICIENT_FUNDS=\"insufficient_funds\",_.TRANSACTION_BROADCAST_FAILURE=\"transaction_broadcast_failure\",_.TRANSACTION_EXECUTION_FAILURE=\"transaction_execution_failure\",_.INVALID_POLICY_FORMAT=\"invalid_policy_format\",_.POLICY_VIOLATION=\"policy_violation\",_.AUTHORIZATION_KEY_HAS_ASSOCIATED_WALLETS=\"authorization_key_has_associated_wallets\",_.INVALID_REQUEST=\"invalid_request\",_.SIGNUP_DISABLED=\"signup_disabled\",_);export{e as PrivyErrorCode};\n","const e=(e,c)=>c?Object.entries(c).reduce(((e,[c,r])=>e.replace(`:${c}`,`${r}`)),e):e;export{e as getPathWithParams};\n","const p={path:\"/api/v1/apps/:app_id\",method:\"GET\"};export{p as AppConfig};\n","const t={path:\"/api/v1/analytics_events\",method:\"POST\"};export{t as AnalyticsEvent};\n","const s={path:\"/api/v1/sessions\",method:\"POST\"},o={path:\"/api/v1/sessions/logout\",method:\"POST\"};export{o as Logout,s as RefreshSession};\n","/*! js-cookie v3.0.5 | MIT */\n/* eslint-disable no-var */\nfunction assign (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n    for (var key in source) {\n      target[key] = source[key];\n    }\n  }\n  return target\n}\n/* eslint-enable no-var */\n\n/* eslint-disable no-var */\nvar defaultConverter = {\n  read: function (value) {\n    if (value[0] === '\"') {\n      value = value.slice(1, -1);\n    }\n    return value.replace(/(%[\\dA-F]{2})+/gi, decodeURIComponent)\n  },\n  write: function (value) {\n    return encodeURIComponent(value).replace(\n      /%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g,\n      decodeURIComponent\n    )\n  }\n};\n/* eslint-enable no-var */\n\n/* eslint-disable no-var */\n\nfunction init (converter, defaultAttributes) {\n  function set (name, value, attributes) {\n    if (typeof document === 'undefined') {\n      return\n    }\n\n    attributes = assign({}, defaultAttributes, attributes);\n\n    if (typeof attributes.expires === 'number') {\n      attributes.expires = new Date(Date.now() + attributes.expires * 864e5);\n    }\n    if (attributes.expires) {\n      attributes.expires = attributes.expires.toUTCString();\n    }\n\n    name = encodeURIComponent(name)\n      .replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent)\n      .replace(/[()]/g, escape);\n\n    var stringifiedAttributes = '';\n    for (var attributeName in attributes) {\n      if (!attributes[attributeName]) {\n        continue\n      }\n\n      stringifiedAttributes += '; ' + attributeName;\n\n      if (attributes[attributeName] === true) {\n        continue\n      }\n\n      // Considers RFC 6265 section 5.2:\n      // ...\n      // 3.  If the remaining unparsed-attributes contains a %x3B (\";\")\n      //     character:\n      // Consume the characters of the unparsed-attributes up to,\n      // not including, the first %x3B (\";\") character.\n      // ...\n      stringifiedAttributes += '=' + attributes[attributeName].split(';')[0];\n    }\n\n    return (document.cookie =\n      name + '=' + converter.write(value, name) + stringifiedAttributes)\n  }\n\n  function get (name) {\n    if (typeof document === 'undefined' || (arguments.length && !name)) {\n      return\n    }\n\n    // To prevent the for loop in the first place assign an empty array\n    // in case there are no cookies at all.\n    var cookies = document.cookie ? document.cookie.split('; ') : [];\n    var jar = {};\n    for (var i = 0; i < cookies.length; i++) {\n      var parts = cookies[i].split('=');\n      var value = parts.slice(1).join('=');\n\n      try {\n        var found = decodeURIComponent(parts[0]);\n        jar[found] = converter.read(value, found);\n\n        if (name === found) {\n          break\n        }\n      } catch (e) {}\n    }\n\n    return name ? jar[name] : jar\n  }\n\n  return Object.create(\n    {\n      set,\n      get,\n      remove: function (name, attributes) {\n        set(\n          name,\n          '',\n          assign({}, attributes, {\n            expires: -1\n          })\n        );\n      },\n      withAttributes: function (attributes) {\n        return init(this.converter, assign({}, this.attributes, attributes))\n      },\n      withConverter: function (converter) {\n        return init(assign({}, this.converter, converter), this.attributes)\n      }\n    },\n    {\n      attributes: { value: Object.freeze(defaultAttributes) },\n      converter: { value: Object.freeze(converter) }\n    }\n  )\n}\n\nvar api = init(defaultConverter, { path: '/' });\n/* eslint-enable no-var */\n\nexport { api as default };\n","import e from\"eventemitter3\";import{base64url as t}from\"jose\";import s from\"js-cookie\";import{Token as r}from\"./Token.mjs\";import{allSettled as i}from\"./utils/allSettled.mjs\";let o=\"privy:token\",n=\"privy-token\",a=\"privy:pat\",_=\"privy:refresh_token\",h=\"privy-refresh-token\",g=\"privy:id-token\",l=\"privy-id-token\",c=\"privy-session\";class k extends e{set isUsingServerCookies(e){this._isUsingServerCookies=e}async getCustomerAccessToken(){let e=await this._storage.get(o);try{return\"string\"==typeof e?new r(e).value:null}catch(e){return console.error(e),await this.destroyLocalState({reason:\"getToken_error\"}),null}}async getPrivyAccessToken(){let e=await this._storage.get(a);try{return\"string\"==typeof e?new r(e).value:null}catch(e){return console.error(e),await this.destroyLocalState({reason:\"getToken_error\"}),null}}async getRefreshToken(){let e=await this._storage.get(_);return\"string\"==typeof e?e:null}async getIdentityToken(){let e=await this._storage.get(g);return\"string\"==typeof e?e:null}get mightHaveServerCookies(){try{let e=s.get(c);return void 0!==e&&e.length>0}catch(e){console.error(e)}return!1}hasRefreshCredentials(e,t){return this.mightHaveServerCookies||\"string\"==typeof e&&\"string\"==typeof t}tokenIsActive(e){if(!e)return!1;let t=r.parse(e);return null!==t&&!t.isExpired(30)}async destroyLocalState(e){await i([this._storage.del(o),this._storage.del(_),this._storage.del(g),this._storage.del(this.GUEST_CREDENTIAL_STORAGE_KEY)]),s.remove(n),s.remove(h),s.remove(l),s.remove(c),e?.reason&&this.emit(\"storage_cleared\",{reason:e.reason})}async storeCustomerAccessToken(e){if(\"string\"==typeof e){let t=await this._storage.get(o);if(await this._storage.put(o,e),!this._isUsingServerCookies){let t=r.parse(e)?.expiration;s.set(n,e,{sameSite:\"Strict\",secure:!0,expires:t?new Date(1e3*t):void 0})}t!==e&&this.emit(\"token_stored\",{cookiesEnabled:this._isUsingServerCookies})}else{let e=await this._storage.get(o);await this._storage.del(o),s.remove(n),null!==e&&this.emit(\"token_cleared\",{reason:\"set_with_non_string_value\"})}}async storePrivyAccessToken(e){\"string\"==typeof e?await this._storage.put(a,e):await this._storage.del(a)}async storeRefreshToken(e){\"string\"==typeof e?(await this._storage.put(_,e),this._isUsingServerCookies||(s.set(c,\"t\",{sameSite:\"Strict\",secure:!0,expires:30}),s.set(h,e,{sameSite:\"Strict\",secure:!0,expires:30})),this.emit(\"refresh_token_stored\",{cookiesEnabled:this._isUsingServerCookies})):(await this._storage.del(_),s.remove(h),s.remove(c),this.emit(\"refresh_token_cleared\",{reason:\"set_with_non_string_value\"}))}async updateWithTokensResponse(e){let t=(await i([this.storeCustomerAccessToken(e.token),this.storePrivyAccessToken(e.privy_access_token),this.storeRefreshToken(e.refresh_token),this.storeIdentityToken(e.identity_token),this.processOAuthTokens(e.oauth_tokens)])).filter((e=>\"rejected\"===e.status));t.length>0&&this.emit(\"error_storing_tokens\",t.map((e=>String(e.reason))).join(\", \"))}async processOAuthTokens(e){e&&this.emit(\"oauth_tokens_granted\",e)}async storeIdentityToken(e){if(\"string\"==typeof e){let t=await this._storage.get(g);if(await this._storage.put(g,e),!this._isUsingServerCookies){let t=r.parse(e)?.expiration;s.set(l,e,{sameSite:\"Strict\",secure:!0,expires:t?new Date(1e3*t):void 0})}t!==e&&this.emit(\"identity_token_stored\",{cookiesEnabled:this._isUsingServerCookies})}else{let e=await this._storage.get(g);await this._storage.del(g),s.remove(l),null!==e&&this.emit(\"identity_token_cleared\",{reason:\"set_with_non_string_value\"})}}async getOrCreateGuestCredential(){let e=this._storage.get(this.GUEST_CREDENTIAL_STORAGE_KEY);if(e&&\"string\"==typeof e)return e;let s=t.encode(crypto.getRandomValues(new Uint8Array(32)));return await this._storage.put(this.GUEST_CREDENTIAL_STORAGE_KEY,s),s}constructor(e){super(),this._isUsingServerCookies=!1,this._storage=e.storage,this.GUEST_CREDENTIAL_STORAGE_KEY=`privy:guest:${e.appId}`}}k.events=[\"storage_cleared\",\"token_cleared\",\"refresh_token_cleared\",\"identity_token_cleared\",\"token_stored\",\"refresh_token_stored\",\"identity_token_stored\",\"oauth_tokens_granted\",\"error_storing_tokens\"];export{k as Session};\n","const e=Promise.allSettled.bind(Promise)??(e=>Promise.all(e.map((e=>e.then((e=>({status:\"fulfilled\",value:e}))).catch((e=>({status:\"rejected\",reason:e})))))));export{e as allSettled};\n","var t=t=>{let e=new AbortController;return setTimeout((()=>e.abort()),t),e.signal};export{t as default};\n","function r(r){let n=new URLSearchParams;for(let t in r)null!=r[t]&&n.append(t,String(r[t]));return Array.from(n).length?\"?\"+n.toString():\"\"}export{r as toSearchParams};\n","const o=()=>{};export{o as noop};\n","import{noop as e}from\"../utils/noop.mjs\";let o={NONE:Number.NEGATIVE_INFINITY,ERROR:1,WARN:2,INFO:3,DEBUG:Number.POSITIVE_INFINITY};const r=({level:r}={level:\"ERROR\"})=>({get level(){return r},error:o[r]>=o.ERROR?console.error:e,warn:o[r]>=o.WARN?console.warn:e,info:o[r]>=o.INFO?console.info:e,debug:o[r]>=o.DEBUG?console.debug:e});export{r as toConsoleLogger};\n","const e={path:\"/api/v1/users/me/accept_terms\",method:\"POST\"};export{e as AcceptTermsOnUser};\n","import{AcceptTermsOnUser as r}from\"@privy-io/routes\";class t{async get(){let{user:r}=await this._privyInternal.refreshSession();return{user:r}}async acceptTerms(){return{user:await this._privyInternal.fetch(r,{})}}constructor(r){this._privyInternal=r}}export{t as default};\n","const t={path:\"/api/v1/custom_jwt_account/authenticate\",method:\"POST\"},a={path:\"/api/v1/custom_jwt_account/link\",method:\"POST\"};export{t as CustomJWTAuthenticate,a as CustomJWTLink};\n","const e=e=>\"wallet\"===e.type&&\"privy\"===e.wallet_client_type&&\"embedded\"===e.connector_type;export{e as isEmbeddedWalletAccount};\n","import{isEmbeddedWalletAccount as e}from\"./embedded-wallets.mjs\";const t=t=>t?t.linked_accounts.filter(e).filter((e=>\"ethereum\"===e.chain_type)).sort(((e,t)=>e.wallet_index-t.wallet_index)):[];export{t as getAllUserEmbeddedEthereumWallets};\n","import{getAllUserEmbeddedEthereumWallets as e}from\"./getAllUserEmbeddedEthereumWallets.mjs\";import\"./embedded-wallets.mjs\";const l=l=>e(l).find((e=>0===e.wallet_index))??null,t=l;export{l as getUserEmbeddedEthereumWallet,t as getUserEmbeddedWallet};\n","import{isEmbeddedWalletAccount as e}from\"./embedded-wallets.mjs\";const t=t=>t?t.linked_accounts.filter(e).filter((e=>\"solana\"===e.chain_type)).sort(((e,t)=>e.wallet_index-t.wallet_index)):[];export{t as getAllUserEmbeddedSolanaWallets};\n","import{getAllUserEmbeddedSolanaWallets as e}from\"./getAllUserEmbeddedSolanaWallets.mjs\";import\"./embedded-wallets.mjs\";const l=l=>e(l).find((e=>0===e.wallet_index))??null;export{l as getUserEmbeddedSolanaWallet};\n","import{getAllUserEmbeddedEthereumWallets as e}from\"./getAllUserEmbeddedEthereumWallets.mjs\";import\"./embedded-wallets.mjs\";const t=(t,l)=>!(\"off\"===l||e(t).length>0||t.linked_accounts.filter((e=>\"wallet\"===e.type&&\"ethereum\"===e.chain_type)).length>0&&\"all-users\"!==l);export{t as shouldCreateEmbeddedEthWallet};\n","import{getAllUserEmbeddedSolanaWallets as e}from\"./getAllUserEmbeddedSolanaWallets.mjs\";import\"./embedded-wallets.mjs\";const l=(l,t)=>!(\"off\"===t||e(l).length>0||l.linked_accounts.filter((e=>\"wallet\"===e.type&&\"solana\"===e.chain_type)).length>0&&\"all-users\"!==t);export{l as shouldCreateEmbeddedSolWallet};\n","import{getUserEmbeddedEthereumWallet as e}from\"../../utils/getUserEmbeddedEthereumWallet.mjs\";import{getUserEmbeddedSolanaWallet as t}from\"../../utils/getUserEmbeddedSolanaWallet.mjs\";import{shouldCreateEmbeddedEthWallet as s}from\"../../utils/shouldCreateEmbeddedEthWallet.mjs\";import{shouldCreateEmbeddedSolWallet as r}from\"../../utils/shouldCreateEmbeddedSolWallet.mjs\";import\"../../utils/getAllUserEmbeddedEthereumWallets.mjs\";import\"../../utils/embedded-wallets.mjs\";import\"../../utils/getAllUserEmbeddedSolanaWallets.mjs\";const o=async(o,a,l)=>{let u=s(a.user,l?.ethereum?.createOnLogin??\"off\"),i=r(a.user,l?.solana?.createOnLogin??\"off\");if(u&&i){let t=await o.create({recoveryMethod:\"privy\",skipCallbacks:!0});return{...await o.createSolana({ethereumAccount:e(t.user)??void 0}),is_new_user:a.is_new_user,oauth_tokens:a.oauth_tokens}}return u?{...await o.create({recoveryMethod:\"privy\",solanaAccount:t(a.user)??void 0}),is_new_user:a.is_new_user,oauth_tokens:a.oauth_tokens}:i?{...await o.createSolana({ethereumAccount:e(a.user)??void 0}),is_new_user:a.is_new_user,oauth_tokens:a.oauth_tokens}:a};export{o as maybeCreateWalletOnLogin};\n","import{CustomJWTAuthenticate as e}from\"@privy-io/routes\";import{maybeCreateWalletOnLogin as t}from\"./maybeCreateWalletOnLogin.mjs\";import\"../../utils/getUserEmbeddedEthereumWallet.mjs\";import\"../../utils/getAllUserEmbeddedEthereumWallets.mjs\";import\"../../utils/embedded-wallets.mjs\";import\"../../utils/getUserEmbeddedSolanaWallet.mjs\";import\"../../utils/getAllUserEmbeddedSolanaWallets.mjs\";import\"../../utils/shouldCreateEmbeddedEthWallet.mjs\";import\"../../utils/shouldCreateEmbeddedSolWallet.mjs\";class s{async syncWithToken(s,l,r){let d=await this._privyInternal.fetch(e,{body:{token:s,mode:r}});await this._privyInternal.session.updateWithTokensResponse(d);let i=await t(this._embedded,d,l?.embedded);return this._privyInternal.callbacks?.setUser?.(i.user),i}constructor(e,t){this._privyInternal=e,this._embedded=t}}export{s as default};\n","const s={path:\"/api/v1/passwordless/authenticate\",method:\"POST\"},a={path:\"/api/v1/passwordless/init\",method:\"POST\"},p={path:\"/api/v1/passwordless/link\",method:\"POST\"},t={path:\"/api/v1/passwordless/unlink\",method:\"POST\"},e={path:\"/api/v1/passwordless/update\",method:\"POST\"};export{s as PasswordlessAuthenticate,a as PasswordlessInit,p as PasswordlessLink,t as PasswordlessUnlink,e as PasswordlessUpdate};\n","import{PasswordlessInit as e,PasswordlessAuthenticate as t,PasswordlessLink as s,PasswordlessUpdate as i,PasswordlessUnlink as r}from\"@privy-io/routes\";import{maybeCreateWalletOnLogin as d}from\"./maybeCreateWalletOnLogin.mjs\";import\"../../utils/getUserEmbeddedEthereumWallet.mjs\";import\"../../utils/getAllUserEmbeddedEthereumWallets.mjs\";import\"../../utils/embedded-wallets.mjs\";import\"../../utils/getUserEmbeddedSolanaWallet.mjs\";import\"../../utils/getAllUserEmbeddedSolanaWallets.mjs\";import\"../../utils/shouldCreateEmbeddedEthWallet.mjs\";import\"../../utils/shouldCreateEmbeddedSolWallet.mjs\";class a{async sendCode(t,s){return this._privyInternal.fetch(e,{body:{email:t,token:s}})}async loginWithCode(e,s,i,r){let a=await this._privyInternal.fetch(t,{body:{email:e,code:s,mode:i}});await this._privyInternal.session.updateWithTokensResponse(a);let l=await d(this._embedded,a,r?.embedded);return this._privyInternal.callbacks?.setUser?.(l.user),l}async linkWithCode(e,t){await this._privyInternal.fetch(s,{body:{email:e,code:t}});let i=await this._privyInternal.refreshSession();return{user:i.user,identity_token:i.identity_token}}async updateEmail({oldEmailAddress:e,newEmailAddress:t,code:s}){await this._privyInternal.fetch(i,{body:{oldAddress:e,newAddress:t,code:s}});let r=await this._privyInternal.refreshSession();return{user:r.user,identity_token:r.identity_token}}async unlink(e){await this._privyInternal.fetch(r,{body:{address:e}});let t=await this._privyInternal.refreshSession();return{user:t.user,identity_token:t.identity_token}}constructor(e,t){this._privyInternal=e,this._embedded=t}}export{a as default};\n","const a={path:\"/api/v1/farcaster/init\",method:\"POST\"},t={path:\"/api/v1/farcaster/authenticate\",method:\"POST\"},e={path:\"/api/v1/farcaster/link\",method:\"POST\"},h={path:\"/api/v1/farcaster/unlink\",method:\"POST\"},i={path:\"/api/v1/farcaster/status\",method:\"GET\"},p={path:\"/api/v2/farcaster/init\",method:\"POST\"},r={path:\"/api/v2/farcaster/authenticate\",method:\"POST\"};export{t as FarcasterAuthenticate,a as FarcasterInit,e as FarcasterLink,i as FarcasterStatus,h as FarcasterUnlink,r as FarcasterV2Authenticate,p as FarcasterV2Init};\n","import{FarcasterInit as e,FarcasterStatus as t,FarcasterAuthenticate as r,FarcasterLink as i,FarcasterUnlink as s}from\"@privy-io/routes\";import{maybeCreateWalletOnLogin as a}from\"./maybeCreateWalletOnLogin.mjs\";import\"../../utils/getUserEmbeddedEthereumWallet.mjs\";import\"../../utils/getAllUserEmbeddedEthereumWallets.mjs\";import\"../../utils/embedded-wallets.mjs\";import\"../../utils/getUserEmbeddedSolanaWallet.mjs\";import\"../../utils/getAllUserEmbeddedSolanaWallets.mjs\";import\"../../utils/shouldCreateEmbeddedEthWallet.mjs\";import\"../../utils/shouldCreateEmbeddedSolWallet.mjs\";class n{async initializeAuth({relyingParty:t,redirectUrl:r,token:i}){return await this._privyInternal.fetch(e,{body:{relying_party:t,redirect_url:r,token:i}})}async getFarcasterStatus({channel_token:e}){return await this._privyInternal.fetch(t,{headers:{\"farcaster-channel-token\":e}})}async authenticate({channel_token:e,message:t,signature:i,fid:s,mode:n},l){let d=await this._privyInternal.fetch(r,{body:{channel_token:e,message:t,signature:i,fid:s,mode:n}});await this._privyInternal.session.updateWithTokensResponse(d);let o=await a(this._embedded,d,l?.embedded);return this._privyInternal.callbacks?.setUser?.(o.user),o}async link({channel_token:e,message:t,signature:r,fid:s}){await this._privyInternal.fetch(i,{body:{channel_token:e,message:t,signature:r,fid:s}});let a=await this._privyInternal.refreshSession();return{user:a.user,identity_token:a.identity_token}}async unlink({fid:e}){await this._privyInternal.fetch(s,{body:{fid:e}});let t=await this._privyInternal.refreshSession();return{user:t.user,identity_token:t.identity_token}}constructor(e,t){this._privyInternal=e,this._embedded=t}}export{n as default};\n","import{FarcasterV2Init as e,FarcasterV2Authenticate as t}from\"@privy-io/routes\";import{maybeCreateWalletOnLogin as s}from\"./maybeCreateWalletOnLogin.mjs\";import\"../../utils/getUserEmbeddedEthereumWallet.mjs\";import\"../../utils/getAllUserEmbeddedEthereumWallets.mjs\";import\"../../utils/embedded-wallets.mjs\";import\"../../utils/getUserEmbeddedSolanaWallet.mjs\";import\"../../utils/getAllUserEmbeddedSolanaWallets.mjs\";import\"../../utils/shouldCreateEmbeddedEthWallet.mjs\";import\"../../utils/shouldCreateEmbeddedSolWallet.mjs\";class i{async initializeAuth(){return await this._privyInternal.fetch(e,{body:{}})}async authenticate({message:e,signature:i,fid:a},l){let r=await this._privyInternal.fetch(t,{body:{message:e,signature:i,fid:a}});await this._privyInternal.session.updateWithTokensResponse(r);let d=await s(this._embedded,r,l?.embedded);return this._privyInternal.callbacks?.setUser?.(d.user),d}constructor(e,t){this._privyInternal=e,this._embedded=t}}export{i as default};\n","const t={path:\"/api/v1/guest/authenticate\",method:\"POST\"};export{t as GuestAuthenticate};\n","import{GuestAuthenticate as e}from\"@privy-io/routes\";import{maybeCreateWalletOnLogin as t}from\"./maybeCreateWalletOnLogin.mjs\";import\"../../utils/getUserEmbeddedEthereumWallet.mjs\";import\"../../utils/getAllUserEmbeddedEthereumWallets.mjs\";import\"../../utils/embedded-wallets.mjs\";import\"../../utils/getUserEmbeddedSolanaWallet.mjs\";import\"../../utils/getAllUserEmbeddedSolanaWallets.mjs\";import\"../../utils/shouldCreateEmbeddedEthWallet.mjs\";import\"../../utils/shouldCreateEmbeddedSolWallet.mjs\";class s{async create(s){let l=await this._privyInternal.session.getOrCreateGuestCredential(),r=await this._privyInternal.fetch(e,{body:{guest_credential:l}});await this._privyInternal.session.updateWithTokensResponse(r);let a=await t(this._embedded,r,s?.embedded);return this._privyInternal.callbacks?.setUser?.(a.user),a}constructor(e,t){this._privyInternal=e,this._embedded=t}}export{s as default};\n","const t={path:\"/api/v1/oauth/authenticate\",method:\"POST\"},a={path:\"/api/v1/oauth/init\",method:\"POST\"},h={path:\"/api/v1/oauth/link\",method:\"POST\"},o={path:\"/api/v1/oauth/unlink\",method:\"POST\"};export{t as OAuthAuthenticate,a as OAuthInit,h as OAuthLink,o as OAuthUnlink};\n","import{base64url as e}from\"jose\";const t=\"privy:state_code\",n=\"privy:code_verifier\";async function r(e,t){let n=(new TextEncoder).encode(e);return new Uint8Array(await t(\"SHA-256\",n))}function o(e){return crypto.getRandomValues(new Uint8Array(e))}function i(){return e.encode(o(36))}function c(){return i()}async function u({codeVerifier:t,method:n=\"S256\",digest:o=crypto.subtle.digest.bind(crypto.subtle)}){if(\"S256\"!=n)return t;{let n=await r(t,o);return e.encode(n)}}export{n as CODE_VERIFIER_KEY,t as STATE_CODE_KEY,i as createCodeVerifier,r as createHashBuffer,c as createStateCode,u as deriveCodeChallengeFromCodeVerifier,o as randomBytes};\n","import{OAuthInit as e,OAuthAuthenticate as t,OAuthLink as i,OAuthUnlink as s}from\"@privy-io/routes\";import{PrivyClientError as r}from\"../../Error.mjs\";import{createCodeVerifier as a,createStateCode as o,deriveCodeChallengeFromCodeVerifier as l,CODE_VERIFIER_KEY as d,STATE_CODE_KEY as n}from\"../../pkce.mjs\";import{maybeCreateWalletOnLogin as h}from\"./maybeCreateWalletOnLogin.mjs\";import\"jose\";import\"../../utils/getUserEmbeddedEthereumWallet.mjs\";import\"../../utils/getAllUserEmbeddedEthereumWallets.mjs\";import\"../../utils/embedded-wallets.mjs\";import\"../../utils/getUserEmbeddedSolanaWallet.mjs\";import\"../../utils/getAllUserEmbeddedSolanaWallets.mjs\";import\"../../utils/shouldCreateEmbeddedEthWallet.mjs\";import\"../../utils/shouldCreateEmbeddedSolWallet.mjs\";class m{async generateURL(t,i){let s=a(),r=o(),h=await l({codeVerifier:s,digest:this._crypto?.digest});return await Promise.all([this._storage.put(d,s),this._storage.put(n,r)]),this._privyInternal.fetch(e,{body:{redirect_to:i,provider:t,code_challenge:h,state_code:r}})}async loginWithCode(e,i,s,a,o,l){let[m,p]=await Promise.all([this._storage.get(d),this._storage.get(n)]);if(p!==i)throw this._privyInternal.createAnalyticsEvent(\"possible_phishing_attempt\",{flow:\"oauth\",provider:s,storedStateCode:p??\"\",returnedStateCode:i??\"\"}),new r({code:\"pkce_state_code_mismatch\",error:\"Unexpected auth flow. This may be a phishing attempt.\"});let _=await this._privyInternal.fetch(t,{body:{authorization_code:e,code_type:a,state_code:p,code_verifier:m,mode:o}});await this._privyInternal.session.updateWithTokensResponse(_);let c=await h(this._embedded,_,l?.embedded);return await Promise.all([this._storage.del(d),this._storage.del(n)]),this._privyInternal.callbacks?.setUser?.(c.user),c}async linkWithCode(e,t,s,a){let[o,l]=await Promise.all([this._storage.get(d),this._storage.get(n)]);if(l!==t)throw this._privyInternal.createAnalyticsEvent(\"possible_phishing_attempt\",{flow:\"oauth\",provider:s,storedStateCode:l??\"\",returnedStateCode:t??\"\"}),new r({code:\"pkce_state_code_mismatch\",error:\"Unexpected auth flow. This may be a phishing attempt.\"});let h=await this._privyInternal.fetch(i,{body:{authorization_code:e,code_type:a,state_code:l,code_verifier:o}});await this._privyInternal.session.processOAuthTokens(h.oauth_tokens);let m=await this._privyInternal.refreshSession();return await Promise.all([this._storage.del(d),this._storage.del(n)]),{user:m.user,identity_token:m.identity_token}}async unlink(e,t){await this._privyInternal.fetch(s,{body:{provider:e,subject:t}});let i=await this._privyInternal.refreshSession();return{user:i.user,identity_token:i.identity_token}}constructor(e,t,i,s){this._privyInternal=e,this._embedded=t,this._storage=i,this._crypto=s}}export{m as default};\n","const t={path:\"/api/v1/passkeys/link\",method:\"POST\"},a={path:\"/api/v1/passkeys/authenticate\",method:\"POST\"},s={path:\"/api/v1/passkeys/register\",method:\"POST\"},e={path:\"/api/v1/passkeys/authenticate/init\",method:\"POST\"},p={path:\"/api/v1/passkeys/register/init\",method:\"POST\"},i={path:\"/api/v1/passkeys/link/init\",method:\"POST\"},h={path:\"/api/v1/passkeys/unlink\",method:\"POST\"};export{a as PasskeyAuthenticate,e as PasskeyAuthenticateInit,t as PasskeyLink,i as PasskeyLinkInit,s as PasskeyRegister,p as PasskeyRegisterInit,h as PasskeyUnlink};\n","import{PasskeyLinkInit as e,PasskeyAuthenticateInit as t,PasskeyRegisterInit as s,PasskeyAuthenticate as a,PasskeyRegister as n,PasskeyLink as i}from\"@privy-io/routes\";import{maybeCreateWalletOnLogin as r}from\"./maybeCreateWalletOnLogin.mjs\";import\"../../utils/getUserEmbeddedEthereumWallet.mjs\";import\"../../utils/getAllUserEmbeddedEthereumWallets.mjs\";import\"../../utils/embedded-wallets.mjs\";import\"../../utils/getUserEmbeddedSolanaWallet.mjs\";import\"../../utils/getAllUserEmbeddedSolanaWallets.mjs\";import\"../../utils/shouldCreateEmbeddedEthWallet.mjs\";import\"../../utils/shouldCreateEmbeddedSolWallet.mjs\";class o{async generateRegistrationOptions(t){return await this._privyInternal.fetch(e,{body:{relying_party:t}})}async generateAuthenticationOptions(e){return await this._privyInternal.fetch(t,{body:{relying_party:e}})}async generateSignupOptions(e){return await this._privyInternal.fetch(s,{body:{relying_party:e}})}async loginWithPasskey(e,t,s,n){let i=await this._privyInternal.fetch(a,{body:{relying_party:s,challenge:t,authenticator_response:this._transformAuthenticationResponseToSnakeCase(e)}});await this._privyInternal.session.updateWithTokensResponse(i);let o=await r(this._embedded,i,n?.embedded);return this._privyInternal.callbacks?.setUser?.(o.user),o}async signupWithPasskey(e,t,s){let a=await this._privyInternal.fetch(n,{body:{relying_party:t,authenticator_response:this._transformRegistrationResponseToSnakeCase(e)}});await this._privyInternal.session.updateWithTokensResponse(a);let i=await r(this._embedded,a,s?.embedded);return this._privyInternal.callbacks?.setUser?.(i.user),i}async linkWithPasskey(e,t){await this._privyInternal.fetch(i,{body:{relying_party:t,authenticator_response:this._transformRegistrationResponseToSnakeCase(e)}});let s=await this._privyInternal.refreshSession();return{user:s.user,identity_token:s.identity_token}}_transformRegistrationResponseToSnakeCase(e){return{type:e.type,id:e.id,raw_id:e.rawId,response:{client_data_json:e.response.clientDataJSON,attestation_object:e.response.attestationObject,authenticator_data:e.response.authenticatorData||void 0,transports:e.response.transports||void 0,public_key:e.response.publicKey||void 0,public_key_algorithm:e.response.publicKeyAlgorithm||void 0},authenticator_attachment:e.authenticatorAttachment||void 0,client_extension_results:{app_id:e.clientExtensionResults.appid||void 0,cred_props:e.clientExtensionResults.credProps||void 0,hmac_create_secret:e.clientExtensionResults.hmacCreateSecret||void 0}}}_transformAuthenticationResponseToSnakeCase(e){return{type:e.type,id:e.id,raw_id:e.rawId,response:{signature:e.response.signature,client_data_json:e.response.clientDataJSON,authenticator_data:e.response.authenticatorData,user_handle:e.response.userHandle||void 0},authenticator_attachment:e.authenticatorAttachment||void 0,client_extension_results:{app_id:e.clientExtensionResults.appid||void 0,cred_props:e.clientExtensionResults.credProps||void 0,hmac_create_secret:e.clientExtensionResults.hmacCreateSecret||void 0}}}constructor(e,t){this._privyInternal=e,this._embedded=t}}export{o as default};\n","const s={path:\"/api/v1/passwordless_sms/authenticate\",method:\"POST\"},a={path:\"/api/v1/passwordless_sms/init\",method:\"POST\"},p={path:\"/api/v1/passwordless_sms/link\",method:\"POST\"},t={path:\"/api/v1/passwordless_sms/unlink\",method:\"POST\"},e={path:\"/api/v1/passwordless_sms/update\",method:\"POST\"};export{s as PasswordlessSmsAuthenticate,a as PasswordlessSmsInit,p as PasswordlessSmsLink,t as PasswordlessSmsUnlink,e as PasswordlessSmsUpdate};\n","import{PasswordlessSmsInit as e,PasswordlessSmsAuthenticate as t,PasswordlessSmsLink as r,PasswordlessSmsUpdate as i,PasswordlessSmsUnlink as n}from\"@privy-io/routes\";import{maybeCreateWalletOnLogin as s}from\"./maybeCreateWalletOnLogin.mjs\";import\"../../utils/getUserEmbeddedEthereumWallet.mjs\";import\"../../utils/getAllUserEmbeddedEthereumWallets.mjs\";import\"../../utils/embedded-wallets.mjs\";import\"../../utils/getUserEmbeddedSolanaWallet.mjs\";import\"../../utils/getAllUserEmbeddedSolanaWallets.mjs\";import\"../../utils/shouldCreateEmbeddedEthWallet.mjs\";import\"../../utils/shouldCreateEmbeddedSolWallet.mjs\";class o{async sendCode(t,r){return this._privyInternal.fetch(e,{body:{phoneNumber:t,token:r}})}async loginWithCode(e,r,i,n){let o=await this._privyInternal.fetch(t,{body:{phoneNumber:e,code:r,mode:i}});await this._privyInternal.session.updateWithTokensResponse(o);let a=await s(this._embedded,o,n?.embedded);return this._privyInternal.callbacks?.setUser?.(a.user),a}async linkWithCode(e,t){await this._privyInternal.fetch(r,{body:{phoneNumber:e,code:t}});let i=await this._privyInternal.refreshSession();return{user:i.user,identity_token:i.identity_token}}async updatePhone({oldPhoneNumber:e,newPhoneNumber:t,code:r}){await this._privyInternal.fetch(i,{body:{old_phone_number:e,new_phone_number:t,code:r}});let n=await this._privyInternal.refreshSession();return{user:n.user,identity_token:n.identity_token}}async unlink(e){await this._privyInternal.fetch(n,{body:{phoneNumber:e}});let t=await this._privyInternal.refreshSession();return{user:t.user,identity_token:t.identity_token}}constructor(e,t){this._privyInternal=e,this._embedded=t}}export{o as default};\n","const t={path:\"/api/v1/siwe/init\",method:\"POST\"},i={path:\"/api/v1/siwe/authenticate\",method:\"POST\"},a={path:\"/api/v1/siwe/link\",method:\"POST\"},e={path:\"/api/v1/siwe/link_smart_wallet\",method:\"POST\"},h={path:\"/api/v1/siwe/unlink\",method:\"POST\"};export{i as SiweAuthenticate,t as SiweInit,a as SiweLink,e as SiweLinkSmartWallet,h as SiweUnlink};\n","import{SiweUnlink as e,SiweLink as t,SiweAuthenticate as i,SiweInit as n}from\"@privy-io/routes\";import{maybeCreateWalletOnLogin as s}from\"./maybeCreateWalletOnLogin.mjs\";import\"../../utils/getUserEmbeddedEthereumWallet.mjs\";import\"../../utils/getAllUserEmbeddedEthereumWallets.mjs\";import\"../../utils/embedded-wallets.mjs\";import\"../../utils/getUserEmbeddedSolanaWallet.mjs\";import\"../../utils/getAllUserEmbeddedSolanaWallets.mjs\";import\"../../utils/shouldCreateEmbeddedEthWallet.mjs\";import\"../../utils/shouldCreateEmbeddedSolWallet.mjs\";class r{async unlinkWallet(t){await this._privyInternal.fetch(e,{body:{address:t}});let i=await this._privyInternal.refreshSession();return{user:i.user,identity_token:i.identity_token}}async linkWithSiwe(e,i,n){let s=i||this._wallet,r=n||this._preparedMessage;if(!s)throw Error(\"A wallet must be provided in the init step or as an argument to linkWithSiwe\");if(!r)throw Error(\"A message must be generated and signed before being used to link a wallet to privy\");await this._privyInternal.fetch(t,{body:{message:r,signature:e,chainId:s.chainId,walletClientType:s.walletClientType??null,connectorType:s.connectorType??null}});let a=await this._privyInternal.refreshSession();return{user:a.user,identity_token:a.identity_token}}async loginWithSiwe(e,t,n,r,a){let l=t||this._wallet,o=n||this._preparedMessage;if(!l)throw Error(\"A wallet must be provided in the init step or as an argument to loginWithSiwe\");if(!o)throw Error(\"A message must be generated and signed before being used to login to privy with a wallet\");let d=await this._privyInternal.fetch(i,{body:{signature:e,message:o,chainId:l.chainId,walletClientType:l.walletClientType??null,connectorType:l.connectorType??null,mode:r}});await this._privyInternal.session.updateWithTokensResponse(d);let h=await s(this._embedded,d,a?.embedded);return this._privyInternal.callbacks?.setUser?.(h.user),h}async init(e,t,i){var s;this._wallet=e;let{nonce:r}=await this._privyInternal.fetch(n,{body:{address:e.address}}),a=`${(s={chainId:e.chainId.toString().replace(\"eip155:\",\"\"),address:e.address,issuedAt:(new Date).toISOString(),statement:\"By signing, you are proving you own this wallet and logging in. This does not initiate a transaction or cost any fees.\",domain:t,nonce:r,uri:i}).domain} wants you to sign in with your Ethereum account:\\n${s.address}\\n\\n${s.statement}\\n\\nURI: ${s.uri}\\nVersion: 1\\nChain ID: ${s.chainId}\\nNonce: ${s.nonce}\\nIssued At: ${s.issuedAt}\\nResources:\\n- https://privy.io`;return this._preparedMessage=a,{nonce:r,message:a}}constructor(e,t){this._wallet=void 0,this._privyInternal=e,this._embedded=t}}export{r as default};\n","const t={path:\"/api/v1/siws/init\",method:\"POST\"},i={path:\"/api/v1/siws/authenticate\",method:\"POST\"},a={path:\"/api/v1/siws/link\",method:\"POST\"},h={path:\"/api/v1/siws/unlink\",method:\"POST\"};export{i as SiwsAuthenticate,t as SiwsInit,a as SiwsLink,h as SiwsUnlink};\n","import{SiwsUnlink as e,SiwsLink as t,SiwsAuthenticate as s,SiwsInit as l}from\"@privy-io/routes\";import{maybeCreateWalletOnLogin as n}from\"./maybeCreateWalletOnLogin.mjs\";import\"../../utils/getUserEmbeddedEthereumWallet.mjs\";import\"../../utils/getAllUserEmbeddedEthereumWallets.mjs\";import\"../../utils/embedded-wallets.mjs\";import\"../../utils/getUserEmbeddedSolanaWallet.mjs\";import\"../../utils/getAllUserEmbeddedSolanaWallets.mjs\";import\"../../utils/shouldCreateEmbeddedEthWallet.mjs\";import\"../../utils/shouldCreateEmbeddedSolWallet.mjs\";class r{async unlink({address:t}){await this._privyInternal.fetch(e,{body:{address:t}});let s=await this._privyInternal.refreshSession();return{user:s.user,identity_token:s.identity_token}}async link({message:e,signature:s,walletClientType:l,connectorType:n}){await this._privyInternal.fetch(t,{body:{message:e,signature:s,walletClientType:l??null,connectorType:n??null}});let r=await this._privyInternal.refreshSession();return{user:r.user,identity_token:r.identity_token}}async login({mode:e,message:t,signature:l,walletClientType:r,connectorType:i,opts:a}){let d=await this._privyInternal.fetch(s,{body:{signature:l,message:t,walletClientType:r??null,connectorType:i??null,mode:e}});await this._privyInternal.session.updateWithTokensResponse(d);let o=await n(this._embedded,d,a?.embedded);return this._privyInternal.callbacks?.setUser?.(o.user),o}async fetchNonce({address:e}){let{nonce:t}=await this._privyInternal.fetch(l,{body:{address:e}});return{nonce:t}}constructor(e,t){this._privyInternal=e,this._embedded=t}}export{r as default};\n","import{SiweLinkSmartWallet as n,SiweInit as t}from\"@privy-io/routes\";class e{async link(t,e,i,s){await this._privyInternal.fetch(n,{body:{message:t,signature:e,smart_wallet_type:i,smart_wallet_version:s}});let a=await this._privyInternal.refreshSession();return{user:a.user,identity_token:a.identity_token}}async init(n){var e;let{nonce:i}=await this._privyInternal.fetch(t,{body:{address:n.address}});return{nonce:i,message:`${(e={chainId:n.chainId.toString().replace(\"eip155:\",\"\"),address:n.address,issuedAt:(new Date).toISOString(),statement:\"By signing, you are proving you own this wallet and logging in. This does not initiate a transaction or cost any fees.\",domain:\"privy.io\",uri:\"https://auth.privy.io\",nonce:i}).domain} wants you to sign in with your Ethereum account:\\n${e.address}\\n\\n${e.statement}\\n\\nURI: ${e.uri}\\nVersion: 1\\nChain ID: ${e.chainId}\\nNonce: ${e.nonce}\\nIssued At: ${e.issuedAt}\\nResources:\\n- https://privy.io`}}constructor(n){this._privyInternal=n}}export{e as default};\n","import{Logout as t}from\"@privy-io/routes\";import e from\"./CustomProviderApi.mjs\";import r from\"./EmailApi.mjs\";import s from\"./FarcasterApi.mjs\";import i from\"./FarcasterV2Api.mjs\";import m from\"./GuestApi.mjs\";import o from\"./OAuthApi.mjs\";import a from\"./PasskeyApi.mjs\";import l from\"./PhoneApi.mjs\";import n from\"./SiweApi.mjs\";import p from\"./SiwsApi.mjs\";import h from\"./SmartWalletApi.mjs\";import\"./maybeCreateWalletOnLogin.mjs\";import\"../../utils/getUserEmbeddedEthereumWallet.mjs\";import\"../../utils/getAllUserEmbeddedEthereumWallets.mjs\";import\"../../utils/embedded-wallets.mjs\";import\"../../utils/getUserEmbeddedSolanaWallet.mjs\";import\"../../utils/getAllUserEmbeddedSolanaWallets.mjs\";import\"../../utils/shouldCreateEmbeddedEthWallet.mjs\";import\"../../utils/shouldCreateEmbeddedSolWallet.mjs\";import\"../../Error.mjs\";import\"../../pkce.mjs\";import\"jose\";class d{async logout(e){try{let e=await this._privyInternal.session.getRefreshToken()??void 0;await this._privyInternal.fetch(t,{body:{refresh_token:e}})}catch(t){console.warn(\"Error destroying session\")}await Promise.all([this._privyInternal.session.destroyLocalState({reason:\"logout\"}),this._privyInternal.destroyClientAnalyticsId(),e?.userId&&this._mfa.clearMfa({userId:e.userId})]),this._privyInternal.callbacks?.setUser?.(null)}constructor(t,d,y,u,j){this._privyInternal=t,this._mfa=j,this.customProvider=new e(this._privyInternal,d),this.phone=new l(this._privyInternal,d),this.email=new r(this._privyInternal,d),this.oauth=new o(this._privyInternal,d,y,u),this.guest=new m(this._privyInternal,d),this.siwe=new n(this._privyInternal,d),this.siws=new p(this._privyInternal,d),this.smartWallet=new h(this._privyInternal),this.passkey=new a(this._privyInternal,d),this.farcaster=new s(this._privyInternal,d),this.farcasterV2=new i(this._privyInternal,d)}}export{d as default};\n","const n={path:\"/api/v1/funding/coinbase_on_ramp/init\",method:\"POST\"},a={path:\"/api/v1/funding/coinbase_on_ramp/status\",method:\"GET\"};export{n as CoinbaseOnRampInit,a as CoinbaseOnRampStatus};\n","import{CoinbaseOnRampInit as t,CoinbaseOnRampStatus as r}from\"@privy-io/routes\";class a{async initOnRampSession(r){return await this._privyInternal.fetch(t,{body:r})}async getStatus(t){return await this._privyInternal.fetch(r,{query:{partnerUserId:t}})}constructor(t){this._privyInternal=t}}export{a as default};\n","const o={path:\"/api/v1/plugins/moonpay_on_ramp/sign\",method:\"POST\"};export{o as MoonpayOnRampSign};\n","import t from\"fetch-retry\";import{MoonpayOnRampSign as r}from\"@privy-io/routes\";import{MoonpayApiError as a}from\"../../Error.mjs\";import{MoonpayEnvironments as o}from\"../../funding/moonpay.mjs\";import\"@privy-io/chains\";class i{async sign(t){return await this._privyInternal.fetch(r,{body:t})}async getTransactionStatus({transactionId:r,useSandbox:i}){let{url:n,key:s}=o[i?\"sandbox\":\"prod\"],e=await t(fetch,{retries:3,retryDelay:500})(`${n}/transactions/ext/${r}?apiKey=${s}`);if(!e.ok)throw new a({error:`Failed to fetch transaction status for Transaction ${r}`,code:\"failed_to_fetch_moonpay_transaction_status\",response:e});let c=await e.json();return Array.isArray(c)?c.at(0):void 0}constructor(t){this._privyInternal=t}}export{i as default};\n","import o from\"./CoinbaseOnRampApi.mjs\";import r from\"./MoonpayOnRampApi.mjs\";import\"@privy-io/routes\";import\"fetch-retry\";import\"../../Error.mjs\";import\"../../funding/moonpay.mjs\";import\"@privy-io/chains\";class i{constructor(i){this.moonpay=new r(i),this.coinbase=new o(i)}}export{i as default};\n","const a={path:\"/api/v1/mfa/passkeys/init\",method:\"POST\"},e={path:\"/api/v1/mfa/passkeys/verify\",method:\"POST\"},p={path:\"/api/v1/mfa/passkeys/enrollment\",method:\"POST\"};export{p as MfaPasskeyEnrollment,a as MfaPasskeyInit,e as MfaPasskeyVerify};\n","import{MfaPasskeyInit as t}from\"@privy-io/routes\";class r{async generateAuthenticationOptions(r){return await this._privyInternal.fetch(t,{body:r})}constructor(t){this._privyInternal=t}}export{r as default};\n","const s={path:\"/api/v1/mfa/passwordless_sms/enroll\",method:\"POST\"},a={path:\"/api/v1/mfa/passwordless_sms/verify\",method:\"POST\"},p={path:\"/api/v1/mfa/passwordless_sms/init\",method:\"POST\"},e={path:\"/api/v1/mfa/passwordless_sms/unenroll\",method:\"POST\"};export{s as MfaPasswordlessSmsEnroll,p as MfaPasswordlessSmsInit,e as MfaPasswordlessSmsUnenroll,a as MfaPasswordlessSmsVerify};\n","import{MfaPasswordlessSmsInit as r}from\"@privy-io/routes\";class t{async sendCode(t){return await this._privyInternal.fetch(r,{body:t})}constructor(r){this._privyInternal=r}}export{t as default};\n","import{PrivyClientError as e}from\"../../Error.mjs\";import t from\"./MfaPasskeyApi.mjs\";import r from\"./MfaSmsApi.mjs\";import\"@privy-io/routes\";class i{setProxy(e){this.proxy=e}async getAccessTokenInternal(){let t=await this.privyInternal.getAccessTokenInternal();if(!t)throw new e({error:\"Missing access token\",code:\"attempted_rpc_call_before_logged_in\"});return t}async verifyMfa(){if(!this.proxy)throw new e({error:\"Embedded wallet proxy not initialized\",code:\"embedded_wallet_webview_not_loaded\"});return await this.proxy.verifyMfa({accessToken:await this.getAccessTokenInternal()})}async initEnrollMfa(t){if(!this.proxy)throw new e({error:\"Embedded wallet proxy not initialized\",code:\"embedded_wallet_webview_not_loaded\"});return await this.proxy.initEnrollMfa({...t,accessToken:await this.getAccessTokenInternal()})}async submitEnrollMfa(t){if(!this.proxy)throw new e({error:\"Embedded wallet proxy not initialized\",code:\"embedded_wallet_webview_not_loaded\"});let r=await this.proxy.submitEnrollMfa({...t,accessToken:await this.getAccessTokenInternal()});return await this.privyInternal.refreshSession(),r}async unenrollMfa(t){if(!this.proxy)throw new e({error:\"Embedded wallet proxy not initialized\",code:\"embedded_wallet_webview_not_loaded\"});let r=await this.proxy.unenrollMfa({method:t,accessToken:await this.getAccessTokenInternal()});return await this.privyInternal.refreshSession(),r}async clearMfa(t){if(!this.proxy)throw new e({error:\"Embedded wallet proxy not initialized\",code:\"embedded_wallet_webview_not_loaded\"});return await this.proxy.clearMfa(t)}constructor(e,i){this.proxy=i,this.privyInternal=e,this.sms=new r(e),this.passkey=new t(e)}}export{i as default};\n","const e={path:\"/api/v1/embedded_wallets/:address/recovery/key_material\",method:\"POST\"},a={path:\"/api/v1/recovery/oauth/init\",method:\"POST\"},t={path:\"/api/v1/recovery/oauth/authenticate\",method:\"POST\"},o={path:\"/api/v1/recovery/oauth/init_icloud\",method:\"POST\"},i={path:\"/api/v1/recovery/oauth/callback_icloud/:app_id/expo_ios\",method:\"GET\"},h={path:\"/api/v1/recovery/configuration_icloud\",method:\"POST\"};export{h as RecoveryConfigurationICloud,e as RecoveryKeyMaterial,t as RecoveryOAuthAuthenticate,i as RecoveryOAuthCallbackICloudExpo,a as RecoveryOAuthInit,o as RecoveryOAuthInitICloud};\n","import{RecoveryOAuthInitICloud as t,RecoveryConfigurationICloud as r}from\"@privy-io/routes\";let e=class{async init(r){return this._privyInternal.fetch(t,{body:{client_type:r}})}async getICloudConfiguration(t){return this._privyInternal.fetch(r,{body:{client_type:t}})}constructor(t){this._privyInternal=t}};export{e as default};\n","import{RecoveryOAuthInit as t,RecoveryOAuthAuthenticate as e}from\"@privy-io/routes\";import{PrivyClientError as r}from\"../../Error.mjs\";import{createCodeVerifier as i,createStateCode as o,deriveCodeChallengeFromCodeVerifier as a,CODE_VERIFIER_KEY as s,STATE_CODE_KEY as h}from\"../../pkce.mjs\";import\"jose\";class c{async generateURL(e){let r=i(),c=o(),_=await a({codeVerifier:r,digest:this._crypto?.digest});return await Promise.all([this._storage.put(s,r),this._storage.put(h,c)]),this._privyInternal.fetch(t,{body:{redirect_to:e,code_challenge:_,state_code:c}})}async authorize(t,i){let[o,a]=await Promise.all([this._storage.get(s),this._storage.get(h)]);if(a!==i)throw this._privyInternal.createAnalyticsEvent(\"possible_phishing_attempt\",{flow:\"recovery_oauth\",storedStateCode:a??\"\",returnedStateCode:i??\"\"}),new r({code:\"pkce_state_code_mismatch\",error:\"Unexpected auth flow. This may be a phishing attempt.\"});let c=await this._privyInternal.fetch(e,{body:{authorization_code:t,state_code:a,code_verifier:o}});return await Promise.all([this._storage.del(s),this._storage.del(h)]),c}constructor(t,e,r){this._privyInternal=t,this._storage=e,this._crypto=r}}export{c as default};\n","import{RecoveryKeyMaterial as r}from\"@privy-io/routes\";import t from\"./RecoveryICloudApi.mjs\";import e from\"./RecoveryOAuthApi.mjs\";import\"../../Error.mjs\";import\"../../pkce.mjs\";import\"jose\";class i{async getRecoveryKeyMaterial(t,e){return this._privyInternal.fetch(r,{body:{chain_type:e},params:{address:t}})}constructor(r,i,o){this._privyInternal=r,this.auth=new e(this._privyInternal,i,o),this.icloudAuth=new t(this._privyInternal)}}export{i as default};\n","/**\n * To add a new error, follow the instructions at\n * https://github.com/anza-xyz/kit/tree/main/packages/errors/#adding-a-new-error\n *\n * @module\n * @privateRemarks\n * WARNING:\n *   - Don't remove error codes\n *   - Don't change or reorder error codes.\n *\n * Good naming conventions:\n *   - Prefixing common errors  e.g. under the same package  can be a good way to namespace them. E.g. All codec-related errors start with `SOLANA_ERROR__CODECS__`.\n *   - Use consistent names  e.g. choose `PDA` or `PROGRAM_DERIVED_ADDRESS` and stick with it. Ensure your names are consistent with existing error codes. The decision might have been made for you.\n *   - Recommended prefixes and suffixes:\n *     - `MALFORMED_`: Some input was not constructed properly. E.g. `MALFORMED_BASE58_ENCODED_ADDRESS`.\n *     - `INVALID_`: Some input is invalid (other than because it was MALFORMED). E.g. `INVALID_NUMBER_OF_BYTES`.\n *     - `EXPECTED_`: Some input was different than expected, no need to specify the \"GOT\" part unless necessary. E.g. `EXPECTED_DECODED_ACCOUNT`.\n *     - `_CANNOT_`: Some operation cannot be performed or some input cannot be used due to some condition. E.g. `CANNOT_DECODE_EMPTY_BYTE_ARRAY` or `PDA_CANNOT_END_WITH_PDA_MARKER`.\n *     - `_MUST_BE_`: Some condition must be true. E.g. `NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE`.\n *     - `_FAILED_TO_`: Tried to perform some operation and failed. E.g. `FAILED_TO_DECODE_ACCOUNT`.\n *     - `_NOT_FOUND`: Some operation lead to not finding something. E.g. `ACCOUNT_NOT_FOUND`.\n *     - `_OUT_OF_RANGE`: Some value is out of range. E.g. `ENUM_DISCRIMINATOR_OUT_OF_RANGE`.\n *     - `_EXCEEDED`: Some limit was exceeded. E.g. `PDA_MAX_SEED_LENGTH_EXCEEDED`.\n *     - `_MISMATCH`: Some elements do not match. E.g. `ENCODER_DECODER_FIXED_SIZE_MISMATCH`.\n *     - `_MISSING`: Some required input is missing. E.g. `TRANSACTION_FEE_PAYER_MISSING`.\n *     - `_UNIMPLEMENTED`: Some required component is not available in the environment. E.g. `SUBTLE_CRYPTO_VERIFY_FUNCTION_UNIMPLEMENTED`.\n */\nexport const SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED = 1;\nexport const SOLANA_ERROR__INVALID_NONCE = 2;\nexport const SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND = 3;\nexport const SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE = 4;\nexport const SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH = 5;\nexport const SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE = 6;\nexport const SOLANA_ERROR__MALFORMED_BIGINT_STRING = 7;\nexport const SOLANA_ERROR__MALFORMED_NUMBER_STRING = 8;\nexport const SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE = 9;\nexport const SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR = 10;\n\n// JSON-RPC-related errors.\n// Reserve error codes in the range [-32768, -32000]\n// Keep in sync with https://github.com/anza-xyz/agave/blob/master/rpc-client-api/src/custom_error.rs\nexport const SOLANA_ERROR__JSON_RPC__PARSE_ERROR = -32700;\nexport const SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR = -32603;\nexport const SOLANA_ERROR__JSON_RPC__INVALID_PARAMS = -32602;\nexport const SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND = -32601;\nexport const SOLANA_ERROR__JSON_RPC__INVALID_REQUEST = -32600;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_UNREACHABLE = -32019;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_NOT_EPOCH_BOUNDARY = -32018;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_EPOCH_REWARDS_PERIOD_ACTIVE = -32017;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED = -32016;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION = -32015;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET = -32014;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH = -32013;\nexport const SOLANA_ERROR__JSON_RPC__SCAN_ERROR = -32012;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE = -32011;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX = -32010;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED = -32009;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT = -32008;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED = -32007;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE = -32006;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY = -32005;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE = -32004;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE = -32003;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE = -32002;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP = -32001;\n\n// Addresses-related errors.\n// Reserve error codes in the range [2800000-2800999].\nexport const SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH = 2800000;\nexport const SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE = 2800001;\nexport const SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS = 2800002;\nexport const SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY = 2800003;\nexport const SOLANA_ERROR__ADDRESSES__MALFORMED_PDA = 2800004;\nexport const SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE = 2800005;\nexport const SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED = 2800006;\nexport const SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED = 2800007;\nexport const SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE = 2800008;\nexport const SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED = 2800009;\nexport const SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER = 2800010;\nexport const SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS = 2800011;\n\n// Account-related errors.\n// Reserve error codes in the range [3230000-3230999].\nexport const SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND = 3230000;\nexport const SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND = 32300001;\nexport const SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT = 3230002;\nexport const SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT = 3230003;\nexport const SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED = 3230004;\n\n// Subtle-Crypto-related errors.\n// Reserve error codes in the range [3610000-3610999].\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT = 3610000;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED = 3610001;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED = 3610002;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED = 3610003;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED = 3610004;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED = 3610005;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED = 3610006;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY = 3610007;\n\n// Crypto-related errors.\n// Reserve error codes in the range [3611000-3611050].\nexport const SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED = 3611000;\n\n// Key-related errors.\n// Reserve error codes in the range [3704000-3704999].\nexport const SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH = 3704000;\nexport const SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH = 3704001;\nexport const SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH = 3704002;\nexport const SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE = 3704003;\nexport const SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY = 3704004;\n\n// Instruction-related errors.\n// Reserve error codes in the range [4128000-4128999].\nexport const SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS = 4128000;\nexport const SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA = 4128001;\nexport const SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH = 4128002;\n\n// Instruction errors.\n// Reserve error codes starting with [4615000-4615999] for the Rust enum `InstructionError`.\n// Error names here are dictated by the RPC (see ./instruction-error.ts).\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN = 4615000;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR = 4615001;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT = 4615002;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA = 4615003;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA = 4615004;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL = 4615005;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS = 4615006;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID = 4615007;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE = 4615008;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED = 4615009;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT = 4615010;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION = 4615011;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID = 4615012;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND = 4615013;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED = 4615014;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE = 4615015;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED = 4615016;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX = 4615017;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED = 4615018;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED = 4615019;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS = 4615020;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED = 4615021;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE = 4615022;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED = 4615023;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = 4615024;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC = 4615025;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM = 4615026;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR = 4615027;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED = 4615028;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE = 4615029;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT = 4615030;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID = 4615031;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH = 4615032;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT = 4615033;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED = 4615034;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED = 4615035;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS = 4615036;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC = 4615037;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED = 4615038;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION = 4615039;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE = 4615040;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE = 4615041;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE = 4615042;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE = 4615043;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY = 4615044;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR = 4615045;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT = 4615046;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER = 4615047;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW = 4615048;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR = 4615049;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER = 4615050;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED = 4615051;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED = 4615052;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED = 4615053;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS = 4615054;\n\n// Signer-related errors.\n// Reserve error codes in the range [5508000-5508999].\nexport const SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS = 5508000;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER = 5508001;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER = 5508002;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER = 5508003;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER = 5508004;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER = 5508005;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER = 5508006;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER = 5508007;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER = 5508008;\nexport const SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS = 5508009;\nexport const SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING = 5508010;\nexport const SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED = 5508011;\n\n// Transaction-related errors.\n// Reserve error codes in the range [5663000-5663999].\nexport const SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES = 5663000;\nexport const SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE = 5663001;\nexport const SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME = 5663002;\nexport const SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME = 5663003;\nexport const SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE = 5663004;\nexport const SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING = 5663005;\nexport const SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE = 5663006;\nexport const SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND = 5663007;\nexport const SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING = 5663008;\nexport const SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING = 5663009;\nexport const SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING = 5663010;\nexport const SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING = 5663011;\nexport const SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING = 5663012;\nexport const SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING = 5663013;\nexport const SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE = 5663014;\nexport const SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION = 5663015;\nexport const SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES = 5663016;\nexport const SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH = 5663017;\nexport const SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT = 5663018;\nexport const SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT = 5663019;\nexport const SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT = 5663020;\nexport const SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_NOT_SUPPORTED = 5663021;\nexport const SOLANA_ERROR__TRANSACTION__NONCE_ACCOUNT_CANNOT_BE_IN_LOOKUP_TABLE = 5663022;\n\n// Transaction errors.\n// Reserve error codes starting with [7050000-7050999] for the Rust enum `TransactionError`.\n// Error names here are dictated by the RPC (see ./transaction-error.ts).\nexport const SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN = 7050000;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE = 7050001;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE = 7050002;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND = 7050003;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND = 7050004;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE = 7050005;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE = 7050006;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED = 7050007;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND = 7050008;\n// `InstructionError` intentionally omitted.\nexport const SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP = 7050009;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE = 7050010;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX = 7050011;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE = 7050012;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION = 7050013;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE = 7050014;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE = 7050015;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = 7050016;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT = 7050017;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION = 7050018;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT = 7050019;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT = 7050020;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT = 7050021;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS = 7050022;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND = 7050023;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER = 7050024;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA = 7050025;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX = 7050026;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT = 7050027;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT = 7050028;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT = 7050029;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION = 7050030;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT = 7050031;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED = 7050032;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT = 7050033;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED = 7050034;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED = 7050035;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION = 7050036;\n\n// Instruction plan related errors.\n// Reserve error codes in the range [7618000-7618999].\nexport const SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN = 7618000;\nexport const SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_PACKER_ALREADY_COMPLETE = 7618001;\nexport const SOLANA_ERROR__INSTRUCTION_PLANS__EMPTY_INSTRUCTION_PLAN = 7618002;\nexport const SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN = 7618003;\n\n// Codec-related errors.\n// Reserve error codes in the range [8078000-8078999].\nexport const SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY = 8078000;\nexport const SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH = 8078001;\nexport const SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH = 8078002;\nexport const SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH = 8078003;\nexport const SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH = 8078004;\nexport const SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH = 8078005;\nexport const SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH = 8078006;\nexport const SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS = 8078007;\nexport const SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE = 8078008;\nexport const SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT = 8078009;\nexport const SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT = 8078010;\nexport const SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE = 8078011;\nexport const SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE = 8078012;\nexport const SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH = 8078013;\nexport const SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE = 8078014;\nexport const SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT = 8078015;\nexport const SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE = 8078016;\nexport const SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE = 8078017;\nexport const SOLANA_ERROR__CODECS__INVALID_CONSTANT = 8078018;\nexport const SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE = 8078019;\nexport const SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL = 8078020;\nexport const SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES = 8078021;\nexport const SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS = 8078022;\nexport const SOLANA_ERROR__CODECS__EXPECTED_DECODER_TO_CONSUME_ENTIRE_BYTE_ARRAY = 8078023;\n\n// RPC-related errors.\n// Reserve error codes in the range [8100000-8100999].\nexport const SOLANA_ERROR__RPC__INTEGER_OVERFLOW = 8100000;\nexport const SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN = 8100001;\nexport const SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR = 8100002;\nexport const SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD = 8100003;\n\n// RPC-Subscriptions-related errors.\n// Reserve error codes in the range [8190000-8190999].\nexport const SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN = 8190000;\nexport const SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID = 8190001;\nexport const SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED = 8190002;\nexport const SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED = 8190003;\nexport const SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT = 8190004;\n\n// Invariant violation errors.\n// Reserve error codes in the range [9900000-9900999].\n// These errors should only be thrown when there is a bug with the\n// library itself and should, in theory, never reach the end user.\nexport const SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING = 9900000;\nexport const SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE = 9900001;\nexport const SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING = 9900002;\nexport const SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE = 9900003;\nexport const SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED = 9900004;\nexport const SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND = 9900005;\nexport const SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND = 9900006;\n\n/**\n * A union of every Solana error code\n *\n * @privateRemarks\n * You might be wondering why this is not a TypeScript enum or const enum.\n *\n * One of the goals of this library is to enable people to use some or none of it without having to\n * bundle all of it.\n *\n * If we made the set of error codes an enum then anyone who imported it (even if to only use a\n * single error code) would be forced to bundle every code and its label.\n *\n * Const enums appear to solve this problem by letting the compiler inline only the codes that are\n * actually used. Unfortunately exporting ambient (const) enums from a library like `@solana/errors`\n * is not safe, for a variety of reasons covered here: https://stackoverflow.com/a/28818850\n */\nexport type SolanaErrorCode =\n    | typeof SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND\n    | typeof SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED\n    | typeof SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT\n    | typeof SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT\n    | typeof SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND\n    | typeof SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED\n    | typeof SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS\n    | typeof SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH\n    | typeof SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY\n    | typeof SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS\n    | typeof SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE\n    | typeof SOLANA_ERROR__ADDRESSES__MALFORMED_PDA\n    | typeof SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED\n    | typeof SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED\n    | typeof SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER\n    | typeof SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED\n    | typeof SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY\n    | typeof SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS\n    | typeof SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL\n    | typeof SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH\n    | typeof SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH\n    | typeof SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH\n    | typeof SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__CODECS__EXPECTED_DECODER_TO_CONSUME_ENTIRE_BYTE_ARRAY\n    | typeof SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH\n    | typeof SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH\n    | typeof SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH\n    | typeof SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE\n    | typeof SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH\n    | typeof SOLANA_ERROR__CODECS__INVALID_CONSTANT\n    | typeof SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT\n    | typeof SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT\n    | typeof SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT\n    | typeof SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS\n    | typeof SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE\n    | typeof SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES\n    | typeof SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS\n    | typeof SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA\n    | typeof SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR\n    | typeof SOLANA_ERROR__INSTRUCTION_PLANS__EMPTY_INSTRUCTION_PLAN\n    | typeof SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN\n    | typeof SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN\n    | typeof SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_PACKER_ALREADY_COMPLETE\n    | typeof SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH\n    | typeof SOLANA_ERROR__INVALID_NONCE\n    | typeof SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING\n    | typeof SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND\n    | typeof SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND\n    | typeof SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE\n    | typeof SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING\n    | typeof SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE\n    | typeof SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR\n    | typeof SOLANA_ERROR__JSON_RPC__INVALID_PARAMS\n    | typeof SOLANA_ERROR__JSON_RPC__INVALID_REQUEST\n    | typeof SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND\n    | typeof SOLANA_ERROR__JSON_RPC__PARSE_ERROR\n    | typeof SOLANA_ERROR__JSON_RPC__SCAN_ERROR\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_EPOCH_REWARDS_PERIOD_ACTIVE\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_UNREACHABLE\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_NOT_EPOCH_BOUNDARY\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION\n    | typeof SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH\n    | typeof SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH\n    | typeof SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH\n    | typeof SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY\n    | typeof SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__MALFORMED_BIGINT_STRING\n    | typeof SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR\n    | typeof SOLANA_ERROR__MALFORMED_NUMBER_STRING\n    | typeof SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND\n    | typeof SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD\n    | typeof SOLANA_ERROR__RPC__INTEGER_OVERFLOW\n    | typeof SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR\n    | typeof SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN\n    | typeof SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN\n    | typeof SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED\n    | typeof SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED\n    | typeof SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT\n    | typeof SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID\n    | typeof SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS\n    | typeof SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING\n    | typeof SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION\n    | typeof SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES\n    | typeof SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME\n    | typeof SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME\n    | typeof SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND\n    | typeof SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE\n    | typeof SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES\n    | typeof SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE\n    | typeof SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH\n    | typeof SOLANA_ERROR__TRANSACTION__NONCE_ACCOUNT_CANNOT_BE_IN_LOOKUP_TABLE\n    | typeof SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_NOT_SUPPORTED\n    | typeof SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT;\n\n/**\n * Errors of this type are understood to have an optional {@link SolanaError} nested inside as\n * `cause`.\n */\nexport type SolanaErrorCodeWithCause = typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE;\n","/**\n * To add a new error, follow the instructions at\n * https://github.com/anza-xyz/kit/tree/main/packages/errors/#adding-a-new-error\n *\n * @privateRemarks\n * WARNING:\n *   - Don't change or remove members of an error's context.\n */\nimport {\n    SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED,\n    SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT,\n    SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT,\n    SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND,\n    SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS,\n    SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED,\n    SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED,\n    SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE,\n    SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED,\n    SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY,\n    SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS,\n    SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__EXPECTED_DECODER_TO_CONSUME_ENTIRE_BYTE_ARRAY,\n    SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH,\n    SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE,\n    SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__CODECS__INVALID_CONSTANT,\n    SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT,\n    SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT,\n    SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT,\n    SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS,\n    SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE,\n    SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES,\n    SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE,\n    SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS,\n    SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA,\n    SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW,\n    SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR,\n    SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH,\n    SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM,\n    SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX,\n    SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND,\n    SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER,\n    SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID,\n    SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR,\n    SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN,\n    SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN,\n    SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH,\n    SOLANA_ERROR__INVALID_NONCE,\n    SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING,\n    SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED,\n    SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND,\n    SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND,\n    SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE,\n    SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR,\n    SOLANA_ERROR__JSON_RPC__INVALID_PARAMS,\n    SOLANA_ERROR__JSON_RPC__INVALID_REQUEST,\n    SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND,\n    SOLANA_ERROR__JSON_RPC__PARSE_ERROR,\n    SOLANA_ERROR__JSON_RPC__SCAN_ERROR,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_EPOCH_REWARDS_PERIOD_ACTIVE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_NOT_EPOCH_BOUNDARY,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION,\n    SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__MALFORMED_BIGINT_STRING,\n    SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR,\n    SOLANA_ERROR__MALFORMED_NUMBER_STRING,\n    SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD,\n    SOLANA_ERROR__RPC__INTEGER_OVERFLOW,\n    SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR,\n    SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT,\n    SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS,\n    SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER,\n    SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY,\n    SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING,\n    SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION,\n    SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND,\n    SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT,\n    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES,\n    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE,\n    SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH,\n    SOLANA_ERROR__TRANSACTION__NONCE_ACCOUNT_CANNOT_BE_IN_LOOKUP_TABLE,\n    SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING,\n    SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_NOT_SUPPORTED,\n    SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION,\n    SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT,\n    SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED,\n    SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN,\n    SolanaErrorCode,\n} from './codes';\nimport { RpcSimulateTransactionResult } from './json-rpc-error';\n\ntype BasicInstructionErrorContext<T extends SolanaErrorCode> = Readonly<{ [P in T]: { index: number } }>;\n\ntype DefaultUnspecifiedErrorContextToUndefined<T> = {\n    [P in SolanaErrorCode]: P extends keyof T ? T[P] : undefined;\n};\n\ntype TypedArrayMutableProperties = 'copyWithin' | 'fill' | 'reverse' | 'set' | 'sort';\ninterface ReadonlyUint8Array extends Omit<Uint8Array, TypedArrayMutableProperties> {\n    readonly [n: number]: number;\n}\n\n/** A amount of bytes. */\ntype Bytes = number;\n\n/**\n * A map of every {@link SolanaError} code to the type of its `context` property.\n */\nexport type SolanaErrorContext = DefaultUnspecifiedErrorContextToUndefined<\n    BasicInstructionErrorContext<\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR\n    > & {\n        [SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND]: {\n            address: string;\n        };\n        [SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED]: {\n            addresses: string[];\n        };\n        [SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT]: {\n            address: string;\n        };\n        [SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT]: {\n            address: string;\n        };\n        [SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND]: {\n            addresses: string[];\n        };\n        [SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS]: {\n            putativeAddress: string;\n        };\n        [SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH]: {\n            actualLength: number;\n        };\n        [SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED]: {\n            actual: number;\n            maxSeeds: number;\n        };\n        [SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED]: {\n            actual: number;\n            index: number;\n            maxSeedLength: number;\n        };\n        [SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE]: {\n            bump: number;\n        };\n        [SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE]: {\n            actualLength: number;\n        };\n        [SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE]: {\n            actualLength: number;\n        };\n        [SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED]: {\n            currentBlockHeight: bigint;\n            lastValidBlockHeight: bigint;\n        };\n        [SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY]: {\n            codecDescription: string;\n        };\n        [SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS]: {\n            stringValues: string[];\n        };\n        [SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL]: {\n            encodedBytes: ReadonlyUint8Array;\n            hexEncodedBytes: string;\n            hexSentinel: string;\n            sentinel: ReadonlyUint8Array;\n        };\n        [SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH]: {\n            decoderFixedSize: number;\n            encoderFixedSize: number;\n        };\n        [SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH]: {\n            decoderMaxSize: number | undefined;\n            encoderMaxSize: number | undefined;\n        };\n        [SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE]: {\n            discriminator: bigint | number;\n            formattedValidDiscriminators: string;\n            validDiscriminators: number[];\n        };\n        [SOLANA_ERROR__CODECS__EXPECTED_DECODER_TO_CONSUME_ENTIRE_BYTE_ARRAY]: {\n            expectedLength: number;\n            numExcessBytes: number;\n        };\n        [SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH]: {\n            bytesLength: number;\n            codecDescription: string;\n        };\n        [SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE]: {\n            codecDescription: string;\n            expectedSize: number;\n            hexZeroValue: string;\n            zeroValue: ReadonlyUint8Array;\n        };\n        [SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH]: {\n            bytesLength: number;\n            codecDescription: string;\n            expected: number;\n        };\n        [SOLANA_ERROR__CODECS__INVALID_CONSTANT]: {\n            constant: ReadonlyUint8Array;\n            data: ReadonlyUint8Array;\n            hexConstant: string;\n            hexData: string;\n            offset: number;\n        };\n        [SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT]: {\n            value: bigint | boolean | number | string | null | undefined;\n            variants: readonly (bigint | boolean | number | string | null | undefined)[];\n        };\n        [SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT]: {\n            formattedNumericalValues: string;\n            numericalValues: number[];\n            stringValues: string[];\n            variant: number | string | symbol;\n        };\n        [SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT]: {\n            value: bigint | boolean | number | string | null | undefined;\n            variants: readonly (bigint | boolean | number | string | null | undefined)[];\n        };\n        [SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS]: {\n            actual: bigint | number;\n            codecDescription: string;\n            expected: bigint | number;\n        };\n        [SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE]: {\n            alphabet: string;\n            base: number;\n            value: string;\n        };\n        [SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE]: {\n            discriminator: bigint | number;\n            maxRange: number;\n            minRange: number;\n        };\n        [SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE]: {\n            codecDescription: string;\n            max: bigint | number;\n            min: bigint | number;\n            value: bigint | number;\n        };\n        [SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE]: {\n            bytesLength: number;\n            codecDescription: string;\n            offset: number;\n        };\n        [SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES]: {\n            decodedBytes: ReadonlyUint8Array;\n            hexDecodedBytes: string;\n            hexSentinel: string;\n            sentinel: ReadonlyUint8Array;\n        };\n        [SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE]: {\n            maxRange: number;\n            minRange: number;\n            variant: number;\n        };\n        [SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR]: {\n            index: number;\n        };\n        [SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM]: {\n            code: number;\n            index: number;\n        };\n        [SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN]: {\n            errorName: string;\n            index: number;\n            instructionErrorContext?: unknown;\n        };\n        [SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN]: {\n            transactionPlanResult: unknown;\n        };\n        [SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN]: {\n            numBytesRequired: number;\n            numFreeBytes: number;\n        };\n        [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS]: {\n            data?: ReadonlyUint8Array;\n            programAddress: string;\n        };\n        [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA]: {\n            accountAddresses?: string[];\n            programAddress: string;\n        };\n        [SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH]: {\n            actualProgramAddress: string;\n            expectedProgramAddress: string;\n        };\n        [SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH]: {\n            actualLength: number;\n        };\n        [SOLANA_ERROR__INVALID_NONCE]: {\n            actualNonceValue: string;\n            expectedNonceValue: string;\n        };\n        [SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING]: {\n            cacheKey: string;\n        };\n        [SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED]: {\n            channelName: string;\n            supportedChannelNames: string[];\n        };\n        [SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND]: {\n            kind: string;\n        };\n        [SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND]: {\n            kind: string;\n        };\n        [SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE]: {\n            unexpectedValue: unknown;\n        };\n        [SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__INVALID_PARAMS]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__INVALID_REQUEST]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__PARSE_ERROR]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SCAN_ERROR]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_EPOCH_REWARDS_PERIOD_ACTIVE]: {\n            currentBlockHeight: bigint;\n            rewardsCompleteBlockHeight: bigint;\n            slot: bigint;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED]: {\n            contextSlot: bigint;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY]: {\n            numSlotsBehind?: number;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE]: Omit<\n            RpcSimulateTransactionResult,\n            'err'\n        >;\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_NOT_EPOCH_BOUNDARY]: {\n            slot: bigint;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH]: {\n            byteLength: number;\n        };\n        [SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH]: {\n            actualLength: number;\n        };\n        [SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH]: {\n            actualLength: number;\n        };\n        [SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE]: {\n            actualLength: number;\n        };\n        [SOLANA_ERROR__MALFORMED_BIGINT_STRING]: {\n            value: string;\n        };\n        [SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR]: {\n            error: unknown;\n            message: string;\n        };\n        [SOLANA_ERROR__MALFORMED_NUMBER_STRING]: {\n            value: string;\n        };\n        [SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND]: {\n            nonceAccountAddress: string;\n        };\n        [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN]: {\n            notificationName: string;\n        };\n        [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT]: {\n            errorEvent: Event;\n        };\n        [SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD]: {\n            method: string;\n            params: unknown[];\n        };\n        [SOLANA_ERROR__RPC__INTEGER_OVERFLOW]: {\n            argumentLabel: string;\n            keyPath: readonly (number | string | symbol)[];\n            methodName: string;\n            optionalPathLabel: string;\n            path?: string;\n            value: bigint;\n        };\n        [SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR]: {\n            headers: Headers;\n            message: string;\n            statusCode: number;\n        };\n        [SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN]: {\n            headers: string[];\n        };\n        [SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY]: {\n            key: CryptoKey;\n        };\n        [SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE]: {\n            value: bigint;\n        };\n        [SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION]: {\n            index: number;\n        };\n        [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT]: {\n            accountIndex: number;\n        };\n        [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED]: {\n            accountIndex: number;\n        };\n        [SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN]: {\n            errorName: string;\n            transactionErrorContext?: unknown;\n        };\n        [SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION]: {\n            expectedAddresses: string[];\n            unexpectedAddresses: string[];\n        };\n        [SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING]: {\n            index: number;\n        };\n        [SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT]: {\n            transactionSize: Bytes;\n            transactionSizeLimit: Bytes;\n        };\n        [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING]: {\n            lookupTableAddresses: string[];\n        };\n        [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE]: {\n            highestKnownIndex: number;\n            highestRequestedIndex: number;\n            lookupTableAddress: string;\n        };\n        [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND]: {\n            index: number;\n        };\n        [SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT]: {\n            unitsConsumed: number;\n        };\n        [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES]: {\n            programAddress: string;\n        };\n        [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE]: {\n            programAddress: string;\n        };\n        [SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH]: {\n            numRequiredSignatures: number;\n            signaturesLength: number;\n            signerAddresses: string[];\n        };\n        [SOLANA_ERROR__TRANSACTION__NONCE_ACCOUNT_CANNOT_BE_IN_LOOKUP_TABLE]: {\n            nonce: string;\n        };\n        [SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING]: {\n            addresses: string[];\n        };\n        [SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_NOT_SUPPORTED]: {\n            unsupportedVersion: number;\n        };\n        [SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE]: {\n            actualVersion: number;\n        };\n    }\n>;\n\nexport function decodeEncodedContext(encodedContext: string): object {\n    const decodedUrlString = __NODEJS__ ? Buffer.from(encodedContext, 'base64').toString('utf8') : atob(encodedContext);\n    return Object.fromEntries(new URLSearchParams(decodedUrlString).entries());\n}\n\nfunction encodeValue(value: unknown): string {\n    if (Array.isArray(value)) {\n        const commaSeparatedValues = value.map(encodeValue).join('%2C%20' /* \", \" */);\n        return '%5B' /* \"[\" */ + commaSeparatedValues + /* \"]\" */ '%5D';\n    } else if (typeof value === 'bigint') {\n        return `${value}n`;\n    } else {\n        return encodeURIComponent(\n            String(\n                value != null && Object.getPrototypeOf(value) === null\n                    ? // Plain objects with no prototype don't have a `toString` method.\n                      // Convert them before stringifying them.\n                      { ...(value as object) }\n                    : value,\n            ),\n        );\n    }\n}\n\nfunction encodeObjectContextEntry([key, value]: [string, unknown]): `${typeof key}=${string}` {\n    return `${key}=${encodeValue(value)}`;\n}\n\nexport function encodeContextObject(context: object): string {\n    const searchParamsString = Object.entries(context).map(encodeObjectContextEntry).join('&');\n    return __NODEJS__ ? Buffer.from(searchParamsString, 'utf8').toString('base64') : btoa(searchParamsString);\n}\n","/* eslint-disable sort-keys-fix/sort-keys-fix */\n/**\n * To add a new error, follow the instructions at\n * https://github.com/anza-xyz/kit/tree/main/packages/errors#adding-a-new-error\n *\n * WARNING:\n *   - Don't change the meaning of an error message.\n */\nimport {\n    SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED,\n    SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT,\n    SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT,\n    SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND,\n    SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED,\n    SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS,\n    SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY,\n    SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS,\n    SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE,\n    SOLANA_ERROR__ADDRESSES__MALFORMED_PDA,\n    SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED,\n    SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED,\n    SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE,\n    SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER,\n    SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED,\n    SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY,\n    SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS,\n    SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH,\n    SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__EXPECTED_DECODER_TO_CONSUME_ENTIRE_BYTE_ARRAY,\n    SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH,\n    SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH,\n    SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH,\n    SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE,\n    SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__CODECS__INVALID_CONSTANT,\n    SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT,\n    SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT,\n    SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT,\n    SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS,\n    SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE,\n    SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES,\n    SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE,\n    SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS,\n    SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA,\n    SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW,\n    SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR,\n    SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH,\n    SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM,\n    SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX,\n    SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND,\n    SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER,\n    SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID,\n    SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR,\n    SOLANA_ERROR__INSTRUCTION_PLANS__EMPTY_INSTRUCTION_PLAN,\n    SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN,\n    SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN,\n    SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_PACKER_ALREADY_COMPLETE,\n    SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH,\n    SOLANA_ERROR__INVALID_NONCE,\n    SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING,\n    SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED,\n    SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND,\n    SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND,\n    SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE,\n    SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING,\n    SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE,\n    SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR,\n    SOLANA_ERROR__JSON_RPC__INVALID_PARAMS,\n    SOLANA_ERROR__JSON_RPC__INVALID_REQUEST,\n    SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND,\n    SOLANA_ERROR__JSON_RPC__PARSE_ERROR,\n    SOLANA_ERROR__JSON_RPC__SCAN_ERROR,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_EPOCH_REWARDS_PERIOD_ACTIVE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_UNREACHABLE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_NOT_EPOCH_BOUNDARY,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION,\n    SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY,\n    SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE,\n    SOLANA_ERROR__MALFORMED_BIGINT_STRING,\n    SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR,\n    SOLANA_ERROR__MALFORMED_NUMBER_STRING,\n    SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD,\n    SOLANA_ERROR__RPC__INTEGER_OVERFLOW,\n    SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR,\n    SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID,\n    SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS,\n    SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER,\n    SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS,\n    SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING,\n    SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY,\n    SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT,\n    SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING,\n    SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION,\n    SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES,\n    SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT,\n    SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME,\n    SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT,\n    SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT,\n    SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING,\n    SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING,\n    SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE,\n    SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING,\n    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES,\n    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE,\n    SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH,\n    SOLANA_ERROR__TRANSACTION__NONCE_ACCOUNT_CANNOT_BE_IN_LOOKUP_TABLE,\n    SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING,\n    SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_NOT_SUPPORTED,\n    SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING,\n    SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE,\n    SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE,\n    SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND,\n    SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED,\n    SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND,\n    SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP,\n    SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE,\n    SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION,\n    SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE,\n    SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT,\n    SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED,\n    SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE,\n    SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED,\n    SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED,\n    SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE,\n    SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE,\n    SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS,\n    SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION,\n    SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN,\n    SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION,\n    SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT,\n    SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT,\n    SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT,\n    SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT,\n    SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT,\n    SolanaErrorCode,\n} from './codes';\n\n/**\n * A map of every {@link SolanaError} code to the error message shown to developers in development\n * mode.\n */\nexport const SolanaErrorMessages: Readonly<{\n    // This type makes this data structure exhaustive with respect to `SolanaErrorCode`.\n    // TypeScript will fail to build this project if add an error code without a message.\n    [P in SolanaErrorCode]: string;\n}> = {\n    [SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND]: 'Account not found at address: $address',\n    [SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED]:\n        'Not all accounts were decoded. Encoded accounts found at addresses: $addresses.',\n    [SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT]: 'Expected decoded account at address: $address',\n    [SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT]: 'Failed to decode account data at address: $address',\n    [SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND]: 'Accounts not found at addresses: $addresses',\n    [SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED]:\n        'Unable to find a viable program address bump seed.',\n    [SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS]: '$putativeAddress is not a base58-encoded address.',\n    [SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH]:\n        'Expected base58 encoded address to decode to a byte array of length 32. Actual length: $actualLength.',\n    [SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY]: 'The `CryptoKey` must be an `Ed25519` public key.',\n    [SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS]:\n        '$putativeOffCurveAddress is not a base58-encoded off-curve address.',\n    [SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE]: 'Invalid seeds; point must fall off the Ed25519 curve.',\n    [SOLANA_ERROR__ADDRESSES__MALFORMED_PDA]:\n        'Expected given program derived address to have the following format: [Address, ProgramDerivedAddressBump].',\n    [SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED]:\n        'A maximum of $maxSeeds seeds, including the bump seed, may be supplied when creating an address. Received: $actual.',\n    [SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED]:\n        'The seed at index $index with length $actual exceeds the maximum length of $maxSeedLength bytes.',\n    [SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE]:\n        'Expected program derived address bump to be in the range [0, 255], got: $bump.',\n    [SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER]: 'Program address cannot end with PDA marker.',\n    [SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE]:\n        'Expected base58-encoded address string of length in the range [32, 44]. Actual length: $actualLength.',\n    [SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE]:\n        'Expected base58-encoded blockash string of length in the range [32, 44]. Actual length: $actualLength.',\n    [SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED]:\n        'The network has progressed past the last block for which this transaction could have been committed.',\n    [SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY]:\n        'Codec [$codecDescription] cannot decode empty byte arrays.',\n    [SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS]:\n        'Enum codec cannot use lexical values [$stringValues] as discriminators. Either remove all lexical values or set `useValuesAsDiscriminators` to `false`.',\n    [SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL]:\n        'Sentinel [$hexSentinel] must not be present in encoded bytes [$hexEncodedBytes].',\n    [SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH]:\n        'Encoder and decoder must have the same fixed size, got [$encoderFixedSize] and [$decoderFixedSize].',\n    [SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH]:\n        'Encoder and decoder must have the same max size, got [$encoderMaxSize] and [$decoderMaxSize].',\n    [SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH]:\n        'Encoder and decoder must either both be fixed-size or variable-size.',\n    [SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE]:\n        'Enum discriminator out of range. Expected a number in [$formattedValidDiscriminators], got $discriminator.',\n    [SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH]: 'Expected a fixed-size codec, got a variable-size one.',\n    [SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH]:\n        'Codec [$codecDescription] expected a positive byte length, got $bytesLength.',\n    [SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH]: 'Expected a variable-size codec, got a fixed-size one.',\n    [SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE]:\n        'Codec [$codecDescription] expected zero-value [$hexZeroValue] to have the same size as the provided fixed-size item [$expectedSize bytes].',\n    [SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH]:\n        'Codec [$codecDescription] expected $expected bytes, got $bytesLength.',\n    [SOLANA_ERROR__CODECS__INVALID_CONSTANT]:\n        'Expected byte array constant [$hexConstant] to be present in data [$hexData] at offset [$offset].',\n    [SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT]:\n        'Invalid discriminated union variant. Expected one of [$variants], got $value.',\n    [SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT]:\n        'Invalid enum variant. Expected one of [$stringValues] or a number in [$formattedNumericalValues], got $variant.',\n    [SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT]:\n        'Invalid literal union variant. Expected one of [$variants], got $value.',\n    [SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS]:\n        'Expected [$codecDescription] to have $expected items, got $actual.',\n    [SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE]: 'Invalid value $value for base $base with alphabet $alphabet.',\n    [SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE]:\n        'Literal union discriminator out of range. Expected a number between $minRange and $maxRange, got $discriminator.',\n    [SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE]:\n        'Codec [$codecDescription] expected number to be in the range [$min, $max], got $value.',\n    [SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE]:\n        'Codec [$codecDescription] expected offset to be in the range [0, $bytesLength], got $offset.',\n    [SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES]:\n        'Expected sentinel [$hexSentinel] to be present in decoded bytes [$hexDecodedBytes].',\n    [SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE]:\n        'Union variant out of range. Expected an index between $minRange and $maxRange, got $variant.',\n    [SOLANA_ERROR__CODECS__EXPECTED_DECODER_TO_CONSUME_ENTIRE_BYTE_ARRAY]:\n        'This decoder expected a byte array of exactly $expectedLength bytes, but $numExcessBytes unexpected excess bytes remained after decoding. Are you sure that you have chosen the correct decoder for this data?',\n    [SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED]: 'No random values implementation could be found.',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED]: 'instruction requires an uninitialized account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED]:\n        'instruction tries to borrow reference for an account which is already borrowed',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING]:\n        'instruction left account with an outstanding borrowed reference',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED]:\n        \"program other than the account's owner changed the size of the account data\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL]: 'account data too small for instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE]: 'instruction expected an executable account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT]:\n        'An account does not have enough lamports to be rent-exempt',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW]: 'Program arithmetic overflowed',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR]: 'Failed to serialize or deserialize account data: $encodedData',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS]:\n        'Builtin programs must consume compute units',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH]: 'Cross-program invocation call depth too deep',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED]: 'Computational budget exceeded',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM]: 'custom program error: #$code',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX]: 'instruction contains duplicate accounts',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC]:\n        'instruction modifications of multiply-passed account differ',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT]: 'executable accounts must be rent exempt',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED]: 'instruction changed executable accounts data',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE]:\n        'instruction changed the balance of an executable account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED]: 'instruction changed executable bit of an account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED]:\n        'instruction modified data of an account it does not own',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND]:\n        'instruction spent from the balance of an account it does not own',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR]: 'generic instruction error',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER]: 'Provided owner is not allowed',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE]: 'Account is immutable',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY]: 'Incorrect authority provided',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID]: 'incorrect program id for instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS]: 'insufficient funds for instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA]: 'invalid account data for instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER]: 'Invalid account owner',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT]: 'invalid program argument',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR]: 'program returned invalid error code',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA]: 'invalid instruction data',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC]: 'Failed to reallocate account data',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS]: 'Provided seeds do not result in a valid address',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED]:\n        'Accounts data allocations exceeded the maximum allowed per transaction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED]: 'Max accounts exceeded',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED]: 'Max instruction trace length exceeded',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED]:\n        'Length of the seed is too long for address generation',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT]: 'An account required by the instruction is missing',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE]: 'missing required signature for instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID]:\n        'instruction illegally modified the program id of an account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS]: 'insufficient account keys for instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION]:\n        'Cross-program invocation with unauthorized signer or writable account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE]:\n        'Failed to create program execution environment',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE]: 'Program failed to compile',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE]: 'Program failed to complete',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED]: 'instruction modified data of a read-only account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE]:\n        'instruction changed the balance of a read-only account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED]:\n        'Cross-program invocation reentrancy not allowed for this instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED]: 'instruction modified rent epoch of an account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION]:\n        'sum of account balances before and after instruction do not match',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT]: 'instruction requires an initialized account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN]: '',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID]: 'Unsupported program id',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR]: 'Unsupported sysvar',\n    [SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND]: 'Invalid instruction plan kind: $kind.',\n    [SOLANA_ERROR__INSTRUCTION_PLANS__EMPTY_INSTRUCTION_PLAN]: 'The provided instruction plan is empty.',\n    [SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN]:\n        'The provided transaction plan failed to execute. See the `transactionPlanResult` attribute and the `cause` error for more details.',\n    [SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN]:\n        'The provided message has insufficient capacity to accommodate the next instruction(s) in this plan. Expected at least $numBytesRequired free byte(s), got $numFreeBytes byte(s).',\n    [SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND]: 'Invalid transaction plan kind: $kind.',\n    [SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_PACKER_ALREADY_COMPLETE]:\n        'No more instructions to pack; the message packer has completed the instruction plan.',\n    [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS]: 'The instruction does not have any accounts.',\n    [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA]: 'The instruction does not have any data.',\n    [SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH]:\n        'Expected instruction to have progress address $expectedProgramAddress, got $actualProgramAddress.',\n    [SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH]:\n        'Expected base58 encoded blockhash to decode to a byte array of length 32. Actual length: $actualLength.',\n    [SOLANA_ERROR__INVALID_NONCE]:\n        'The nonce `$expectedNonceValue` is no longer valid. It has advanced to `$actualNonceValue`',\n    [SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING]:\n        'Invariant violation: Found no abortable iterable cache entry for key `$cacheKey`. It ' +\n        'should be impossible to hit this error; please file an issue at ' +\n        'https://sola.na/web3invariant',\n    [SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED]:\n        'Invariant violation: This data publisher does not publish to the channel named ' +\n        '`$channelName`. Supported channels include $supportedChannelNames.',\n    [SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE]:\n        'Invariant violation: WebSocket message iterator state is corrupt; iterated without first ' +\n        'resolving existing message promise. It should be impossible to hit this error; please ' +\n        'file an issue at https://sola.na/web3invariant',\n    [SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING]:\n        'Invariant violation: WebSocket message iterator is missing state storage. It should be ' +\n        'impossible to hit this error; please file an issue at https://sola.na/web3invariant',\n    [SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE]:\n        'Invariant violation: Switch statement non-exhaustive. Received unexpected value ' +\n        '`$unexpectedValue`. It should be impossible to hit this error; please file an issue at ' +\n        'https://sola.na/web3invariant',\n    [SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR]: 'JSON-RPC error: Internal JSON-RPC error ($__serverMessage)',\n    [SOLANA_ERROR__JSON_RPC__INVALID_PARAMS]: 'JSON-RPC error: Invalid method parameter(s) ($__serverMessage)',\n    [SOLANA_ERROR__JSON_RPC__INVALID_REQUEST]:\n        'JSON-RPC error: The JSON sent is not a valid `Request` object ($__serverMessage)',\n    [SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND]:\n        'JSON-RPC error: The method does not exist / is not available ($__serverMessage)',\n    [SOLANA_ERROR__JSON_RPC__PARSE_ERROR]:\n        'JSON-RPC error: An error occurred on the server while parsing the JSON text ($__serverMessage)',\n    [SOLANA_ERROR__JSON_RPC__SCAN_ERROR]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_EPOCH_REWARDS_PERIOD_ACTIVE]:\n        'Epoch rewards period still active at slot $slot',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_UNREACHABLE]:\n        'Failed to query long-term storage; please try again',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED]: 'Minimum context slot has not been reached',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY]: 'Node is unhealthy; behind by $numSlotsBehind slots',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT]: 'No snapshot',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE]: 'Transaction simulation failed',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_NOT_EPOCH_BOUNDARY]:\n        \"Rewards cannot be found because slot $slot is not the epoch boundary. This may be due to gap in the queried node's local ledger or long-term storage\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE]:\n        'Transaction history is not available from this node',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH]: 'Transaction signature length mismatch',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE]:\n        'Transaction signature verification failure',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION]: '$__serverMessage',\n    [SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH]: 'Key pair bytes must be of length 64, got $byteLength.',\n    [SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH]:\n        'Expected private key bytes with length 32. Actual length: $actualLength.',\n    [SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH]:\n        'Expected base58-encoded signature to decode to a byte array of length 64. Actual length: $actualLength.',\n    [SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY]:\n        'The provided private key does not match the provided public key.',\n    [SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE]:\n        'Expected base58-encoded signature string of length in the range [64, 88]. Actual length: $actualLength.',\n    [SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE]: 'Lamports value must be in the range [0, 2e64-1]',\n    [SOLANA_ERROR__MALFORMED_BIGINT_STRING]: '`$value` cannot be parsed as a `BigInt`',\n    [SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR]: '$message',\n    [SOLANA_ERROR__MALFORMED_NUMBER_STRING]: '`$value` cannot be parsed as a `Number`',\n    [SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND]: 'No nonce account could be found at address `$nonceAccountAddress`',\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN]:\n        \"The notification name must end in 'Notifications' and the API must supply a \" +\n        \"subscription plan creator function for the notification '$notificationName'.\",\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED]:\n        'WebSocket was closed before payload could be added to the send buffer',\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED]: 'WebSocket connection closed',\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT]: 'WebSocket failed to connect',\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID]:\n        'Failed to obtain a subscription id from the server',\n    [SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD]: 'Could not find an API plan for RPC method: `$method`',\n    [SOLANA_ERROR__RPC__INTEGER_OVERFLOW]:\n        'The $argumentLabel argument to the `$methodName` RPC method$optionalPathLabel was ' +\n        '`$value`. This number is unsafe for use with the Solana JSON-RPC because it exceeds ' +\n        '`Number.MAX_SAFE_INTEGER`.',\n    [SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR]: 'HTTP error ($statusCode): $message',\n    [SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN]:\n        'HTTP header(s) forbidden: $headers. Learn more at ' +\n        'https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name.',\n    [SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS]:\n        'Multiple distinct signers were identified for address `$address`. Please ensure that ' +\n        'you are using the same signer instance for each address.',\n    [SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER]:\n        'The provided value does not implement the `KeyPairSigner` interface',\n    [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER]:\n        'The provided value does not implement the `MessageModifyingSigner` interface',\n    [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER]:\n        'The provided value does not implement the `MessagePartialSigner` interface',\n    [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER]:\n        'The provided value does not implement any of the `MessageSigner` interfaces',\n    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER]:\n        'The provided value does not implement the `TransactionModifyingSigner` interface',\n    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER]:\n        'The provided value does not implement the `TransactionPartialSigner` interface',\n    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER]:\n        'The provided value does not implement the `TransactionSendingSigner` interface',\n    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER]:\n        'The provided value does not implement any of the `TransactionSigner` interfaces',\n    [SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS]:\n        'More than one `TransactionSendingSigner` was identified.',\n    [SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING]:\n        'No `TransactionSendingSigner` was identified. Please provide a valid ' +\n        '`TransactionWithSingleSendingSigner` transaction.',\n    [SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED]:\n        'Wallet account signers do not support signing multiple messages/transactions in a single operation',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY]: 'Cannot export a non-extractable key.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED]: 'No digest implementation could be found.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT]:\n        'Cryptographic operations are only allowed in secure browser contexts. Read more ' +\n        'here: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED]:\n        'This runtime does not support the generation of Ed25519 key pairs.\\n\\nInstall ' +\n        '@solana/webcrypto-ed25519-polyfill and call its `install` function before generating keys in ' +\n        'environments that do not support Ed25519.\\n\\nFor a list of runtimes that ' +\n        'currently support Ed25519 operations, visit ' +\n        'https://github.com/WICG/webcrypto-secure-curves/issues/20.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED]:\n        'No signature verification implementation could be found.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED]: 'No key generation implementation could be found.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED]: 'No signing implementation could be found.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED]: 'No key export implementation could be found.',\n    [SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE]:\n        'Timestamp value must be in the range [-(2n ** 63n), (2n ** 63n) - 1]. `$value` given',\n    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING]:\n        'Transaction processing left an account with an outstanding borrowed reference',\n    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE]: 'Account in use',\n    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE]: 'Account loaded twice',\n    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND]:\n        'Attempt to debit an account but found no record of a prior credit.',\n    [SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND]:\n        \"Transaction loads an address table account that doesn't exist\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED]: 'This transaction has already been processed',\n    [SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND]: 'Blockhash not found',\n    [SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP]: 'Loader call chain is too deep',\n    [SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE]:\n        'Transactions are currently disabled due to cluster maintenance',\n    [SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION]:\n        'Transaction contains a duplicate instruction ($index) that is not allowed',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE]: 'Insufficient funds for fee',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT]:\n        'Transaction results in an account ($accountIndex) with insufficient funds for rent',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE]: 'This account may not be used to pay transaction fees',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX]: 'Transaction contains an invalid account reference',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA]:\n        'Transaction loads an address table account with invalid data',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX]:\n        'Transaction address table lookup uses an invalid index',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER]:\n        'Transaction loads an address table account with an invalid owner',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT]:\n        'LoadedAccountsDataSizeLimit set for transaction must be greater than 0.',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION]:\n        'This program may not be used for executing instructions',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT]:\n        'Transaction leaves an account with a lower balance than rent-exempt minimum',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT]:\n        'Transaction loads a writable account that cannot be written',\n    [SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED]:\n        'Transaction exceeded max loaded accounts data size cap',\n    [SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE]:\n        'Transaction requires a fee but has no signature present',\n    [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND]: 'Attempt to load a program that does not exist',\n    [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED]:\n        'Execution of the program referenced by account at index $accountIndex is temporarily restricted.',\n    [SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED]: 'ResanitizationNeeded',\n    [SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE]: 'Transaction failed to sanitize accounts offsets correctly',\n    [SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE]: 'Transaction did not pass signature verification',\n    [SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS]: 'Transaction locked too many accounts',\n    [SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION]:\n        'Sum of account balances before and after transaction do not match',\n    [SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN]: 'The transaction failed with the error `$errorName`',\n    [SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION]: 'Transaction version is unsupported',\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT]:\n        'Transaction would exceed account data limit within the block',\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT]:\n        'Transaction would exceed total account data limit',\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT]:\n        'Transaction would exceed max account limit within the block',\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT]:\n        'Transaction would exceed max Block Cost Limit',\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT]: 'Transaction would exceed max Vote Cost Limit',\n    [SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION]:\n        'Attempted to sign a transaction with an address that is not a signer for it',\n    [SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING]: 'Transaction is missing an address at index: $index.',\n    [SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES]:\n        'Transaction has no expected signers therefore it cannot be encoded',\n    [SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT]:\n        'Transaction size $transactionSize exceeds limit of $transactionSizeLimit bytes',\n    [SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME]: 'Transaction does not have a blockhash lifetime',\n    [SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME]: 'Transaction is not a durable nonce transaction',\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING]:\n        'Contents of these address lookup tables unknown: $lookupTableAddresses',\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE]:\n        'Lookup of address at index $highestRequestedIndex failed for lookup table ' +\n        '`$lookupTableAddress`. Highest known index is $highestKnownIndex. The lookup table ' +\n        'may have been extended since its contents were retrieved',\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING]: 'No fee payer set in CompiledTransaction',\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND]:\n        'Could not find program address at index $index',\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT]:\n        'Failed to estimate the compute unit consumption for this transaction message. This is ' +\n        'likely because simulating the transaction failed. Inspect the `cause` property of this ' +\n        'error to learn more',\n    [SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT]:\n        'Transaction failed when it was simulated in order to estimate the compute unit consumption. ' +\n        'The compute unit estimate provided is for a transaction that failed when simulated and may not ' +\n        'be representative of the compute units this transaction would consume if successful. Inspect the ' +\n        '`cause` property of this error to learn more',\n    [SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING]: 'Transaction is missing a fee payer.',\n    [SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING]:\n        \"Could not determine this transaction's signature. Make sure that the transaction has \" +\n        'been signed by its fee payer.',\n    [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE]:\n        'Transaction first instruction is not advance nonce account instruction.',\n    [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING]:\n        'Transaction with no instructions cannot be durable nonce transaction.',\n    [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES]:\n        'This transaction includes an address (`$programAddress`) which is both ' +\n        'invoked and set as the fee payer. Program addresses may not pay fees',\n    [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE]:\n        'This transaction includes an address (`$programAddress`) which is both invoked and ' +\n        'marked writable. Program addresses may not be writable',\n    [SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH]:\n        'The transaction message expected the transaction to have $numRequiredSignatures signatures, got $signaturesLength.',\n    [SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING]: 'Transaction is missing signatures for addresses: $addresses.',\n    [SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE]:\n        'Transaction version must be in the range [0, 127]. `$actualVersion` given',\n    [SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_NOT_SUPPORTED]:\n        'This version of Kit does not support decoding transactions with version $unsupportedVersion. The current max supported version is 0.',\n    [SOLANA_ERROR__TRANSACTION__NONCE_ACCOUNT_CANNOT_BE_IN_LOOKUP_TABLE]:\n        'The transaction has a durable nonce lifetime (with nonce `$nonce`), but the nonce account address is in a lookup table. The lifetime constraint cannot be constructed without fetching the lookup tables for the transaction.',\n};\n","import { SolanaErrorCode } from './codes';\nimport { encodeContextObject } from './context';\nimport { SolanaErrorMessages } from './messages';\n\nconst enum StateType {\n    EscapeSequence,\n    Text,\n    Variable,\n}\ntype State = Readonly<{\n    [START_INDEX]: number;\n    [TYPE]: StateType;\n}>;\nconst START_INDEX = 'i';\nconst TYPE = 't';\n\nexport function getHumanReadableErrorMessage<TErrorCode extends SolanaErrorCode>(\n    code: TErrorCode,\n    context: object = {},\n): string {\n    const messageFormatString = SolanaErrorMessages[code];\n    if (messageFormatString.length === 0) {\n        return '';\n    }\n    let state: State;\n    function commitStateUpTo(endIndex?: number) {\n        if (state[TYPE] === StateType.Variable) {\n            const variableName = messageFormatString.slice(state[START_INDEX] + 1, endIndex);\n\n            fragments.push(\n                variableName in context\n                    ? // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n                      `${context[variableName as keyof typeof context]}`\n                    : `$${variableName}`,\n            );\n        } else if (state[TYPE] === StateType.Text) {\n            fragments.push(messageFormatString.slice(state[START_INDEX], endIndex));\n        }\n    }\n    const fragments: string[] = [];\n    messageFormatString.split('').forEach((char, ii) => {\n        if (ii === 0) {\n            state = {\n                [START_INDEX]: 0,\n                [TYPE]:\n                    messageFormatString[0] === '\\\\'\n                        ? StateType.EscapeSequence\n                        : messageFormatString[0] === '$'\n                          ? StateType.Variable\n                          : StateType.Text,\n            };\n            return;\n        }\n        let nextState;\n        switch (state[TYPE]) {\n            case StateType.EscapeSequence:\n                nextState = { [START_INDEX]: ii, [TYPE]: StateType.Text };\n                break;\n            case StateType.Text:\n                if (char === '\\\\') {\n                    nextState = { [START_INDEX]: ii, [TYPE]: StateType.EscapeSequence };\n                } else if (char === '$') {\n                    nextState = { [START_INDEX]: ii, [TYPE]: StateType.Variable };\n                }\n                break;\n            case StateType.Variable:\n                if (char === '\\\\') {\n                    nextState = { [START_INDEX]: ii, [TYPE]: StateType.EscapeSequence };\n                } else if (char === '$') {\n                    nextState = { [START_INDEX]: ii, [TYPE]: StateType.Variable };\n                } else if (!char.match(/\\w/)) {\n                    nextState = { [START_INDEX]: ii, [TYPE]: StateType.Text };\n                }\n                break;\n        }\n        if (nextState) {\n            if (state !== nextState) {\n                commitStateUpTo(ii);\n            }\n            state = nextState;\n        }\n    });\n    commitStateUpTo();\n    return fragments.join('');\n}\n\nexport function getErrorMessage<TErrorCode extends SolanaErrorCode>(\n    code: TErrorCode,\n    context: Record<string, unknown> = {},\n): string {\n    if (process.env.NODE_ENV !== \"production\") {\n        return getHumanReadableErrorMessage(code, context);\n    } else {\n        let decodingAdviceMessage = `Solana error #${code}; Decode this error by running \\`npx @solana/errors decode -- ${code}`;\n        if (Object.keys(context).length) {\n            /**\n             * DANGER: Be sure that the shell command is escaped in such a way that makes it\n             *         impossible for someone to craft malicious context values that would result in\n             *         an exploit against anyone who bindly copy/pastes it into their terminal.\n             */\n            decodingAdviceMessage += ` '${encodeContextObject(context)}'`;\n        }\n        return `${decodingAdviceMessage}\\``;\n    }\n}\n","import { SolanaErrorCode, SolanaErrorCodeWithCause } from './codes';\nimport { SolanaErrorContext } from './context';\nimport { getErrorMessage } from './message-formatter';\n\n/**\n * A type guard that returns `true` if the input is a {@link SolanaError}, optionally with a\n * particular error code.\n *\n * When the `code` argument is supplied and the input is a {@link SolanaError}, TypeScript will\n * refine the error's {@link SolanaError#context | `context`} property to the type associated with\n * that error code. You can use that context to render useful error messages, or to make\n * context-aware decisions that help your application to recover from the error.\n *\n * @example\n * ```ts\n * import {\n *     SOLANA_ERROR__TRANSACTION__MISSING_SIGNATURE,\n *     SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING,\n *     isSolanaError,\n * } from '@solana/errors';\n * import { assertIsFullySignedTransaction, getSignatureFromTransaction } from '@solana/transactions';\n *\n * try {\n *     const transactionSignature = getSignatureFromTransaction(tx);\n *     assertIsFullySignedTransaction(tx);\n *     /* ... *\\/\n * } catch (e) {\n *     if (isSolanaError(e, SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING)) {\n *         displayError(\n *             \"We can't send this transaction without signatures for these addresses:\\n- %s\",\n *             // The type of the `context` object is now refined to contain `addresses`.\n *             e.context.addresses.join('\\n- '),\n *         );\n *         return;\n *     } else if (isSolanaError(e, SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING)) {\n *         if (!tx.feePayer) {\n *             displayError('Choose a fee payer for this transaction before sending it');\n *         } else {\n *             displayError('The fee payer still needs to sign for this transaction');\n *         }\n *         return;\n *     }\n *     throw e;\n * }\n * ```\n */\nexport function isSolanaError<TErrorCode extends SolanaErrorCode>(\n    e: unknown,\n    /**\n     * When supplied, this function will require that the input is a {@link SolanaError} _and_ that\n     * its error code is exactly this value.\n     */\n    code?: TErrorCode,\n): e is SolanaError<TErrorCode> {\n    const isSolanaError = e instanceof Error && e.name === 'SolanaError';\n    if (isSolanaError) {\n        if (code !== undefined) {\n            return (e as SolanaError<TErrorCode>).context.__code === code;\n        }\n        return true;\n    }\n    return false;\n}\n\ntype SolanaErrorCodedContext = Readonly<{\n    [P in SolanaErrorCode]: (SolanaErrorContext[P] extends undefined ? object : SolanaErrorContext[P]) & {\n        __code: P;\n    };\n}>;\n\n/**\n * Encapsulates an error's stacktrace, a Solana-specific numeric code that indicates what went\n * wrong, and optional context if the type of error indicated by the code supports it.\n */\nexport class SolanaError<TErrorCode extends SolanaErrorCode = SolanaErrorCode> extends Error {\n    /**\n     * Indicates the root cause of this {@link SolanaError}, if any.\n     *\n     * For example, a transaction error might have an instruction error as its root cause. In this\n     * case, you will be able to access the instruction error on the transaction error as `cause`.\n     */\n    readonly cause?: TErrorCode extends SolanaErrorCodeWithCause ? SolanaError : unknown = this.cause;\n    /**\n     * Contains context that can assist in understanding or recovering from a {@link SolanaError}.\n     */\n    readonly context: SolanaErrorCodedContext[TErrorCode];\n    constructor(\n        ...[code, contextAndErrorOptions]: SolanaErrorContext[TErrorCode] extends undefined\n            ? [code: TErrorCode, errorOptions?: ErrorOptions | undefined]\n            : [code: TErrorCode, contextAndErrorOptions: SolanaErrorContext[TErrorCode] & (ErrorOptions | undefined)]\n    ) {\n        let context: SolanaErrorContext[TErrorCode] | undefined;\n        let errorOptions: ErrorOptions | undefined;\n        if (contextAndErrorOptions) {\n            Object.entries(Object.getOwnPropertyDescriptors(contextAndErrorOptions)).forEach(([name, descriptor]) => {\n                // If the `ErrorOptions` type ever changes, update this code.\n                if (name === 'cause') {\n                    errorOptions = { cause: descriptor.value };\n                } else {\n                    if (context === undefined) {\n                        context = {} as SolanaErrorContext[TErrorCode];\n                    }\n                    Object.defineProperty(context, name, descriptor);\n                }\n            });\n        }\n        const message = getErrorMessage(code, context);\n        super(message, errorOptions);\n        this.context = (context === undefined ? {} : context) as SolanaErrorCodedContext[TErrorCode];\n        this.context.__code = code;\n        // This is necessary so that `isSolanaError()` can identify a `SolanaError` without having\n        // to import the class for use in an `instanceof` check.\n        this.name = 'SolanaError';\n    }\n}\n","export function safeCaptureStackTrace(...args: Parameters<typeof Error.captureStackTrace>): void {\n    if ('captureStackTrace' in Error && typeof Error.captureStackTrace === 'function') {\n        Error.captureStackTrace(...args);\n    }\n}\n","import { SolanaErrorCode } from './codes';\nimport { SolanaErrorContext } from './context';\nimport { SolanaError } from './error';\nimport { safeCaptureStackTrace } from './stack-trace';\n\ntype Config = Readonly<{\n    /**\n     * Oh, hello. You might wonder what in tarnation is going on here. Allow us to explain.\n     *\n     * One of the goals of `@solana/errors` is to allow errors that are not interesting to your\n     * application to shake out of your app bundle in production. This means that we must never\n     * export large hardcoded maps of error codes/messages.\n     *\n     * Unfortunately, where instruction and transaction errors from the RPC are concerned, we have\n     * no choice but to keep a map between the RPC `rpcEnumError` enum name and its corresponding\n     * `SolanaError` code. In the interest of implementing that map in as few bytes of source code\n     * as possible, we do the following:\n     *\n     *   1. Reserve a block of sequential error codes for the enum in question\n     *   2. Hardcode the list of enum names in that same order\n     *   3. Match the enum error name from the RPC with its index in that list, and reconstruct the\n     *      `SolanaError` code by adding the `errorCodeBaseOffset` to that index\n     */\n    errorCodeBaseOffset: number;\n    getErrorContext: (\n        errorCode: SolanaErrorCode,\n        rpcErrorName: string,\n        rpcErrorContext?: unknown,\n    ) => SolanaErrorContext[SolanaErrorCode];\n    orderedErrorNames: string[];\n    rpcEnumError: string | { [key: string]: unknown };\n}>;\n\nexport function getSolanaErrorFromRpcError(\n    { errorCodeBaseOffset, getErrorContext, orderedErrorNames, rpcEnumError }: Config,\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\n    constructorOpt: Function,\n): SolanaError {\n    let rpcErrorName;\n    let rpcErrorContext;\n    if (typeof rpcEnumError === 'string') {\n        rpcErrorName = rpcEnumError;\n    } else {\n        rpcErrorName = Object.keys(rpcEnumError)[0];\n        rpcErrorContext = rpcEnumError[rpcErrorName];\n    }\n    const codeOffset = orderedErrorNames.indexOf(rpcErrorName);\n    const errorCode = (errorCodeBaseOffset + codeOffset) as SolanaErrorCode;\n    const errorContext = getErrorContext(errorCode, rpcErrorName, rpcErrorContext);\n    const err = new SolanaError(errorCode, errorContext);\n    safeCaptureStackTrace(err, constructorOpt);\n    return err;\n}\n","import { SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM, SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN } from './codes';\nimport { SolanaError } from './error';\nimport { getSolanaErrorFromRpcError } from './rpc-enum-errors';\n\nconst ORDERED_ERROR_NAMES = [\n    // Keep synced with RPC source: https://github.com/anza-xyz/solana-sdk/blob/master/instruction-error/src/lib.rs\n    // If this list ever gets too large, consider implementing a compression strategy like this:\n    // https://gist.github.com/steveluscher/aaa7cbbb5433b1197983908a40860c47\n    'GenericError',\n    'InvalidArgument',\n    'InvalidInstructionData',\n    'InvalidAccountData',\n    'AccountDataTooSmall',\n    'InsufficientFunds',\n    'IncorrectProgramId',\n    'MissingRequiredSignature',\n    'AccountAlreadyInitialized',\n    'UninitializedAccount',\n    'UnbalancedInstruction',\n    'ModifiedProgramId',\n    'ExternalAccountLamportSpend',\n    'ExternalAccountDataModified',\n    'ReadonlyLamportChange',\n    'ReadonlyDataModified',\n    'DuplicateAccountIndex',\n    'ExecutableModified',\n    'RentEpochModified',\n    'NotEnoughAccountKeys',\n    'AccountDataSizeChanged',\n    'AccountNotExecutable',\n    'AccountBorrowFailed',\n    'AccountBorrowOutstanding',\n    'DuplicateAccountOutOfSync',\n    'Custom',\n    'InvalidError',\n    'ExecutableDataModified',\n    'ExecutableLamportChange',\n    'ExecutableAccountNotRentExempt',\n    'UnsupportedProgramId',\n    'CallDepth',\n    'MissingAccount',\n    'ReentrancyNotAllowed',\n    'MaxSeedLengthExceeded',\n    'InvalidSeeds',\n    'InvalidRealloc',\n    'ComputationalBudgetExceeded',\n    'PrivilegeEscalation',\n    'ProgramEnvironmentSetupFailure',\n    'ProgramFailedToComplete',\n    'ProgramFailedToCompile',\n    'Immutable',\n    'IncorrectAuthority',\n    'BorshIoError',\n    'AccountNotRentExempt',\n    'InvalidAccountOwner',\n    'ArithmeticOverflow',\n    'UnsupportedSysvar',\n    'IllegalOwner',\n    'MaxAccountsDataAllocationsExceeded',\n    'MaxAccountsExceeded',\n    'MaxInstructionTraceLengthExceeded',\n    'BuiltinProgramsMustConsumeComputeUnits',\n];\n\nexport function getSolanaErrorFromInstructionError(\n    /**\n     * The index of the instruction inside the transaction.\n     */\n    index: bigint | number,\n    instructionError: string | { [key: string]: unknown },\n): SolanaError {\n    const numberIndex = Number(index);\n    return getSolanaErrorFromRpcError(\n        {\n            errorCodeBaseOffset: 4615001,\n            getErrorContext(errorCode, rpcErrorName, rpcErrorContext) {\n                if (errorCode === SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN) {\n                    return {\n                        errorName: rpcErrorName,\n                        index: numberIndex,\n                        ...(rpcErrorContext !== undefined ? { instructionErrorContext: rpcErrorContext } : null),\n                    };\n                } else if (errorCode === SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM) {\n                    return {\n                        code: Number(rpcErrorContext as bigint | number),\n                        index: numberIndex,\n                    };\n                }\n                return { index: numberIndex };\n            },\n            orderedErrorNames: ORDERED_ERROR_NAMES,\n            rpcEnumError: instructionError,\n        },\n        getSolanaErrorFromInstructionError,\n    );\n}\n","import {\n    SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION,\n    SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT,\n    SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED,\n    SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN,\n} from './codes';\nimport { SolanaError } from './error';\nimport { getSolanaErrorFromInstructionError } from './instruction-error';\nimport { getSolanaErrorFromRpcError } from './rpc-enum-errors';\n\n/**\n * How to add an error when an entry is added to the RPC `TransactionError` enum:\n *\n *   1. Follow the instructions in `./codes.ts` to add a corresponding Solana error code\n *   2. Add the `TransactionError` enum name in the same order as it appears in `./codes.ts`\n *   3. Add the new error name/code mapping to `./__tests__/transaction-error-test.ts`\n */\nconst ORDERED_ERROR_NAMES = [\n    // Keep synced with RPC source: https://github.com/anza-xyz/agave/blob/master/sdk/src/transaction/error.rs\n    // If this list ever gets too large, consider implementing a compression strategy like this:\n    // https://gist.github.com/steveluscher/aaa7cbbb5433b1197983908a40860c47\n    'AccountInUse',\n    'AccountLoadedTwice',\n    'AccountNotFound',\n    'ProgramAccountNotFound',\n    'InsufficientFundsForFee',\n    'InvalidAccountForFee',\n    'AlreadyProcessed',\n    'BlockhashNotFound',\n    // `InstructionError` intentionally omitted; delegated to `getSolanaErrorFromInstructionError`\n    'CallChainTooDeep',\n    'MissingSignatureForFee',\n    'InvalidAccountIndex',\n    'SignatureFailure',\n    'InvalidProgramForExecution',\n    'SanitizeFailure',\n    'ClusterMaintenance',\n    'AccountBorrowOutstanding',\n    'WouldExceedMaxBlockCostLimit',\n    'UnsupportedVersion',\n    'InvalidWritableAccount',\n    'WouldExceedMaxAccountCostLimit',\n    'WouldExceedAccountDataBlockLimit',\n    'TooManyAccountLocks',\n    'AddressLookupTableNotFound',\n    'InvalidAddressLookupTableOwner',\n    'InvalidAddressLookupTableData',\n    'InvalidAddressLookupTableIndex',\n    'InvalidRentPayingAccount',\n    'WouldExceedMaxVoteCostLimit',\n    'WouldExceedAccountDataTotalLimit',\n    'DuplicateInstruction',\n    'InsufficientFundsForRent',\n    'MaxLoadedAccountsDataSizeExceeded',\n    'InvalidLoadedAccountsDataSizeLimit',\n    'ResanitizationNeeded',\n    'ProgramExecutionTemporarilyRestricted',\n    'UnbalancedTransaction',\n];\n\nexport function getSolanaErrorFromTransactionError(transactionError: string | { [key: string]: unknown }): SolanaError {\n    if (typeof transactionError === 'object' && 'InstructionError' in transactionError) {\n        return getSolanaErrorFromInstructionError(\n            ...(transactionError.InstructionError as Parameters<typeof getSolanaErrorFromInstructionError>),\n        );\n    }\n    return getSolanaErrorFromRpcError(\n        {\n            errorCodeBaseOffset: 7050001,\n            getErrorContext(errorCode, rpcErrorName, rpcErrorContext) {\n                if (errorCode === SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN) {\n                    return {\n                        errorName: rpcErrorName,\n                        ...(rpcErrorContext !== undefined ? { transactionErrorContext: rpcErrorContext } : null),\n                    };\n                } else if (errorCode === SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION) {\n                    return {\n                        index: Number(rpcErrorContext as bigint | number),\n                    };\n                } else if (\n                    errorCode === SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT ||\n                    errorCode === SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED\n                ) {\n                    return {\n                        accountIndex: Number((rpcErrorContext as { account_index: bigint | number }).account_index),\n                    };\n                }\n            },\n            orderedErrorNames: ORDERED_ERROR_NAMES,\n            rpcEnumError: transactionError,\n        },\n        getSolanaErrorFromTransactionError,\n    );\n}\n","import {\n    SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR,\n    SOLANA_ERROR__JSON_RPC__INVALID_PARAMS,\n    SOLANA_ERROR__JSON_RPC__INVALID_REQUEST,\n    SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND,\n    SOLANA_ERROR__JSON_RPC__PARSE_ERROR,\n    SOLANA_ERROR__JSON_RPC__SCAN_ERROR,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION,\n    SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR,\n    SolanaErrorCode,\n} from './codes';\nimport { SolanaErrorContext } from './context';\nimport { SolanaError } from './error';\nimport { safeCaptureStackTrace } from './stack-trace';\nimport { getSolanaErrorFromTransactionError } from './transaction-error';\n\ninterface RpcErrorResponse {\n    code: bigint | number;\n    data?: unknown;\n    message: string;\n}\n\ntype TransactionError = string | { [key: string]: unknown };\n\n/**\n * Keep in sync with https://github.com/anza-xyz/agave/blob/master/rpc-client-types/src/response.rs\n * @hidden\n */\nexport interface RpcSimulateTransactionResult {\n    accounts:\n        | ({\n              data:\n                  | string // LegacyBinary\n                  | {\n                        // Json\n                        parsed: unknown;\n                        program: string;\n                        space: number;\n                    }\n                  // Binary\n                  | [encodedBytes: string, encoding: 'base58' | 'base64' | 'base64+zstd' | 'binary' | 'jsonParsed'];\n              executable: boolean;\n              lamports: number;\n              owner: string;\n              rentEpoch: number;\n              space?: number;\n          } | null)[]\n        | null;\n    err: TransactionError | null;\n    // Enabled by `enable_cpi_recording`\n    innerInstructions?:\n        | {\n              index: number;\n              instructions: (\n                  | {\n                        // Compiled\n                        accounts: number[];\n                        data: string;\n                        programIdIndex: number;\n                        stackHeight?: number;\n                    }\n                  | {\n                        // Parsed\n                        parsed: unknown;\n                        program: string;\n                        programId: string;\n                        stackHeight?: number;\n                    }\n                  | {\n                        // PartiallyDecoded\n                        accounts: string[];\n                        data: string;\n                        programId: string;\n                        stackHeight?: number;\n                    }\n              )[];\n          }[]\n        | null;\n    loadedAccountsDataSize: number | null;\n    logs: string[] | null;\n    replacementBlockhash: string | null;\n    returnData: {\n        data: [string, 'base64'];\n        programId: string;\n    } | null;\n    unitsConsumed: bigint | null;\n}\n\nexport function getSolanaErrorFromJsonRpcError(putativeErrorResponse: unknown): SolanaError {\n    let out: SolanaError;\n    if (isRpcErrorResponse(putativeErrorResponse)) {\n        const { code: rawCode, data, message } = putativeErrorResponse;\n        const code = Number(rawCode);\n        if (code === SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE) {\n            const { err, ...preflightErrorContext } = data as RpcSimulateTransactionResult;\n            const causeObject = err ? { cause: getSolanaErrorFromTransactionError(err) } : null;\n            out = new SolanaError(SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE, {\n                ...preflightErrorContext,\n                ...causeObject,\n            });\n        } else {\n            let errorContext;\n            switch (code) {\n                case SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR:\n                case SOLANA_ERROR__JSON_RPC__INVALID_PARAMS:\n                case SOLANA_ERROR__JSON_RPC__INVALID_REQUEST:\n                case SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND:\n                case SOLANA_ERROR__JSON_RPC__PARSE_ERROR:\n                case SOLANA_ERROR__JSON_RPC__SCAN_ERROR:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION:\n                    // The server supplies no structured data, but rather a pre-formatted message. Put\n                    // the server message in `context` so as not to completely lose the data. The long\n                    // term fix for this is to add data to the server responses and modify the\n                    // messages in `@solana/errors` to be actual format strings.\n                    errorContext = { __serverMessage: message };\n                    break;\n                default:\n                    if (typeof data === 'object' && !Array.isArray(data)) {\n                        errorContext = data;\n                    }\n            }\n            out = new SolanaError(code as SolanaErrorCode, errorContext as SolanaErrorContext[SolanaErrorCode]);\n        }\n    } else {\n        const message =\n            typeof putativeErrorResponse === 'object' &&\n            putativeErrorResponse !== null &&\n            'message' in putativeErrorResponse &&\n            typeof putativeErrorResponse.message === 'string'\n                ? putativeErrorResponse.message\n                : 'Malformed JSON-RPC error with no message attribute';\n        out = new SolanaError(SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR, { error: putativeErrorResponse, message });\n    }\n    safeCaptureStackTrace(out, getSolanaErrorFromJsonRpcError);\n    return out;\n}\n\nfunction isRpcErrorResponse(value: unknown): value is RpcErrorResponse {\n    return (\n        typeof value === 'object' &&\n        value !== null &&\n        'code' in value &&\n        'message' in value &&\n        (typeof value.code === 'number' || typeof value.code === 'bigint') &&\n        typeof value.message === 'string'\n    );\n}\n","import { Address } from '@solana/addresses';\nimport { ReadonlyUint8Array } from '@solana/codecs-core';\nimport {\n    SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS,\n    SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA,\n    SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH,\n    SolanaError,\n} from '@solana/errors';\n\nimport { AccountLookupMeta, AccountMeta } from './accounts';\n\n/**\n * An instruction destined for a given program.\n *\n * @example\n * ```ts\n * type StakeProgramInstruction = Instruction<'StakeConfig11111111111111111111111111111111'>;\n * ```\n */\nexport interface Instruction<\n    TProgramAddress extends string = string,\n    TAccounts extends readonly (AccountLookupMeta | AccountMeta)[] = readonly (AccountLookupMeta | AccountMeta)[],\n> {\n    readonly accounts?: TAccounts;\n    readonly data?: ReadonlyUint8Array;\n    readonly programAddress: Address<TProgramAddress>;\n}\n\n/**\n * An instruction that loads certain accounts.\n *\n * @example\n * ```ts\n * type InstructionWithTwoAccounts = InstructionWithAccounts<\n *     [\n *         WritableAccount, // First account\n *         RentSysvar, // Second account\n *     ]\n * >;\n * ```\n */\nexport interface InstructionWithAccounts<TAccounts extends readonly (AccountLookupMeta | AccountMeta)[]>\n    extends Instruction {\n    readonly accounts: TAccounts;\n}\n\nexport function isInstructionForProgram<TProgramAddress extends string, TInstruction extends Instruction>(\n    instruction: TInstruction,\n    programAddress: Address<TProgramAddress>,\n): instruction is TInstruction & { programAddress: Address<TProgramAddress> } {\n    return instruction.programAddress === programAddress;\n}\n\nexport function assertIsInstructionForProgram<TProgramAddress extends string, TInstruction extends Instruction>(\n    instruction: TInstruction,\n    programAddress: Address<TProgramAddress>,\n): asserts instruction is TInstruction & { programAddress: Address<TProgramAddress> } {\n    if (instruction.programAddress !== programAddress) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH, {\n            actualProgramAddress: instruction.programAddress,\n            expectedProgramAddress: programAddress,\n        });\n    }\n}\n\nexport function isInstructionWithAccounts<\n    TAccounts extends readonly (AccountLookupMeta | AccountMeta)[] = readonly (AccountLookupMeta | AccountMeta)[],\n    TInstruction extends Instruction = Instruction,\n>(instruction: TInstruction): instruction is InstructionWithAccounts<TAccounts> & TInstruction {\n    return instruction.accounts !== undefined;\n}\n\nexport function assertIsInstructionWithAccounts<\n    TAccounts extends readonly (AccountLookupMeta | AccountMeta)[] = readonly (AccountLookupMeta | AccountMeta)[],\n    TInstruction extends Instruction = Instruction,\n>(instruction: TInstruction): asserts instruction is InstructionWithAccounts<TAccounts> & TInstruction {\n    if (instruction.accounts === undefined) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS, {\n            data: instruction.data,\n            programAddress: instruction.programAddress,\n        });\n    }\n}\n\n/**\n * An instruction whose data conforms to a certain type.\n *\n * This is most useful when you have a branded `Uint8Array` that represents a particular\n * instruction's data.\n *\n * @example A type for the \\`AdvanceNonce\\` instruction of the System program\n * ```ts\n * type AdvanceNonceAccountInstruction<\n *     TNonceAccountAddress extends string = string,\n *     TNonceAuthorityAddress extends string = string,\n * > = Instruction<'11111111111111111111111111111111'> &\n *     InstructionWithAccounts<\n *         [\n *             WritableAccount<TNonceAccountAddress>,\n *             ReadonlyAccount<'SysvarRecentB1ockHashes11111111111111111111'>,\n *             ReadonlySignerAccount<TNonceAuthorityAddress>,\n *         ]\n *     > &\n *     InstructionWithData<AdvanceNonceAccountInstructionData>;\n * ```\n */\nexport interface InstructionWithData<TData extends ReadonlyUint8Array> extends Instruction {\n    readonly data: TData;\n}\n\nexport function isInstructionWithData<\n    TData extends ReadonlyUint8Array = ReadonlyUint8Array,\n    TInstruction extends Instruction = Instruction,\n>(instruction: TInstruction): instruction is InstructionWithData<TData> & TInstruction {\n    return instruction.data !== undefined;\n}\n\nexport function assertIsInstructionWithData<\n    TData extends ReadonlyUint8Array = ReadonlyUint8Array,\n    TInstruction extends Instruction = Instruction,\n>(instruction: TInstruction): asserts instruction is InstructionWithData<TData> & TInstruction {\n    if (instruction.data === undefined) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA, {\n            accountAddresses: instruction.accounts?.map(a => a.address),\n            programAddress: instruction.programAddress,\n        });\n    }\n}\n","/**\n * Describes the purpose for which an account participates in a transaction.\n *\n * Every account that participates in a transaction can be read from, but only ones that you mark as\n * writable may be written to, and only ones that you indicate must sign the transaction will gain\n * the privileges associated with signers at runtime.\n *\n * |                               | `isSigner` | `isWritable` |\n * | ----------------------------- | ---------- | ------------ |\n * | `AccountRole.READONLY`        | &#x274c;   | &#x274c;     |\n * | `AccountRole.WRITABLE`        | &#x274c;   | &#x2705;     |\n * | `AccountRole.READONLY_SIGNER` | &#x2705;   | &#x274c;     |\n * | `AccountRole.WRITABLE_SIGNER` | &#x2705;   | &#x2705;     |\n */\nexport enum AccountRole {\n    // Bitflag guide: is signer  is writable\n    WRITABLE_SIGNER = /* 3 */ 0b11, // prettier-ignore\n    READONLY_SIGNER = /* 2 */ 0b10, // prettier-ignore\n    WRITABLE =        /* 1 */ 0b01, // prettier-ignore\n    READONLY =        /* 0 */ 0b00, // prettier-ignore\n}\n\n// Quick primer on bitwise operations: https://stackoverflow.com/a/1436448/802047\nconst IS_SIGNER_BITMASK = 0b10;\nconst IS_WRITABLE_BITMASK = 0b01;\n\n/**\n * @returns An {@link AccountRole} representing the non-signer variant of the supplied role.\n */\nexport function downgradeRoleToNonSigner(role: AccountRole.READONLY_SIGNER): AccountRole.READONLY;\nexport function downgradeRoleToNonSigner(role: AccountRole.WRITABLE_SIGNER): AccountRole.WRITABLE;\nexport function downgradeRoleToNonSigner(role: AccountRole): AccountRole;\nexport function downgradeRoleToNonSigner(role: AccountRole): AccountRole {\n    return role & ~IS_SIGNER_BITMASK;\n}\n\n/**\n * @returns An {@link AccountRole} representing the read-only variant of the supplied role.\n */\nexport function downgradeRoleToReadonly(role: AccountRole.WRITABLE): AccountRole.READONLY;\nexport function downgradeRoleToReadonly(role: AccountRole.WRITABLE_SIGNER): AccountRole.READONLY_SIGNER;\nexport function downgradeRoleToReadonly(role: AccountRole): AccountRole;\nexport function downgradeRoleToReadonly(role: AccountRole): AccountRole {\n    return role & ~IS_WRITABLE_BITMASK;\n}\n\n/**\n * Returns `true` if the {@link AccountRole} given represents that of a signer. Also refines the\n * TypeScript type of the supplied role.\n */\nexport function isSignerRole(role: AccountRole): role is AccountRole.READONLY_SIGNER | AccountRole.WRITABLE_SIGNER {\n    return role >= AccountRole.READONLY_SIGNER;\n}\n\n/**\n * Returns `true` if the {@link AccountRole} given represents that of a writable account. Also\n * refines the TypeScript type of the supplied role.\n */\nexport function isWritableRole(role: AccountRole): role is AccountRole.WRITABLE | AccountRole.WRITABLE_SIGNER {\n    return (role & IS_WRITABLE_BITMASK) !== 0;\n}\n\n/**\n * Given two {@link AccountRole | AccountRoles}, will return the {@link AccountRole} that grants the\n * highest privileges of both.\n *\n * @example\n * ```ts\n * // Returns `AccountRole.WRITABLE_SIGNER`\n * mergeRoles(AccountRole.READONLY_SIGNER, AccountRole.WRITABLE);\n * ```\n */\nexport function mergeRoles(roleA: AccountRole.WRITABLE, roleB: AccountRole.READONLY_SIGNER): AccountRole.WRITABLE_SIGNER; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole.READONLY_SIGNER, roleB: AccountRole.WRITABLE): AccountRole.WRITABLE_SIGNER; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole, roleB: AccountRole.WRITABLE_SIGNER): AccountRole.WRITABLE_SIGNER; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole.WRITABLE_SIGNER, roleB: AccountRole): AccountRole.WRITABLE_SIGNER; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole, roleB: AccountRole.READONLY_SIGNER): AccountRole.READONLY_SIGNER; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole.READONLY_SIGNER, roleB: AccountRole): AccountRole.READONLY_SIGNER; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole, roleB: AccountRole.WRITABLE): AccountRole.WRITABLE; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole.WRITABLE, roleB: AccountRole): AccountRole.WRITABLE; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole.READONLY, roleB: AccountRole.READONLY): AccountRole.READONLY; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole, roleB: AccountRole): AccountRole; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole, roleB: AccountRole): AccountRole {\n    return roleA | roleB;\n}\n\n/**\n * @returns An {@link AccountRole} representing the signer variant of the supplied role.\n */\nexport function upgradeRoleToSigner(role: AccountRole.READONLY): AccountRole.READONLY_SIGNER;\nexport function upgradeRoleToSigner(role: AccountRole.WRITABLE): AccountRole.WRITABLE_SIGNER;\nexport function upgradeRoleToSigner(role: AccountRole): AccountRole;\nexport function upgradeRoleToSigner(role: AccountRole): AccountRole {\n    return role | IS_SIGNER_BITMASK;\n}\n\n/**\n * @returns An {@link AccountRole} representing the writable variant of the supplied role.\n */\nexport function upgradeRoleToWritable(role: AccountRole.READONLY): AccountRole.WRITABLE;\nexport function upgradeRoleToWritable(role: AccountRole.READONLY_SIGNER): AccountRole.WRITABLE_SIGNER;\nexport function upgradeRoleToWritable(role: AccountRole): AccountRole;\nexport function upgradeRoleToWritable(role: AccountRole): AccountRole {\n    return role | IS_WRITABLE_BITMASK;\n}\n","import { SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED, SolanaError } from '@solana/errors';\n\n/**\n * Throws an exception unless {@link Crypto#getRandomValues | `crypto.getRandomValues()`} is\n * available in the current JavaScript environment.\n */\nexport function assertPRNGIsAvailable() {\n    if (typeof globalThis.crypto === 'undefined' || typeof globalThis.crypto.getRandomValues !== 'function') {\n        throw new SolanaError(SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED);\n    }\n}\n","import { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\n/**\n * Asserts that a given string contains only characters from the specified alphabet.\n *\n * This function validates whether a string consists exclusively of characters\n * from the provided `alphabet`. If the validation fails, it throws an error\n * indicating the invalid base string.\n *\n * @param alphabet - The allowed set of characters for the base encoding.\n * @param testValue - The string to validate against the given alphabet.\n * @param givenValue - The original string provided by the user (defaults to `testValue`).\n *\n * @throws {SolanaError} If `testValue` contains characters not present in `alphabet`.\n *\n * @example\n * Validating a base-8 encoded string.\n * ```ts\n * assertValidBaseString('01234567', '123047'); // Passes\n * assertValidBaseString('01234567', '128');    // Throws error\n * ```\n */\nexport function assertValidBaseString(alphabet: string, testValue: string, givenValue = testValue) {\n    if (!testValue.match(new RegExp(`^[${alphabet}]*$`))) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n            alphabet,\n            base: alphabet.length,\n            value: givenValue,\n        });\n    }\n}\n","import { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Concatenates an array of `Uint8Array`s into a single `Uint8Array`.\n * Reuses the original byte array when applicable.\n *\n * @param byteArrays - The array of byte arrays to concatenate.\n *\n * @example\n * ```ts\n * const bytes1 = new Uint8Array([0x01, 0x02]);\n * const bytes2 = new Uint8Array([]);\n * const bytes3 = new Uint8Array([0x03, 0x04]);\n * const bytes = mergeBytes([bytes1, bytes2, bytes3]);\n * //    ^ [0x01, 0x02, 0x03, 0x04]\n * ```\n */\nexport const mergeBytes = (byteArrays: Uint8Array[]): Uint8Array => {\n    const nonEmptyByteArrays = byteArrays.filter(arr => arr.length);\n    if (nonEmptyByteArrays.length === 0) {\n        return byteArrays.length ? byteArrays[0] : new Uint8Array();\n    }\n\n    if (nonEmptyByteArrays.length === 1) {\n        return nonEmptyByteArrays[0];\n    }\n\n    const totalLength = nonEmptyByteArrays.reduce((total, arr) => total + arr.length, 0);\n    const result = new Uint8Array(totalLength);\n    let offset = 0;\n    nonEmptyByteArrays.forEach(arr => {\n        result.set(arr, offset);\n        offset += arr.length;\n    });\n    return result;\n};\n\n/**\n * Pads a `Uint8Array` with zeroes to the specified length.\n * If the array is longer than the specified length, it is returned as-is.\n *\n * @param bytes - The byte array to pad.\n * @param length - The desired length of the byte array.\n *\n * @example\n * Adds zeroes to the end of the byte array to reach the desired length.\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02]);\n * const paddedBytes = padBytes(bytes, 4);\n * //    ^ [0x01, 0x02, 0x00, 0x00]\n * ```\n *\n * @example\n * Returns the original byte array if it is already at the desired length.\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02]);\n * const paddedBytes = padBytes(bytes, 2);\n * // bytes === paddedBytes\n * ```\n */\nexport function padBytes(bytes: Uint8Array, length: number): Uint8Array;\nexport function padBytes(bytes: ReadonlyUint8Array, length: number): ReadonlyUint8Array;\nexport function padBytes(bytes: ReadonlyUint8Array, length: number): ReadonlyUint8Array {\n    if (bytes.length >= length) return bytes;\n    const paddedBytes = new Uint8Array(length).fill(0);\n    paddedBytes.set(bytes);\n    return paddedBytes;\n}\n\n/**\n * Fixes a `Uint8Array` to the specified length.\n * If the array is longer than the specified length, it is truncated.\n * If the array is shorter than the specified length, it is padded with zeroes.\n *\n * @param bytes - The byte array to truncate or pad.\n * @param length - The desired length of the byte array.\n *\n * @example\n * Truncates the byte array to the desired length.\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02, 0x03, 0x04]);\n * const fixedBytes = fixBytes(bytes, 2);\n * //    ^ [0x01, 0x02]\n * ```\n *\n * @example\n * Adds zeroes to the end of the byte array to reach the desired length.\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02]);\n * const fixedBytes = fixBytes(bytes, 4);\n * //    ^ [0x01, 0x02, 0x00, 0x00]\n * ```\n *\n * @example\n * Returns the original byte array if it is already at the desired length.\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02]);\n * const fixedBytes = fixBytes(bytes, 2);\n * // bytes === fixedBytes\n * ```\n */\nexport const fixBytes = (bytes: ReadonlyUint8Array | Uint8Array, length: number): ReadonlyUint8Array | Uint8Array =>\n    padBytes(bytes.length <= length ? bytes : bytes.slice(0, length), length);\n\n/**\n * Returns true if and only if the provided `data` byte array contains\n * the provided `bytes` byte array at the specified `offset`.\n *\n * @param data - The byte sequence to search for.\n * @param bytes - The byte array in which to search for `data`.\n * @param offset - The position in `bytes` where the search begins.\n *\n * @example\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02, 0x03, 0x04]);\n * const data = new Uint8Array([0x02, 0x03]);\n * containsBytes(bytes, data, 1); // true\n * containsBytes(bytes, data, 2); // false\n * ```\n */\nexport function containsBytes(\n    data: ReadonlyUint8Array | Uint8Array,\n    bytes: ReadonlyUint8Array | Uint8Array,\n    offset: number,\n): boolean {\n    const slice = offset === 0 && data.length === bytes.length ? data : data.slice(offset, offset + bytes.length);\n    if (slice.length !== bytes.length) return false;\n    return bytes.every((b, i) => b === slice[i]);\n}\n","import {\n    combineCodec,\n    Decoder,\n    Encoder,\n    fixDecoderSize,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    fixEncoderSize,\n    transformEncoder,\n} from '@solana/codecs-core';\nimport { getBase58Decoder, getBase58Encoder } from '@solana/codecs-strings';\nimport {\n    SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE,\n    SolanaError,\n} from '@solana/errors';\nimport { Brand, EncodedString } from '@solana/nominal-types';\n\n/**\n * Represents a string that validates as a Solana address. Functions that require well-formed\n * addresses should specify their inputs in terms of this type.\n *\n * Whenever you need to validate an arbitrary string as a base58-encoded address, use the\n * {@link address}, {@link assertIsAddress}, or {@link isAddress} functions in this package.\n */\nexport type Address<TAddress extends string = string> = Brand<EncodedString<TAddress, 'base58'>, 'Address'>;\n\nlet memoizedBase58Encoder: Encoder<string> | undefined;\nlet memoizedBase58Decoder: Decoder<string> | undefined;\n\nfunction getMemoizedBase58Encoder(): Encoder<string> {\n    if (!memoizedBase58Encoder) memoizedBase58Encoder = getBase58Encoder();\n    return memoizedBase58Encoder;\n}\n\nfunction getMemoizedBase58Decoder(): Decoder<string> {\n    if (!memoizedBase58Decoder) memoizedBase58Decoder = getBase58Decoder();\n    return memoizedBase58Decoder;\n}\n\n/**\n * A type guard that returns `true` if the input string conforms to the {@link Address} type, and\n * refines its type for use in your program.\n *\n * @example\n * ```ts\n * import { isAddress } from '@solana/addresses';\n *\n * if (isAddress(ownerAddress)) {\n *     // At this point, `ownerAddress` has been refined to a\n *     // `Address` that can be used with the RPC.\n *     const { value: lamports } = await rpc.getBalance(ownerAddress).send();\n *     setBalanceLamports(lamports);\n * } else {\n *     setError(`${ownerAddress} is not an address`);\n * }\n * ```\n */\nexport function isAddress(putativeAddress: string): putativeAddress is Address<typeof putativeAddress> {\n    // Fast-path; see if the input string is of an acceptable length.\n    if (\n        // Lowest address (32 bytes of zeroes)\n        putativeAddress.length < 32 ||\n        // Highest address (32 bytes of 255)\n        putativeAddress.length > 44\n    ) {\n        return false;\n    }\n    // Slow-path; actually attempt to decode the input string.\n    const base58Encoder = getMemoizedBase58Encoder();\n    try {\n        return base58Encoder.encode(putativeAddress).byteLength === 32;\n    } catch {\n        return false;\n    }\n}\n\n/**\n * From time to time you might acquire a string, that you expect to validate as an address or public\n * key, from an untrusted network API or user input. Use this function to assert that such an\n * arbitrary string is a base58-encoded address.\n *\n * @example\n * ```ts\n * import { assertIsAddress } from '@solana/addresses';\n *\n * // Imagine a function that fetches an account's balance when a user submits a form.\n * function handleSubmit() {\n *     // We know only that what the user typed conforms to the `string` type.\n *     const address: string = accountAddressInput.value;\n *     try {\n *         // If this type assertion function doesn't throw, then\n *         // Typescript will upcast `address` to `Address`.\n *         assertIsAddress(address);\n *         // At this point, `address` is an `Address` that can be used with the RPC.\n *         const balanceInLamports = await rpc.getBalance(address).send();\n *     } catch (e) {\n *         // `address` turned out not to be a base58-encoded address\n *     }\n * }\n * ```\n */\nexport function assertIsAddress(putativeAddress: string): asserts putativeAddress is Address<typeof putativeAddress> {\n    // Fast-path; see if the input string is of an acceptable length.\n    if (\n        // Lowest address (32 bytes of zeroes)\n        putativeAddress.length < 32 ||\n        // Highest address (32 bytes of 255)\n        putativeAddress.length > 44\n    ) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE, {\n            actualLength: putativeAddress.length,\n        });\n    }\n    // Slow-path; actually attempt to decode the input string.\n    const base58Encoder = getMemoizedBase58Encoder();\n    const bytes = base58Encoder.encode(putativeAddress);\n    const numBytes = bytes.byteLength;\n    if (numBytes !== 32) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH, {\n            actualLength: numBytes,\n        });\n    }\n}\n\n/**\n * Combines _asserting_ that a string is an address with _coercing_ it to the {@link Address} type.\n * It's most useful with untrusted input.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n *\n * await transfer(address(fromAddress), address(toAddress), lamports(100000n));\n * ```\n *\n * > [!TIP]\n * > When starting from a known-good address as a string, it's more efficient to typecast it rather\n * than to use the {@link address} helper, because the helper unconditionally performs validation on\n * its input.\n * >\n * > ```ts\n * > import { Address } from '@solana/addresses';\n * >\n * > const MEMO_PROGRAM_ADDRESS =\n * >     'MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr' as Address<'MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'>;\n * > ```\n */\nexport function address<TAddress extends string = string>(putativeAddress: TAddress): Address<TAddress> {\n    assertIsAddress(putativeAddress);\n    return putativeAddress as Address<TAddress>;\n}\n\n/**\n * Returns an encoder that you can use to encode a base58-encoded address to a byte array.\n *\n * @example\n * ```ts\n * import { getAddressEncoder } from '@solana/addresses';\n *\n * const address = 'B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka' as Address;\n * const addressEncoder = getAddressEncoder();\n * const addressBytes = addressEncoder.encode(address);\n * // Uint8Array(32) [\n * //   150, 183, 190,  48, 171,   8, 39, 156,\n * //   122, 213, 172, 108, 193,  95, 26, 158,\n * //   149, 243, 115, 254,  20, 200, 36,  30,\n * //   248, 179, 178, 232, 220,  89, 53, 127\n * // ]\n * ```\n */\nexport function getAddressEncoder(): FixedSizeEncoder<Address, 32> {\n    return transformEncoder(fixEncoderSize(getMemoizedBase58Encoder(), 32), putativeAddress =>\n        address(putativeAddress),\n    );\n}\n\n/**\n * Returns a decoder that you can use to convert an array of 32 bytes representing an address to the\n * base58-encoded representation of that address.\n *\n * @example\n * ```ts\n * import { getAddressDecoder } from '@solana/addresses';\n *\n * const addressBytes = new Uint8Array([\n *     150, 183, 190,  48, 171,   8, 39, 156,\n *     122, 213, 172, 108, 193,  95, 26, 158,\n *     149, 243, 115, 254,  20, 200, 36,  30,\n *     248, 179, 178, 232, 220,  89, 53, 127\n * ]);\n * const addressDecoder = getAddressDecoder();\n * const address = addressDecoder.decode(addressBytes); // B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka\n * ```\n */\nexport function getAddressDecoder(): FixedSizeDecoder<Address, 32> {\n    return fixDecoderSize(getMemoizedBase58Decoder(), 32) as FixedSizeDecoder<Address, 32>;\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to a base-58 encoded address.\n *\n * @see {@link getAddressDecoder}\n * @see {@link getAddressEncoder}\n */\nexport function getAddressCodec(): FixedSizeCodec<Address, Address, 32> {\n    return combineCodec(getAddressEncoder(), getAddressDecoder());\n}\n\nexport function getAddressComparator(): (x: string, y: string) => number {\n    return new Intl.Collator('en', {\n        caseFirst: 'lower',\n        ignorePunctuation: false,\n        localeMatcher: 'best fit',\n        numeric: false,\n        sensitivity: 'variant',\n        usage: 'sort',\n    }).compare;\n}\n","import {\n    SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT,\n    SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED,\n    SolanaError,\n} from '@solana/errors';\n\nfunction assertIsSecureContext() {\n    if (__BROWSER__ && !globalThis.isSecureContext) {\n        throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT);\n    }\n}\n\nlet cachedEd25519Decision: PromiseLike<boolean> | boolean | undefined;\nasync function isEd25519CurveSupported(subtle: SubtleCrypto): Promise<boolean> {\n    if (cachedEd25519Decision === undefined) {\n        cachedEd25519Decision = new Promise(resolve => {\n            subtle\n                .generateKey('Ed25519', /* extractable */ false, ['sign', 'verify'])\n                .then(() => {\n                    resolve((cachedEd25519Decision = true));\n                })\n                .catch(() => {\n                    resolve((cachedEd25519Decision = false));\n                });\n        });\n    }\n    if (typeof cachedEd25519Decision === 'boolean') {\n        return cachedEd25519Decision;\n    } else {\n        return await cachedEd25519Decision;\n    }\n}\n\n/**\n * Throws an exception unless {@link SubtleCrypto#digest | `crypto.subtle.digest()`} is available in\n * the current JavaScript environment.\n */\nexport function assertDigestCapabilityIsAvailable() {\n    assertIsSecureContext();\n    if (typeof globalThis.crypto === 'undefined' || typeof globalThis.crypto.subtle?.digest !== 'function') {\n        throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED);\n    }\n}\n\n/**\n * Throws an exception unless {@link SubtleCrypto#generateKey | `crypto.subtle.generateKey()`} is\n * available in the current JavaScript environment and has support for the Ed25519 curve.\n */\nexport async function assertKeyGenerationIsAvailable() {\n    assertIsSecureContext();\n    if (typeof globalThis.crypto === 'undefined' || typeof globalThis.crypto.subtle?.generateKey !== 'function') {\n        throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED);\n    }\n    if (!(await isEd25519CurveSupported(globalThis.crypto.subtle))) {\n        throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED);\n    }\n}\n\n/**\n * Throws an exception unless {@link SubtleCrypto#exportKey | `crypto.subtle.exportKey()`} is\n * available in the current JavaScript environment.\n */\nexport function assertKeyExporterIsAvailable() {\n    assertIsSecureContext();\n    if (typeof globalThis.crypto === 'undefined' || typeof globalThis.crypto.subtle?.exportKey !== 'function') {\n        throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED);\n    }\n}\n\n/**\n * Throws an exception unless {@link SubtleCrypto#sign | `crypto.subtle.sign()`} is available in the\n * current JavaScript environment.\n */\nexport function assertSigningCapabilityIsAvailable() {\n    assertIsSecureContext();\n    if (typeof globalThis.crypto === 'undefined' || typeof globalThis.crypto.subtle?.sign !== 'function') {\n        throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED);\n    }\n}\n/**\n * Throws an exception unless {@link SubtleCrypto#verify | `crypto.subtle.verify()`} is available in\n * the current JavaScript environment.\n */\nexport function assertVerificationCapabilityIsAvailable() {\n    assertIsSecureContext();\n    if (typeof globalThis.crypto === 'undefined' || typeof globalThis.crypto.subtle?.verify !== 'function') {\n        throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED);\n    }\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidBaseString } from './assertions';\n\n/**\n * Returns an encoder for base-X encoded strings.\n *\n * This encoder serializes strings using a custom alphabet, treating the length of the alphabet as the base.\n * The encoding process involves converting the input string to a numeric value in base-X, then\n * encoding that value into bytes while preserving leading zeroes.\n *\n * For more details, see {@link getBaseXCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeEncoder<string>` for encoding base-X strings.\n *\n * @example\n * Encoding a base-X string using a custom alphabet.\n * ```ts\n * const encoder = getBaseXEncoder('0123456789abcdef');\n * const bytes = encoder.encode('deadface'); // 0xdeadface\n * ```\n *\n * @see {@link getBaseXCodec}\n */\nexport const getBaseXEncoder = (alphabet: string): VariableSizeEncoder<string> => {\n    return createEncoder({\n        getSizeFromValue: (value: string): number => {\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet[0]);\n            if (!tailChars) return value.length;\n\n            const base10Number = getBigIntFromBaseX(tailChars, alphabet);\n            return leadingZeroes.length + Math.ceil(base10Number.toString(16).length / 2);\n        },\n        write(value: string, bytes, offset) {\n            // Check if the value is valid.\n            assertValidBaseString(alphabet, value);\n            if (value === '') return offset;\n\n            // Handle leading zeroes.\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet[0]);\n            if (!tailChars) {\n                bytes.set(new Uint8Array(leadingZeroes.length).fill(0), offset);\n                return offset + leadingZeroes.length;\n            }\n\n            // From baseX to base10.\n            let base10Number = getBigIntFromBaseX(tailChars, alphabet);\n\n            // From base10 to bytes.\n            const tailBytes: number[] = [];\n            while (base10Number > 0n) {\n                tailBytes.unshift(Number(base10Number % 256n));\n                base10Number /= 256n;\n            }\n\n            const bytesToAdd = [...Array(leadingZeroes.length).fill(0), ...tailBytes];\n            bytes.set(bytesToAdd, offset);\n            return offset + bytesToAdd.length;\n        },\n    });\n};\n\n/**\n * Returns a decoder for base-X encoded strings.\n *\n * This decoder deserializes base-X encoded strings from a byte array using a custom alphabet.\n * The decoding process converts the byte array into a numeric value in base-10, then\n * maps that value back to characters in the specified base-X alphabet.\n *\n * For more details, see {@link getBaseXCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeDecoder<string>` for decoding base-X strings.\n *\n * @example\n * Decoding a base-X string using a custom alphabet.\n * ```ts\n * const decoder = getBaseXDecoder('0123456789abcdef');\n * const value = decoder.decode(new Uint8Array([0xde, 0xad, 0xfa, 0xce])); // \"deadface\"\n * ```\n *\n * @see {@link getBaseXCodec}\n */\nexport const getBaseXDecoder = (alphabet: string): VariableSizeDecoder<string> => {\n    return createDecoder({\n        read(rawBytes, offset): [string, number] {\n            const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n            if (bytes.length === 0) return ['', 0];\n\n            // Handle leading zeroes.\n            let trailIndex = bytes.findIndex(n => n !== 0);\n            trailIndex = trailIndex === -1 ? bytes.length : trailIndex;\n            const leadingZeroes = alphabet[0].repeat(trailIndex);\n            if (trailIndex === bytes.length) return [leadingZeroes, rawBytes.length];\n\n            // From bytes to base10.\n            const base10Number = bytes.slice(trailIndex).reduce((sum, byte) => sum * 256n + BigInt(byte), 0n);\n\n            // From base10 to baseX.\n            const tailChars = getBaseXFromBigInt(base10Number, alphabet);\n\n            return [leadingZeroes + tailChars, rawBytes.length];\n        },\n    });\n};\n\n/**\n * Returns a codec for encoding and decoding base-X strings.\n *\n * This codec serializes strings using a custom alphabet, treating the length of the alphabet as the base.\n * The encoding process converts the input string into a numeric value in base-X, which is then encoded as bytes.\n * The decoding process reverses this transformation to reconstruct the original string.\n *\n * This codec supports leading zeroes by treating the first character of the alphabet as the zero character.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-X strings.\n *\n * @example\n * Encoding and decoding a base-X string using a custom alphabet.\n * ```ts\n * const codec = getBaseXCodec('0123456789abcdef');\n * const bytes = codec.encode('deadface'); // 0xdeadface\n * const value = codec.decode(bytes);      // \"deadface\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-X codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBaseXCodec('0123456789abcdef'), 8);\n * ```\n *\n * If you need a size-prefixed base-X codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBaseXCodec('0123456789abcdef'), getU32Codec());\n * ```\n *\n * Separate {@link getBaseXEncoder} and {@link getBaseXDecoder} functions are available.\n *\n * ```ts\n * const bytes = getBaseXEncoder('0123456789abcdef').encode('deadface');\n * const value = getBaseXDecoder('0123456789abcdef').decode(bytes);\n * ```\n *\n * @see {@link getBaseXEncoder}\n * @see {@link getBaseXDecoder}\n */\nexport const getBaseXCodec = (alphabet: string): VariableSizeCodec<string> =>\n    combineCodec(getBaseXEncoder(alphabet), getBaseXDecoder(alphabet));\n\nfunction partitionLeadingZeroes(\n    value: string,\n    zeroCharacter: string,\n): [leadingZeros: string, tailChars: string | undefined] {\n    const [leadingZeros, tailChars] = value.split(new RegExp(`((?!${zeroCharacter}).*)`));\n    return [leadingZeros, tailChars];\n}\n\nfunction getBigIntFromBaseX(value: string, alphabet: string): bigint {\n    const base = BigInt(alphabet.length);\n    let sum = 0n;\n    for (const char of value) {\n        sum *= base;\n        sum += BigInt(alphabet.indexOf(char));\n    }\n    return sum;\n}\n\nfunction getBaseXFromBigInt(value: bigint, alphabet: string): string {\n    const base = BigInt(alphabet.length);\n    const tailChars = [];\n    while (value > 0n) {\n        tailChars.unshift(alphabet[Number(value % base)]);\n        value /= base;\n    }\n    return tailChars.join('');\n}\n","import {\n    SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH,\n    SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH,\n    SolanaError,\n} from '@solana/errors';\n\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Defines an offset in bytes.\n */\nexport type Offset = number;\n\n/**\n * An object that can encode a value of type {@link TFrom} into a {@link ReadonlyUint8Array}.\n *\n * This is a common interface for {@link FixedSizeEncoder} and {@link VariableSizeEncoder}.\n *\n * @interface\n * @typeParam TFrom - The type of the value to encode.\n *\n * @see {@link FixedSizeEncoder}\n * @see {@link VariableSizeEncoder}\n */\ntype BaseEncoder<TFrom> = {\n    /** Encode the provided value and return the encoded bytes directly. */\n    readonly encode: (value: TFrom) => ReadonlyUint8Array;\n    /**\n     * Writes the encoded value into the provided byte array at the given offset.\n     * Returns the offset of the next byte after the encoded value.\n     */\n    readonly write: (value: TFrom, bytes: Uint8Array, offset: Offset) => Offset;\n};\n\n/**\n * An object that can encode a value of type {@link TFrom} into a fixed-size {@link ReadonlyUint8Array}.\n *\n * See {@link Encoder} to learn more about creating and composing encoders.\n *\n * @interface\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @example\n * ```ts\n * const encoder: FixedSizeEncoder<number, 4>;\n * const bytes = encoder.encode(42);\n * const size = encoder.fixedSize; // 4\n * ```\n *\n * @see {@link Encoder}\n * @see {@link VariableSizeEncoder}\n */\nexport type FixedSizeEncoder<TFrom, TSize extends number = number> = BaseEncoder<TFrom> & {\n    /** The fixed size of the encoded value in bytes. */\n    readonly fixedSize: TSize;\n};\n\n/**\n * An object that can encode a value of type {@link TFrom} into a variable-size {@link ReadonlyUint8Array}.\n *\n * See {@link Encoder} to learn more about creating and composing encoders.\n *\n * @interface\n * @typeParam TFrom - The type of the value to encode.\n *\n * @example\n * ```ts\n * const encoder: VariableSizeEncoder<string>;\n * const bytes = encoder.encode('hello');\n * const size = encoder.getSizeFromValue('hello');\n * ```\n *\n * @see {@link Encoder}\n * @see {@link FixedSizeEncoder}\n */\nexport type VariableSizeEncoder<TFrom> = BaseEncoder<TFrom> & {\n    /** Returns the size of the encoded value in bytes for a given input. */\n    readonly getSizeFromValue: (value: TFrom) => number;\n    /** The maximum possible size of an encoded value in bytes, if applicable. */\n    readonly maxSize?: number;\n};\n\n/**\n * An object that can encode a value of type {@link TFrom} into a {@link ReadonlyUint8Array}.\n *\n * An `Encoder` can be either:\n * - A {@link FixedSizeEncoder}, where all encoded values have the same fixed size.\n * - A {@link VariableSizeEncoder}, where encoded values can vary in size.\n *\n * @typeParam TFrom - The type of the value to encode.\n *\n * @example\n * Encoding a value into a new byte array.\n * ```ts\n * const encoder: Encoder<string>;\n * const bytes = encoder.encode('hello');\n * ```\n *\n * @example\n * Writing the encoded value into an existing byte array.\n * ```ts\n * const encoder: Encoder<string>;\n * const bytes = new Uint8Array(100);\n * const nextOffset = encoder.write('hello', bytes, 20);\n * ```\n *\n * @remarks\n * You may create `Encoders` manually using the {@link createEncoder} function but it is more common\n * to compose multiple `Encoders` together using the various helpers of the `@solana/codecs` package.\n *\n * For instance, here's how you might create an `Encoder` for a `Person` object type that contains\n * a `name` string and an `age` number:\n *\n * ```ts\n * import { getStructEncoder, addEncoderSizePrefix, getUtf8Encoder, getU32Encoder } from '@solana/codecs';\n *\n * type Person = { name: string; age: number };\n * const getPersonEncoder = (): Encoder<Person> =>\n *     getStructEncoder([\n *         ['name', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n *         ['age', getU32Encoder()],\n *     ]);\n * ```\n *\n * Note that composed `Encoder` types are clever enough to understand whether\n * they are fixed-size or variable-size. In the example above, `getU32Encoder()` is\n * a fixed-size encoder, while `addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())`\n * is a variable-size encoder. This makes the final `Person` encoder a variable-size encoder.\n *\n * @see {@link FixedSizeEncoder}\n * @see {@link VariableSizeEncoder}\n * @see {@link createEncoder}\n */\nexport type Encoder<TFrom> = FixedSizeEncoder<TFrom> | VariableSizeEncoder<TFrom>;\n\n/**\n * An object that can decode a byte array into a value of type {@link TTo}.\n *\n * This is a common interface for {@link FixedSizeDecoder} and {@link VariableSizeDecoder}.\n *\n * @interface\n * @typeParam TTo - The type of the decoded value.\n *\n * @see {@link FixedSizeDecoder}\n * @see {@link VariableSizeDecoder}\n */\ntype BaseDecoder<TTo> = {\n    /** Decodes the provided byte array at the given offset (or zero) and returns the value directly. */\n    readonly decode: (bytes: ReadonlyUint8Array | Uint8Array, offset?: Offset) => TTo;\n    /**\n     * Reads the encoded value from the provided byte array at the given offset.\n     * Returns the decoded value and the offset of the next byte after the encoded value.\n     */\n    readonly read: (bytes: ReadonlyUint8Array | Uint8Array, offset: Offset) => [TTo, Offset];\n};\n\n/**\n * An object that can decode a fixed-size byte array into a value of type {@link TTo}.\n *\n * See {@link Decoder} to learn more about creating and composing decoders.\n *\n * @interface\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @example\n * ```ts\n * const decoder: FixedSizeDecoder<number, 4>;\n * const value = decoder.decode(bytes);\n * const size = decoder.fixedSize; // 4\n * ```\n *\n * @see {@link Decoder}\n * @see {@link VariableSizeDecoder}\n */\nexport type FixedSizeDecoder<TTo, TSize extends number = number> = BaseDecoder<TTo> & {\n    /** The fixed size of the encoded value in bytes. */\n    readonly fixedSize: TSize;\n};\n\n/**\n * An object that can decode a variable-size byte array into a value of type {@link TTo}.\n *\n * See {@link Decoder} to learn more about creating and composing decoders.\n *\n * @interface\n * @typeParam TTo - The type of the decoded value.\n *\n * @example\n * ```ts\n * const decoder: VariableSizeDecoder<number>;\n * const value = decoder.decode(bytes);\n * ```\n *\n * @see {@link Decoder}\n * @see {@link VariableSizeDecoder}\n */\nexport type VariableSizeDecoder<TTo> = BaseDecoder<TTo> & {\n    /** The maximum possible size of an encoded value in bytes, if applicable. */\n    readonly maxSize?: number;\n};\n\n/**\n * An object that can decode a byte array into a value of type {@link TTo}.\n *\n * An `Decoder` can be either:\n * - A {@link FixedSizeDecoder}, where all byte arrays have the same fixed size.\n * - A {@link VariableSizeDecoder}, where byte arrays can vary in size.\n *\n * @typeParam TTo - The type of the decoded value.\n *\n * @example\n * Getting the decoded value from a byte array.\n * ```ts\n * const decoder: Decoder<string>;\n * const value = decoder.decode(bytes);\n * ```\n *\n * @example\n * Reading the decoded value from a byte array at a specific offset\n * and getting the offset of the next byte to read.\n * ```ts\n * const decoder: Decoder<string>;\n * const [value, nextOffset] = decoder.read('hello', bytes, 20);\n * ```\n *\n * @remarks\n * You may create `Decoders` manually using the {@link createDecoder} function but it is more common\n * to compose multiple `Decoders` together using the various helpers of the `@solana/codecs` package.\n *\n * For instance, here's how you might create an `Decoder` for a `Person` object type that contains\n * a `name` string and an `age` number:\n *\n * ```ts\n * import { getStructDecoder, addDecoderSizePrefix, getUtf8Decoder, getU32Decoder } from '@solana/codecs';\n *\n * type Person = { name: string; age: number };\n * const getPersonDecoder = (): Decoder<Person> =>\n *     getStructDecoder([\n *         ['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n *         ['age', getU32Decoder()],\n *     ]);\n * ```\n *\n * Note that composed `Decoder` types are clever enough to understand whether\n * they are fixed-size or variable-size. In the example above, `getU32Decoder()` is\n * a fixed-size decoder, while `addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())`\n * is a variable-size decoder. This makes the final `Person` decoder a variable-size decoder.\n *\n * @see {@link FixedSizeDecoder}\n * @see {@link VariableSizeDecoder}\n * @see {@link createDecoder}\n */\nexport type Decoder<TTo> = FixedSizeDecoder<TTo> | VariableSizeDecoder<TTo>;\n\n/**\n * An object that can encode and decode a value to and from a fixed-size byte array.\n *\n * See {@link Codec} to learn more about creating and composing codecs.\n *\n * @interface\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @example\n * ```ts\n * const codec: FixedSizeCodec<number | bigint, bigint, 8>;\n * const bytes = codec.encode(42);\n * const value = codec.decode(bytes); // 42n\n * const size = codec.fixedSize; // 8\n * ```\n *\n * @see {@link Codec}\n * @see {@link VariableSizeCodec}\n */\nexport type FixedSizeCodec<TFrom, TTo extends TFrom = TFrom, TSize extends number = number> = FixedSizeDecoder<\n    TTo,\n    TSize\n> &\n    FixedSizeEncoder<TFrom, TSize>;\n\n/**\n * An object that can encode and decode a value to and from a variable-size byte array.\n *\n * See {@link Codec} to learn more about creating and composing codecs.\n *\n * @interface\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n *\n * @example\n * ```ts\n * const codec: VariableSizeCodec<number | bigint, bigint>;\n * const bytes = codec.encode(42);\n * const value = codec.decode(bytes); // 42n\n * const size = codec.getSizeFromValue(42);\n * ```\n *\n * @see {@link Codec}\n * @see {@link FixedSizeCodec}\n */\nexport type VariableSizeCodec<TFrom, TTo extends TFrom = TFrom> = VariableSizeDecoder<TTo> & VariableSizeEncoder<TFrom>;\n\n/**\n * An object that can encode and decode a value to and from a byte array.\n *\n * A `Codec` can be either:\n * - A {@link FixedSizeCodec}, where all encoded values have the same fixed size.\n * - A {@link VariableSizeCodec}, where encoded values can vary in size.\n *\n * @example\n * ```ts\n * const codec: Codec<string>;\n * const bytes = codec.encode('hello');\n * const value = codec.decode(bytes); // 'hello'\n * ```\n *\n * @remarks\n * For convenience, codecs can encode looser types than they decode.\n * That is, type {@link TFrom} can be a superset of type {@link TTo}.\n * For instance, a `Codec<bigint | number, bigint>` can encode both\n * `bigint` and `number` values, but will always decode to a `bigint`.\n *\n * ```ts\n * const codec: Codec<bigint | number, bigint>;\n * const bytes = codec.encode(42);\n * const value = codec.decode(bytes); // 42n\n * ```\n *\n * It is worth noting that codecs are the union of encoders and decoders.\n * This means that a `Codec<TFrom, TTo>` can be combined from an `Encoder<TFrom>`\n * and a `Decoder<TTo>` using the {@link combineCodec} function. This is particularly\n * useful for library authors who want to expose all three types of objects to their users.\n *\n * ```ts\n * const encoder: Encoder<bigint | number>;\n * const decoder: Decoder<bigint>;\n * const codec: Codec<bigint | number, bigint> = combineCodec(encoder, decoder);\n * ```\n *\n * Aside from combining encoders and decoders, codecs can also be created from scratch using\n * the {@link createCodec} function but it is more common to compose multiple codecs together\n * using the various helpers of the `@solana/codecs` package.\n *\n * For instance, here's how you might create a `Codec` for a `Person` object type that contains\n * a `name` string and an `age` number:\n *\n * ```ts\n * import { getStructCodec, addCodecSizePrefix, getUtf8Codec, getU32Codec } from '@solana/codecs';\n *\n * type Person = { name: string; age: number };\n * const getPersonCodec = (): Codec<Person> =>\n *     getStructCodec([\n *         ['name', addCodecSizePrefix(getUtf8Codec(), getU32Codec())],\n *         ['age', getU32Codec()],\n *     ]);\n * ```\n *\n * Note that composed `Codec` types are clever enough to understand whether\n * they are fixed-size or variable-size. In the example above, `getU32Codec()` is\n * a fixed-size codec, while `addCodecSizePrefix(getUtf8Codec(), getU32Codec())`\n * is a variable-size codec. This makes the final `Person` codec a variable-size codec.\n *\n * @see {@link FixedSizeCodec}\n * @see {@link VariableSizeCodec}\n * @see {@link combineCodec}\n * @see {@link createCodec}\n */\nexport type Codec<TFrom, TTo extends TFrom = TFrom> = FixedSizeCodec<TFrom, TTo> | VariableSizeCodec<TFrom, TTo>;\n\n/**\n * Gets the encoded size of a given value in bytes using the provided encoder.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @param value - The value to be encoded.\n * @param encoder - The encoder used to determine the encoded size.\n * @returns The size of the encoded value in bytes.\n *\n * @example\n * ```ts\n * const fixedSizeEncoder = { fixedSize: 4 };\n * getEncodedSize(123, fixedSizeEncoder); // Returns 4.\n *\n * const variableSizeEncoder = { getSizeFromValue: (value: string) => value.length };\n * getEncodedSize(\"hello\", variableSizeEncoder); // Returns 5.\n * ```\n *\n * @see {@link Encoder}\n */\nexport function getEncodedSize<TFrom>(\n    value: TFrom,\n    encoder: { fixedSize: number } | { getSizeFromValue: (value: TFrom) => number },\n): number {\n    return 'fixedSize' in encoder ? encoder.fixedSize : encoder.getSizeFromValue(value);\n}\n\n/**\n * Creates an `Encoder` by filling in the missing `encode` function using the provided `write` function and\n * either the `fixedSize` property (for {@link FixedSizeEncoder | FixedSizeEncoders}) or\n * the `getSizeFromValue` function (for {@link VariableSizeEncoder | VariableSizeEncoders}).\n *\n * Instead of manually implementing `encode`, this utility leverages the existing `write` function\n * and the size helpers to generate a complete encoder. The provided `encode` method will allocate\n * a new `Uint8Array` of the correct size and use `write` to populate it.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TSize - The fixed size of the encoded value in bytes (for fixed-size encoders).\n *\n * @param encoder - An encoder object that implements `write`, but not `encode`.\n * - If the encoder has a `fixedSize` property, it is treated as a {@link FixedSizeEncoder}.\n * - Otherwise, it is treated as a {@link VariableSizeEncoder}.\n *\n * @returns A fully functional `Encoder` with both `write` and `encode` methods.\n *\n * @example\n * Creating a custom fixed-size encoder.\n * ```ts\n * const encoder = createEncoder({\n *     fixedSize: 4,\n *     write: (value: number, bytes, offset) => {\n *         bytes.set(new Uint8Array([value]), offset);\n *         return offset + 4;\n *     },\n * });\n *\n * const bytes = encoder.encode(42);\n * // 0x2a000000\n * ```\n *\n * @example\n * Creating a custom variable-size encoder:\n * ```ts\n * const encoder = createEncoder({\n *     getSizeFromValue: (value: string) => value.length,\n *     write: (value: string, bytes, offset) => {\n *         const encodedValue = new TextEncoder().encode(value);\n *         bytes.set(encodedValue, offset);\n *         return offset + encodedValue.length;\n *     },\n * });\n *\n * const bytes = encoder.encode(\"hello\");\n * // 0x68656c6c6f\n * ```\n *\n * @remarks\n * Note that, while `createEncoder` is useful for defining more complex encoders, it is more common to compose\n * encoders together using the various helpers and primitives of the `@solana/codecs` package.\n *\n * Here are some alternative examples using codec primitives instead of `createEncoder`.\n *\n * ```ts\n * // Fixed-size encoder for unsigned 32-bit integers.\n * const encoder = getU32Encoder();\n * const bytes = encoder.encode(42);\n * // 0x2a000000\n *\n * // Variable-size encoder for 32-bytes prefixed UTF-8 strings.\n * const encoder = addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder());\n * const bytes = encoder.encode(\"hello\");\n * // 0x0500000068656c6c6f\n *\n * // Variable-size encoder for custom objects.\n * type Person = { name: string; age: number };\n * const encoder: Encoder<Person> = getStructEncoder([\n *     ['name', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n *     ['age', getU32Encoder()],\n * ]);\n * const bytes = encoder.encode({ name: \"Bob\", age: 42 });\n * // 0x03000000426f622a000000\n * ```\n *\n * @see {@link Encoder}\n * @see {@link FixedSizeEncoder}\n * @see {@link VariableSizeEncoder}\n * @see {@link getStructEncoder}\n * @see {@link getU32Encoder}\n * @see {@link getUtf8Encoder}\n * @see {@link addEncoderSizePrefix}\n */\nexport function createEncoder<TFrom, TSize extends number>(\n    encoder: Omit<FixedSizeEncoder<TFrom, TSize>, 'encode'>,\n): FixedSizeEncoder<TFrom, TSize>;\nexport function createEncoder<TFrom>(encoder: Omit<VariableSizeEncoder<TFrom>, 'encode'>): VariableSizeEncoder<TFrom>;\nexport function createEncoder<TFrom>(\n    encoder: Omit<FixedSizeEncoder<TFrom>, 'encode'> | Omit<VariableSizeEncoder<TFrom>, 'encode'>,\n): Encoder<TFrom>;\nexport function createEncoder<TFrom>(\n    encoder: Omit<FixedSizeEncoder<TFrom>, 'encode'> | Omit<VariableSizeEncoder<TFrom>, 'encode'>,\n): Encoder<TFrom> {\n    return Object.freeze({\n        ...encoder,\n        encode: value => {\n            const bytes = new Uint8Array(getEncodedSize(value, encoder));\n            encoder.write(value, bytes, 0);\n            return bytes;\n        },\n    });\n}\n\n/**\n * Creates a `Decoder` by filling in the missing `decode` function using the provided `read` function.\n *\n * Instead of manually implementing `decode`, this utility leverages the existing `read` function\n * and the size properties to generate a complete decoder. The provided `decode` method will read\n * from a `Uint8Array` at the given offset and return the decoded value.\n *\n * If the `fixedSize` property is provided, a {@link FixedSizeDecoder} will be created, otherwise\n * a {@link VariableSizeDecoder} will be created.\n *\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes (for fixed-size decoders).\n *\n * @param decoder - A decoder object that implements `read`, but not `decode`.\n * - If the decoder has a `fixedSize` property, it is treated as a {@link FixedSizeDecoder}.\n * - Otherwise, it is treated as a {@link VariableSizeDecoder}.\n *\n * @returns A fully functional `Decoder` with both `read` and `decode` methods.\n *\n * @example\n * Creating a custom fixed-size decoder.\n * ```ts\n * const decoder = createDecoder({\n *     fixedSize: 4,\n *     read: (bytes, offset) => {\n *         const value = bytes[offset];\n *         return [value, offset + 4];\n *     },\n * });\n *\n * const value = decoder.decode(new Uint8Array([42, 0, 0, 0]));\n * // 42\n * ```\n *\n * @example\n * Creating a custom variable-size decoder:\n * ```ts\n * const decoder = createDecoder({\n *     read: (bytes, offset) => {\n *         const decodedValue = new TextDecoder().decode(bytes.subarray(offset));\n *         return [decodedValue, bytes.length];\n *     },\n * });\n *\n * const value = decoder.decode(new Uint8Array([104, 101, 108, 108, 111]));\n * // \"hello\"\n * ```\n *\n * @remarks\n * Note that, while `createDecoder` is useful for defining more complex decoders, it is more common to compose\n * decoders together using the various helpers and primitives of the `@solana/codecs` package.\n *\n * Here are some alternative examples using codec primitives instead of `createDecoder`.\n *\n * ```ts\n * // Fixed-size decoder for unsigned 32-bit integers.\n * const decoder = getU32Decoder();\n * const value = decoder.decode(new Uint8Array([42, 0, 0, 0]));\n * // 42\n *\n * // Variable-size decoder for 32-bytes prefixed UTF-8 strings.\n * const decoder = addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder());\n * const value = decoder.decode(new Uint8Array([5, 0, 0, 0, 104, 101, 108, 108, 111]));\n * // \"hello\"\n *\n * // Variable-size decoder for custom objects.\n * type Person = { name: string; age: number };\n * const decoder: Decoder<Person> = getStructDecoder([\n *     ['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n *     ['age', getU32Decoder()],\n * ]);\n * const value = decoder.decode(new Uint8Array([3, 0, 0, 0, 66, 111, 98, 42, 0, 0, 0]));\n * // { name: \"Bob\", age: 42 }\n * ```\n *\n * @see {@link Decoder}\n * @see {@link FixedSizeDecoder}\n * @see {@link VariableSizeDecoder}\n * @see {@link getStructDecoder}\n * @see {@link getU32Decoder}\n * @see {@link getUtf8Decoder}\n * @see {@link addDecoderSizePrefix}\n */\nexport function createDecoder<TTo, TSize extends number>(\n    decoder: Omit<FixedSizeDecoder<TTo, TSize>, 'decode'>,\n): FixedSizeDecoder<TTo, TSize>;\nexport function createDecoder<TTo>(decoder: Omit<VariableSizeDecoder<TTo>, 'decode'>): VariableSizeDecoder<TTo>;\nexport function createDecoder<TTo>(\n    decoder: Omit<FixedSizeDecoder<TTo>, 'decode'> | Omit<VariableSizeDecoder<TTo>, 'decode'>,\n): Decoder<TTo>;\nexport function createDecoder<TTo>(\n    decoder: Omit<FixedSizeDecoder<TTo>, 'decode'> | Omit<VariableSizeDecoder<TTo>, 'decode'>,\n): Decoder<TTo> {\n    return Object.freeze({\n        ...decoder,\n        decode: (bytes, offset = 0) => decoder.read(bytes, offset)[0],\n    });\n}\n\n/**\n * Creates a `Codec` by filling in the missing `encode` and `decode` functions using the provided `write` and `read` functions.\n *\n * This utility combines the behavior of {@link createEncoder} and {@link createDecoder} to produce a fully functional `Codec`.\n * The `encode` method is derived from the `write` function, while the `decode` method is derived from the `read` function.\n *\n * If the `fixedSize` property is provided, a {@link FixedSizeCodec} will be created, otherwise\n * a {@link VariableSizeCodec} will be created.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes (for fixed-size codecs).\n *\n * @param codec - A codec object that implements `write` and `read`, but not `encode` or `decode`.\n * - If the codec has a `fixedSize` property, it is treated as a {@link FixedSizeCodec}.\n * - Otherwise, it is treated as a {@link VariableSizeCodec}.\n *\n * @returns A fully functional `Codec` with `write`, `read`, `encode`, and `decode` methods.\n *\n * @example\n * Creating a custom fixed-size codec.\n * ```ts\n * const codec = createCodec({\n *     fixedSize: 4,\n *     read: (bytes, offset) => {\n *         const value = bytes[offset];\n *         return [value, offset + 4];\n *     },\n *     write: (value: number, bytes, offset) => {\n *         bytes.set(new Uint8Array([value]), offset);\n *         return offset + 4;\n *     },\n * });\n *\n * const bytes = codec.encode(42);\n * // 0x2a000000\n * const value = codec.decode(bytes);\n * // 42\n * ```\n *\n * @example\n * Creating a custom variable-size codec:\n * ```ts\n * const codec = createCodec({\n *     getSizeFromValue: (value: string) => value.length,\n *     read: (bytes, offset) => {\n *         const decodedValue = new TextDecoder().decode(bytes.subarray(offset));\n *         return [decodedValue, bytes.length];\n *     },\n *     write: (value: string, bytes, offset) => {\n *         const encodedValue = new TextEncoder().encode(value);\n *         bytes.set(encodedValue, offset);\n *         return offset + encodedValue.length;\n *     },\n * });\n *\n * const bytes = codec.encode(\"hello\");\n * // 0x68656c6c6f\n * const value = codec.decode(bytes);\n * // \"hello\"\n * ```\n *\n * @remarks\n * This function effectively combines the behavior of {@link createEncoder} and {@link createDecoder}.\n * If you only need to encode or decode (but not both), consider using those functions instead.\n *\n * Here are some alternative examples using codec primitives instead of `createCodec`.\n *\n * ```ts\n * // Fixed-size codec for unsigned 32-bit integers.\n * const codec = getU32Codec();\n * const bytes = codec.encode(42);\n * // 0x2a000000\n * const value = codec.decode(bytes);\n * // 42\n *\n * // Variable-size codec for 32-bytes prefixed UTF-8 strings.\n * const codec = addCodecSizePrefix(getUtf8Codec(), getU32Codec());\n * const bytes = codec.encode(\"hello\");\n * // 0x0500000068656c6c6f\n * const value = codec.decode(bytes);\n * // \"hello\"\n *\n * // Variable-size codec for custom objects.\n * type Person = { name: string; age: number };\n * const codec: Codec<PersonInput, Person> = getStructCodec([\n *     ['name', addCodecSizePrefix(getUtf8Codec(), getU32Codec())],\n *     ['age', getU32Codec()],\n * ]);\n * const bytes = codec.encode({ name: \"Bob\", age: 42 });\n * // 0x03000000426f622a000000\n * const value = codec.decode(bytes);\n * // { name: \"Bob\", age: 42 }\n * ```\n *\n * @see {@link Codec}\n * @see {@link FixedSizeCodec}\n * @see {@link VariableSizeCodec}\n * @see {@link createEncoder}\n * @see {@link createDecoder}\n * @see {@link getStructCodec}\n * @see {@link getU32Codec}\n * @see {@link getUtf8Codec}\n * @see {@link addCodecSizePrefix}\n */\nexport function createCodec<TFrom, TTo extends TFrom = TFrom, TSize extends number = number>(\n    codec: Omit<FixedSizeCodec<TFrom, TTo, TSize>, 'decode' | 'encode'>,\n): FixedSizeCodec<TFrom, TTo, TSize>;\nexport function createCodec<TFrom, TTo extends TFrom = TFrom>(\n    codec: Omit<VariableSizeCodec<TFrom, TTo>, 'decode' | 'encode'>,\n): VariableSizeCodec<TFrom, TTo>;\nexport function createCodec<TFrom, TTo extends TFrom = TFrom>(\n    codec:\n        | Omit<FixedSizeCodec<TFrom, TTo>, 'decode' | 'encode'>\n        | Omit<VariableSizeCodec<TFrom, TTo>, 'decode' | 'encode'>,\n): Codec<TFrom, TTo>;\nexport function createCodec<TFrom, TTo extends TFrom = TFrom>(\n    codec:\n        | Omit<FixedSizeCodec<TFrom, TTo>, 'decode' | 'encode'>\n        | Omit<VariableSizeCodec<TFrom, TTo>, 'decode' | 'encode'>,\n): Codec<TFrom, TTo> {\n    return Object.freeze({\n        ...codec,\n        decode: (bytes, offset = 0) => codec.read(bytes, offset)[0],\n        encode: value => {\n            const bytes = new Uint8Array(getEncodedSize(value, codec));\n            codec.write(value, bytes, 0);\n            return bytes;\n        },\n    });\n}\n\n/**\n * Determines whether the given codec, encoder, or decoder is fixed-size.\n *\n * A fixed-size object is identified by the presence of a `fixedSize` property.\n * If this property exists, the object is considered a {@link FixedSizeCodec},\n * {@link FixedSizeEncoder}, or {@link FixedSizeDecoder}.\n * Otherwise, it is assumed to be a {@link VariableSizeCodec},\n * {@link VariableSizeEncoder}, or {@link VariableSizeDecoder}.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n * @returns `true` if the object is fixed-size, `false` otherwise.\n *\n * @example\n * Checking a fixed-size encoder.\n * ```ts\n * const encoder = getU32Encoder();\n * isFixedSize(encoder); // true\n * ```\n *\n * @example\n * Checking a variable-size encoder.\n * ```ts\n * const encoder = addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder());\n * isFixedSize(encoder); // false\n * ```\n *\n * @remarks\n * This function is commonly used to distinguish between fixed-size and variable-size objects at runtime.\n * If you need to enforce this distinction with type assertions, consider using {@link assertIsFixedSize}.\n *\n * @see {@link assertIsFixedSize}\n */\nexport function isFixedSize<TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize> | VariableSizeEncoder<TFrom>,\n): encoder is FixedSizeEncoder<TFrom, TSize>;\nexport function isFixedSize<TTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TTo, TSize> | VariableSizeDecoder<TTo>,\n): decoder is FixedSizeDecoder<TTo, TSize>;\nexport function isFixedSize<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize> | VariableSizeCodec<TFrom, TTo>,\n): codec is FixedSizeCodec<TFrom, TTo, TSize>;\nexport function isFixedSize<TSize extends number>(\n    codec: { fixedSize: TSize } | { maxSize?: number },\n): codec is { fixedSize: TSize };\nexport function isFixedSize(codec: { fixedSize: number } | { maxSize?: number }): codec is { fixedSize: number } {\n    return 'fixedSize' in codec && typeof codec.fixedSize === 'number';\n}\n\n/**\n * Asserts that the given codec, encoder, or decoder is fixed-size.\n *\n * If the object is not fixed-size (i.e., it lacks a `fixedSize` property),\n * this function throws a {@link SolanaError} with the code `SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH`.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n * @throws {SolanaError} If the object is not fixed-size.\n *\n * @example\n * Asserting a fixed-size encoder.\n * ```ts\n * const encoder = getU32Encoder();\n * assertIsFixedSize(encoder); // Passes\n * ```\n *\n * @example\n * Attempting to assert a variable-size encoder.\n * ```ts\n * const encoder = addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder());\n * assertIsFixedSize(encoder); // Throws SolanaError\n * ```\n *\n * @remarks\n * This function is the assertion-based counterpart of {@link isFixedSize}.\n * If you only need to check whether an object is fixed-size without throwing an error, use {@link isFixedSize} instead.\n *\n * @see {@link isFixedSize}\n */\nexport function assertIsFixedSize<TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize> | VariableSizeEncoder<TFrom>,\n): asserts encoder is FixedSizeEncoder<TFrom, TSize>;\nexport function assertIsFixedSize<TTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TTo, TSize> | VariableSizeDecoder<TTo>,\n): asserts decoder is FixedSizeDecoder<TTo, TSize>;\nexport function assertIsFixedSize<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize> | VariableSizeCodec<TFrom, TTo>,\n): asserts codec is FixedSizeCodec<TFrom, TTo, TSize>;\nexport function assertIsFixedSize<TSize extends number>(\n    codec: { fixedSize: TSize } | { maxSize?: number },\n): asserts codec is { fixedSize: TSize };\nexport function assertIsFixedSize(\n    codec: { fixedSize: number } | { maxSize?: number },\n): asserts codec is { fixedSize: number } {\n    if (!isFixedSize(codec)) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH);\n    }\n}\n\n/**\n * Determines whether the given codec, encoder, or decoder is variable-size.\n *\n * A variable-size object is identified by the absence of a `fixedSize` property.\n * If this property is missing, the object is considered a {@link VariableSizeCodec},\n * {@link VariableSizeEncoder}, or {@link VariableSizeDecoder}.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n * @returns `true` if the object is variable-size, `false` otherwise.\n *\n * @example\n * Checking a variable-size encoder.\n * ```ts\n * const encoder = addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder());\n * isVariableSize(encoder); // true\n * ```\n *\n * @example\n * Checking a fixed-size encoder.\n * ```ts\n * const encoder = getU32Encoder();\n * isVariableSize(encoder); // false\n * ```\n *\n * @remarks\n * This function is the inverse of {@link isFixedSize}.\n *\n * @see {@link isFixedSize}\n * @see {@link assertIsVariableSize}\n */\nexport function isVariableSize<TFrom>(encoder: Encoder<TFrom>): encoder is VariableSizeEncoder<TFrom>;\nexport function isVariableSize<TTo>(decoder: Decoder<TTo>): decoder is VariableSizeDecoder<TTo>;\nexport function isVariableSize<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n): codec is VariableSizeCodec<TFrom, TTo>;\nexport function isVariableSize(codec: { fixedSize: number } | { maxSize?: number }): codec is { maxSize?: number };\nexport function isVariableSize(codec: { fixedSize: number } | { maxSize?: number }): codec is { maxSize?: number } {\n    return !isFixedSize(codec);\n}\n\n/**\n * Asserts that the given codec, encoder, or decoder is variable-size.\n *\n * If the object is not variable-size (i.e., it has a `fixedSize` property),\n * this function throws a {@link SolanaError} with the code `SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH`.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n * @throws {SolanaError} If the object is not variable-size.\n *\n * @example\n * Asserting a variable-size encoder.\n * ```ts\n * const encoder = addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder());\n * assertIsVariableSize(encoder); // Passes\n * ```\n *\n * @example\n * Attempting to assert a fixed-size encoder.\n * ```ts\n * const encoder = getU32Encoder();\n * assertIsVariableSize(encoder); // Throws SolanaError\n * ```\n *\n * @remarks\n * This function is the assertion-based counterpart of {@link isVariableSize}.\n * If you only need to check whether an object is variable-size without throwing an error, use {@link isVariableSize} instead.\n *\n * Also note that this function is the inverse of {@link assertIsFixedSize}.\n *\n * @see {@link isVariableSize}\n * @see {@link assertIsFixedSize}\n */\nexport function assertIsVariableSize<TFrom>(encoder: Encoder<TFrom>): asserts encoder is VariableSizeEncoder<TFrom>;\nexport function assertIsVariableSize<TTo>(decoder: Decoder<TTo>): asserts decoder is VariableSizeDecoder<TTo>;\nexport function assertIsVariableSize<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n): asserts codec is VariableSizeCodec<TFrom, TTo>;\nexport function assertIsVariableSize(\n    codec: { fixedSize: number } | { maxSize?: number },\n): asserts codec is { maxSize?: number };\nexport function assertIsVariableSize(\n    codec: { fixedSize: number } | { maxSize?: number },\n): asserts codec is { maxSize?: number } {\n    if (!isVariableSize(codec)) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH);\n    }\n}\n","/**!\n * noble-ed25519\n *\n * The MIT License (MIT)\n *\n * Copyright (c) 2019 Paul Miller (https://paulmillr.com)\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the Software), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\nconst D = 37095705934669439343138083508754565189542113879843219016388785533085940283555n;\nconst P = 57896044618658097711785492504343953926634992332820282019728792003956564819949n; // 2n ** 255n - 19n;  ed25519 is twisted edwards curve\nconst RM1 = 19681161376707505956807079304988542015446066515923890162744021073123829784752n; // -1\n\n// mod division\nfunction mod(a: bigint): bigint {\n    const r = a % P;\n    return r >= 0n ? r : P + r;\n}\nfunction pow2(x: bigint, power: bigint): bigint {\n    // pow2(x, 4) == x^(2^4)\n    let r = x;\n    while (power-- > 0n) {\n        r *= r;\n        r %= P;\n    }\n    return r;\n}\nfunction pow_2_252_3(x: bigint): bigint {\n    // x^(2^252-3) unrolled util for square root\n    const x2 = (x * x) % P; // x^2,       bits 1\n    const b2 = (x2 * x) % P; // x^3,       bits 11\n    const b4 = (pow2(b2, 2n) * b2) % P; // x^(2^4-1), bits 1111\n    const b5 = (pow2(b4, 1n) * x) % P; // x^(2^5-1), bits 11111\n    const b10 = (pow2(b5, 5n) * b5) % P; // x^(2^10)\n    const b20 = (pow2(b10, 10n) * b10) % P; // x^(2^20)\n    const b40 = (pow2(b20, 20n) * b20) % P; // x^(2^40)\n    const b80 = (pow2(b40, 40n) * b40) % P; // x^(2^80)\n    const b160 = (pow2(b80, 80n) * b80) % P; // x^(2^160)\n    const b240 = (pow2(b160, 80n) * b80) % P; // x^(2^240)\n    const b250 = (pow2(b240, 10n) * b10) % P; // x^(2^250)\n    const pow_p_5_8 = (pow2(b250, 2n) * x) % P; // < To pow to (p+3)/8, multiply it by x.\n    return pow_p_5_8;\n}\nfunction uvRatio(u: bigint, v: bigint): bigint | null {\n    // for sqrt comp\n    const v3 = mod(v * v * v); // v\n    const v7 = mod(v3 * v3 * v); // v\n    const pow = pow_2_252_3(u * v7); // (uv)^(p-5)/8\n    let x = mod(u * v3 * pow); // (uv)(uv)^(p-5)/8\n    const vx2 = mod(v * x * x); // vx\n    const root1 = x; // First root candidate\n    const root2 = mod(x * RM1); // Second root candidate; RM1 is -1\n    const useRoot1 = vx2 === u; // If vx = u (mod p), x is a square root\n    const useRoot2 = vx2 === mod(-u); // If vx = -u, set x <-- x * 2^((p-1)/4)\n    const noRoot = vx2 === mod(-u * RM1); // There is no valid root, vx = -u-1\n    if (useRoot1) x = root1;\n    if (useRoot2 || noRoot) x = root2; // We return root2 anyway, for const-time\n    if ((mod(x) & 1n) === 1n) x = mod(-x); // edIsNegative\n    if (!useRoot1 && !useRoot2) {\n        return null;\n    }\n    return x;\n}\n// https://datatracker.ietf.org/doc/html/rfc8032#section-5.1.3\nexport function pointIsOnCurve(y: bigint, lastByte: number): boolean {\n    const y2 = mod(y * y); // y\n    const u = mod(y2 - 1n); // u=y-1\n    const v = mod(D * y2 + 1n);\n    const x = uvRatio(u, v); // (uv)(uv)^(p-5)/8; square root\n    if (x === null) {\n        return false;\n    }\n    const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit\n    if (x === 0n && isLastByteOdd) {\n        return false;\n    }\n    return true;\n}\n","import {\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH,\n    SolanaError,\n} from '@solana/errors';\n\nimport {\n    Codec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from './codec';\n\n/**\n * Combines an `Encoder` and a `Decoder` into a `Codec`.\n *\n * That is, given a `Encoder<TFrom>` and a `Decoder<TTo>`, this function returns a `Codec<TFrom, TTo>`.\n *\n * This allows for modular composition by keeping encoding and decoding logic separate\n * while still offering a convenient way to bundle them into a single `Codec`.\n * This is particularly useful for library maintainers who want to expose `Encoders`,\n * `Decoders`, and `Codecs` separately, enabling tree-shaking of unused logic.\n *\n * The provided `Encoder` and `Decoder` must be compatible in terms of:\n * - **Fixed Size:** If both are fixed-size, they must have the same `fixedSize` value.\n * - **Variable Size:** If either has a `maxSize` attribute, it must match the other.\n *\n * If these conditions are not met, a {@link SolanaError} will be thrown.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes (for fixed-size codecs).\n *\n * @param encoder - The `Encoder` to combine.\n * @param decoder - The `Decoder` to combine.\n * @returns A `Codec` that provides both `encode` and `decode` methods.\n *\n * @throws {SolanaError}\n * - `SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH`\n *   Thrown if the encoder and decoder have mismatched size types (fixed vs. variable).\n * - `SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH`\n *   Thrown if both are fixed-size but have different `fixedSize` values.\n * - `SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH`\n *   Thrown if the `maxSize` attributes do not match.\n *\n * @example\n * Creating a fixed-size `Codec` from an encoder and a decoder.\n * ```ts\n * const encoder = getU32Encoder();\n * const decoder = getU32Decoder();\n * const codec = combineCodec(encoder, decoder);\n *\n * const bytes = codec.encode(42); // 0x2a000000\n * const value = codec.decode(bytes); // 42\n * ```\n *\n * @example\n * Creating a variable-size `Codec` from an encoder and a decoder.\n * ```ts\n * const encoder = addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder());\n * const decoder = addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder());\n * const codec = combineCodec(encoder, decoder);\n *\n * const bytes = codec.encode(\"hello\"); // 0x0500000068656c6c6f\n * const value = codec.decode(bytes); // \"hello\"\n * ```\n *\n * @remarks\n * The recommended pattern for defining codecs in libraries is to expose separate functions for the encoder, decoder, and codec.\n * This allows users to import only what they need, improving tree-shaking efficiency.\n *\n * ```ts\n * type MyType = \\/* ... *\\/;\n * const getMyTypeEncoder = (): Encoder<MyType> => { \\/* ... *\\/ };\n * const getMyTypeDecoder = (): Decoder<MyType> => { \\/* ... *\\/ };\n * const getMyTypeCodec = (): Codec<MyType> =>\n *     combineCodec(getMyTypeEncoder(), getMyTypeDecoder());\n * ```\n *\n * @see {@link Codec}\n * @see {@link Encoder}\n * @see {@link Decoder}\n */\nexport function combineCodec<TFrom, TTo extends TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize>,\n    decoder: FixedSizeDecoder<TTo, TSize>,\n): FixedSizeCodec<TFrom, TTo, TSize>;\nexport function combineCodec<TFrom, TTo extends TFrom>(\n    encoder: VariableSizeEncoder<TFrom>,\n    decoder: VariableSizeDecoder<TTo>,\n): VariableSizeCodec<TFrom, TTo>;\nexport function combineCodec<TFrom, TTo extends TFrom>(\n    encoder: Encoder<TFrom>,\n    decoder: Decoder<TTo>,\n): Codec<TFrom, TTo>;\nexport function combineCodec<TFrom, TTo extends TFrom>(\n    encoder: Encoder<TFrom>,\n    decoder: Decoder<TTo>,\n): Codec<TFrom, TTo> {\n    if (isFixedSize(encoder) !== isFixedSize(decoder)) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH);\n    }\n\n    if (isFixedSize(encoder) && isFixedSize(decoder) && encoder.fixedSize !== decoder.fixedSize) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH, {\n            decoderFixedSize: decoder.fixedSize,\n            encoderFixedSize: encoder.fixedSize,\n        });\n    }\n\n    if (!isFixedSize(encoder) && !isFixedSize(decoder) && encoder.maxSize !== decoder.maxSize) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH, {\n            decoderMaxSize: decoder.maxSize,\n            encoderMaxSize: encoder.maxSize,\n        });\n    }\n\n    return {\n        ...decoder,\n        ...encoder,\n        decode: decoder.decode,\n        encode: encoder.encode,\n        read: decoder.read,\n        write: encoder.write,\n    };\n}\n","import { getBaseXCodec, getBaseXDecoder, getBaseXEncoder } from './baseX';\n\nconst alphabet = '0123456789';\n\n/**\n * Returns an encoder for base-10 strings.\n *\n * This encoder serializes strings using a base-10 encoding scheme.\n * The output consists of bytes representing the numerical values of the input string.\n *\n * For more details, see {@link getBase10Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-10 strings.\n *\n * @example\n * Encoding a base-10 string.\n * ```ts\n * const encoder = getBase10Encoder();\n * const bytes = encoder.encode('1024'); // 0x0400\n * ```\n *\n * @see {@link getBase10Codec}\n */\nexport const getBase10Encoder = () => getBaseXEncoder(alphabet);\n\n/**\n * Returns a decoder for base-10 strings.\n *\n * This decoder deserializes base-10 encoded strings from a byte array.\n *\n * For more details, see {@link getBase10Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-10 strings.\n *\n * @example\n * Decoding a base-10 string.\n * ```ts\n * const decoder = getBase10Decoder();\n * const value = decoder.decode(new Uint8Array([0x04, 0x00])); // \"1024\"\n * ```\n *\n * @see {@link getBase10Codec}\n */\nexport const getBase10Decoder = () => getBaseXDecoder(alphabet);\n\n/**\n * Returns a codec for encoding and decoding base-10 strings.\n *\n * This codec serializes strings using a base-10 encoding scheme.\n * The output consists of bytes representing the numerical values of the input string.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-10 strings.\n *\n * @example\n * Encoding and decoding a base-10 string.\n * ```ts\n * const codec = getBase10Codec();\n * const bytes = codec.encode('1024'); // 0x0400\n * const value = codec.decode(bytes);  // \"1024\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-10 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase10Codec(), 5);\n * ```\n *\n * If you need a size-prefixed base-10 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase10Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase10Encoder} and {@link getBase10Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase10Encoder().encode('1024');\n * const value = getBase10Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase10Encoder}\n * @see {@link getBase10Decoder}\n */\nexport const getBase10Codec = () => getBaseXCodec(alphabet);\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\nconst enum HexC {\n    ZERO = 48, // 0\n    NINE = 57, // 9\n    A_UP = 65, // A\n    F_UP = 70, // F\n    A_LO = 97, // a\n    F_LO = 102, // f\n}\n\nconst INVALID_STRING_ERROR_BASE_CONFIG = {\n    alphabet: '0123456789abcdef',\n    base: 16,\n} as const;\n\nfunction charCodeToBase16(char: number) {\n    if (char >= HexC.ZERO && char <= HexC.NINE) return char - HexC.ZERO;\n    if (char >= HexC.A_UP && char <= HexC.F_UP) return char - (HexC.A_UP - 10);\n    if (char >= HexC.A_LO && char <= HexC.F_LO) return char - (HexC.A_LO - 10);\n}\n\n/**\n * Returns an encoder for base-16 (hexadecimal) strings.\n *\n * This encoder serializes strings using a base-16 encoding scheme.\n * The output consists of bytes representing the hexadecimal values of the input string.\n *\n * For more details, see {@link getBase16Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-16 strings.\n *\n * @example\n * Encoding a base-16 string.\n * ```ts\n * const encoder = getBase16Encoder();\n * const bytes = encoder.encode('deadface'); // 0xdeadface\n * ```\n *\n * @see {@link getBase16Codec}\n */\nexport const getBase16Encoder = (): VariableSizeEncoder<string> =>\n    createEncoder({\n        getSizeFromValue: (value: string) => Math.ceil(value.length / 2),\n        write(value: string, bytes, offset) {\n            const len = value.length;\n            const al = len / 2;\n            if (len === 1) {\n                const c = value.charCodeAt(0);\n                const n = charCodeToBase16(c);\n                if (n === undefined) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        ...INVALID_STRING_ERROR_BASE_CONFIG,\n                        value,\n                    });\n                }\n                bytes.set([n], offset);\n                return 1 + offset;\n            }\n            const hexBytes = new Uint8Array(al);\n            for (let i = 0, j = 0; i < al; i++) {\n                const c1 = value.charCodeAt(j++);\n                const c2 = value.charCodeAt(j++);\n\n                const n1 = charCodeToBase16(c1);\n                const n2 = charCodeToBase16(c2);\n                if (n1 === undefined || (n2 === undefined && !Number.isNaN(c2))) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        ...INVALID_STRING_ERROR_BASE_CONFIG,\n                        value,\n                    });\n                }\n                hexBytes[i] = !Number.isNaN(c2) ? (n1 << 4) | (n2 ?? 0) : n1;\n            }\n\n            bytes.set(hexBytes, offset);\n            return hexBytes.length + offset;\n        },\n    });\n\n/**\n * Returns a decoder for base-16 (hexadecimal) strings.\n *\n * This decoder deserializes base-16 encoded strings from a byte array.\n *\n * For more details, see {@link getBase16Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-16 strings.\n *\n * @example\n * Decoding a base-16 string.\n * ```ts\n * const decoder = getBase16Decoder();\n * const value = decoder.decode(new Uint8Array([0xde, 0xad, 0xfa, 0xce])); // \"deadface\"\n * ```\n *\n * @see {@link getBase16Codec}\n */\nexport const getBase16Decoder = (): VariableSizeDecoder<string> =>\n    createDecoder({\n        read(bytes, offset) {\n            const value = bytes.slice(offset).reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n            return [value, bytes.length];\n        },\n    });\n\n/**\n * Returns a codec for encoding and decoding base-16 (hexadecimal) strings.\n *\n * This codec serializes strings using a base-16 encoding scheme.\n * The output consists of bytes representing the hexadecimal values of the input string.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-16 strings.\n *\n * @example\n * Encoding and decoding a base-16 string.\n * ```ts\n * const codec = getBase16Codec();\n * const bytes = codec.encode('deadface'); // 0xdeadface\n * const value = codec.decode(bytes);      // \"deadface\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-16 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase16Codec(), 8);\n * ```\n *\n * If you need a size-prefixed base-16 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase16Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase16Encoder} and {@link getBase16Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase16Encoder().encode('deadface');\n * const value = getBase16Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase16Encoder}\n * @see {@link getBase16Decoder}\n */\nexport const getBase16Codec = (): VariableSizeCodec<string> => combineCodec(getBase16Encoder(), getBase16Decoder());\n","import {\n    SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL,\n    SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES,\n    SolanaError,\n} from '@solana/errors';\n\nimport { containsBytes } from './bytes';\nimport {\n    Codec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from './codec';\nimport { combineCodec } from './combine-codec';\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Creates an encoder that writes a `Uint8Array` sentinel after the encoded value.\n * This is useful to delimit the encoded value when being read by a decoder.\n *\n * See {@link addCodecSentinel} for more information.\n *\n * @typeParam TFrom - The type of the value to encode.\n *\n * @see {@link addCodecSentinel}\n */\nexport function addEncoderSentinel<TFrom>(\n    encoder: FixedSizeEncoder<TFrom>,\n    sentinel: ReadonlyUint8Array,\n): FixedSizeEncoder<TFrom>;\nexport function addEncoderSentinel<TFrom>(\n    encoder: Encoder<TFrom>,\n    sentinel: ReadonlyUint8Array,\n): VariableSizeEncoder<TFrom>;\nexport function addEncoderSentinel<TFrom>(encoder: Encoder<TFrom>, sentinel: ReadonlyUint8Array): Encoder<TFrom> {\n    const write = ((value, bytes, offset) => {\n        // Here we exceptionally use the `encode` function instead of the `write`\n        // function to contain the content of the encoder within its own bounds\n        // and to avoid writing the sentinel as part of the encoded value.\n        const encoderBytes = encoder.encode(value);\n        if (findSentinelIndex(encoderBytes, sentinel) >= 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL, {\n                encodedBytes: encoderBytes,\n                hexEncodedBytes: hexBytes(encoderBytes),\n                hexSentinel: hexBytes(sentinel),\n                sentinel,\n            });\n        }\n        bytes.set(encoderBytes, offset);\n        offset += encoderBytes.length;\n        bytes.set(sentinel, offset);\n        offset += sentinel.length;\n        return offset;\n    }) as Encoder<TFrom>['write'];\n\n    if (isFixedSize(encoder)) {\n        return createEncoder({ ...encoder, fixedSize: encoder.fixedSize + sentinel.length, write });\n    }\n\n    return createEncoder({\n        ...encoder,\n        ...(encoder.maxSize != null ? { maxSize: encoder.maxSize + sentinel.length } : {}),\n        getSizeFromValue: value => encoder.getSizeFromValue(value) + sentinel.length,\n        write,\n    });\n}\n\n/**\n * Creates a decoder that continues reading until\n * a given `Uint8Array` sentinel is found.\n *\n * See {@link addCodecSentinel} for more information.\n *\n * @typeParam TTo - The type of the decoded value.\n *\n * @see {@link addCodecSentinel}\n */\nexport function addDecoderSentinel<TTo>(\n    decoder: FixedSizeDecoder<TTo>,\n    sentinel: ReadonlyUint8Array,\n): FixedSizeDecoder<TTo>;\nexport function addDecoderSentinel<TTo>(decoder: Decoder<TTo>, sentinel: ReadonlyUint8Array): VariableSizeDecoder<TTo>;\nexport function addDecoderSentinel<TTo>(decoder: Decoder<TTo>, sentinel: ReadonlyUint8Array): Decoder<TTo> {\n    const read = ((bytes, offset) => {\n        const candidateBytes = offset === 0 ? bytes : bytes.slice(offset);\n        const sentinelIndex = findSentinelIndex(candidateBytes, sentinel);\n        if (sentinelIndex === -1) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES, {\n                decodedBytes: candidateBytes,\n                hexDecodedBytes: hexBytes(candidateBytes),\n                hexSentinel: hexBytes(sentinel),\n                sentinel,\n            });\n        }\n        const preSentinelBytes = candidateBytes.slice(0, sentinelIndex);\n        // Here we exceptionally use the `decode` function instead of the `read`\n        // function to contain the content of the decoder within its own bounds\n        // and ensure that the sentinel is not part of the decoded value.\n        return [decoder.decode(preSentinelBytes), offset + preSentinelBytes.length + sentinel.length];\n    }) as Decoder<TTo>['read'];\n\n    if (isFixedSize(decoder)) {\n        return createDecoder({ ...decoder, fixedSize: decoder.fixedSize + sentinel.length, read });\n    }\n\n    return createDecoder({\n        ...decoder,\n        ...(decoder.maxSize != null ? { maxSize: decoder.maxSize + sentinel.length } : {}),\n        read,\n    });\n}\n\n/**\n * Creates a Codec that writes a given `Uint8Array` sentinel after the encoded\n * value and, when decoding, continues reading until the sentinel is found.\n *\n * This sets a limit on variable-size codecs and tells us when to stop decoding.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n *\n * @example\n * ```ts\n * const codec = addCodecSentinel(getUtf8Codec(), new Uint8Array([255, 255]));\n * codec.encode('hello');\n * // 0x68656c6c6fffff\n * //   |        -- Our sentinel.\n * //   -- Our encoded string.\n * ```\n *\n * @remarks\n * Note that the sentinel _must not_ be present in the encoded data and\n * _must_ be present in the decoded data for this to work.\n * If this is not the case, dedicated errors will be thrown.\n *\n * ```ts\n * const sentinel = new Uint8Array([108, 108]); // 'll'\n * const codec = addCodecSentinel(getUtf8Codec(), sentinel);\n *\n * codec.encode('hello'); // Throws: sentinel is in encoded data.\n * codec.decode(new Uint8Array([1, 2, 3])); // Throws: sentinel missing in decoded data.\n * ```\n *\n * Separate {@link addEncoderSentinel} and {@link addDecoderSentinel} functions are also available.\n *\n * ```ts\n * const bytes = addEncoderSentinel(getUtf8Encoder(), sentinel).encode('hello');\n * const value = addDecoderSentinel(getUtf8Decoder(), sentinel).decode(bytes);\n * ```\n *\n * @see {@link addEncoderSentinel}\n * @see {@link addDecoderSentinel}\n */\nexport function addCodecSentinel<TFrom, TTo extends TFrom>(\n    codec: FixedSizeCodec<TFrom, TTo>,\n    sentinel: ReadonlyUint8Array,\n): FixedSizeCodec<TFrom, TTo>;\nexport function addCodecSentinel<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    sentinel: ReadonlyUint8Array,\n): VariableSizeCodec<TFrom, TTo>;\nexport function addCodecSentinel<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    sentinel: ReadonlyUint8Array,\n): Codec<TFrom, TTo> {\n    return combineCodec(addEncoderSentinel(codec, sentinel), addDecoderSentinel(codec, sentinel));\n}\n\nfunction findSentinelIndex(bytes: ReadonlyUint8Array, sentinel: ReadonlyUint8Array) {\n    return bytes.findIndex((byte, index, arr) => {\n        if (sentinel.length === 1) return byte === sentinel[0];\n        return containsBytes(arr, sentinel, index);\n    });\n}\n\nfunction hexBytes(bytes: ReadonlyUint8Array): string {\n    return bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n}\n","import { getBaseXCodec, getBaseXDecoder, getBaseXEncoder } from './baseX';\n\nconst alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\n\n/**\n * Returns an encoder for base-58 strings.\n *\n * This encoder serializes strings using a base-58 encoding scheme,\n * commonly used in cryptocurrency addresses and other compact representations.\n *\n * For more details, see {@link getBase58Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-58 strings.\n *\n * @example\n * Encoding a base-58 string.\n * ```ts\n * const encoder = getBase58Encoder();\n * const bytes = encoder.encode('heLLo'); // 0x1b6a3070\n * ```\n *\n * @see {@link getBase58Codec}\n */\nexport const getBase58Encoder = () => getBaseXEncoder(alphabet);\n\n/**\n * Returns a decoder for base-58 strings.\n *\n * This decoder deserializes base-58 encoded strings from a byte array.\n *\n * For more details, see {@link getBase58Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-58 strings.\n *\n * @example\n * Decoding a base-58 string.\n * ```ts\n * const decoder = getBase58Decoder();\n * const value = decoder.decode(new Uint8Array([0x1b, 0x6a, 0x30, 0x70])); // \"heLLo\"\n * ```\n *\n * @see {@link getBase58Codec}\n */\nexport const getBase58Decoder = () => getBaseXDecoder(alphabet);\n\n/**\n * Returns a codec for encoding and decoding base-58 strings.\n *\n * This codec serializes strings using a base-58 encoding scheme,\n * commonly used in cryptocurrency addresses and other compact representations.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-58 strings.\n *\n * @example\n * Encoding and decoding a base-58 string.\n * ```ts\n * const codec = getBase58Codec();\n * const bytes = codec.encode('heLLo'); // 0x1b6a3070\n * const value = codec.decode(bytes);   // \"heLLo\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-58 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase58Codec(), 8);\n * ```\n *\n * If you need a size-prefixed base-58 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase58Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase58Encoder} and {@link getBase58Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase58Encoder().encode('heLLo');\n * const value = getBase58Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase58Encoder}\n * @see {@link getBase58Decoder}\n */\nexport const getBase58Codec = () => getBaseXCodec(alphabet);\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidBaseString } from './assertions';\n\n/**\n * Returns an encoder for base-X encoded strings using bit re-slicing.\n *\n * This encoder serializes strings by dividing the input into custom-sized bit chunks,\n * mapping them to an alphabet, and encoding the result into a byte array.\n * This approach is commonly used for encoding schemes where the alphabet's length is a power of 2,\n * such as base-16 or base-64.\n *\n * For more details, see {@link getBaseXResliceCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @param bits - The number of bits per encoded chunk, typically `log2(alphabet.length)`.\n * @returns A `VariableSizeEncoder<string>` for encoding base-X strings using bit re-slicing.\n *\n * @example\n * Encoding a base-X string using bit re-slicing.\n * ```ts\n * const encoder = getBaseXResliceEncoder('elho', 2);\n * const bytes = encoder.encode('hellolol'); // 0x4aee\n * ```\n *\n * @see {@link getBaseXResliceCodec}\n */\nexport const getBaseXResliceEncoder = (alphabet: string, bits: number): VariableSizeEncoder<string> =>\n    createEncoder({\n        getSizeFromValue: (value: string) => Math.floor((value.length * bits) / 8),\n        write(value: string, bytes, offset) {\n            assertValidBaseString(alphabet, value);\n            if (value === '') return offset;\n            const charIndices = [...value].map(c => alphabet.indexOf(c));\n            const reslicedBytes = reslice(charIndices, bits, 8, false);\n            bytes.set(reslicedBytes, offset);\n            return reslicedBytes.length + offset;\n        },\n    });\n\n/**\n * Returns a decoder for base-X encoded strings using bit re-slicing.\n *\n * This decoder deserializes base-X encoded strings by re-slicing the bits of a byte array into\n * custom-sized chunks and mapping them to a specified alphabet.\n * This is typically used for encoding schemes where the alphabet's length is a power of 2,\n * such as base-16 or base-64.\n *\n * For more details, see {@link getBaseXResliceCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @param bits - The number of bits per encoded chunk, typically `log2(alphabet.length)`.\n * @returns A `VariableSizeDecoder<string>` for decoding base-X strings using bit re-slicing.\n *\n * @example\n * Decoding a base-X string using bit re-slicing.\n * ```ts\n * const decoder = getBaseXResliceDecoder('elho', 2);\n * const value = decoder.decode(new Uint8Array([0x4a, 0xee])); // \"hellolol\"\n * ```\n *\n * @see {@link getBaseXResliceCodec}\n */\nexport const getBaseXResliceDecoder = (alphabet: string, bits: number): VariableSizeDecoder<string> =>\n    createDecoder({\n        read(rawBytes, offset = 0): [string, number] {\n            const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n            if (bytes.length === 0) return ['', rawBytes.length];\n            const charIndices = reslice([...bytes], 8, bits, true);\n            return [charIndices.map(i => alphabet[i]).join(''), rawBytes.length];\n        },\n    });\n\n/**\n * Returns a codec for encoding and decoding base-X strings using bit re-slicing.\n *\n * This codec serializes strings by dividing the input into custom-sized bit chunks,\n * mapping them to a given alphabet, and encoding the result into bytes.\n * It is particularly suited for encoding schemes where the alphabet's length is a power of 2,\n * such as base-16 or base-64.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @param bits - The number of bits per encoded chunk, typically `log2(alphabet.length)`.\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-X strings using bit re-slicing.\n *\n * @example\n * Encoding and decoding a base-X string using bit re-slicing.\n * ```ts\n * const codec = getBaseXResliceCodec('elho', 2);\n * const bytes = codec.encode('hellolol'); // 0x4aee\n * const value = codec.decode(bytes);      // \"hellolol\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-X codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBaseXResliceCodec('elho', 2), 8);\n * ```\n *\n * If you need a size-prefixed base-X codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBaseXResliceCodec('elho', 2), getU32Codec());\n * ```\n *\n * Separate {@link getBaseXResliceEncoder} and {@link getBaseXResliceDecoder} functions are available.\n *\n * ```ts\n * const bytes = getBaseXResliceEncoder('elho', 2).encode('hellolol');\n * const value = getBaseXResliceDecoder('elho', 2).decode(bytes);\n * ```\n *\n * @see {@link getBaseXResliceEncoder}\n * @see {@link getBaseXResliceDecoder}\n */\nexport const getBaseXResliceCodec = (alphabet: string, bits: number): VariableSizeCodec<string> =>\n    combineCodec(getBaseXResliceEncoder(alphabet, bits), getBaseXResliceDecoder(alphabet, bits));\n\n/** Helper function to reslice the bits inside bytes. */\nfunction reslice(input: number[], inputBits: number, outputBits: number, useRemainder: boolean): number[] {\n    const output = [];\n    let accumulator = 0;\n    let bitsInAccumulator = 0;\n    const mask = (1 << outputBits) - 1;\n    for (const value of input) {\n        accumulator = (accumulator << inputBits) | value;\n        bitsInAccumulator += inputBits;\n        while (bitsInAccumulator >= outputBits) {\n            bitsInAccumulator -= outputBits;\n            output.push((accumulator >> bitsInAccumulator) & mask);\n        }\n    }\n    if (useRemainder && bitsInAccumulator > 0) {\n        output.push((accumulator << (outputBits - bitsInAccumulator)) & mask);\n    }\n    return output;\n}\n","import { ReadonlyUint8Array } from '@solana/codecs-core';\n\nimport { pointIsOnCurve } from './vendor/noble/ed25519';\n\nfunction byteToHex(byte: number): string {\n    const hexString = byte.toString(16);\n    if (hexString.length === 1) {\n        return `0${hexString}`;\n    } else {\n        return hexString;\n    }\n}\n\nfunction decompressPointBytes(bytes: ReadonlyUint8Array): bigint {\n    const hexString = bytes.reduce((acc, byte, ii) => `${byteToHex(ii === 31 ? byte & ~0x80 : byte)}${acc}`, '');\n    const integerLiteralString = `0x${hexString}`;\n    return BigInt(integerLiteralString);\n}\n\nexport function compressedPointBytesAreOnCurve(bytes: ReadonlyUint8Array): boolean {\n    if (bytes.byteLength !== 32) {\n        return false;\n    }\n    const y = decompressPointBytes(bytes);\n    return pointIsOnCurve(y, bytes[31]);\n}\n","import { SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS, SolanaError } from '@solana/errors';\nimport type { AffinePoint } from '@solana/nominal-types';\n\nimport { type Address, getAddressCodec } from './address';\nimport { compressedPointBytesAreOnCurve } from './curve-internal';\n\n/**\n * Represents an {@link Address} that validates as being off-curve. Functions that require off-curve\n * addresses should specify their inputs in terms of this type.\n *\n * Whenever you need to validate an address as being off-curve, use the {@link offCurveAddress},\n * {@link assertIsOffCurveAddress}, or {@link isOffCurveAddress} functions in this package.\n */\nexport type OffCurveAddress<TAddress extends string = string> = AffinePoint<Address<TAddress>, 'invalid'>;\n\n/**\n * A type guard that returns `true` if the input address conforms to the {@link OffCurveAddress}\n * type, and refines its type for use in your application.\n *\n * @example\n * ```ts\n * import { isOffCurveAddress } from '@solana/addresses';\n *\n * if (isOffCurveAddress(accountAddress)) {\n *     // At this point, `accountAddress` has been refined to a\n *     // `OffCurveAddress` that can be used within your business logic.\n *     const { value: account } = await rpc.getAccountInfo(accountAddress).send();\n * } else {\n *     setError(`${accountAddress} is not off-curve`);\n * }\n * ```\n */\nexport function isOffCurveAddress<TAddress extends Address>(\n    putativeOffCurveAddress: TAddress,\n): putativeOffCurveAddress is OffCurveAddress<TAddress> {\n    const addressBytes = getAddressCodec().encode(putativeOffCurveAddress);\n    return compressedPointBytesAreOnCurve(addressBytes) === false;\n}\n\n/**\n * From time to time you might acquire an {@link Address}, that you expect to validate as an\n * off-curve address, from an untrusted source. Use this function to assert that such an address is\n * off-curve.\n *\n * @example\n * ```ts\n * import { assertIsOffCurveAddress } from '@solana/addresses';\n *\n * // Imagine a function that fetches an account's balance when a user submits a form.\n * function handleSubmit() {\n *     // We know only that the input conforms to the `string` type.\n *     const address: string = accountAddressInput.value;\n *     try {\n *         // If this type assertion function doesn't throw, then\n *         // Typescript will upcast `address` to `Address`.\n *         assertIsAddress(address);\n *         // If this type assertion function doesn't throw, then\n *         // Typescript will upcast `address` to `OffCurveAddress`.\n *         assertIsOffCurveAddress(address);\n *         // At this point, `address` is an `OffCurveAddress` that can be used with the RPC.\n *         const balanceInLamports = await rpc.getBalance(address).send();\n *     } catch (e) {\n *         // `address` turned out to NOT be a base58-encoded off-curve address\n *     }\n * }\n * ```\n */\nexport function assertIsOffCurveAddress<TAddress extends Address>(\n    putativeOffCurveAddress: TAddress,\n): asserts putativeOffCurveAddress is OffCurveAddress<TAddress> {\n    if (!isOffCurveAddress(putativeOffCurveAddress)) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS);\n    }\n}\n\n/**\n * Combines _asserting_ that an {@link Address} is off-curve with _coercing_ it to the\n * {@link OffCurveAddress} type. It's most useful with untrusted input.\n */\nexport function offCurveAddress<TAddress extends Address>(\n    putativeOffCurveAddress: TAddress,\n): OffCurveAddress<TAddress> {\n    assertIsOffCurveAddress(putativeOffCurveAddress);\n    return putativeOffCurveAddress;\n}\n","import {\n    SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY,\n    SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE,\n    SolanaError,\n} from '@solana/errors';\n\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Asserts that a given byte array is not empty (after the optional provided offset).\n *\n * Returns void if the byte array is not empty but throws a {@link SolanaError} otherwise.\n *\n * @param codecDescription - A description of the codec used by the assertion error.\n * @param bytes - The byte array to check.\n * @param offset - The offset from which to start checking the byte array.\n * If provided, the byte array is considered empty if it has no bytes after the offset.\n *\n * @example\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02, 0x03]);\n * assertByteArrayIsNotEmptyForCodec('myCodec', bytes); // OK\n * assertByteArrayIsNotEmptyForCodec('myCodec', bytes, 1); // OK\n * assertByteArrayIsNotEmptyForCodec('myCodec', bytes, 3); // Throws\n * ```\n */\nexport function assertByteArrayIsNotEmptyForCodec(\n    codecDescription: string,\n    bytes: ReadonlyUint8Array | Uint8Array,\n    offset = 0,\n) {\n    if (bytes.length - offset <= 0) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY, {\n            codecDescription,\n        });\n    }\n}\n\n/**\n * Asserts that a given byte array has enough bytes to decode\n * (after the optional provided offset).\n *\n * Returns void if the byte array has at least the expected number\n * of bytes but throws a {@link SolanaError} otherwise.\n *\n * @param codecDescription - A description of the codec used by the assertion error.\n * @param expected - The minimum number of bytes expected in the byte array.\n * @param bytes - The byte array to check.\n * @param offset - The offset from which to start checking the byte array.\n *\n * @example\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02, 0x03]);\n * assertByteArrayHasEnoughBytesForCodec('myCodec', 3, bytes); // OK\n * assertByteArrayHasEnoughBytesForCodec('myCodec', 4, bytes); // Throws\n * assertByteArrayHasEnoughBytesForCodec('myCodec', 2, bytes, 1); // OK\n * assertByteArrayHasEnoughBytesForCodec('myCodec', 3, bytes, 1); // Throws\n * ```\n */\nexport function assertByteArrayHasEnoughBytesForCodec(\n    codecDescription: string,\n    expected: number,\n    bytes: ReadonlyUint8Array | Uint8Array,\n    offset = 0,\n) {\n    const bytesLength = bytes.length - offset;\n    if (bytesLength < expected) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, {\n            bytesLength,\n            codecDescription,\n            expected,\n        });\n    }\n}\n\n/**\n * Asserts that a given offset is within the byte array bounds.\n * This range is between 0 and the byte array length and is inclusive.\n * An offset equals to the byte array length is considered a valid offset\n * as it allows the post-offset of codecs to signal the end of the byte array.\n *\n * @param codecDescription - A description of the codec used by the assertion error.\n * @param offset - The offset to check.\n * @param bytesLength - The length of the byte array from which the offset should be within bounds.\n *\n * @example\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02, 0x03]);\n * assertByteArrayOffsetIsNotOutOfRange('myCodec', 0, bytes.length); // OK\n * assertByteArrayOffsetIsNotOutOfRange('myCodec', 3, bytes.length); // OK\n * assertByteArrayOffsetIsNotOutOfRange('myCodec', 4, bytes.length); // Throws\n * ```\n */\nexport function assertByteArrayOffsetIsNotOutOfRange(codecDescription: string, offset: number, bytesLength: number) {\n    if (offset < 0 || offset > bytesLength) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE, {\n            bytesLength,\n            codecDescription,\n            offset,\n        });\n    }\n}\n","import { assertDigestCapabilityIsAvailable } from '@solana/assertions';\nimport type { ReadonlyUint8Array } from '@solana/codecs-core';\nimport {\n    isSolanaError,\n    SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED,\n    SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE,\n    SOLANA_ERROR__ADDRESSES__MALFORMED_PDA,\n    SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED,\n    SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED,\n    SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE,\n    SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER,\n    SolanaError,\n} from '@solana/errors';\nimport { Brand } from '@solana/nominal-types';\n\nimport { Address, assertIsAddress, getAddressCodec, isAddress } from './address';\nimport { compressedPointBytesAreOnCurve } from './curve-internal';\n\n/**\n * A tuple representing a program derived address (derived from the address of some program and a\n * set of seeds) and the associated bump seed used to ensure that the address, as derived, does not\n * fall on the Ed25519 curve.\n *\n * Whenever you need to validate an arbitrary tuple as one that represents a program derived\n * address, use the {@link assertIsProgramDerivedAddress} or {@link isProgramDerivedAddress}\n * functions in this package.\n */\nexport type ProgramDerivedAddress<TAddress extends string = string> = Readonly<\n    [Address<TAddress>, ProgramDerivedAddressBump]\n>;\n\n/**\n * Represents an integer in the range [0,255] used in the derivation of a program derived address to\n * ensure that it does not fall on the Ed25519 curve.\n */\nexport type ProgramDerivedAddressBump = Brand<number, 'ProgramDerivedAddressBump'>;\n\n/**\n * A type guard that returns `true` if the input tuple conforms to the {@link ProgramDerivedAddress}\n * type, and refines its type for use in your program.\n *\n * @see The {@link isAddress} function for an example of how to use a type guard.\n */\nexport function isProgramDerivedAddress<TAddress extends string = string>(\n    value: unknown,\n): value is ProgramDerivedAddress<TAddress> {\n    return (\n        Array.isArray(value) &&\n        value.length === 2 &&\n        typeof value[0] === 'string' &&\n        typeof value[1] === 'number' &&\n        value[1] >= 0 &&\n        value[1] <= 255 &&\n        isAddress(value[0])\n    );\n}\n\n/**\n * In the event that you receive an address/bump-seed tuple from some untrusted source, use this\n * function to assert that it conforms to the {@link ProgramDerivedAddress} interface.\n *\n * @see The {@link assertIsAddress} function for an example of how to use an assertion function.\n */\nexport function assertIsProgramDerivedAddress<TAddress extends string = string>(\n    value: unknown,\n): asserts value is ProgramDerivedAddress<TAddress> {\n    const validFormat =\n        Array.isArray(value) && value.length === 2 && typeof value[0] === 'string' && typeof value[1] === 'number';\n    if (!validFormat) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__MALFORMED_PDA);\n    }\n    if (value[1] < 0 || value[1] > 255) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE, {\n            bump: value[1],\n        });\n    }\n    assertIsAddress(value[0]);\n}\n\ntype ProgramDerivedAddressInput = Readonly<{\n    programAddress: Address;\n    seeds: Seed[];\n}>;\n\ntype SeedInput = Readonly<{\n    baseAddress: Address;\n    programAddress: Address;\n    seed: Seed;\n}>;\n\ntype Seed = ReadonlyUint8Array | string;\n\nconst MAX_SEED_LENGTH = 32;\nconst MAX_SEEDS = 16;\nconst PDA_MARKER_BYTES = [\n    // The string 'ProgramDerivedAddress'\n    80, 114, 111, 103, 114, 97, 109, 68, 101, 114, 105, 118, 101, 100, 65, 100, 100, 114, 101, 115, 115,\n] as const;\n\nasync function createProgramDerivedAddress({ programAddress, seeds }: ProgramDerivedAddressInput): Promise<Address> {\n    assertDigestCapabilityIsAvailable();\n    if (seeds.length > MAX_SEEDS) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED, {\n            actual: seeds.length,\n            maxSeeds: MAX_SEEDS,\n        });\n    }\n    let textEncoder: TextEncoder;\n    const seedBytes = seeds.reduce((acc, seed, ii) => {\n        const bytes = typeof seed === 'string' ? (textEncoder ||= new TextEncoder()).encode(seed) : seed;\n        if (bytes.byteLength > MAX_SEED_LENGTH) {\n            throw new SolanaError(SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED, {\n                actual: bytes.byteLength,\n                index: ii,\n                maxSeedLength: MAX_SEED_LENGTH,\n            });\n        }\n        acc.push(...bytes);\n        return acc;\n    }, [] as number[]);\n    const base58EncodedAddressCodec = getAddressCodec();\n    const programAddressBytes = base58EncodedAddressCodec.encode(programAddress);\n    const addressBytesBuffer = await crypto.subtle.digest(\n        'SHA-256',\n        new Uint8Array([...seedBytes, ...programAddressBytes, ...PDA_MARKER_BYTES]),\n    );\n    const addressBytes = new Uint8Array(addressBytesBuffer);\n    if (compressedPointBytesAreOnCurve(addressBytes)) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE);\n    }\n    return base58EncodedAddressCodec.decode(addressBytes);\n}\n\n/**\n * Given a program's {@link Address} and up to 16 {@link Seed | Seeds}, this method will return the\n * program derived address (PDA) associated with each.\n *\n * @example\n * ```ts\n * import { getAddressEncoder, getProgramDerivedAddress } from '@solana/addresses';\n *\n * const addressEncoder = getAddressEncoder();\n * const [pda, bumpSeed] = await getProgramDerivedAddress({\n *     programAddress: 'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL' as Address,\n *     seeds: [\n *         // Owner\n *         addressEncoder.encode('9fYLFVoVqwH37C3dyPi6cpeobfbQ2jtLpN5HgAYDDdkm' as Address),\n *         // Token program\n *         addressEncoder.encode('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address),\n *         // Mint\n *         addressEncoder.encode('EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v' as Address),\n *     ],\n * });\n * ```\n */\nexport async function getProgramDerivedAddress({\n    programAddress,\n    seeds,\n}: ProgramDerivedAddressInput): Promise<ProgramDerivedAddress> {\n    let bumpSeed = 255;\n    while (bumpSeed > 0) {\n        try {\n            const address = await createProgramDerivedAddress({\n                programAddress,\n                seeds: [...seeds, new Uint8Array([bumpSeed])],\n            });\n            return [address, bumpSeed as ProgramDerivedAddressBump];\n        } catch (e) {\n            if (isSolanaError(e, SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE)) {\n                bumpSeed--;\n            } else {\n                throw e;\n            }\n        }\n    }\n    throw new SolanaError(SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED);\n}\n\n/**\n * Returns a base58-encoded address derived from some base address, some program address, and a seed\n * string or byte array.\n *\n * @example\n * ```ts\n * import { createAddressWithSeed } from '@solana/addresses';\n *\n * const derivedAddress = await createAddressWithSeed({\n *     // The private key associated with this address will be able to sign for `derivedAddress`.\n *     baseAddress: 'B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka' as Address,\n *     // Only this program will be able to write data to this account.\n *     programAddress: '445erYq578p2aERrGW9mn9KiYe3fuG6uHdcJ2LPPShGw' as Address,\n *     seed: 'data-account',\n * });\n * ```\n */\nexport async function createAddressWithSeed({ baseAddress, programAddress, seed }: SeedInput): Promise<Address> {\n    const { encode, decode } = getAddressCodec();\n\n    const seedBytes = typeof seed === 'string' ? new TextEncoder().encode(seed) : seed;\n    if (seedBytes.byteLength > MAX_SEED_LENGTH) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED, {\n            actual: seedBytes.byteLength,\n            index: 0,\n            maxSeedLength: MAX_SEED_LENGTH,\n        });\n    }\n\n    const programAddressBytes = encode(programAddress);\n    if (\n        programAddressBytes.length >= PDA_MARKER_BYTES.length &&\n        programAddressBytes.slice(-PDA_MARKER_BYTES.length).every((byte, index) => byte === PDA_MARKER_BYTES[index])\n    ) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER);\n    }\n\n    const addressBytesBuffer = await crypto.subtle.digest(\n        'SHA-256',\n        new Uint8Array([...encode(baseAddress), ...seedBytes, ...programAddressBytes]),\n    );\n    const addressBytes = new Uint8Array(addressBytesBuffer);\n\n    return decode(addressBytes);\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\nimport { assertValidBaseString } from './assertions';\nimport { getBaseXResliceDecoder, getBaseXResliceEncoder } from './baseX-reslice';\n\nconst alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n/**\n * Returns an encoder for base-64 strings.\n *\n * This encoder serializes strings using a base-64 encoding scheme,\n * commonly used for data encoding in URLs, cryptographic keys, and binary-to-text encoding.\n *\n * For more details, see {@link getBase64Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-64 strings.\n *\n * @example\n * Encoding a base-64 string.\n * ```ts\n * const encoder = getBase64Encoder();\n * const bytes = encoder.encode('hello+world'); // 0x85e965a3ec28ae57\n * ```\n *\n * @see {@link getBase64Codec}\n */\nexport const getBase64Encoder = (): VariableSizeEncoder<string> => {\n    if (__BROWSER__) {\n        return createEncoder({\n            getSizeFromValue: (value: string) => {\n                try {\n                    return (atob as Window['atob'])(value).length;\n                } catch {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        alphabet,\n                        base: 64,\n                        value,\n                    });\n                }\n            },\n            write(value: string, bytes, offset) {\n                try {\n                    const bytesToAdd = (atob as Window['atob'])(value)\n                        .split('')\n                        .map(c => c.charCodeAt(0));\n                    bytes.set(bytesToAdd, offset);\n                    return bytesToAdd.length + offset;\n                } catch {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        alphabet,\n                        base: 64,\n                        value,\n                    });\n                }\n            },\n        });\n    }\n\n    if (__NODEJS__) {\n        return createEncoder({\n            getSizeFromValue: (value: string) => Buffer.from(value, 'base64').length,\n            write(value: string, bytes, offset) {\n                assertValidBaseString(alphabet, value.replace(/=/g, ''));\n                const buffer = Buffer.from(value, 'base64');\n                bytes.set(buffer, offset);\n                return buffer.length + offset;\n            },\n        });\n    }\n\n    return transformEncoder(getBaseXResliceEncoder(alphabet, 6), (value: string): string => value.replace(/=/g, ''));\n};\n\n/**\n * Returns a decoder for base-64 strings.\n *\n * This decoder deserializes base-64 encoded strings from a byte array.\n *\n * For more details, see {@link getBase64Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-64 strings.\n *\n * @example\n * Decoding a base-64 string.\n * ```ts\n * const decoder = getBase64Decoder();\n * const value = decoder.decode(new Uint8Array([0x85, 0xe9, 0x65, 0xa3, 0xec, 0x28, 0xae, 0x57])); // \"hello+world\"\n * ```\n *\n * @see {@link getBase64Codec}\n */\nexport const getBase64Decoder = (): VariableSizeDecoder<string> => {\n    if (__BROWSER__) {\n        return createDecoder({\n            read(bytes, offset = 0) {\n                const slice = bytes.slice(offset);\n                const value = (btoa as Window['btoa'])(String.fromCharCode(...slice));\n                return [value, bytes.length];\n            },\n        });\n    }\n\n    if (__NODEJS__) {\n        return createDecoder({\n            read: (bytes, offset = 0) => [Buffer.from(bytes, offset).toString('base64'), bytes.length],\n        });\n    }\n\n    return transformDecoder(getBaseXResliceDecoder(alphabet, 6), (value: string): string =>\n        value.padEnd(Math.ceil(value.length / 4) * 4, '='),\n    );\n};\n\n/**\n * Returns a codec for encoding and decoding base-64 strings.\n *\n * This codec serializes strings using a base-64 encoding scheme,\n * commonly used for data encoding in URLs, cryptographic keys, and binary-to-text encoding.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-64 strings.\n *\n * @example\n * Encoding and decoding a base-64 string.\n * ```ts\n * const codec = getBase64Codec();\n * const bytes = codec.encode('hello+world'); // 0x85e965a3ec28ae57\n * const value = codec.decode(bytes);         // \"hello+world\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-64 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase64Codec(), 8);\n * ```\n *\n * If you need a size-prefixed base-64 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase64Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase64Encoder} and {@link getBase64Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase64Encoder().encode('hello+world');\n * const value = getBase64Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase64Encoder}\n * @see {@link getBase64Decoder}\n */\nexport const getBase64Codec = (): VariableSizeCodec<string> => combineCodec(getBase64Encoder(), getBase64Decoder());\n","import { assertByteArrayHasEnoughBytesForCodec } from './assertions';\nimport {\n    Codec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    getEncodedSize,\n    isFixedSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from './codec';\nimport { combineCodec } from './combine-codec';\n\ntype NumberEncoder = Encoder<bigint | number> | Encoder<number>;\ntype FixedSizeNumberEncoder<TSize extends number = number> =\n    | FixedSizeEncoder<bigint | number, TSize>\n    | FixedSizeEncoder<number, TSize>;\ntype NumberDecoder = Decoder<bigint> | Decoder<number>;\ntype FixedSizeNumberDecoder<TSize extends number = number> =\n    | FixedSizeDecoder<bigint, TSize>\n    | FixedSizeDecoder<number, TSize>;\ntype NumberCodec = Codec<bigint | number, bigint> | Codec<number>;\ntype FixedSizeNumberCodec<TSize extends number = number> =\n    | FixedSizeCodec<bigint | number, bigint, TSize>\n    | FixedSizeCodec<number, number, TSize>;\n\n/**\n * Stores the size of the `encoder` in bytes as a prefix using the `prefix` encoder.\n *\n * See {@link addCodecSizePrefix} for more information.\n *\n * @typeParam TFrom - The type of the value to encode.\n *\n * @see {@link addCodecSizePrefix}\n */\nexport function addEncoderSizePrefix<TFrom>(\n    encoder: FixedSizeEncoder<TFrom>,\n    prefix: FixedSizeNumberEncoder,\n): FixedSizeEncoder<TFrom>;\nexport function addEncoderSizePrefix<TFrom>(encoder: Encoder<TFrom>, prefix: NumberEncoder): VariableSizeEncoder<TFrom>;\nexport function addEncoderSizePrefix<TFrom>(encoder: Encoder<TFrom>, prefix: NumberEncoder): Encoder<TFrom> {\n    const write = ((value, bytes, offset) => {\n        // Here we exceptionally use the `encode` function instead of the `write`\n        // function to contain the content of the encoder within its own bounds.\n        const encoderBytes = encoder.encode(value);\n        offset = prefix.write(encoderBytes.length, bytes, offset);\n        bytes.set(encoderBytes, offset);\n        return offset + encoderBytes.length;\n    }) as Encoder<TFrom>['write'];\n\n    if (isFixedSize(prefix) && isFixedSize(encoder)) {\n        return createEncoder({ ...encoder, fixedSize: prefix.fixedSize + encoder.fixedSize, write });\n    }\n\n    const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : (prefix.maxSize ?? null);\n    const encoderMaxSize = isFixedSize(encoder) ? encoder.fixedSize : (encoder.maxSize ?? null);\n    const maxSize = prefixMaxSize !== null && encoderMaxSize !== null ? prefixMaxSize + encoderMaxSize : null;\n\n    return createEncoder({\n        ...encoder,\n        ...(maxSize !== null ? { maxSize } : {}),\n        getSizeFromValue: value => {\n            const encoderSize = getEncodedSize(value, encoder);\n            return getEncodedSize(encoderSize, prefix) + encoderSize;\n        },\n        write,\n    });\n}\n\n/**\n * Bounds the size of the nested `decoder` by reading its encoded `prefix`.\n *\n * See {@link addCodecSizePrefix} for more information.\n *\n * @typeParam TTo - The type of the decoded value.\n *\n * @see {@link addCodecSizePrefix}\n */\nexport function addDecoderSizePrefix<TTo>(\n    decoder: FixedSizeDecoder<TTo>,\n    prefix: FixedSizeNumberDecoder,\n): FixedSizeDecoder<TTo>;\nexport function addDecoderSizePrefix<TTo>(decoder: Decoder<TTo>, prefix: NumberDecoder): VariableSizeDecoder<TTo>;\nexport function addDecoderSizePrefix<TTo>(decoder: Decoder<TTo>, prefix: NumberDecoder): Decoder<TTo> {\n    const read = ((bytes, offset) => {\n        const [bigintSize, decoderOffset] = prefix.read(bytes, offset);\n        const size = Number(bigintSize);\n        offset = decoderOffset;\n        // Slice the byte array to the contained size if necessary.\n        if (offset > 0 || bytes.length > size) {\n            bytes = bytes.slice(offset, offset + size);\n        }\n        assertByteArrayHasEnoughBytesForCodec('addDecoderSizePrefix', size, bytes);\n        // Here we exceptionally use the `decode` function instead of the `read`\n        // function to contain the content of the decoder within its own bounds.\n        return [decoder.decode(bytes), offset + size];\n    }) as Decoder<TTo>['read'];\n\n    if (isFixedSize(prefix) && isFixedSize(decoder)) {\n        return createDecoder({ ...decoder, fixedSize: prefix.fixedSize + decoder.fixedSize, read });\n    }\n\n    const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : (prefix.maxSize ?? null);\n    const decoderMaxSize = isFixedSize(decoder) ? decoder.fixedSize : (decoder.maxSize ?? null);\n    const maxSize = prefixMaxSize !== null && decoderMaxSize !== null ? prefixMaxSize + decoderMaxSize : null;\n    return createDecoder({ ...decoder, ...(maxSize !== null ? { maxSize } : {}), read });\n}\n\n/**\n * Stores the byte size of any given codec as an encoded number prefix.\n *\n * This sets a limit on variable-size codecs and tells us when to stop decoding.\n * When encoding, the size of the encoded data is stored before the encoded data itself.\n * When decoding, the size is read first to know how many bytes to read next.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n *\n * @example\n * For example, say we want to bound a variable-size base-58 string using a `u32` size prefix.\n * Heres how you can use the `addCodecSizePrefix` function to achieve that.\n *\n * ```ts\n * const getU32Base58Codec = () => addCodecSizePrefix(getBase58Codec(), getU32Codec());\n *\n * getU32Base58Codec().encode('hello world');\n * // 0x0b00000068656c6c6f20776f726c64\n * //   |       -- Our encoded base-58 string.\n * //   -- Our encoded u32 size prefix.\n * ```\n *\n * @remarks\n * Separate {@link addEncoderSizePrefix} and {@link addDecoderSizePrefix} functions are also available.\n *\n * ```ts\n * const bytes = addEncoderSizePrefix(getBase58Encoder(), getU32Encoder()).encode('hello');\n * const value = addDecoderSizePrefix(getBase58Decoder(), getU32Decoder()).decode(bytes);\n * ```\n *\n * @see {@link addEncoderSizePrefix}\n * @see {@link addDecoderSizePrefix}\n */\nexport function addCodecSizePrefix<TFrom, TTo extends TFrom>(\n    codec: FixedSizeCodec<TFrom, TTo>,\n    prefix: FixedSizeNumberCodec,\n): FixedSizeCodec<TFrom, TTo>;\nexport function addCodecSizePrefix<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    prefix: NumberCodec,\n): VariableSizeCodec<TFrom, TTo>;\nexport function addCodecSizePrefix<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    prefix: NumberCodec,\n): Codec<TFrom, TTo> {\n    return combineCodec(addEncoderSizePrefix(codec, prefix), addDecoderSizePrefix(codec, prefix));\n}\n","/**\n * Removes all null characters (`\\u0000`) from a string.\n *\n * This function cleans a string by stripping out any null characters,\n * which are often used as padding in fixed-size string encodings.\n *\n * @param value - The string to process.\n * @returns The input string with all null characters removed.\n *\n * @example\n * Removing null characters from a string.\n * ```ts\n * removeNullCharacters('hello\\u0000\\u0000'); // \"hello\"\n * ```\n */\nexport const removeNullCharacters = (value: string) =>\n    // eslint-disable-next-line no-control-regex\n    value.replace(/\\u0000/g, '');\n\n/**\n * Pads a string with null characters (`\\u0000`) at the end to reach a fixed length.\n *\n * If the input string is shorter than the specified length, it is padded with null characters\n * until it reaches the desired size. If it is already long enough, it remains unchanged.\n *\n * @param value - The string to pad.\n * @param chars - The total length of the resulting string, including padding.\n * @returns The input string padded with null characters up to the specified length.\n *\n * @example\n * Padding a string with null characters.\n * ```ts\n * padNullCharacters('hello', 8); // \"hello\\u0000\\u0000\\u0000\"\n * ```\n */\nexport const padNullCharacters = (value: string, chars: number) => value.padEnd(chars, '\\u0000');\n","export const TextDecoder = globalThis.TextDecoder;\nexport const TextEncoder = globalThis.TextEncoder;\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { TextDecoder, TextEncoder } from '@solana/text-encoding-impl';\n\nimport { removeNullCharacters } from './null-characters';\n\n/**\n * Returns an encoder for UTF-8 strings.\n *\n * This encoder serializes strings using UTF-8 encoding.\n * The encoded output contains as many bytes as needed to represent the string.\n *\n * For more details, see {@link getUtf8Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding UTF-8 strings.\n *\n * @example\n * Encoding a UTF-8 string.\n * ```ts\n * const encoder = getUtf8Encoder();\n * const bytes = encoder.encode('hello'); // 0x68656c6c6f\n * ```\n *\n * @see {@link getUtf8Codec}\n */\nexport const getUtf8Encoder = (): VariableSizeEncoder<string> => {\n    let textEncoder: TextEncoder;\n    return createEncoder({\n        getSizeFromValue: value => (textEncoder ||= new TextEncoder()).encode(value).length,\n        write: (value: string, bytes, offset) => {\n            const bytesToAdd = (textEncoder ||= new TextEncoder()).encode(value);\n            bytes.set(bytesToAdd, offset);\n            return offset + bytesToAdd.length;\n        },\n    });\n};\n\n/**\n * Returns a decoder for UTF-8 strings.\n *\n * This decoder deserializes UTF-8 encoded strings from a byte array.\n * It reads all available bytes starting from the given offset.\n *\n * For more details, see {@link getUtf8Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding UTF-8 strings.\n *\n * @example\n * Decoding a UTF-8 string.\n * ```ts\n * const decoder = getUtf8Decoder();\n * const value = decoder.decode(new Uint8Array([0x68, 0x65, 0x6c, 0x6c, 0x6f])); // \"hello\"\n * ```\n *\n * @see {@link getUtf8Codec}\n */\nexport const getUtf8Decoder = (): VariableSizeDecoder<string> => {\n    let textDecoder: TextDecoder;\n    return createDecoder({\n        read(bytes, offset) {\n            const value = (textDecoder ||= new TextDecoder()).decode(bytes.slice(offset));\n            return [removeNullCharacters(value), bytes.length];\n        },\n    });\n};\n\n/**\n * Returns a codec for encoding and decoding UTF-8 strings.\n *\n * This codec serializes strings using UTF-8 encoding.\n * The encoded output contains as many bytes as needed to represent the string.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding UTF-8 strings.\n *\n * @example\n * Encoding and decoding a UTF-8 string.\n * ```ts\n * const codec = getUtf8Codec();\n * const bytes = codec.encode('hello'); // 0x68656c6c6f\n * const value = codec.decode(bytes);   // \"hello\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size UTF-8 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getUtf8Codec(), 5);\n * ```\n *\n * If you need a size-prefixed UTF-8 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getUtf8Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getUtf8Encoder} and {@link getUtf8Decoder} functions are available.\n *\n * ```ts\n * const bytes = getUtf8Encoder().encode('hello');\n * const value = getUtf8Decoder().decode(bytes);\n * ```\n *\n * @see {@link getUtf8Encoder}\n * @see {@link getUtf8Decoder}\n */\nexport const getUtf8Codec = (): VariableSizeCodec<string> => combineCodec(getUtf8Encoder(), getUtf8Decoder());\n","import { SOLANA_ERROR__CODECS__EXPECTED_DECODER_TO_CONSUME_ENTIRE_BYTE_ARRAY, SolanaError } from '@solana/errors';\n\nimport { createDecoder, Decoder } from './codec';\n\n/**\n * Create a {@link Decoder} that asserts that the bytes provided to `decode` or `read` are fully consumed by the inner decoder\n * @param decoder A decoder to wrap\n * @returns A new decoder that will throw if provided with a byte array that it does not fully consume\n *\n * @typeParam T - The type of the decoder\n *\n * @remarks\n * Note that this compares the offset after encoding to the length of the input byte array\n *\n * The `offset` parameter to `decode` and `read` is still considered, and will affect the new offset that is compared to the byte array length\n *\n * The error that is thrown by the returned decoder is a {@link SolanaError} with the code `SOLANA_ERROR__CODECS__EXPECTED_DECODER_TO_CONSUME_ENTIRE_BYTE_ARRAY`\n *\n * @example\n * Create a decoder that decodes a `u32` (4 bytes) and ensures the entire byte array is consumed\n * ```ts\n * const decoder = createDecoderThatUsesExactByteArray(getU32Decoder());\n * decoder.decode(new Uint8Array([0, 0, 0, 0])); // 0\n * decoder.decode(new Uint8Array([0, 0, 0, 0, 0])); // throws\n *\n * // with an offset\n * decoder.decode(new Uint8Array([0, 0, 0, 0, 0]), 1); // 0\n * decoder.decode(new Uint8Array([0, 0, 0, 0, 0, 0]), 1); // throws\n * ```\n */\nexport function createDecoderThatConsumesEntireByteArray<T>(decoder: Decoder<T>): Decoder<T> {\n    return createDecoder({\n        ...decoder,\n        read(bytes, offset) {\n            const [value, newOffset] = decoder.read(bytes, offset);\n            if (bytes.length > newOffset) {\n                throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_DECODER_TO_CONSUME_ENTIRE_BYTE_ARRAY, {\n                    expectedLength: newOffset,\n                    numExcessBytes: bytes.length - newOffset,\n                });\n            }\n            return [value, newOffset];\n        },\n    });\n}\n","import { assertByteArrayHasEnoughBytesForCodec } from './assertions';\nimport { fixBytes } from './bytes';\nimport {\n    Codec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n    Offset,\n} from './codec';\nimport { combineCodec } from './combine-codec';\n\n/**\n * Creates a fixed-size encoder from a given encoder.\n *\n * The resulting encoder ensures that encoded values always have the specified number of bytes.\n * If the original encoded value is larger than `fixedBytes`, it is truncated.\n * If it is smaller, it is padded with trailing zeroes.\n *\n * For more details, see {@link fixCodecSize}.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @param encoder - The encoder to wrap into a fixed-size encoder.\n * @param fixedBytes - The fixed number of bytes to write.\n * @returns A `FixedSizeEncoder` that ensures a consistent output size.\n *\n * @example\n * ```ts\n * const encoder = fixEncoderSize(getUtf8Encoder(), 4);\n * encoder.encode(\"Hello\"); // 0x48656c6c (truncated)\n * encoder.encode(\"Hi\");    // 0x48690000 (padded)\n * encoder.encode(\"Hiya\");  // 0x48697961 (same length)\n * ```\n *\n * @remarks\n * If you need a full codec with both encoding and decoding, use {@link fixCodecSize}.\n *\n * @see {@link fixCodecSize}\n * @see {@link fixDecoderSize}\n */\nexport function fixEncoderSize<TFrom, TSize extends number>(\n    encoder: Encoder<TFrom>,\n    fixedBytes: TSize,\n): FixedSizeEncoder<TFrom, TSize> {\n    return createEncoder({\n        fixedSize: fixedBytes,\n        write: (value: TFrom, bytes: Uint8Array, offset: Offset) => {\n            // Here we exceptionally use the `encode` function instead of the `write`\n            // function as using the nested `write` function on a fixed-sized byte\n            // array may result in a out-of-bounds error on the nested encoder.\n            const variableByteArray = encoder.encode(value);\n            const fixedByteArray =\n                variableByteArray.length > fixedBytes ? variableByteArray.slice(0, fixedBytes) : variableByteArray;\n            bytes.set(fixedByteArray, offset);\n            return offset + fixedBytes;\n        },\n    });\n}\n\n/**\n * Creates a fixed-size decoder from a given decoder.\n *\n * The resulting decoder always reads exactly `fixedBytes` bytes from the input.\n * If the nested decoder is also fixed-size, the bytes are truncated or padded as needed.\n *\n * For more details, see {@link fixCodecSize}.\n *\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @param decoder - The decoder to wrap into a fixed-size decoder.\n * @param fixedBytes - The fixed number of bytes to read.\n * @returns A `FixedSizeDecoder` that ensures a consistent input size.\n *\n * @example\n * ```ts\n * const decoder = fixDecoderSize(getUtf8Decoder(), 4);\n * decoder.decode(new Uint8Array([72, 101, 108, 108, 111])); // \"Hell\" (truncated)\n * decoder.decode(new Uint8Array([72, 105, 0, 0]));          // \"Hi\" (zeroes ignored)\n * decoder.decode(new Uint8Array([72, 105, 121, 97]));       // \"Hiya\" (same length)\n * ```\n *\n * @remarks\n * If you need a full codec with both encoding and decoding, use {@link fixCodecSize}.\n *\n * @see {@link fixCodecSize}\n * @see {@link fixEncoderSize}\n */\nexport function fixDecoderSize<TTo, TSize extends number>(\n    decoder: Decoder<TTo>,\n    fixedBytes: TSize,\n): FixedSizeDecoder<TTo, TSize> {\n    return createDecoder({\n        fixedSize: fixedBytes,\n        read: (bytes, offset) => {\n            assertByteArrayHasEnoughBytesForCodec('fixCodecSize', fixedBytes, bytes, offset);\n            // Slice the byte array to the fixed size if necessary.\n            if (offset > 0 || bytes.length > fixedBytes) {\n                bytes = bytes.slice(offset, offset + fixedBytes);\n            }\n            // If the nested decoder is fixed-size, pad and truncate the byte array accordingly.\n            if (isFixedSize(decoder)) {\n                bytes = fixBytes(bytes, decoder.fixedSize);\n            }\n            // Decode the value using the nested decoder.\n            const [value] = decoder.read(bytes, 0);\n            return [value, offset + fixedBytes];\n        },\n    });\n}\n\n/**\n * Creates a fixed-size codec from a given codec.\n *\n * The resulting codec ensures that both encoding and decoding operate on a fixed number of bytes.\n * When encoding:\n * - If the encoded value is larger than `fixedBytes`, it is truncated.\n * - If it is smaller, it is padded with trailing zeroes.\n * - If it is exactly `fixedBytes`, it remains unchanged.\n *\n * When decoding:\n * - Exactly `fixedBytes` bytes are read from the input.\n * - If the nested decoder has a smaller fixed size, bytes are truncated or padded as necessary.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @param codec - The codec to wrap into a fixed-size codec.\n * @param fixedBytes - The fixed number of bytes to read/write.\n * @returns A `FixedSizeCodec` that ensures both encoding and decoding conform to a fixed size.\n *\n * @example\n * ```ts\n * const codec = fixCodecSize(getUtf8Codec(), 4);\n *\n * const bytes1 = codec.encode(\"Hello\"); // 0x48656c6c (truncated)\n * const value1 = codec.decode(bytes1);  // \"Hell\"\n *\n * const bytes2 = codec.encode(\"Hi\");    // 0x48690000 (padded)\n * const value2 = codec.decode(bytes2);  // \"Hi\"\n *\n * const bytes3 = codec.encode(\"Hiya\");  // 0x48697961 (same length)\n * const value3 = codec.decode(bytes3);  // \"Hiya\"\n * ```\n *\n * @remarks\n * If you only need to enforce a fixed size for encoding, use {@link fixEncoderSize}.\n * If you only need to enforce a fixed size for decoding, use {@link fixDecoderSize}.\n *\n * ```ts\n * const bytes = fixEncoderSize(getUtf8Encoder(), 4).encode(\"Hiya\");\n * const value = fixDecoderSize(getUtf8Decoder(), 4).decode(bytes);\n * ```\n *\n * @see {@link fixEncoderSize}\n * @see {@link fixDecoderSize}\n */\nexport function fixCodecSize<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: Codec<TFrom, TTo>,\n    fixedBytes: TSize,\n): FixedSizeCodec<TFrom, TTo, TSize> {\n    return combineCodec(fixEncoderSize(codec, fixedBytes), fixDecoderSize(codec, fixedBytes));\n}\n","import { assertByteArrayOffsetIsNotOutOfRange } from './assertions';\nimport { Codec, createDecoder, createEncoder, Decoder, Encoder, Offset } from './codec';\nimport { combineCodec } from './combine-codec';\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyEncoder = Encoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyDecoder = Decoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyCodec = Codec<any>;\n\n/**\n * Configuration object for modifying the offset of an encoder, decoder, or codec.\n *\n * This type defines optional functions for adjusting the **pre-offset** (before encoding/decoding)\n * and the **post-offset** (after encoding/decoding). These functions allow precise control\n * over where data is written or read within a byte array.\n *\n * @property preOffset - A function that modifies the offset before encoding or decoding.\n * @property postOffset - A function that modifies the offset after encoding or decoding.\n *\n * @example\n * Moving the pre-offset forward by 2 bytes.\n * ```ts\n * const config: OffsetConfig = {\n *     preOffset: ({ preOffset }) => preOffset + 2,\n * };\n * ```\n *\n * @example\n * Moving the post-offset forward by 2 bytes.\n * ```ts\n * const config: OffsetConfig = {\n *     postOffset: ({ postOffset }) => postOffset + 2,\n * };\n * ```\n *\n * @example\n * Using both pre-offset and post-offset together.\n * ```ts\n * const config: OffsetConfig = {\n *     preOffset: ({ preOffset }) => preOffset + 2,\n *     postOffset: ({ postOffset }) => postOffset + 4,\n * };\n * ```\n *\n * @see {@link offsetEncoder}\n * @see {@link offsetDecoder}\n * @see {@link offsetCodec}\n */\ntype OffsetConfig = {\n    postOffset?: PostOffsetFunction;\n    preOffset?: PreOffsetFunction;\n};\n\n/**\n * Scope provided to the `preOffset` and `postOffset` functions,\n * containing contextual information about the current encoding or decoding process.\n *\n * The pre-offset function modifies where encoding or decoding begins,\n * while the post-offset function modifies where the next operation continues.\n *\n * @property bytes - The entire byte array being encoded or decoded.\n * @property preOffset - The original offset before encoding or decoding starts.\n * @property wrapBytes - A helper function that wraps offsets around the byte array length.\n *\n * @example\n * Using `wrapBytes` to wrap a negative offset to the end of the byte array.\n * ```ts\n * const config: OffsetConfig = {\n *     preOffset: ({ wrapBytes }) => wrapBytes(-4), // Moves to last 4 bytes\n * };\n * ```\n *\n * @example\n * Adjusting the offset dynamically based on the byte array size.\n * ```ts\n * const config: OffsetConfig = {\n *     preOffset: ({ bytes }) => bytes.length > 10 ? 4 : 2,\n * };\n * ```\n *\n * @see {@link PreOffsetFunction}\n * @see {@link PostOffsetFunction}\n */\ntype PreOffsetFunctionScope = {\n    /** The entire byte array. */\n    bytes: ReadonlyUint8Array | Uint8Array;\n    /** The original offset prior to encode or decode. */\n    preOffset: Offset;\n    /** Wraps the offset to the byte array length. */\n    wrapBytes: (offset: Offset) => Offset;\n};\n\n/**\n * A function that modifies the pre-offset before encoding or decoding.\n *\n * This function is used to adjust the starting position before writing\n * or reading data in a byte array.\n *\n * @param scope - The current encoding or decoding context.\n * @returns The new offset at which encoding or decoding should start.\n *\n * @example\n * Skipping the first 2 bytes before writing or reading.\n * ```ts\n * const preOffset: PreOffsetFunction = ({ preOffset }) => preOffset + 2;\n * ```\n *\n * @example\n * Wrapping the offset to ensure it stays within bounds.\n * ```ts\n * const preOffset: PreOffsetFunction = ({ wrapBytes, preOffset }) => wrapBytes(preOffset + 10);\n * ```\n *\n * @see {@link OffsetConfig}\n * @see {@link PreOffsetFunctionScope}\n */\ntype PreOffsetFunction = (scope: PreOffsetFunctionScope) => Offset;\n\n/**\n * A function that modifies the post-offset after encoding or decoding.\n *\n * This function adjusts where the next encoder or decoder should start\n * after the current operation has completed.\n *\n * @param scope - The current encoding or decoding context, including the modified pre-offset\n * and the original post-offset.\n * @returns The new offset at which the next operation should begin.\n *\n * @example\n * Moving the post-offset forward by 4 bytes.\n * ```ts\n * const postOffset: PostOffsetFunction = ({ postOffset }) => postOffset + 4;\n * ```\n *\n * @example\n * Wrapping the post-offset within the byte array length.\n * ```ts\n * const postOffset: PostOffsetFunction = ({ wrapBytes, postOffset }) => wrapBytes(postOffset);\n * ```\n *\n * @example\n * Ensuring a minimum spacing of 8 bytes between values.\n * ```ts\n * const postOffset: PostOffsetFunction = ({ postOffset, newPreOffset }) =>\n *     Math.max(postOffset, newPreOffset + 8);\n * ```\n *\n * @see {@link OffsetConfig}\n * @see {@link PreOffsetFunctionScope}\n */\ntype PostOffsetFunction = (\n    scope: PreOffsetFunctionScope & {\n        /** The modified offset used to encode or decode. */\n        newPreOffset: Offset;\n        /** The original offset returned by the encoder or decoder. */\n        postOffset: Offset;\n    },\n) => Offset;\n\n/**\n * Moves the offset of a given encoder before and/or after encoding.\n *\n * This function allows an encoder to write its encoded value at a different offset\n * than the one originally provided. It supports both pre-offset adjustments\n * (before encoding) and post-offset adjustments (after encoding).\n *\n * The pre-offset function determines where encoding should start, while the\n * post-offset function adjusts where the next encoder should continue writing.\n *\n * For more details, see {@link offsetCodec}.\n *\n * @typeParam TFrom - The type of the value to encode.\n *\n * @param encoder - The encoder to adjust.\n * @param config - An object specifying how the offset should be modified.\n * @returns A new encoder with adjusted offsets.\n *\n * @example\n * Moving the pre-offset forward by 2 bytes.\n * ```ts\n * const encoder = offsetEncoder(getU32Encoder(), {\n *     preOffset: ({ preOffset }) => preOffset + 2,\n * });\n * const bytes = new Uint8Array(10);\n * encoder.write(42, bytes, 0); // Actually written at offset 2\n * ```\n *\n * @example\n * Moving the post-offset forward by 2 bytes.\n * ```ts\n * const encoder = offsetEncoder(getU32Encoder(), {\n *     postOffset: ({ postOffset }) => postOffset + 2,\n * });\n * const bytes = new Uint8Array(10);\n * const nextOffset = encoder.write(42, bytes, 0); // Next encoder starts at offset 6 instead of 4\n * ```\n *\n * @example\n * Using `wrapBytes` to ensure an offset wraps around the byte array length.\n * ```ts\n * const encoder = offsetEncoder(getU32Encoder(), {\n *     preOffset: ({ wrapBytes }) => wrapBytes(-4), // Moves offset to last 4 bytes of the array\n * });\n * const bytes = new Uint8Array(10);\n * encoder.write(42, bytes, 0); // Writes at bytes.length - 4\n * ```\n *\n * @remarks\n * If you need both encoding and decoding offsets to be adjusted, use {@link offsetCodec}.\n *\n * @see {@link offsetCodec}\n * @see {@link offsetDecoder}\n */\nexport function offsetEncoder<TEncoder extends AnyEncoder>(encoder: TEncoder, config: OffsetConfig): TEncoder {\n    return createEncoder({\n        ...encoder,\n        write: (value, bytes, preOffset) => {\n            const wrapBytes = (offset: Offset) => modulo(offset, bytes.length);\n            const newPreOffset = config.preOffset ? config.preOffset({ bytes, preOffset, wrapBytes }) : preOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetEncoder', newPreOffset, bytes.length);\n            const postOffset = encoder.write(value, bytes, newPreOffset);\n            const newPostOffset = config.postOffset\n                ? config.postOffset({ bytes, newPreOffset, postOffset, preOffset, wrapBytes })\n                : postOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetEncoder', newPostOffset, bytes.length);\n            return newPostOffset;\n        },\n    }) as TEncoder;\n}\n\n/**\n * Moves the offset of a given decoder before and/or after decoding.\n *\n * This function allows a decoder to read its input from a different offset\n * than the one originally provided. It supports both pre-offset adjustments\n * (before decoding) and post-offset adjustments (after decoding).\n *\n * The pre-offset function determines where decoding should start, while the\n * post-offset function adjusts where the next decoder should continue reading.\n *\n * For more details, see {@link offsetCodec}.\n *\n * @typeParam TTo - The type of the decoded value.\n *\n * @param decoder - The decoder to adjust.\n * @param config - An object specifying how the offset should be modified.\n * @returns A new decoder with adjusted offsets.\n *\n * @example\n * Moving the pre-offset forward by 2 bytes.\n * ```ts\n * const decoder = offsetDecoder(getU32Decoder(), {\n *     preOffset: ({ preOffset }) => preOffset + 2,\n * });\n * const bytes = new Uint8Array([0, 0, 42, 0]); // Value starts at offset 2\n * decoder.read(bytes, 0); // Actually reads from offset 2\n * ```\n *\n * @example\n * Moving the post-offset forward by 2 bytes.\n * ```ts\n * const decoder = offsetDecoder(getU32Decoder(), {\n *     postOffset: ({ postOffset }) => postOffset + 2,\n * });\n * const bytes = new Uint8Array([42, 0, 0, 0]);\n * const [value, nextOffset] = decoder.read(bytes, 0); // Next decoder starts at offset 6 instead of 4\n * ```\n *\n * @example\n * Using `wrapBytes` to read from the last 4 bytes of an array.\n * ```ts\n * const decoder = offsetDecoder(getU32Decoder(), {\n *     preOffset: ({ wrapBytes }) => wrapBytes(-4), // Moves offset to last 4 bytes of the array\n * });\n * const bytes = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 42]); // Value stored at the last 4 bytes\n * decoder.read(bytes, 0); // Reads from bytes.length - 4\n * ```\n *\n * @remarks\n * If you need both encoding and decoding offsets to be adjusted, use {@link offsetCodec}.\n *\n * @see {@link offsetCodec}\n * @see {@link offsetEncoder}\n */\nexport function offsetDecoder<TDecoder extends AnyDecoder>(decoder: TDecoder, config: OffsetConfig): TDecoder {\n    return createDecoder({\n        ...decoder,\n        read: (bytes, preOffset) => {\n            const wrapBytes = (offset: Offset) => modulo(offset, bytes.length);\n            const newPreOffset = config.preOffset ? config.preOffset({ bytes, preOffset, wrapBytes }) : preOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetDecoder', newPreOffset, bytes.length);\n            const [value, postOffset] = decoder.read(bytes, newPreOffset);\n            const newPostOffset = config.postOffset\n                ? config.postOffset({ bytes, newPreOffset, postOffset, preOffset, wrapBytes })\n                : postOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetDecoder', newPostOffset, bytes.length);\n            return [value, newPostOffset];\n        },\n    }) as TDecoder;\n}\n\n/**\n * Moves the offset of a given codec before and/or after encoding and decoding.\n *\n * This function allows a codec to encode and decode values at custom offsets\n * within a byte array. It modifies both the **pre-offset** (where encoding/decoding starts)\n * and the **post-offset** (where the next operation should continue).\n *\n * This is particularly useful when working with structured binary formats\n * that require skipping reserved bytes, inserting padding, or aligning fields at\n * specific locations.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n *\n * @param codec - The codec to adjust.\n * @param config - An object specifying how the offset should be modified.\n * @returns A new codec with adjusted offsets.\n *\n * @example\n * Moving the pre-offset forward by 2 bytes when encoding and decoding.\n * ```ts\n * const codec = offsetCodec(getU32Codec(), {\n *     preOffset: ({ preOffset }) => preOffset + 2,\n * });\n * const bytes = new Uint8Array(10);\n * codec.write(42, bytes, 0); // Actually written at offset 2\n * codec.read(bytes, 0);      // Actually read from offset 2\n * ```\n *\n * @example\n * Moving the post-offset forward by 2 bytes when encoding and decoding.\n * ```ts\n * const codec = offsetCodec(getU32Codec(), {\n *     postOffset: ({ postOffset }) => postOffset + 2,\n * });\n * const bytes = new Uint8Array(10);\n * codec.write(42, bytes, 0);\n * // Next encoding starts at offset 6 instead of 4\n * codec.read(bytes, 0);\n * // Next decoding starts at offset 6 instead of 4\n * ```\n *\n * @example\n * Using `wrapBytes` to loop around negative offsets.\n * ```ts\n * const codec = offsetCodec(getU32Codec(), {\n *     preOffset: ({ wrapBytes }) => wrapBytes(-4), // Moves offset to last 4 bytes\n * });\n * const bytes = new Uint8Array(10);\n * codec.write(42, bytes, 0); // Writes at bytes.length - 4\n * codec.read(bytes, 0); // Reads from bytes.length - 4\n * ```\n *\n * @remarks\n * If you only need to adjust offsets for encoding, use {@link offsetEncoder}.\n * If you only need to adjust offsets for decoding, use {@link offsetDecoder}.\n *\n * ```ts\n * const bytes = new Uint8Array(10);\n * offsetEncoder(getU32Encoder(), { preOffset: ({ preOffset }) => preOffset + 2 }).write(42, bytes, 0);\n * const [value] = offsetDecoder(getU32Decoder(), { preOffset: ({ preOffset }) => preOffset + 2 }).read(bytes, 0);\n * ```\n *\n * @see {@link offsetEncoder}\n * @see {@link offsetDecoder}\n */\nexport function offsetCodec<TCodec extends AnyCodec>(codec: TCodec, config: OffsetConfig): TCodec {\n    return combineCodec(offsetEncoder(codec, config), offsetDecoder(codec, config)) as TCodec;\n}\n\n/** A modulo function that handles negative dividends and zero divisors. */\nfunction modulo(dividend: number, divisor: number) {\n    if (divisor === 0) return 0;\n    return ((dividend % divisor) + divisor) % divisor;\n}\n","import { assertKeyExporterIsAvailable } from '@solana/assertions';\nimport { SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY, SolanaError } from '@solana/errors';\n\nimport { Address, getAddressDecoder, getAddressEncoder } from './address';\n\n/**\n * Given a public {@link CryptoKey}, this method will return its associated {@link Address}.\n *\n * @example\n * ```ts\n * import { getAddressFromPublicKey } from '@solana/addresses';\n *\n * const address = await getAddressFromPublicKey(publicKey);\n * ```\n */\nexport async function getAddressFromPublicKey(publicKey: CryptoKey): Promise<Address> {\n    assertKeyExporterIsAvailable();\n    if (publicKey.type !== 'public' || publicKey.algorithm.name !== 'Ed25519') {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY);\n    }\n    const publicKeyBytes = await crypto.subtle.exportKey('raw', publicKey);\n    return getAddressDecoder().decode(new Uint8Array(publicKeyBytes));\n}\n\n/**\n * Given an {@link Address}, return a {@link CryptoKey} that can be used to verify signatures.\n *\n * @example\n * ```ts\n * import { getAddressFromPublicKey } from '@solana/addresses';\n *\n * const publicKey = await getPublicKeyFromAddress(address);\n * ```\n */\nexport async function getPublicKeyFromAddress(address: Address) {\n    const addressBytes = getAddressEncoder().encode(address);\n    return await crypto.subtle.importKey('raw', addressBytes, { name: 'Ed25519' }, true /* extractable */, ['verify']);\n}\n","import { SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, SolanaError } from '@solana/errors';\n\nimport {\n    Codec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n} from './codec';\nimport { combineCodec } from './combine-codec';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyEncoder = Encoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyDecoder = Decoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyCodec = Codec<any>;\n\n/**\n * Updates the size of a given encoder.\n *\n * This function modifies the size of an encoder using a provided transformation function.\n * For fixed-size encoders, it updates the `fixedSize` property, and for variable-size\n * encoders, it adjusts the size calculation based on the encoded value.\n *\n * If the new size is negative, an error will be thrown.\n *\n * For more details, see {@link resizeCodec}.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TSize - The original fixed size of the encoded value.\n * @typeParam TNewSize - The new fixed size after resizing.\n *\n * @param encoder - The encoder whose size will be updated.\n * @param resize - A function that takes the current size and returns the new size.\n * @returns A new encoder with the updated size.\n *\n * @example\n * Increasing the size of a `u16` encoder by 2 bytes.\n * ```ts\n * const encoder = resizeEncoder(getU16Encoder(), size => size + 2);\n * encoder.encode(0xffff); // 0xffff0000 (two extra bytes added)\n * ```\n *\n * @example\n * Shrinking a `u32` encoder to only use 2 bytes.\n * ```ts\n * const encoder = resizeEncoder(getU32Encoder(), () => 2);\n * encoder.fixedSize; // 2\n * ```\n *\n * @see {@link resizeCodec}\n * @see {@link resizeDecoder}\n */\nexport function resizeEncoder<TFrom, TSize extends number, TNewSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize>,\n    resize: (size: TSize) => TNewSize,\n): FixedSizeEncoder<TFrom, TNewSize>;\nexport function resizeEncoder<TEncoder extends AnyEncoder>(\n    encoder: TEncoder,\n    resize: (size: number) => number,\n): TEncoder;\nexport function resizeEncoder<TEncoder extends AnyEncoder>(\n    encoder: TEncoder,\n    resize: (size: number) => number,\n): TEncoder {\n    if (isFixedSize(encoder)) {\n        const fixedSize = resize(encoder.fixedSize);\n        if (fixedSize < 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                bytesLength: fixedSize,\n                codecDescription: 'resizeEncoder',\n            });\n        }\n        return createEncoder({ ...encoder, fixedSize }) as TEncoder;\n    }\n    return createEncoder({\n        ...encoder,\n        getSizeFromValue: value => {\n            const newSize = resize(encoder.getSizeFromValue(value));\n            if (newSize < 0) {\n                throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                    bytesLength: newSize,\n                    codecDescription: 'resizeEncoder',\n                });\n            }\n            return newSize;\n        },\n    }) as TEncoder;\n}\n\n/**\n * Updates the size of a given decoder.\n *\n * This function modifies the size of a decoder using a provided transformation function.\n * For fixed-size decoders, it updates the `fixedSize` property to reflect the new size.\n * Variable-size decoders remain unchanged, as their size is determined dynamically.\n *\n * If the new size is negative, an error will be thrown.\n *\n * For more details, see {@link resizeCodec}.\n *\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The original fixed size of the decoded value.\n * @typeParam TNewSize - The new fixed size after resizing.\n *\n * @param decoder - The decoder whose size will be updated.\n * @param resize - A function that takes the current size and returns the new size.\n * @returns A new decoder with the updated size.\n *\n * @example\n * Expanding a `u16` decoder to read 4 bytes instead of 2.\n * ```ts\n * const decoder = resizeDecoder(getU16Decoder(), size => size + 2);\n * decoder.fixedSize; // 4\n * ```\n *\n * @example\n * Shrinking a `u32` decoder to only read 2 bytes.\n * ```ts\n * const decoder = resizeDecoder(getU32Decoder(), () => 2);\n * decoder.fixedSize; // 2\n * ```\n *\n * @see {@link resizeCodec}\n * @see {@link resizeEncoder}\n */\nexport function resizeDecoder<TFrom, TSize extends number, TNewSize extends number>(\n    decoder: FixedSizeDecoder<TFrom, TSize>,\n    resize: (size: TSize) => TNewSize,\n): FixedSizeDecoder<TFrom, TNewSize>;\nexport function resizeDecoder<TDecoder extends AnyDecoder>(\n    decoder: TDecoder,\n    resize: (size: number) => number,\n): TDecoder;\nexport function resizeDecoder<TDecoder extends AnyDecoder>(\n    decoder: TDecoder,\n    resize: (size: number) => number,\n): TDecoder {\n    if (isFixedSize(decoder)) {\n        const fixedSize = resize(decoder.fixedSize);\n        if (fixedSize < 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                bytesLength: fixedSize,\n                codecDescription: 'resizeDecoder',\n            });\n        }\n        return createDecoder({ ...decoder, fixedSize }) as TDecoder;\n    }\n    return decoder;\n}\n\n/**\n * Updates the size of a given codec.\n *\n * This function modifies the size of both the codec using a provided\n * transformation function. It is useful for adjusting the allocated byte size for\n * encoding and decoding without altering the underlying data structure.\n *\n * If the new size is negative, an error will be thrown.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The original fixed size of the encoded/decoded value (for fixed-size codecs).\n * @typeParam TNewSize - The new fixed size after resizing (for fixed-size codecs).\n *\n * @param codec - The codec whose size will be updated.\n * @param resize - A function that takes the current size and returns the new size.\n * @returns A new codec with the updated size.\n *\n * @example\n * Expanding a `u16` codec from 2 to 4 bytes.\n * ```ts\n * const codec = resizeCodec(getU16Codec(), size => size + 2);\n * const bytes = codec.encode(0xffff); // 0xffff0000 (two extra bytes added)\n * const value = codec.decode(bytes);  // 0xffff (reads original two bytes)\n * ```\n *\n * @example\n * Shrinking a `u32` codec to only use 2 bytes.\n * ```ts\n * const codec = resizeCodec(getU32Codec(), () => 2);\n * codec.fixedSize; // 2\n * ```\n *\n * @remarks\n * If you only need to resize an encoder, use {@link resizeEncoder}.\n * If you only need to resize a decoder, use {@link resizeDecoder}.\n *\n * ```ts\n * const bytes = resizeEncoder(getU32Encoder(), (size) => size + 2).encode(0xffff);\n * const value = resizeDecoder(getU32Decoder(), (size) => size + 2).decode(bytes);\n * ```\n *\n * @see {@link resizeEncoder}\n * @see {@link resizeDecoder}\n */\nexport function resizeCodec<TFrom, TTo extends TFrom, TSize extends number, TNewSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize>,\n    resize: (size: TSize) => TNewSize,\n): FixedSizeCodec<TFrom, TTo, TNewSize>;\nexport function resizeCodec<TCodec extends AnyCodec>(codec: TCodec, resize: (size: number) => number): TCodec;\nexport function resizeCodec<TCodec extends AnyCodec>(codec: TCodec, resize: (size: number) => number): TCodec {\n    return combineCodec(resizeEncoder(codec, resize), resizeDecoder(codec, resize)) as TCodec;\n}\n","import { Codec, Decoder, Encoder, Offset } from './codec';\nimport { combineCodec } from './combine-codec';\nimport { offsetDecoder, offsetEncoder } from './offset-codec';\nimport { resizeDecoder, resizeEncoder } from './resize-codec';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyEncoder = Encoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyDecoder = Decoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyCodec = Codec<any>;\n\n/**\n * Adds left padding to the given encoder, shifting the encoded value forward\n * by `offset` bytes whilst increasing the size of the encoder accordingly.\n *\n * For more details, see {@link padLeftCodec}.\n *\n * @typeParam TFrom - The type of the value to encode.\n *\n * @param encoder - The encoder to pad.\n * @param offset - The number of padding bytes to add before encoding.\n * @returns A new encoder with left padding applied.\n *\n * @example\n * ```ts\n * const encoder = padLeftEncoder(getU16Encoder(), 2);\n * const bytes = encoder.encode(0xffff); // 0x0000ffff (0xffff written at offset 2)\n * ```\n *\n * @see {@link padLeftCodec}\n * @see {@link padLeftDecoder}\n */\nexport function padLeftEncoder<TEncoder extends AnyEncoder>(encoder: TEncoder, offset: Offset): TEncoder {\n    return offsetEncoder(\n        resizeEncoder(encoder, size => size + offset),\n        { preOffset: ({ preOffset }) => preOffset + offset },\n    );\n}\n\n/**\n * Adds right padding to the given encoder, extending the encoded value by `offset`\n * bytes whilst increasing the size of the encoder accordingly.\n *\n * For more details, see {@link padRightCodec}.\n *\n * @typeParam TFrom - The type of the value to encode.\n *\n * @param encoder - The encoder to pad.\n * @param offset - The number of padding bytes to add after encoding.\n * @returns A new encoder with right padding applied.\n *\n * @example\n * ```ts\n * const encoder = padRightEncoder(getU16Encoder(), 2);\n * const bytes = encoder.encode(0xffff); // 0xffff0000 (two extra bytes added at the end)\n * ```\n *\n * @see {@link padRightCodec}\n * @see {@link padRightDecoder}\n */\nexport function padRightEncoder<TEncoder extends AnyEncoder>(encoder: TEncoder, offset: Offset): TEncoder {\n    return offsetEncoder(\n        resizeEncoder(encoder, size => size + offset),\n        { postOffset: ({ postOffset }) => postOffset + offset },\n    );\n}\n\n/**\n * Adds left padding to the given decoder, shifting the decoding position forward\n * by `offset` bytes whilst increasing the size of the decoder accordingly.\n *\n * For more details, see {@link padLeftCodec}.\n *\n * @typeParam TTo - The type of the decoded value.\n *\n * @param decoder - The decoder to pad.\n * @param offset - The number of padding bytes to skip before decoding.\n * @returns A new decoder with left padding applied.\n *\n * @example\n * ```ts\n * const decoder = padLeftDecoder(getU16Decoder(), 2);\n * const value = decoder.decode(new Uint8Array([0, 0, 0x12, 0x34])); // 0xffff (reads from offset 2)\n * ```\n *\n * @see {@link padLeftCodec}\n * @see {@link padLeftEncoder}\n */\nexport function padLeftDecoder<TDecoder extends AnyDecoder>(decoder: TDecoder, offset: Offset): TDecoder {\n    return offsetDecoder(\n        resizeDecoder(decoder, size => size + offset),\n        { preOffset: ({ preOffset }) => preOffset + offset },\n    );\n}\n\n/**\n * Adds right padding to the given decoder, extending the post-offset by `offset`\n * bytes whilst increasing the size of the decoder accordingly.\n *\n * For more details, see {@link padRightCodec}.\n *\n * @typeParam TTo - The type of the decoded value.\n *\n * @param decoder - The decoder to pad.\n * @param offset - The number of padding bytes to skip after decoding.\n * @returns A new decoder with right padding applied.\n *\n * @example\n * ```ts\n * const decoder = padRightDecoder(getU16Decoder(), 2);\n * const value = decoder.decode(new Uint8Array([0x12, 0x34, 0, 0])); // 0xffff (ignores trailing bytes)\n * ```\n *\n * @see {@link padRightCodec}\n * @see {@link padRightEncoder}\n */\nexport function padRightDecoder<TDecoder extends AnyDecoder>(decoder: TDecoder, offset: Offset): TDecoder {\n    return offsetDecoder(\n        resizeDecoder(decoder, size => size + offset),\n        { postOffset: ({ postOffset }) => postOffset + offset },\n    );\n}\n\n/**\n * Adds left padding to the given codec, shifting the encoding and decoding positions\n * forward by `offset` bytes whilst increasing the size of the codec accordingly.\n *\n * This ensures that values are read and written at a later position in the byte array,\n * while the padding bytes remain unused.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n *\n * @param codec - The codec to pad.\n * @param offset - The number of padding bytes to add before encoding and decoding.\n * @returns A new codec with left padding applied.\n *\n * @example\n * ```ts\n * const codec = padLeftCodec(getU16Codec(), 2);\n * const bytes = codec.encode(0xffff); // 0x0000ffff (0xffff written at offset 2)\n * const value = codec.decode(bytes);  // 0xffff (reads from offset 2)\n * ```\n *\n * @remarks\n * If you only need to apply padding for encoding, use {@link padLeftEncoder}.\n * If you only need to apply padding for decoding, use {@link padLeftDecoder}.\n *\n * ```ts\n * const bytes = padLeftEncoder(getU16Encoder(), 2).encode(0xffff);\n * const value = padLeftDecoder(getU16Decoder(), 2).decode(bytes);\n * ```\n *\n * @see {@link padLeftEncoder}\n * @see {@link padLeftDecoder}\n */\nexport function padLeftCodec<TCodec extends AnyCodec>(codec: TCodec, offset: Offset): TCodec {\n    return combineCodec(padLeftEncoder(codec, offset), padLeftDecoder(codec, offset)) as TCodec;\n}\n\n/**\n * Adds right padding to the given codec, extending the encoded and decoded value\n * by `offset` bytes whilst increasing the size of the codec accordingly.\n *\n * The extra bytes remain unused, ensuring that the next operation starts further\n * along the byte array.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n *\n * @param codec - The codec to pad.\n * @param offset - The number of padding bytes to add after encoding and decoding.\n * @returns A new codec with right padding applied.\n *\n * @example\n * ```ts\n * const codec = padRightCodec(getU16Codec(), 2);\n * const bytes = codec.encode(0xffff); // 0xffff0000 (two extra bytes added)\n * const value = codec.decode(bytes);  // 0xffff (ignores padding bytes)\n * ```\n *\n * @remarks\n * If you only need to apply padding for encoding, use {@link padRightEncoder}.\n * If you only need to apply padding for decoding, use {@link padRightDecoder}.\n *\n * ```ts\n * const bytes = padRightEncoder(getU16Encoder(), 2).encode(0xffff);\n * const value = padRightDecoder(getU16Decoder(), 2).decode(bytes);\n * ```\n *\n * @see {@link padRightEncoder}\n * @see {@link padRightDecoder}\n */\nexport function padRightCodec<TCodec extends AnyCodec>(codec: TCodec, offset: Offset): TCodec {\n    return combineCodec(padRightEncoder(codec, offset), padRightDecoder(codec, offset)) as TCodec;\n}\n","import {\n    assertIsFixedSize,\n    createDecoder,\n    createEncoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n} from './codec';\nimport { combineCodec } from './combine-codec';\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\nfunction copySourceToTargetInReverse(\n    source: ReadonlyUint8Array,\n    target_WILL_MUTATE: Uint8Array,\n    sourceOffset: number,\n    sourceLength: number,\n    targetOffset: number = 0,\n) {\n    while (sourceOffset < --sourceLength) {\n        const leftValue = source[sourceOffset];\n        target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceLength];\n        target_WILL_MUTATE[sourceLength + targetOffset] = leftValue;\n        sourceOffset++;\n    }\n    if (sourceOffset === sourceLength) {\n        target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceOffset];\n    }\n}\n\n/**\n * Reverses the bytes of a fixed-size encoder.\n *\n * Given a `FixedSizeEncoder`, this function returns a new `FixedSizeEncoder` that\n * reverses the bytes within the fixed-size byte array when encoding.\n *\n * This can be useful to modify endianness or for other byte-order transformations.\n *\n * For more details, see {@link reverseCodec}.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @param encoder - The fixed-size encoder to reverse.\n * @returns A new encoder that writes bytes in reverse order.\n *\n * @example\n * Encoding a `u16` value in reverse order.\n * ```ts\n * const encoder = reverseEncoder(getU16Encoder({ endian: Endian.Big }));\n * const bytes = encoder.encode(0x1234); // 0x3412 (bytes are flipped)\n * ```\n *\n * @see {@link reverseCodec}\n * @see {@link reverseDecoder}\n */\nexport function reverseEncoder<TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize>,\n): FixedSizeEncoder<TFrom, TSize> {\n    assertIsFixedSize(encoder);\n    return createEncoder({\n        ...encoder,\n        write: (value: TFrom, bytes, offset) => {\n            const newOffset = encoder.write(value, bytes, offset);\n            copySourceToTargetInReverse(\n                bytes /* source */,\n                bytes /* target_WILL_MUTATE */,\n                offset /* sourceOffset */,\n                offset + encoder.fixedSize /* sourceLength */,\n            );\n            return newOffset;\n        },\n    });\n}\n\n/**\n * Reverses the bytes of a fixed-size decoder.\n *\n * Given a `FixedSizeDecoder`, this function returns a new `FixedSizeDecoder` that\n * reverses the bytes within the fixed-size byte array before decoding.\n *\n * This can be useful to modify endianness or for other byte-order transformations.\n *\n * For more details, see {@link reverseCodec}.\n *\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the decoded value in bytes.\n *\n * @param decoder - The fixed-size decoder to reverse.\n * @returns A new decoder that reads bytes in reverse order.\n *\n * @example\n * Decoding a reversed `u16` value.\n * ```ts\n * const decoder = reverseDecoder(getU16Decoder({ endian: Endian.Big }));\n * const value = decoder.decode(new Uint8Array([0x34, 0x12])); // 0x1234 (bytes are flipped back)\n * ```\n *\n * @see {@link reverseCodec}\n * @see {@link reverseEncoder}\n */\nexport function reverseDecoder<TTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TTo, TSize>,\n): FixedSizeDecoder<TTo, TSize> {\n    assertIsFixedSize(decoder);\n    return createDecoder({\n        ...decoder,\n        read: (bytes, offset) => {\n            const reversedBytes = bytes.slice();\n            copySourceToTargetInReverse(\n                bytes /* source */,\n                reversedBytes /* target_WILL_MUTATE */,\n                offset /* sourceOffset */,\n                offset + decoder.fixedSize /* sourceLength */,\n            );\n            return decoder.read(reversedBytes, offset);\n        },\n    });\n}\n\n/**\n * Reverses the bytes of a fixed-size codec.\n *\n * Given a `FixedSizeCodec`, this function returns a new `FixedSizeCodec` that\n * reverses the bytes within the fixed-size byte array during encoding and decoding.\n *\n * This can be useful to modify endianness or for other byte-order transformations.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded/decoded value in bytes.\n *\n * @param codec - The fixed-size codec to reverse.\n * @returns A new codec that encodes and decodes bytes in reverse order.\n *\n * @example\n * Reversing a `u16` codec.\n * ```ts\n * const codec = reverseCodec(getU16Codec({ endian: Endian.Big }));\n * const bytes = codec.encode(0x1234); // 0x3412 (bytes are flipped)\n * const value = codec.decode(bytes);  // 0x1234 (bytes are flipped back)\n * ```\n *\n * @remarks\n * If you only need to reverse an encoder, use {@link reverseEncoder}.\n * If you only need to reverse a decoder, use {@link reverseDecoder}.\n *\n * ```ts\n * const bytes = reverseEncoder(getU16Encoder()).encode(0x1234);\n * const value = reverseDecoder(getU16Decoder()).decode(bytes);\n * ```\n *\n * @see {@link reverseEncoder}\n * @see {@link reverseDecoder}\n */\nexport function reverseCodec<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize>,\n): FixedSizeCodec<TFrom, TTo, TSize> {\n    return combineCodec(reverseEncoder(codec), reverseDecoder(codec));\n}\n","import {\n    Codec,\n    createCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isVariableSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from './codec';\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Transforms an encoder by mapping its input values.\n *\n * This function takes an existing `Encoder<A>` and returns an `Encoder<B>`, allowing values of type `B`\n * to be converted into values of type `A` before encoding. The transformation is applied via the `unmap` function.\n *\n * This is useful for handling type conversions, applying default values, or structuring data before encoding.\n *\n * For more details, see {@link transformCodec}.\n *\n * @typeParam TOldFrom - The original type expected by the encoder.\n * @typeParam TNewFrom - The new type that will be transformed before encoding.\n *\n * @param encoder - The encoder to transform.\n * @param unmap - A function that converts values of `TNewFrom` into `TOldFrom` before encoding.\n * @returns A new encoder that accepts `TNewFrom` values and transforms them before encoding.\n *\n * @example\n * Encoding a string by counting its characters and storing the length as a `u32`.\n * ```ts\n * const encoder = transformEncoder(getU32Encoder(), (value: string) => value.length);\n * encoder.encode(\"hello\"); // 0x05000000 (stores length 5)\n * ```\n *\n * @see {@link transformCodec}\n * @see {@link transformDecoder}\n */\nexport function transformEncoder<TOldFrom, TNewFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TOldFrom, TSize>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): FixedSizeEncoder<TNewFrom, TSize>;\nexport function transformEncoder<TOldFrom, TNewFrom>(\n    encoder: VariableSizeEncoder<TOldFrom>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): VariableSizeEncoder<TNewFrom>;\nexport function transformEncoder<TOldFrom, TNewFrom>(\n    encoder: Encoder<TOldFrom>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): Encoder<TNewFrom>;\nexport function transformEncoder<TOldFrom, TNewFrom>(\n    encoder: Encoder<TOldFrom>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): Encoder<TNewFrom> {\n    return createEncoder({\n        ...(isVariableSize(encoder)\n            ? { ...encoder, getSizeFromValue: (value: TNewFrom) => encoder.getSizeFromValue(unmap(value)) }\n            : encoder),\n        write: (value: TNewFrom, bytes, offset) => encoder.write(unmap(value), bytes, offset),\n    });\n}\n\n/**\n * Transforms a decoder by mapping its output values.\n *\n * This function takes an existing `Decoder<A>` and returns a `Decoder<B>`, allowing values of type `A`\n * to be converted into values of type `B` after decoding. The transformation is applied via the `map` function.\n *\n * This is useful for post-processing, type conversions, or enriching decoded data.\n *\n * For more details, see {@link transformCodec}.\n *\n * @typeParam TOldTo - The original type returned by the decoder.\n * @typeParam TNewTo - The new type that will be transformed after decoding.\n *\n * @param decoder - The decoder to transform.\n * @param map - A function that converts values of `TOldTo` into `TNewTo` after decoding.\n * @returns A new decoder that decodes into `TNewTo`.\n *\n * @example\n * Decoding a stored `u32` length into a string of `'x'` characters.\n * ```ts\n * const decoder = transformDecoder(getU32Decoder(), (length) => 'x'.repeat(length));\n * decoder.decode(new Uint8Array([0x05, 0x00, 0x00, 0x00])); // \"xxxxx\"\n * ```\n *\n * @see {@link transformCodec}\n * @see {@link transformEncoder}\n */\nexport function transformDecoder<TOldTo, TNewTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TOldTo, TSize>,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): FixedSizeDecoder<TNewTo, TSize>;\nexport function transformDecoder<TOldTo, TNewTo>(\n    decoder: VariableSizeDecoder<TOldTo>,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): VariableSizeDecoder<TNewTo>;\nexport function transformDecoder<TOldTo, TNewTo>(\n    decoder: Decoder<TOldTo>,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): Decoder<TNewTo>;\nexport function transformDecoder<TOldTo, TNewTo>(\n    decoder: Decoder<TOldTo>,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): Decoder<TNewTo> {\n    return createDecoder({\n        ...decoder,\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset) => {\n            const [value, newOffset] = decoder.read(bytes, offset);\n            return [map(value, bytes, offset), newOffset];\n        },\n    });\n}\n\n/**\n * Transforms a codec by mapping its input and output values.\n *\n * This function takes an existing `Codec<A, B>` and returns a `Codec<C, D>`, allowing:\n * - Values of type `C` to be transformed into `A` before encoding.\n * - Values of type `B` to be transformed into `D` after decoding.\n *\n * This is useful for adapting codecs to work with different representations, handling default values, or\n * converting between primitive and structured types.\n *\n * @typeParam TOldFrom - The original type expected by the codec.\n * @typeParam TNewFrom - The new type that will be transformed before encoding.\n * @typeParam TOldTo - The original type returned by the codec.\n * @typeParam TNewTo - The new type that will be transformed after decoding.\n *\n * @param codec - The codec to transform.\n * @param unmap - A function that converts values of `TNewFrom` into `TOldFrom` before encoding.\n * @param map - A function that converts values of `TOldTo` into `TNewTo` after decoding (optional).\n * @returns A new codec that encodes `TNewFrom` and decodes into `TNewTo`.\n *\n * @example\n * Mapping a `u32` codec to encode string lengths and decode them into `'x'` characters.\n * ```ts\n * const codec = transformCodec(\n *     getU32Codec(),\n *     (value: string) => value.length, // Encode string length\n *     (length) => 'x'.repeat(length)  // Decode length into a string of 'x's\n * );\n *\n * const bytes = codec.encode(\"hello\"); // 0x05000000 (stores length 5)\n * const value = codec.decode(bytes);   // \"xxxxx\"\n * ```\n *\n * @remarks\n * If only input transformation is needed, use {@link transformEncoder}.\n * If only output transformation is needed, use {@link transformDecoder}.\n *\n * ```ts\n * const bytes = transformEncoder(getU32Encoder(), (value: string) => value.length).encode(\"hello\");\n * const value = transformDecoder(getU32Decoder(), (length) => 'x'.repeat(length)).decode(bytes);\n * ```\n *\n * @see {@link transformEncoder}\n * @see {@link transformDecoder}\n */\nexport function transformCodec<TOldFrom, TNewFrom, TTo extends TNewFrom & TOldFrom, TSize extends number>(\n    codec: FixedSizeCodec<TOldFrom, TTo, TSize>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): FixedSizeCodec<TNewFrom, TTo, TSize>;\nexport function transformCodec<TOldFrom, TNewFrom, TTo extends TNewFrom & TOldFrom>(\n    codec: VariableSizeCodec<TOldFrom, TTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): VariableSizeCodec<TNewFrom, TTo>;\nexport function transformCodec<TOldFrom, TNewFrom, TTo extends TNewFrom & TOldFrom>(\n    codec: Codec<TOldFrom, TTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): Codec<TNewFrom, TTo>;\nexport function transformCodec<\n    TOldFrom,\n    TNewFrom,\n    TOldTo extends TOldFrom,\n    TNewTo extends TNewFrom,\n    TSize extends number,\n>(\n    codec: FixedSizeCodec<TOldFrom, TOldTo, TSize>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): FixedSizeCodec<TNewFrom, TNewTo, TSize>;\nexport function transformCodec<TOldFrom, TNewFrom, TOldTo extends TOldFrom, TNewTo extends TNewFrom>(\n    codec: VariableSizeCodec<TOldFrom, TOldTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): VariableSizeCodec<TNewFrom, TNewTo>;\nexport function transformCodec<TOldFrom, TNewFrom, TOldTo extends TOldFrom, TNewTo extends TNewFrom>(\n    codec: Codec<TOldFrom, TOldTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): Codec<TNewFrom, TNewTo>;\nexport function transformCodec<TOldFrom, TNewFrom, TOldTo extends TOldFrom, TNewTo extends TNewFrom>(\n    codec: Codec<TOldFrom, TOldTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map?: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): Codec<TNewFrom, TNewTo> {\n    return createCodec({\n        ...transformEncoder(codec, unmap),\n        read: map ? transformDecoder(codec, map).read : (codec.read as unknown as Decoder<TNewTo>['read']),\n    });\n}\n","export const ED25519_ALGORITHM_IDENTIFIER =\n    // Resist the temptation to convert this to a simple string; As of version 133.0.3, Firefox\n    // requires the object form of `AlgorithmIdentifier` and will throw a `DOMException` otherwise.\n    Object.freeze({ name: 'Ed25519' });\n","import { ReadonlyUint8Array } from '@solana/codecs-core';\nimport { SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH, SolanaError } from '@solana/errors';\n\nimport { ED25519_ALGORITHM_IDENTIFIER } from './algorithm';\n\nfunction addPkcs8Header(bytes: ReadonlyUint8Array): ReadonlyUint8Array {\n    // prettier-ignore\n    return new Uint8Array([\n        /**\n         * PKCS#8 header\n         */\n        0x30, // ASN.1 sequence tag\n        0x2e, // Length of sequence (46 more bytes)\n\n            0x02, // ASN.1 integer tag\n            0x01, // Length of integer\n                0x00, // Version number\n\n            0x30, // ASN.1 sequence tag\n            0x05, // Length of sequence\n                0x06, // ASN.1 object identifier tag\n                0x03, // Length of object identifier\n                    // Edwards curve algorithms identifier https://oid-rep.orange-labs.fr/get/1.3.101.112\n                        0x2b, // iso(1) / identified-organization(3) (The first node is multiplied by the decimal 40 and the result is added to the value of the second node)\n                        0x65, // thawte(101)\n                    // Ed25519 identifier\n                        0x70, // id-Ed25519(112)\n\n        /**\n         * Private key payload\n         */\n        0x04, // ASN.1 octet string tag\n        0x22, // String length (34 more bytes)\n\n            // Private key bytes as octet string\n            0x04, // ASN.1 octet string tag\n            0x20, // String length (32 bytes)\n\n        ...bytes\n    ]);\n}\n\n/**\n * Given a private key represented as a 32-byte `Uint8Array`, creates an Ed25519 private key for use\n * with other methods in this package that accept\n * [`CryptoKey`](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey) objects.\n *\n * @param bytes 32 bytes that represent the private key\n * @param extractable Setting this to `true` makes it possible to extract the bytes of the private\n * key using the [`crypto.subtle.exportKey()`](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/exportKey)\n * API. Defaults to `false`.\n *\n * @example\n * ```ts\n * import { createPrivateKeyFromBytes } from '@solana/keys';\n *\n * const privateKey = await createPrivateKeyFromBytes(new Uint8Array([...]));\n * const extractablePrivateKey = await createPrivateKeyFromBytes(new Uint8Array([...]), true);\n * ```\n */\nexport async function createPrivateKeyFromBytes(\n    bytes: ReadonlyUint8Array,\n    extractable: boolean = false,\n): Promise<CryptoKey> {\n    const actualLength = bytes.byteLength;\n    if (actualLength !== 32) {\n        throw new SolanaError(SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH, {\n            actualLength,\n        });\n    }\n    const privateKeyBytesPkcs8 = addPkcs8Header(bytes);\n    return await crypto.subtle.importKey('pkcs8', privateKeyBytesPkcs8, ED25519_ALGORITHM_IDENTIFIER, extractable, [\n        'sign',\n    ]);\n}\n","import { assertKeyExporterIsAvailable } from '@solana/assertions';\nimport { SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY, SolanaError } from '@solana/errors';\n\n/**\n * Given an extractable [`CryptoKey`](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey)\n * private key, gets the corresponding public key as a\n * [`CryptoKey`](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey).\n *\n * @param extractable Setting this to `true` makes it possible to extract the bytes of the public\n * key using the [`crypto.subtle.exportKey()`](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/exportKey)\n * API. Defaults to `false`.\n *\n * @example\n * ```ts\n * import { createPrivateKeyFromBytes, getPublicKeyFromPrivateKey } from '@solana/keys';\n *\n * const privateKey = await createPrivateKeyFromBytes(new Uint8Array([...]), true);\n *\n * const publicKey = await getPublicKeyFromPrivateKey(privateKey);\n * const extractablePublicKey = await getPublicKeyFromPrivateKey(privateKey, true);\n * ```\n */\nexport async function getPublicKeyFromPrivateKey(\n    privateKey: CryptoKey,\n    extractable: boolean = false,\n): Promise<CryptoKey> {\n    assertKeyExporterIsAvailable();\n\n    if (privateKey.extractable === false) {\n        throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY, { key: privateKey });\n    }\n\n    // Export private key.\n    const jwk = await crypto.subtle.exportKey('jwk', privateKey);\n\n    // Import public key.\n    return await crypto.subtle.importKey(\n        'jwk',\n        {\n            crv /* curve */: 'Ed25519',\n            ext /* extractable */: extractable,\n            key_ops /* key operations */: ['verify'],\n            kty /* key type */: 'OKP' /* octet key pair */,\n            x /* public key x-coordinate */: jwk.x,\n        },\n        'Ed25519',\n        extractable,\n        ['verify'],\n    );\n}\n","import { assertSigningCapabilityIsAvailable, assertVerificationCapabilityIsAvailable } from '@solana/assertions';\nimport { Encoder, ReadonlyUint8Array } from '@solana/codecs-core';\nimport { getBase58Encoder } from '@solana/codecs-strings';\nimport {\n    SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE,\n    SolanaError,\n} from '@solana/errors';\nimport { Brand, EncodedString } from '@solana/nominal-types';\n\nimport { ED25519_ALGORITHM_IDENTIFIER } from './algorithm';\n\n/**\n * A 64-byte Ed25519 signature as a base58-encoded string.\n */\nexport type Signature = Brand<EncodedString<string, 'base58'>, 'Signature'>;\n/**\n * A 64-byte Ed25519 signature.\n *\n * Whenever you need to verify that a particular signature is, in fact, the one that would have been\n * produced by signing some known bytes using the private key associated with some known public key,\n * use the {@link verifySignature} function in this package.\n */\nexport type SignatureBytes = Brand<Uint8Array, 'SignatureBytes'>;\n\nlet base58Encoder: Encoder<string> | undefined;\n\n/**\n * Asserts that an arbitrary string is a base58-encoded Ed25519 signature.\n *\n * Useful when you receive a string from user input or an untrusted network API that you expect to\n * represent an Ed25519 signature (eg. of a transaction).\n *\n * @example\n * ```ts\n * import { assertIsSignature } from '@solana/keys';\n *\n * // Imagine a function that asserts whether a user-supplied signature is valid or not.\n * function handleSubmit() {\n *     // We know only that what the user typed conforms to the `string` type.\n *     const signature: string = signatureInput.value;\n *     try {\n *         // If this type assertion function doesn't throw, then\n *         // Typescript will upcast `signature` to `Signature`.\n *         assertIsSignature(signature);\n *         // At this point, `signature` is a `Signature` that can be used with the RPC.\n *         const {\n *             value: [status],\n *         } = await rpc.getSignatureStatuses([signature]).send();\n *     } catch (e) {\n *         // `signature` turned out not to be a base58-encoded signature\n *     }\n * }\n * ```\n */\nexport function assertIsSignature(putativeSignature: string): asserts putativeSignature is Signature {\n    if (!base58Encoder) base58Encoder = getBase58Encoder();\n    // Fast-path; see if the input string is of an acceptable length.\n    if (\n        // Lowest value (64 bytes of zeroes)\n        putativeSignature.length < 64 ||\n        // Highest value (64 bytes of 255)\n        putativeSignature.length > 88\n    ) {\n        throw new SolanaError(SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE, {\n            actualLength: putativeSignature.length,\n        });\n    }\n    // Slow-path; actually attempt to decode the input string.\n    const bytes = base58Encoder.encode(putativeSignature);\n    assertIsSignatureBytes(bytes);\n}\n\n/**\n * Asserts that an arbitrary `ReadonlyUint8Array` is an Ed25519 signature.\n *\n * Useful when you receive a `ReadonlyUint8Array` from an external interface (like the browser wallets' `signMessage` API) that you expect to\n * represent an Ed25519 signature.\n *\n * @example\n * ```ts\n * import { assertIsSignatureBytes } from '@solana/keys';\n *\n * // Imagine a function that verifies a signature.\n * function verifySignature() {\n *     // We know only that the input conforms to the `ReadonlyUint8Array` type.\n *     const signatureBytes: ReadonlyUint8Array = signatureBytesInput;\n *     try {\n *         // If this type assertion function doesn't throw, then\n *         // Typescript will upcast `signatureBytes` to `SignatureBytes`.\n *         assertIsSignatureBytes(signatureBytes);\n *         // At this point, `signatureBytes` is a `SignatureBytes` that can be used with `verifySignature`.\n *         if (!(await verifySignature(publicKey, signatureBytes, data))) {\n *             throw new Error('The data were *not* signed by the private key associated with `publicKey`');\n *         }\n *     } catch (e) {\n *         // `signatureBytes` turned out not to be a 64-byte Ed25519 signature\n *     }\n * }\n * ```\n */\nexport function assertIsSignatureBytes(\n    putativeSignatureBytes: ReadonlyUint8Array,\n): asserts putativeSignatureBytes is SignatureBytes {\n    const numBytes = putativeSignatureBytes.byteLength;\n    if (numBytes !== 64) {\n        throw new SolanaError(SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH, {\n            actualLength: numBytes,\n        });\n    }\n}\n\n/**\n * A type guard that accepts a string as input. It will both return `true` if the string conforms to\n * the {@link Signature} type and will refine the type for use in your program.\n *\n * @example\n * ```ts\n * import { isSignature } from '@solana/keys';\n *\n * if (isSignature(signature)) {\n *     // At this point, `signature` has been refined to a\n *     // `Signature` that can be used with the RPC.\n *     const {\n *         value: [status],\n *     } = await rpc.getSignatureStatuses([signature]).send();\n *     setSignatureStatus(status);\n * } else {\n *     setError(`${signature} is not a transaction signature`);\n * }\n * ```\n */\nexport function isSignature(putativeSignature: string): putativeSignature is Signature {\n    if (!base58Encoder) base58Encoder = getBase58Encoder();\n\n    // Fast-path; see if the input string is of an acceptable length.\n    if (\n        // Lowest value (64 bytes of zeroes)\n        putativeSignature.length < 64 ||\n        // Highest value (64 bytes of 255)\n        putativeSignature.length > 88\n    ) {\n        return false;\n    }\n    // Slow-path; actually attempt to decode the input string.\n    const bytes = base58Encoder.encode(putativeSignature);\n    return isSignatureBytes(bytes);\n}\n\n/**\n * A type guard that accepts a `ReadonlyUint8Array` as input. It will both return `true` if the `ReadonlyUint8Array` conforms to\n * the {@link SignatureBytes} type and will refine the type for use in your program.\n *\n * @example\n * ```ts\n * import { isSignatureBytes } from '@solana/keys';\n *\n * if (isSignatureBytes(signatureBytes)) {\n *     // At this point, `signatureBytes` has been refined to a\n *     // `SignatureBytes` that can be used with `verifySignature`.\n *     if (!(await verifySignature(publicKey, signatureBytes, data))) {\n *         throw new Error('The data were *not* signed by the private key associated with `publicKey`');\n *     }\n * } else {\n *     setError(`${signatureBytes} is not a 64-byte Ed25519 signature`);\n * }\n * ```\n */\nexport function isSignatureBytes(putativeSignatureBytes: ReadonlyUint8Array): putativeSignatureBytes is SignatureBytes {\n    return putativeSignatureBytes.byteLength === 64;\n}\n\n/**\n * Given a private [`CryptoKey`](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey) and a\n * `Uint8Array` of bytes, this method will return the 64-byte Ed25519 signature of that data as a\n * `Uint8Array`.\n *\n * @example\n * ```ts\n * import { signBytes } from '@solana/keys';\n *\n * const data = new Uint8Array([1, 2, 3]);\n * const signature = await signBytes(privateKey, data);\n * ```\n */\nexport async function signBytes(key: CryptoKey, data: ReadonlyUint8Array): Promise<SignatureBytes> {\n    assertSigningCapabilityIsAvailable();\n    const signedData = await crypto.subtle.sign(ED25519_ALGORITHM_IDENTIFIER, key, data);\n    return new Uint8Array(signedData) as SignatureBytes;\n}\n\n/**\n * This helper combines _asserting_ that a string is an Ed25519 signature with _coercing_ it to the\n * {@link Signature} type. It's best used with untrusted input.\n *\n * @example\n * ```ts\n * import { signature } from '@solana/keys';\n *\n * const signature = signature(userSuppliedSignature);\n * const {\n *     value: [status],\n * } = await rpc.getSignatureStatuses([signature]).send();\n * ```\n */\nexport function signature(putativeSignature: string): Signature {\n    assertIsSignature(putativeSignature);\n    return putativeSignature;\n}\n\n/**\n * This helper combines _asserting_ that a `ReadonlyUint8Array` is an Ed25519 signature with _coercing_ it to the\n * {@link SignatureBytes} type. It's best used with untrusted input.\n *\n * @example\n * ```ts\n * import { signatureBytes } from '@solana/keys';\n *\n * const signature = signatureBytes(userSuppliedSignatureBytes);\n * if (!(await verifySignature(publicKey, signature, data))) {\n *     throw new Error('The data were *not* signed by the private key associated with `publicKey`');\n * }\n * ```\n */\nexport function signatureBytes(putativeSignatureBytes: ReadonlyUint8Array): SignatureBytes {\n    assertIsSignatureBytes(putativeSignatureBytes);\n    return putativeSignatureBytes;\n}\n\n/**\n * Given a public [`CryptoKey`](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey), some\n * {@link SignatureBytes}, and a `Uint8Array` of data, this method will return `true` if the\n * signature was produced by signing the data using the private key associated with the public key,\n * and `false` otherwise.\n *\n * @example\n * ```ts\n * import { verifySignature } from '@solana/keys';\n *\n * const data = new Uint8Array([1, 2, 3]);\n * if (!(await verifySignature(publicKey, signature, data))) {\n *     throw new Error('The data were *not* signed by the private key associated with `publicKey`');\n * }\n * ```\n */\nexport async function verifySignature(\n    key: CryptoKey,\n    signature: SignatureBytes,\n    data: ReadonlyUint8Array,\n): Promise<boolean> {\n    assertVerificationCapabilityIsAvailable();\n    return await crypto.subtle.verify(ED25519_ALGORITHM_IDENTIFIER, key, signature, data);\n}\n","import { assertKeyGenerationIsAvailable, assertPRNGIsAvailable } from '@solana/assertions';\nimport { ReadonlyUint8Array } from '@solana/codecs-core';\nimport {\n    SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY,\n    SolanaError,\n} from '@solana/errors';\n\nimport { ED25519_ALGORITHM_IDENTIFIER } from './algorithm';\nimport { createPrivateKeyFromBytes } from './private-key';\nimport { getPublicKeyFromPrivateKey } from './public-key';\nimport { signBytes, verifySignature } from './signatures';\n\n/**\n * Generates an Ed25519 public/private key pair for use with other methods in this package that\n * accept [`CryptoKey`](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey) objects.\n *\n * @example\n * ```ts\n * import { generateKeyPair } from '@solana/keys';\n *\n * const { privateKey, publicKey } = await generateKeyPair();\n * ```\n */\nexport async function generateKeyPair(): Promise<CryptoKeyPair> {\n    await assertKeyGenerationIsAvailable();\n    const keyPair = await crypto.subtle.generateKey(\n        /* algorithm */ ED25519_ALGORITHM_IDENTIFIER, // Native implementation status: https://github.com/WICG/webcrypto-secure-curves/issues/20\n        /* extractable */ false, // Prevents the bytes of the private key from being visible to JS.\n        /* allowed uses */ ['sign', 'verify'],\n    );\n    return keyPair;\n}\n\n/**\n * Given a 64-byte `Uint8Array` secret key, creates an Ed25519 public/private key pair for use with\n * other methods in this package that accept [`CryptoKey`](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey)\n * objects.\n *\n * @param bytes 64 bytes, the first 32 of which represent the private key and the last 32 of which\n * represent its associated public key\n * @param extractable Setting this to `true` makes it possible to extract the bytes of the private\n * key using the [`crypto.subtle.exportKey()`](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/exportKey)\n * API. Defaults to `false`.\n *\n * @example\n * ```ts\n * import fs from 'fs';\n * import { createKeyPairFromBytes } from '@solana/keys';\n *\n * // Get bytes from local keypair file.\n * const keypairFile = fs.readFileSync('~/.config/solana/id.json');\n * const keypairBytes = new Uint8Array(JSON.parse(keypairFile.toString()));\n *\n * // Create a CryptoKeyPair from the bytes.\n * const { privateKey, publicKey } = await createKeyPairFromBytes(keypairBytes);\n * ```\n */\nexport async function createKeyPairFromBytes(\n    bytes: ReadonlyUint8Array,\n    extractable: boolean = false,\n): Promise<CryptoKeyPair> {\n    assertPRNGIsAvailable();\n\n    if (bytes.byteLength !== 64) {\n        throw new SolanaError(SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH, { byteLength: bytes.byteLength });\n    }\n    const [publicKey, privateKey] = await Promise.all([\n        crypto.subtle.importKey('raw', bytes.slice(32), ED25519_ALGORITHM_IDENTIFIER, /* extractable */ true, [\n            'verify',\n        ]),\n        createPrivateKeyFromBytes(bytes.slice(0, 32), extractable),\n    ]);\n\n    // Verify the key pair\n    const randomBytes = new Uint8Array(32);\n    crypto.getRandomValues(randomBytes);\n    const signedData = await signBytes(privateKey, randomBytes);\n    const isValid = await verifySignature(publicKey, signedData, randomBytes);\n    if (!isValid) {\n        throw new SolanaError(SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY);\n    }\n\n    return { privateKey, publicKey } as CryptoKeyPair;\n}\n\n/**\n * Given a private key represented as a 32-byte `Uint8Array`, creates an Ed25519 public/private key\n * pair for use with other methods in this package that accept [`CryptoKey`](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey)\n * objects.\n *\n * @param bytes 32 bytes that represent the private key\n * @param extractable Setting this to `true` makes it possible to extract the bytes of the private\n * key using the [`crypto.subtle.exportKey()`](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/exportKey)\n * API. Defaults to `false`.\n *\n * @example\n * ```ts\n * import { createKeyPairFromPrivateKeyBytes } from '@solana/keys';\n *\n * const { privateKey, publicKey } = await createKeyPairFromPrivateKeyBytes(new Uint8Array([...]));\n * ```\n *\n * This can be useful when you have a private key but not the corresponding public key or when you\n * need to derive key pairs from seeds. For instance, the following code snippet derives a key pair\n * from the hash of a message.\n *\n * ```ts\n * import { getUtf8Encoder } from '@solana/codecs-strings';\n * import { createKeyPairFromPrivateKeyBytes } from '@solana/keys';\n *\n * const message = getUtf8Encoder().encode('Hello, World!');\n * const seed = new Uint8Array(await crypto.subtle.digest('SHA-256', message));\n *\n * const derivedKeypair = await createKeyPairFromPrivateKeyBytes(seed);\n * ```\n */\nexport async function createKeyPairFromPrivateKeyBytes(\n    bytes: ReadonlyUint8Array,\n    extractable: boolean = false,\n): Promise<CryptoKeyPair> {\n    const privateKeyPromise = createPrivateKeyFromBytes(bytes, extractable);\n\n    // Here we need the private key to be extractable in order to export\n    // it as a public key. Therefore, if the `extractable` parameter\n    // is `false`, we need to create two private keys such that:\n    //   - The extractable one is used to create the public key and\n    //   - The non-extractable one is the one we will return.\n    const [publicKey, privateKey] = await Promise.all([\n        // This nested promise makes things efficient by\n        // creating the public key in parallel with the\n        // second private key creation, if it is needed.\n        (extractable ? privateKeyPromise : createPrivateKeyFromBytes(bytes, true /* extractable */)).then(\n            async privateKey => await getPublicKeyFromPrivateKey(privateKey, true /* extractable */),\n        ),\n        privateKeyPromise,\n    ]);\n\n    return { privateKey, publicKey };\n}\n","import { SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE, SolanaError } from '@solana/errors';\n\n/**\n * Ensures that a given number falls within a specified range.\n *\n * If the number is outside the allowed range, an error is thrown.\n * This function is primarily used to validate values before encoding them in a codec.\n *\n * @param codecDescription - A string describing the codec that is performing the validation.\n * @param min - The minimum allowed value (inclusive).\n * @param max - The maximum allowed value (inclusive).\n * @param value - The number to validate.\n *\n * @throws {@link SolanaError} if the value is out of range.\n *\n * @example\n * Validating a number within range.\n * ```ts\n * assertNumberIsBetweenForCodec('u8', 0, 255, 42); // Passes\n * ```\n *\n * @example\n * Throwing an error for an out-of-range value.\n * ```ts\n * assertNumberIsBetweenForCodec('u8', 0, 255, 300); // Throws\n * ```\n */\nexport function assertNumberIsBetweenForCodec(\n    codecDescription: string,\n    min: bigint | number,\n    max: bigint | number,\n    value: bigint | number,\n) {\n    if (value < min || value > max) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE, {\n            codecDescription,\n            max,\n            min,\n            value,\n        });\n    }\n}\n","import { SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS, SolanaError } from '@solana/errors';\n\n/** Checks the number of items in an array-like structure is expected. */\nexport function assertValidNumberOfItemsForCodec(\n    codecDescription: string,\n    expected: bigint | number,\n    actual: bigint | number,\n) {\n    if (expected !== actual) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS, {\n            actual,\n            codecDescription,\n            expected,\n        });\n    }\n}\n","import { Address, assertIsAddress, getAddressDecoder, getAddressEncoder, isAddress } from '@solana/addresses';\nimport { combineCodec, createEncoder, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\nimport {\n    isSolanaError,\n    SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH,\n    SolanaError,\n} from '@solana/errors';\nimport { Brand, EncodedString } from '@solana/nominal-types';\n\nexport type Blockhash = Brand<EncodedString<string, 'base58'>, 'Blockhash'>;\n\n/**\n * A type guard that returns `true` if the input string conforms to the {@link Blockhash} type, and\n * refines its type for use in your program.\n *\n * @example\n * ```ts\n * import { isBlockhash } from '@solana/rpc-types';\n *\n * if (isBlockhash(blockhash)) {\n *     // At this point, `blockhash` has been refined to a\n *     // `Blockhash` that can be used with the RPC.\n *     const { value: isValid } = await rpc.isBlockhashValid(blockhash).send();\n *     setBlockhashIsFresh(isValid);\n * } else {\n *     setError(`${blockhash} is not a blockhash`);\n * }\n * ```\n */\nexport function isBlockhash(putativeBlockhash: string): putativeBlockhash is Blockhash {\n    return isAddress(putativeBlockhash);\n}\n\n/**\n * From time to time you might acquire a string, that you expect to validate as a blockhash, from an\n * untrusted network API or user input. Use this function to assert that such an arbitrary string is\n * a base58-encoded blockhash.\n *\n * @example\n * ```ts\n * import { assertIsBlockhash } from '@solana/rpc-types';\n *\n * // Imagine a function that determines whether a blockhash is fresh when a user submits a form.\n * function handleSubmit() {\n *     // We know only that what the user typed conforms to the `string` type.\n *     const blockhash: string = blockhashInput.value;\n *     try {\n *         // If this type assertion function doesn't throw, then\n *         // Typescript will upcast `blockhash` to `Blockhash`.\n *         assertIsBlockhash(blockhash);\n *         // At this point, `blockhash` is a `Blockhash` that can be used with the RPC.\n *         const { value: isValid } = await rpc.isBlockhashValid(blockhash).send();\n *     } catch (e) {\n *         // `blockhash` turned out not to be a base58-encoded blockhash\n *     }\n * }\n * ```\n */\nexport function assertIsBlockhash(putativeBlockhash: string): asserts putativeBlockhash is Blockhash {\n    try {\n        assertIsAddress(putativeBlockhash);\n    } catch (error) {\n        if (isSolanaError(error, SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE)) {\n            throw new SolanaError(SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE, error.context);\n        }\n        if (isSolanaError(error, SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH)) {\n            throw new SolanaError(SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH, error.context);\n        }\n        throw error;\n    }\n}\n\n/**\n * Combines _asserting_ that a string is a blockhash with _coercing_ it to the {@link Blockhash}\n * type. It's most useful with untrusted input.\n *\n * @example\n * ```ts\n * import { blockhash } from '@solana/rpc-types';\n *\n * const { value: isValid } = await rpc.isBlockhashValid(blockhash(blockhashFromUserInput)).send();\n * ```\n *\n * > [!TIP]\n * > When starting from a known-good blockhash as a string, it's more efficient to typecast it\n * rather than to use the {@link blockhash} helper, because the helper unconditionally performs\n * validation on its input.\n * >\n * > ```ts\n * > import { Blockhash } from '@solana/rpc-types';\n * >\n * > const blockhash = 'ABmPH5KDXX99u6woqFS5vfBGSNyKG42SzpvBMWWqAy48' as Blockhash;\n * > ```\n */\nexport function blockhash(putativeBlockhash: string): Blockhash {\n    assertIsBlockhash(putativeBlockhash);\n    return putativeBlockhash;\n}\n\n/**\n * Returns an encoder that you can use to encode a base58-encoded blockhash to a byte array.\n *\n * @example\n * ```ts\n * import { getBlockhashEncoder } from '@solana/rpc-types';\n *\n * const blockhash = 'ABmPH5KDXX99u6woqFS5vfBGSNyKG42SzpvBMWWqAy48' as Blockhash;\n * const blockhashEncoder = getBlockhashEncoder();\n * const blockhashBytes = blockhashEncoder.encode(blockhash);\n * // Uint8Array(32) [\n * //   136, 123,  44, 249,  43,  19,  60,  14,\n * //   144,  16, 168, 241, 121, 111,  70, 232,\n * //   186,  26, 140, 202, 213,  64, 231,  82,\n * //   179,  66, 103, 237,  52, 117, 217,  93\n * // ]\n * ```\n */\nexport function getBlockhashEncoder(): FixedSizeEncoder<Blockhash, 32> {\n    const addressEncoder = getAddressEncoder();\n    return createEncoder({\n        fixedSize: 32,\n        write: (value: string, bytes, offset) => {\n            assertIsBlockhash(value);\n            return addressEncoder.write(value as string as Address, bytes, offset);\n        },\n    });\n}\n\n/**\n * Returns a decoder that you can use to convert an array of 32 bytes representing a blockhash to\n * the base58-encoded representation of that blockhash.\n *\n * @example\n * ```ts\n * import { getBlockhashDecoder } from '@solana/rpc-types';\n *\n * const blockhashBytes = new Uint8Array([\n *     136, 123,  44, 249,  43,  19,  60,  14,\n *     144,  16, 168, 241, 121, 111,  70, 232,\n *     186,  26, 140, 202, 213,  64, 231,  82,\n *     179,  66, 103, 237,  52, 117, 217,  93\n * ]);\n * const blockhashDecoder = getBlockhashDecoder();\n * const blockhash = blockhashDecoder.decode(blockhashBytes); // ABmPH5KDXX99u6woqFS5vfBGSNyKG42SzpvBMWWqAy48\n * ```\n */\nexport function getBlockhashDecoder(): FixedSizeDecoder<Blockhash, 32> {\n    return getAddressDecoder() as FixedSizeDecoder<string, 32> as FixedSizeDecoder<Blockhash, 32>;\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to a base-58 encoded blockhash.\n *\n * @see {@link getBlockhashDecoder}\n * @see {@link getBlockhashEncoder}\n */\nexport function getBlockhashCodec(): FixedSizeCodec<Blockhash, Blockhash, 32> {\n    return combineCodec(getBlockhashEncoder(), getBlockhashDecoder());\n}\n\nexport function getBlockhashComparator(): (x: string, y: string) => number {\n    return new Intl.Collator('en', {\n        caseFirst: 'lower',\n        ignorePunctuation: false,\n        localeMatcher: 'best fit',\n        numeric: false,\n        sensitivity: 'variant',\n        usage: 'sort',\n    }).compare;\n}\n","import { isFixedSize } from '@solana/codecs-core';\n\n/**\n * Functionally, this type helper is equivalent to the identity type  i.e. `type Identity<T> = T`.\n * However, wrapping generic object mappings in this type significantly reduces the number\n * of instantiation expressions processed, which increases TypeScript performance and\n * prevents \"Type instantiation is excessively deep and possibly infinite\" errors.\n *\n * This works because TypeScript doesn't create a new level of nesting when encountering conditional generic types.\n * @see https://github.com/microsoft/TypeScript/issues/34933\n * @see https://github.com/kysely-org/kysely/pull/483\n */\nexport type DrainOuterGeneric<T> = [T] extends [unknown] ? T : never;\n\nexport function maxCodecSizes(sizes: (number | null)[]): number | null {\n    return sizes.reduce(\n        (all, size) => (all === null || size === null ? null : Math.max(all, size)),\n        0 as number | null,\n    );\n}\n\nexport function sumCodecSizes(sizes: (number | null)[]): number | null {\n    return sizes.reduce((all, size) => (all === null || size === null ? null : all + size), 0 as number | null);\n}\n\nexport function getFixedSize(codec: { fixedSize: number } | { maxSize?: number }): number | null {\n    return isFixedSize(codec) ? codec.fixedSize : null;\n}\n\nexport function getMaxSize(codec: { fixedSize: number } | { maxSize?: number }): number | null {\n    return isFixedSize(codec) ? codec.fixedSize : (codec.maxSize ?? null);\n}\n","import { Codec, Decoder, Encoder, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n/**\n * Represents an encoder for numbers and bigints.\n *\n * This type allows encoding values that are either `number` or `bigint`.\n * Depending on the specific implementation, the encoded output may have a fixed or variable size.\n *\n * @see {@link FixedSizeNumberEncoder}\n */\nexport type NumberEncoder = Encoder<bigint | number>;\n\n/**\n * Represents a fixed-size encoder for numbers and bigints.\n *\n * This encoder serializes values using an exact number of bytes, defined by `TSize`.\n *\n * @typeParam TSize - The number of bytes used for encoding.\n *\n * @see {@link NumberEncoder}\n */\nexport type FixedSizeNumberEncoder<TSize extends number = number> = FixedSizeEncoder<bigint | number, TSize>;\n\n/**\n * Represents a decoder for numbers and bigints.\n *\n * This type supports decoding values as either `number` or `bigint`, depending on the implementation.\n *\n * @see {@link FixedSizeNumberDecoder}\n */\nexport type NumberDecoder = Decoder<bigint> | Decoder<number>;\n\n/**\n * Represents a fixed-size decoder for numbers and bigints.\n *\n * This decoder reads a fixed number of bytes (`TSize`) and converts them into a `number` or `bigint`.\n *\n * @typeParam TSize - The number of bytes expected for decoding.\n *\n * @see {@link NumberDecoder}\n */\nexport type FixedSizeNumberDecoder<TSize extends number = number> =\n    | FixedSizeDecoder<bigint, TSize>\n    | FixedSizeDecoder<number, TSize>;\n\n/**\n * Represents a codec for encoding and decoding numbers and bigints.\n *\n * - The encoded value can be either a `number` or a `bigint`.\n * - The decoded value will always be either a `number` or `bigint`, depending on the implementation.\n *\n * @see {@link FixedSizeNumberCodec}\n */\nexport type NumberCodec = Codec<bigint | number, bigint> | Codec<bigint | number, number>;\n\n/**\n * Represents a fixed-size codec for encoding and decoding numbers and bigints.\n *\n * This codec uses a specific number of bytes (`TSize`) for serialization.\n * The encoded value can be either a `number` or `bigint`, but the decoded value will always be a `number` or `bigint`,\n * depending on the implementation.\n *\n * @typeParam TSize - The number of bytes used for encoding and decoding.\n *\n * @see {@link NumberCodec}\n */\nexport type FixedSizeNumberCodec<TSize extends number = number> =\n    | FixedSizeCodec<bigint | number, bigint, TSize>\n    | FixedSizeCodec<bigint | number, number, TSize>;\n\n/**\n * Configuration options for number codecs that use more than one byte.\n *\n * This configuration applies to all number codecs except `u8` and `i8`,\n * allowing the user to specify the endianness of serialization.\n */\nexport type NumberCodecConfig = {\n    /**\n     * Specifies whether numbers should be encoded in little-endian or big-endian format.\n     *\n     * @defaultValue `Endian.Little`\n     */\n    endian?: Endian;\n};\n\n/**\n * Defines the byte order used for number serialization.\n *\n * - `Little`: The least significant byte is stored first.\n * - `Big`: The most significant byte is stored first.\n */\nexport enum Endian {\n    Little,\n    Big,\n}\n","import {\n    assertByteArrayHasEnoughBytesForCodec,\n    assertByteArrayIsNotEmptyForCodec,\n    createDecoder,\n    createEncoder,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    Offset,\n    ReadonlyUint8Array,\n} from '@solana/codecs-core';\n\nimport { assertNumberIsBetweenForCodec } from './assertions';\nimport { Endian, NumberCodecConfig } from './common';\n\ntype NumberFactorySharedInput<TSize extends number> = {\n    config?: NumberCodecConfig;\n    name: string;\n    size: TSize;\n};\n\ntype NumberFactoryEncoderInput<TFrom, TSize extends number> = NumberFactorySharedInput<TSize> & {\n    range?: [bigint | number, bigint | number];\n    set: (view: DataView, value: TFrom, littleEndian?: boolean) => void;\n};\n\ntype NumberFactoryDecoderInput<TTo, TSize extends number> = NumberFactorySharedInput<TSize> & {\n    get: (view: DataView, littleEndian?: boolean) => TTo;\n};\n\nfunction isLittleEndian(config?: NumberCodecConfig): boolean {\n    return config?.endian === Endian.Big ? false : true;\n}\n\nexport function numberEncoderFactory<TFrom extends bigint | number, TSize extends number>(\n    input: NumberFactoryEncoderInput<TFrom, TSize>,\n): FixedSizeEncoder<TFrom, TSize> {\n    return createEncoder({\n        fixedSize: input.size,\n        write(value: TFrom, bytes: Uint8Array, offset: Offset): Offset {\n            if (input.range) {\n                assertNumberIsBetweenForCodec(input.name, input.range[0], input.range[1], value);\n            }\n            const arrayBuffer = new ArrayBuffer(input.size);\n            input.set(new DataView(arrayBuffer), value, isLittleEndian(input.config));\n            bytes.set(new Uint8Array(arrayBuffer), offset);\n            return offset + input.size;\n        },\n    });\n}\n\nexport function numberDecoderFactory<TTo extends bigint | number, TSize extends number>(\n    input: NumberFactoryDecoderInput<TTo, TSize>,\n): FixedSizeDecoder<TTo, TSize> {\n    return createDecoder({\n        fixedSize: input.size,\n        read(bytes, offset = 0): [TTo, number] {\n            assertByteArrayIsNotEmptyForCodec(input.name, bytes, offset);\n            assertByteArrayHasEnoughBytesForCodec(input.name, input.size, bytes, offset);\n            const view = new DataView(toArrayBuffer(bytes, offset, input.size));\n            return [input.get(view, isLittleEndian(input.config)), offset + input.size];\n        },\n    });\n}\n\n/**\n * Helper function to ensure that the ArrayBuffer is converted properly from a Uint8Array\n * Source: https://stackoverflow.com/questions/37228285/uint8array-to-arraybuffer\n */\nfunction toArrayBuffer(bytes: ReadonlyUint8Array | Uint8Array, offset?: number, length?: number): ArrayBuffer {\n    const bytesOffset = bytes.byteOffset + (offset ?? 0);\n    const bytesLength = length ?? bytes.byteLength;\n    return bytes.buffer.slice(bytesOffset, bytesOffset + bytesLength);\n}\n","import {\n    Codec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    getEncodedSize,\n    ReadonlyUint8Array,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { getU32Decoder, getU32Encoder, NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\n\nimport { assertValidNumberOfItemsForCodec } from './assertions';\nimport { getFixedSize, getMaxSize } from './utils';\n\n/**\n * Defines the possible size strategies for array-like codecs (`array`, `map`, and `set`).\n *\n * The size of the collection can be determined using one of the following approaches:\n * - A {@link NumberCodec}, {@link NumberDecoder}, or {@link NumberEncoder} to store a size prefix.\n * - A fixed `number` of items, enforcing an exact length.\n * - The string `\"remainder\"`, which infers the number of items by consuming the rest of the available bytes.\n *   This option is only available when encoding fixed-size items.\n *\n * @typeParam TPrefix - A number codec, decoder, or encoder used for size prefixing.\n */\nexport type ArrayLikeCodecSize<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> =\n    | TPrefix\n    | number\n    | 'remainder';\n\n/**\n * Defines the configuration options for array codecs.\n *\n * @typeParam TPrefix - A number codec, decoder, or encoder used for size prefixing.\n */\nexport type ArrayCodecConfig<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * Specifies how the size of the array is determined.\n     *\n     * - A {@link NumberCodec}, {@link NumberDecoder}, or {@link NumberEncoder} stores a size prefix before encoding the array.\n     * - A `number` enforces a fixed number of elements.\n     * - `\"remainder\"` uses all remaining bytes to infer the array length (only for fixed-size items).\n     *\n     * @defaultValue A `u32` size prefix.\n     */\n    size?: ArrayLikeCodecSize<TPrefix>;\n};\n\n/**\n * Returns an encoder for arrays of values.\n *\n * This encoder serializes arrays by encoding each element using the provided item encoder.\n * By default, a `u32` size prefix is included to indicate the number of items in the array.\n * The `size` option can be used to modify this behaviour.\n *\n * For more details, see {@link getArrayCodec}.\n *\n * @typeParam TFrom - The type of the elements in the array.\n *\n * @param item - The encoder for each item in the array.\n * @param config - Optional configuration for the size encoding strategy.\n * @returns A `VariableSizeEncoder<TFrom[]>` for encoding arrays.\n *\n * @example\n * Encoding an array of `u8` numbers.\n * ```ts\n * const encoder = getArrayEncoder(getU8Encoder());\n * const bytes = encoder.encode([1, 2, 3]);\n * // 0x03000000010203\n * //   |       -- 3 items of 1 byte each.\n * //   -- 4-byte prefix telling us to read 3 items.\n * ```\n *\n * @see {@link getArrayCodec}\n */\nexport function getArrayEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: ArrayCodecConfig<NumberEncoder> & { size: 0 },\n): FixedSizeEncoder<TFrom[], 0>;\nexport function getArrayEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: ArrayCodecConfig<NumberEncoder> & { size: number },\n): FixedSizeEncoder<TFrom[]>;\nexport function getArrayEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config?: ArrayCodecConfig<NumberEncoder>,\n): VariableSizeEncoder<TFrom[]>;\nexport function getArrayEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: ArrayCodecConfig<NumberEncoder> = {},\n): Encoder<TFrom[]> {\n    const size = config.size ?? getU32Encoder();\n    const fixedSize = computeArrayLikeCodecSize(size, getFixedSize(item));\n    const maxSize = computeArrayLikeCodecSize(size, getMaxSize(item)) ?? undefined;\n\n    return createEncoder({\n        ...(fixedSize !== null\n            ? { fixedSize }\n            : {\n                  getSizeFromValue: (array: TFrom[]) => {\n                      const prefixSize = typeof size === 'object' ? getEncodedSize(array.length, size) : 0;\n                      return prefixSize + [...array].reduce((all, value) => all + getEncodedSize(value, item), 0);\n                  },\n                  maxSize,\n              }),\n        write: (array: TFrom[], bytes, offset) => {\n            if (typeof size === 'number') {\n                assertValidNumberOfItemsForCodec('array', size, array.length);\n            }\n            if (typeof size === 'object') {\n                offset = size.write(array.length, bytes, offset);\n            }\n            array.forEach(value => {\n                offset = item.write(value, bytes, offset);\n            });\n            return offset;\n        },\n    });\n}\n\n/**\n * Returns a decoder for arrays of values.\n *\n * This decoder deserializes arrays by decoding each element using the provided item decoder.\n * By default, a `u32` size prefix is expected to indicate the number of items in the array.\n * The `size` option can be used to modify this behaviour.\n *\n * For more details, see {@link getArrayCodec}.\n *\n * @typeParam TTo - The type of the decoded elements in the array.\n *\n * @param item - The decoder for each item in the array.\n * @param config - Optional configuration for the size decoding strategy.\n * @returns A `VariableSizeDecoder<TTo[]>` for decoding arrays.\n *\n * @example\n * Decoding an array of `u8` numbers.\n * ```ts\n * const decoder = getArrayDecoder(getU8Decoder());\n * const array = decoder.decode(new Uint8Array([0x03, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03]));\n * // [1, 2, 3]\n * // 0x03000000010203\n * //   |       -- 3 items of 1 byte each.\n * //   -- 4-byte prefix telling us to read 3 items.\n * ```\n *\n * @see {@link getArrayCodec}\n */\nexport function getArrayDecoder<TTo>(\n    item: Decoder<TTo>,\n    config: ArrayCodecConfig<NumberDecoder> & { size: 0 },\n): FixedSizeDecoder<TTo[], 0>;\nexport function getArrayDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: ArrayCodecConfig<NumberDecoder> & { size: number },\n): FixedSizeDecoder<TTo[]>;\nexport function getArrayDecoder<TTo>(\n    item: Decoder<TTo>,\n    config?: ArrayCodecConfig<NumberDecoder>,\n): VariableSizeDecoder<TTo[]>;\nexport function getArrayDecoder<TTo>(item: Decoder<TTo>, config: ArrayCodecConfig<NumberDecoder> = {}): Decoder<TTo[]> {\n    const size = config.size ?? getU32Decoder();\n    const itemSize = getFixedSize(item);\n    const fixedSize = computeArrayLikeCodecSize(size, itemSize);\n    const maxSize = computeArrayLikeCodecSize(size, getMaxSize(item)) ?? undefined;\n\n    return createDecoder({\n        ...(fixedSize !== null ? { fixedSize } : { maxSize }),\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset) => {\n            const array: TTo[] = [];\n            if (typeof size === 'object' && bytes.slice(offset).length === 0) {\n                return [array, offset];\n            }\n\n            if (size === 'remainder') {\n                while (offset < bytes.length) {\n                    const [value, newOffset] = item.read(bytes, offset);\n                    offset = newOffset;\n                    array.push(value);\n                }\n                return [array, offset];\n            }\n\n            const [resolvedSize, newOffset] = typeof size === 'number' ? [size, offset] : size.read(bytes, offset);\n            offset = newOffset;\n            for (let i = 0; i < resolvedSize; i += 1) {\n                const [value, newOffset] = item.read(bytes, offset);\n                offset = newOffset;\n                array.push(value);\n            }\n            return [array, offset];\n        },\n    });\n}\n\n/**\n * Returns a codec for encoding and decoding arrays of values.\n *\n * This codec serializes arrays by encoding each element using the provided item codec.\n * By default, a `u32` size prefix is included to indicate the number of items in the array.\n * The `size` option can be used to modify this behaviour.\n *\n * @typeParam TFrom - The type of the elements to encode.\n * @typeParam TTo - The type of the decoded elements.\n *\n * @param item - The codec for each item in the array.\n * @param config - Optional configuration for the size encoding/decoding strategy.\n * @returns A `VariableSizeCodec<TFrom[], TTo[]>` for encoding and decoding arrays.\n *\n * @example\n * Encoding and decoding an array of `u8` numbers.\n * ```ts\n * const codec = getArrayCodec(getU8Codec());\n * const bytes = codec.encode([1, 2, 3]);\n * // 0x03000000010203\n * //   |       -- 3 items of 1 byte each.\n * //   -- 4-byte prefix telling us to read 3 items.\n *\n * const array = codec.decode(bytes);\n * // [1, 2, 3]\n * ```\n *\n * @example\n * Using a `u16` size prefix instead of `u32`.\n * ```ts\n * const codec = getArrayCodec(getU8Codec(), { size: getU16Codec() });\n * const bytes = codec.encode([1, 2, 3]);\n * // 0x0300010203\n * //   |   -- 3 items of 1 byte each.\n * //   -- 2-byte prefix telling us to read 3 items.\n * ```\n *\n * @example\n * Using a fixed-size array of 3 items.\n * ```ts\n * const codec = getArrayCodec(getU8Codec(), { size: 3 });\n * codec.encode([1, 2, 3]);\n * // 0x010203\n * //   -- 3 items of 1 byte each. There must always be 3 items in the array.\n * ```\n *\n * @example\n * Using the `\"remainder\"` size strategy.\n * ```ts\n * const codec = getArrayCodec(getU8Codec(), { size: 'remainder' });\n * codec.encode([1, 2, 3]);\n * // 0x010203\n * //   -- 3 items of 1 byte each. The size is inferred from the remainder of the bytes.\n * ```\n *\n * @remarks\n * The size of the array can be controlled using the `size` option:\n * - A `Codec<number>` (e.g. `getU16Codec()`) stores a size prefix before the array.\n * - A `number` enforces a fixed number of elements.\n * - `\"remainder\"` uses all remaining bytes to infer the array length.\n *\n * Separate {@link getArrayEncoder} and {@link getArrayDecoder} functions are available.\n *\n * ```ts\n * const bytes = getArrayEncoder(getU8Encoder()).encode([1, 2, 3]);\n * const array = getArrayDecoder(getU8Decoder()).decode(bytes);\n * ```\n *\n * @see {@link getArrayEncoder}\n * @see {@link getArrayDecoder}\n */\nexport function getArrayCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: ArrayCodecConfig<NumberCodec> & { size: 0 },\n): FixedSizeCodec<TFrom[], TTo[], 0>;\nexport function getArrayCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: ArrayCodecConfig<NumberCodec> & { size: number },\n): FixedSizeCodec<TFrom[], TTo[]>;\nexport function getArrayCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config?: ArrayCodecConfig<NumberCodec>,\n): VariableSizeCodec<TFrom[], TTo[]>;\nexport function getArrayCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: ArrayCodecConfig<NumberCodec> = {},\n): Codec<TFrom[], TTo[]> {\n    return combineCodec(getArrayEncoder(item, config as object), getArrayDecoder(item, config as object));\n}\n\nfunction computeArrayLikeCodecSize(size: number | object | 'remainder', itemSize: number | null): number | null {\n    if (typeof size !== 'number') return null;\n    if (size === 0) return 0;\n    return itemSize === null ? null : itemSize * size;\n}\n","export type MainnetUrl = string & { '~cluster': 'mainnet' };\nexport type DevnetUrl = string & { '~cluster': 'devnet' };\nexport type TestnetUrl = string & { '~cluster': 'testnet' };\nexport type ClusterUrl = DevnetUrl | MainnetUrl | TestnetUrl | string;\n\n/** Given a URL casts it to a type that is only accepted where mainnet URLs are expected. */\nexport function mainnet(putativeString: string): MainnetUrl {\n    return putativeString as MainnetUrl;\n}\n/** Given a URL casts it to a type that is only accepted where devnet URLs are expected. */\nexport function devnet(putativeString: string): DevnetUrl {\n    return putativeString as DevnetUrl;\n}\n/** Given a URL casts it to a type that is only accepted where testnet URLs are expected. */\nexport function testnet(putativeString: string): TestnetUrl {\n    return putativeString as TestnetUrl;\n}\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 32-bit floating-point numbers (`f32`).\n *\n * This encoder serializes `f32` values using 4 bytes.\n * Floating-point values may lose precision when encoded.\n *\n * For more details, see {@link getF32Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeEncoder<number, 4>` for encoding `f32` values.\n *\n * @example\n * Encoding an `f32` value.\n * ```ts\n * const encoder = getF32Encoder();\n * const bytes = encoder.encode(-1.5); // 0x0000c0bf\n * ```\n *\n * @see {@link getF32Codec}\n */\nexport const getF32Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 4> =>\n    numberEncoderFactory({\n        config,\n        name: 'f32',\n        set: (view, value, le) => view.setFloat32(0, Number(value), le),\n        size: 4,\n    });\n\n/**\n * Returns a decoder for 32-bit floating-point numbers (`f32`).\n *\n * This decoder deserializes `f32` values from 4 bytes.\n * Some precision may be lost during decoding due to floating-point representation.\n *\n * For more details, see {@link getF32Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeDecoder<number, 4>` for decoding `f32` values.\n *\n * @example\n * Decoding an `f32` value.\n * ```ts\n * const decoder = getF32Decoder();\n * const value = decoder.decode(new Uint8Array([0x00, 0x00, 0xc0, 0xbf])); // -1.5\n * ```\n *\n * @see {@link getF32Codec}\n */\nexport const getF32Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 4> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getFloat32(0, le),\n        name: 'f32',\n        size: 4,\n    });\n\n/**\n * Returns a codec for encoding and decoding 32-bit floating-point numbers (`f32`).\n *\n * This codec serializes `f32` values using 4 bytes.\n * Due to the IEEE 754 floating-point representation, some precision loss may occur.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number, number, 4>` for encoding and decoding `f32` values.\n *\n * @example\n * Encoding and decoding an `f32` value.\n * ```ts\n * const codec = getF32Codec();\n * const bytes = codec.encode(-1.5); // 0x0000c0bf\n * const value = codec.decode(bytes); // -1.5\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getF32Codec({ endian: Endian.Big });\n * const bytes = codec.encode(-1.5); // 0xbfc00000\n * ```\n *\n * @remarks\n * `f32` values follow the IEEE 754 single-precision floating-point standard.\n * Precision loss may occur for certain values.\n *\n * - If you need higher precision, consider using {@link getF64Codec}.\n * - If you need integer values, consider using {@link getI32Codec} or {@link getU32Codec}.\n *\n * Separate {@link getF32Encoder} and {@link getF32Decoder} functions are available.\n *\n * ```ts\n * const bytes = getF32Encoder().encode(-1.5);\n * const value = getF32Decoder().decode(bytes);\n * ```\n *\n * @see {@link getF32Encoder}\n * @see {@link getF32Decoder}\n */\nexport const getF32Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 4> =>\n    combineCodec(getF32Encoder(config), getF32Decoder(config));\n","import { SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE, SolanaError } from '@solana/errors';\n\n/**\n * A union of all possible commitment statuses -- each a measure of the network confirmation and\n * stake levels on a particular block.\n *\n * Read more about the statuses themselves, [here](https://docs.solana.com/cluster/commitments).\n */\nexport type Commitment = 'confirmed' | 'finalized' | 'processed';\n\nfunction getCommitmentScore(commitment: Commitment): number {\n    switch (commitment) {\n        case 'finalized':\n            return 2;\n        case 'confirmed':\n            return 1;\n        case 'processed':\n            return 0;\n        default:\n            throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE, {\n                unexpectedValue: commitment satisfies never,\n            });\n    }\n}\n\nexport function commitmentComparator(a: Commitment, b: Commitment): -1 | 0 | 1 {\n    if (a === b) {\n        return 0;\n    }\n    return getCommitmentScore(a) < getCommitmentScore(b) ? -1 : 1;\n}\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 64-bit floating-point numbers (`f64`).\n *\n * This encoder serializes `f64` values using 8 bytes.\n * Floating-point values may lose precision when encoded.\n *\n * For more details, see {@link getF64Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeEncoder<number, 8>` for encoding `f64` values.\n *\n * @example\n * Encoding an `f64` value.\n * ```ts\n * const encoder = getF64Encoder();\n * const bytes = encoder.encode(-1.5); // 0x000000000000f8bf\n * ```\n *\n * @see {@link getF64Codec}\n */\nexport const getF64Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 8> =>\n    numberEncoderFactory({\n        config,\n        name: 'f64',\n        set: (view, value, le) => view.setFloat64(0, Number(value), le),\n        size: 8,\n    });\n\n/**\n * Returns a decoder for 64-bit floating-point numbers (`f64`).\n *\n * This decoder deserializes `f64` values from 8 bytes.\n * Some precision may be lost during decoding due to floating-point representation.\n *\n * For more details, see {@link getF64Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeDecoder<number, 8>` for decoding `f64` values.\n *\n * @example\n * Decoding an `f64` value.\n * ```ts\n * const decoder = getF64Decoder();\n * const value = decoder.decode(new Uint8Array([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xbf])); // -1.5\n * ```\n *\n * @see {@link getF64Codec}\n */\nexport const getF64Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 8> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getFloat64(0, le),\n        name: 'f64',\n        size: 8,\n    });\n\n/**\n * Returns a codec for encoding and decoding 64-bit floating-point numbers (`f64`).\n *\n * This codec serializes `f64` values using 8 bytes.\n * Due to the IEEE 754 floating-point representation, some precision loss may occur.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number, number, 8>` for encoding and decoding `f64` values.\n *\n * @example\n * Encoding and decoding an `f64` value.\n * ```ts\n * const codec = getF64Codec();\n * const bytes = codec.encode(-1.5); // 0x000000000000f8bf\n * const value = codec.decode(bytes); // -1.5\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getF64Codec({ endian: Endian.Big });\n * const bytes = codec.encode(-1.5); // 0xbff8000000000000\n * ```\n *\n * @remarks\n * `f64` values follow the IEEE 754 double-precision floating-point standard.\n * Precision loss may still occur but is significantly lower than `f32`.\n *\n * - If you need smaller floating-point values, consider using {@link getF32Codec}.\n * - If you need integer values, consider using {@link getI64Codec} or {@link getU64Codec}.\n *\n * Separate {@link getF64Encoder} and {@link getF64Decoder} functions are available.\n *\n * ```ts\n * const bytes = getF64Encoder().encode(-1.5);\n * const value = getF64Decoder().decode(bytes);\n * ```\n *\n * @see {@link getF64Encoder}\n * @see {@link getF64Decoder}\n */\nexport const getF64Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 8> =>\n    combineCodec(getF64Encoder(config), getF64Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 128-bit signed integers (`i128`).\n *\n * This encoder serializes `i128` values using 16 bytes.\n * Values can be provided as either `number` or `bigint`.\n *\n * For more details, see {@link getI128Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeEncoder<number | bigint, 16>` for encoding `i128` values.\n *\n * @example\n * Encoding an `i128` value.\n * ```ts\n * const encoder = getI128Encoder();\n * const bytes = encoder.encode(-42n); // 0xd6ffffffffffffffffffffffffffffff\n * ```\n *\n * @see {@link getI128Codec}\n */\nexport const getI128Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 16> =>\n    numberEncoderFactory({\n        config,\n        name: 'i128',\n        range: [-BigInt('0x7fffffffffffffffffffffffffffffff') - 1n, BigInt('0x7fffffffffffffffffffffffffffffff')],\n        set: (view, value, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const rightMask = 0xffffffffffffffffn;\n            view.setBigInt64(leftOffset, BigInt(value) >> 64n, le);\n            view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);\n        },\n        size: 16,\n    });\n\n/**\n * Returns a decoder for 128-bit signed integers (`i128`).\n *\n * This decoder deserializes `i128` values from 16 bytes.\n * The decoded value is always a `bigint`.\n *\n * For more details, see {@link getI128Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeDecoder<bigint, 16>` for decoding `i128` values.\n *\n * @example\n * Decoding an `i128` value.\n * ```ts\n * const decoder = getI128Decoder();\n * const value = decoder.decode(new Uint8Array([\n *   0xd6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n *   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff\n * ])); // -42n\n * ```\n *\n * @see {@link getI128Codec}\n */\nexport const getI128Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<bigint, 16> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const left = view.getBigInt64(leftOffset, le);\n            const right = view.getBigUint64(rightOffset, le);\n            return (left << 64n) + right;\n        },\n        name: 'i128',\n        size: 16,\n    });\n\n/**\n * Returns a codec for encoding and decoding 128-bit signed integers (`i128`).\n *\n * This codec serializes `i128` values using 16 bytes.\n * Values can be provided as either `number` or `bigint`, but the decoded value is always a `bigint`.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number | bigint, bigint, 16>` for encoding and decoding `i128` values.\n *\n * @example\n * Encoding and decoding an `i128` value.\n * ```ts\n * const codec = getI128Codec();\n * const bytes = codec.encode(-42n); // 0xd6ffffffffffffffffffffffffffffff\n * const value = codec.decode(bytes); // -42n\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getI128Codec({ endian: Endian.Big });\n * const bytes = codec.encode(-42n); // 0xffffffffffffffffffffffffffffd6\n * ```\n *\n * @remarks\n * This codec supports values between `-2^127` and `2^127 - 1`.\n * Since JavaScript `number` cannot safely represent values beyond `2^53 - 1`, the decoded value is always a `bigint`.\n *\n * - If you need a smaller signed integer, consider using {@link getI64Codec} or {@link getI32Codec}.\n * - If you need a larger signed integer, consider using a custom codec.\n * - If you need unsigned integers, consider using {@link getU128Codec}.\n *\n * Separate {@link getI128Encoder} and {@link getI128Decoder} functions are available.\n *\n * ```ts\n * const bytes = getI128Encoder().encode(-42);\n * const value = getI128Decoder().decode(bytes);\n * ```\n *\n * @see {@link getI128Encoder}\n * @see {@link getI128Decoder}\n */\nexport const getI128Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, bigint, 16> =>\n    combineCodec(getI128Encoder(config), getI128Decoder(config));\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n} from '@solana/codecs-core';\nimport { getU64Decoder, getU64Encoder, NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\nimport { SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE, SolanaError } from '@solana/errors';\nimport { Brand } from '@solana/nominal-types';\n\n/**\n * Represents an integer value denominated in Lamports (ie. $1 \\times 10^{-9}$ ).\n *\n * It is represented as a `bigint` in client code and an `u64` in server code.\n */\nexport type Lamports = Brand<bigint, 'Lamports'>;\n\n// Largest possible value to be represented by a u64\nconst maxU64Value = 18446744073709551615n; // 2n ** 64n - 1n\n\nlet memoizedU64Encoder: FixedSizeEncoder<bigint | number, 8> | undefined;\nlet memoizedU64Decoder: FixedSizeDecoder<bigint, 8> | undefined;\n\nfunction getMemoizedU64Encoder(): FixedSizeEncoder<bigint | number, 8> {\n    if (!memoizedU64Encoder) memoizedU64Encoder = getU64Encoder();\n    return memoizedU64Encoder;\n}\n\nfunction getMemoizedU64Decoder(): FixedSizeDecoder<bigint, 8> {\n    if (!memoizedU64Decoder) memoizedU64Decoder = getU64Decoder();\n    return memoizedU64Decoder;\n}\n\n/**\n * This is a type guard that accepts a `bigint` as input. It will both return `true` if the integer\n * conforms to the {@link Lamports} type and will refine the type for use in your program.\n *\n * @example\n * ```ts\n * import { isLamports } from '@solana/rpc-types';\n *\n * if (isLamports(lamports)) {\n *     // At this point, `lamports` has been refined to a\n *     // `Lamports` that can be used anywhere Lamports are expected.\n *     await transfer(fromAddress, toAddress, lamports);\n * } else {\n *     setError(`${lamports} is not a quantity of Lamports`);\n * }\n * ```\n */\nexport function isLamports(putativeLamports: bigint): putativeLamports is Lamports {\n    return putativeLamports >= 0 && putativeLamports <= maxU64Value;\n}\n\n/**\n * Lamport values returned from the RPC API conform to the type {@link Lamports}. You can use a\n * value of that type wherever a quantity of Lamports is expected.\n *\n * @example\n * From time to time you might acquire a number that you expect to be a quantity of Lamports, from\n * an untrusted network API or user input. To assert that such an arbitrary number is usable as a\n * quantity of Lamports, use this function.\n *\n * ```ts\n * import { assertIsLamports } from '@solana/rpc-types';\n *\n * // Imagine a function that creates a transfer instruction when a user submits a form.\n * function handleSubmit() {\n *     // We know only that what the user typed conforms to the `number` type.\n *     const lamports: number = parseInt(quantityInput.value, 10);\n *     try {\n *         // If this type assertion function doesn't throw, then\n *         // Typescript will upcast `lamports` to `Lamports`.\n *         assertIsLamports(lamports);\n *         // At this point, `lamports` is a `Lamports` that can be used anywhere Lamports are expected.\n *         await transfer(fromAddress, toAddress, lamports);\n *     } catch (e) {\n *         // `lamports` turned out not to validate as a quantity of Lamports.\n *     }\n * }\n * ```\n */\nexport function assertIsLamports(putativeLamports: bigint): asserts putativeLamports is Lamports {\n    if (putativeLamports < 0 || putativeLamports > maxU64Value) {\n        throw new SolanaError(SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE);\n    }\n}\n\n/**\n * This helper combines _asserting_ that a number is a possible number of {@link Lamports} with\n * _coercing_ it to the {@link Lamports} type. It's best used with untrusted input.\n *\n * @example\n * ```ts\n * import { lamports } from '@solana/rpc-types';\n *\n * await transfer(address(fromAddress), address(toAddress), lamports(100000n));\n * ```\n */\nexport function lamports(putativeLamports: bigint): Lamports {\n    assertIsLamports(putativeLamports);\n    return putativeLamports;\n}\n\ntype ExtractAdditionalProps<T, U> = Omit<T, keyof U>;\n\n/**\n * Returns an encoder that you can use to encode a 64-bit {@link Lamports} value to 8 bytes in\n * little endian order.\n */\nexport function getDefaultLamportsEncoder(): FixedSizeEncoder<Lamports, 8> {\n    return getLamportsEncoder(getMemoizedU64Encoder());\n}\n\n/**\n * Returns an encoder that you can use to encode a {@link Lamports} value to a byte array.\n *\n * You must supply a number decoder that will determine how encode the numeric value.\n *\n * @example\n * ```ts\n * import { getLamportsEncoder } from '@solana/rpc-types';\n * import { getU16Encoder } from '@solana/codecs-numbers';\n *\n * const lamports = lamports(256n);\n * const lamportsEncoder = getLamportsEncoder(getU16Encoder());\n * const lamportsBytes = lamportsEncoder.encode(lamports);\n * // Uint8Array(2) [ 0, 1 ]\n * ```\n */\nexport function getLamportsEncoder<TEncoder extends NumberEncoder>(\n    innerEncoder: TEncoder,\n): Encoder<Lamports> & ExtractAdditionalProps<TEncoder, NumberEncoder> {\n    return innerEncoder;\n}\n\n/**\n * Returns a decoder that you can use to decode a byte array representing a 64-bit little endian\n * number to a {@link Lamports} value.\n */\nexport function getDefaultLamportsDecoder(): FixedSizeDecoder<Lamports, 8> {\n    return getLamportsDecoder(getMemoizedU64Decoder());\n}\n\n/**\n * Returns a decoder that you can use to convert an array of bytes representing a number to a\n * {@link Lamports} value.\n *\n * You must supply a number decoder that will determine how many bits to use to decode the numeric\n * value.\n *\n * @example\n * ```ts\n * import { getLamportsDecoder } from '@solana/rpc-types';\n * import { getU16Decoder } from '@solana/codecs-numbers';\n *\n * const lamportsBytes = new Uint8Array([ 0, 1 ]);\n * const lamportsDecoder = getLamportsDecoder(getU16Decoder());\n * const lamports = lamportsDecoder.decode(lamportsBytes); // lamports(256n)\n * ```\n */\nexport function getLamportsDecoder<TDecoder extends NumberDecoder>(\n    innerDecoder: TDecoder,\n): Decoder<Lamports> & ExtractAdditionalProps<TDecoder, NumberDecoder> {\n    return transformDecoder<bigint | number, Lamports>(innerDecoder, value =>\n        lamports(typeof value === 'bigint' ? value : BigInt(value)),\n    ) as Decoder<Lamports> & ExtractAdditionalProps<TDecoder, NumberDecoder>;\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to a 64-bit {@link Lamports} value.\n *\n * @see {@link getDefaultLamportsDecoder}\n * @see {@link getDefaultLamportsEncoder}\n */\nexport function getDefaultLamportsCodec(): FixedSizeCodec<Lamports, Lamports, 8> {\n    return combineCodec(getDefaultLamportsEncoder(), getDefaultLamportsDecoder());\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to {@link Lamports} value.\n *\n * @see {@link getLamportsDecoder}\n * @see {@link getLamportsEncoder}\n */\nexport function getLamportsCodec<TCodec extends NumberCodec>(\n    innerCodec: TCodec,\n): Codec<Lamports, Lamports> & ExtractAdditionalProps<TCodec, NumberCodec> {\n    return combineCodec(getLamportsEncoder(innerCodec), getLamportsDecoder(innerCodec)) as Codec<Lamports, Lamports> &\n        ExtractAdditionalProps<TCodec, NumberCodec>;\n}\n","import {\n    assertByteArrayHasEnoughBytesForCodec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n} from '@solana/codecs-core';\n\n/**\n * Defines the configuration options for bit array codecs.\n *\n * A bit array codec encodes an array of booleans into bits, packing them into bytes.\n * This configuration allows adjusting the bit ordering.\n *\n * @see {@link getBitArrayEncoder}\n * @see {@link getBitArrayDecoder}\n * @see {@link getBitArrayCodec}\n */\nexport type BitArrayCodecConfig = {\n    /**\n     * Determines whether the bits should be read in reverse order.\n     *\n     * - `false` (default): The first boolean is stored in the most significant bit (MSB-first).\n     * - `true`: The first boolean is stored in the least significant bit (LSB-first).\n     *\n     * @defaultValue `false`\n     */\n    backward?: boolean;\n};\n\n/**\n * Returns an encoder that packs an array of booleans into bits.\n *\n * This encoder converts a list of `boolean` values into a compact bit representation,\n * storing 8 booleans per byte.\n *\n * The `backward` config option determines whether the bits are stored in MSB-first (`false`)\n * or LSB-first (`true`).\n *\n * For more details, see {@link getBitArrayCodec}.\n *\n * @typeParam TSize - The number of bytes used to store the bit array.\n *\n * @param size - The number of bytes allocated for the bit array (must be sufficient for the expected boolean count).\n * @param config - Configuration options for encoding the bit array.\n * @returns A `FixedSizeEncoder<boolean[], TSize>` for encoding bit arrays.\n *\n * @example\n * Encoding a bit array.\n * ```ts\n * const encoder = getBitArrayEncoder(1);\n *\n * encoder.encode([true, false, true, false, false, false, false, false]);\n * // 0xa0 (0b10100000)\n * ```\n *\n * @see {@link getBitArrayCodec}\n */\nexport function getBitArrayEncoder<TSize extends number>(\n    size: TSize,\n    config: BitArrayCodecConfig | boolean = {},\n): FixedSizeEncoder<boolean[], TSize> {\n    const parsedConfig: BitArrayCodecConfig = typeof config === 'boolean' ? { backward: config } : config;\n    const backward = parsedConfig.backward ?? false;\n    return createEncoder({\n        fixedSize: size,\n        write(value: boolean[], bytes, offset) {\n            const bytesToAdd: number[] = [];\n\n            for (let i = 0; i < size; i += 1) {\n                let byte = 0;\n                for (let j = 0; j < 8; j += 1) {\n                    const feature = Number(value[i * 8 + j] ?? 0);\n                    byte |= feature << (backward ? j : 7 - j);\n                }\n                if (backward) {\n                    bytesToAdd.unshift(byte);\n                } else {\n                    bytesToAdd.push(byte);\n                }\n            }\n\n            bytes.set(bytesToAdd, offset);\n            return size;\n        },\n    });\n}\n\n/**\n * Returns a decoder that unpacks bits into an array of booleans.\n *\n * This decoder converts a compact bit representation back into a list of `boolean` values.\n * Each byte is expanded into 8 booleans.\n *\n * The `backward` config option determines whether the bits are read in MSB-first (`false`)\n * or LSB-first (`true`).\n *\n * For more details, see {@link getBitArrayCodec}.\n *\n * @typeParam TSize - The number of bytes used to store the bit array.\n *\n * @param size - The number of bytes allocated for the bit array (must be sufficient for the expected boolean count).\n * @param config - Configuration options for decoding the bit array.\n * @returns A `FixedSizeDecoder<boolean[], TSize>` for decoding bit arrays.\n *\n * @example\n * Decoding a bit array.\n * ```ts\n * const decoder = getBitArrayDecoder(1);\n *\n * decoder.decode(new Uint8Array([0xa0]));\n * // [true, false, true, false, false, false, false, false]\n * ```\n *\n * @see {@link getBitArrayCodec}\n */\nexport function getBitArrayDecoder<TSize extends number>(\n    size: TSize,\n    config: BitArrayCodecConfig | boolean = {},\n): FixedSizeDecoder<boolean[], TSize> {\n    const parsedConfig: BitArrayCodecConfig = typeof config === 'boolean' ? { backward: config } : config;\n    const backward = parsedConfig.backward ?? false;\n    return createDecoder({\n        fixedSize: size,\n        read(bytes, offset) {\n            assertByteArrayHasEnoughBytesForCodec('bitArray', size, bytes, offset);\n            const booleans: boolean[] = [];\n            let slice = bytes.slice(offset, offset + size);\n            slice = backward ? slice.reverse() : slice;\n\n            slice.forEach(byte => {\n                for (let i = 0; i < 8; i += 1) {\n                    if (backward) {\n                        booleans.push(Boolean(byte & 1));\n                        byte >>= 1;\n                    } else {\n                        booleans.push(Boolean(byte & 0b1000_0000));\n                        byte <<= 1;\n                    }\n                }\n            });\n\n            return [booleans, offset + size];\n        },\n    });\n}\n\n/**\n * Returns a codec that encodes and decodes boolean arrays as compact bit representations.\n *\n * This codec efficiently stores boolean arrays as bits, packing 8 values per byte.\n * The `backward` config option determines whether bits are stored in MSB-first (`false`)\n * or LSB-first (`true`).\n *\n * @typeParam TSize - The number of bytes used to store the bit array.\n *\n * @param size - The number of bytes allocated for the bit array (must be sufficient for the expected boolean count).\n * @param config - Configuration options for encoding and decoding the bit array.\n * @returns A `FixedSizeCodec<boolean[], boolean[], TSize>` for encoding and decoding bit arrays.\n *\n * @example\n * Encoding and decoding a bit array.\n * ```ts\n * const codec = getBitArrayCodec(1);\n *\n * codec.encode([true, false, true, false, false, false, false, false]);\n * // 0xa0 (0b10100000)\n *\n * codec.decode(new Uint8Array([0xa0]));\n * // [true, false, true, false, false, false, false, false]\n * ```\n *\n * @example\n * Encoding and decoding a bit array backwards.\n * ```ts\n * const codec = getBitArrayCodec(1, { backward: true });\n *\n * codec.encode([true, false, true, false, false, false, false, false]);\n * // 0x05 (0b00000101)\n *\n * codec.decode(new Uint8Array([0x05]));\n * // [true, false, true, false, false, false, false, false]\n * ```\n *\n * @remarks\n * Separate {@link getBitArrayEncoder} and {@link getBitArrayDecoder} functions are available.\n *\n * ```ts\n * const bytes = getBitArrayEncoder(1).encode([true, false, true, false]);\n * const value = getBitArrayDecoder(1).decode(bytes);\n * ```\n *\n * @see {@link getBitArrayEncoder}\n * @see {@link getBitArrayDecoder}\n */\nexport function getBitArrayCodec<TSize extends number>(\n    size: TSize,\n    config: BitArrayCodecConfig | boolean = {},\n): FixedSizeCodec<boolean[], boolean[], TSize> {\n    return combineCodec(getBitArrayEncoder(size, config), getBitArrayDecoder(size, config));\n}\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 16-bit signed integers (`i16`).\n *\n * This encoder serializes `i16` values using 2 bytes.\n * Values can be provided as either `number` or `bigint`.\n *\n * For more details, see {@link getI16Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeEncoder<number | bigint, 2>` for encoding `i16` values.\n *\n * @example\n * Encoding an `i16` value.\n * ```ts\n * const encoder = getI16Encoder();\n * const bytes = encoder.encode(-42); // 0xd6ff\n * ```\n *\n * @see {@link getI16Codec}\n */\nexport const getI16Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 2> =>\n    numberEncoderFactory({\n        config,\n        name: 'i16',\n        range: [-Number('0x7fff') - 1, Number('0x7fff')],\n        set: (view, value, le) => view.setInt16(0, Number(value), le),\n        size: 2,\n    });\n\n/**\n * Returns a decoder for 16-bit signed integers (`i16`).\n *\n * This decoder deserializes `i16` values from 2 bytes.\n * The decoded value is always a `number`.\n *\n * For more details, see {@link getI16Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeDecoder<number, 2>` for decoding `i16` values.\n *\n * @example\n * Decoding an `i16` value.\n * ```ts\n * const decoder = getI16Decoder();\n * const value = decoder.decode(new Uint8Array([0xd6, 0xff])); // -42\n * ```\n *\n * @see {@link getI16Codec}\n */\nexport const getI16Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 2> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getInt16(0, le),\n        name: 'i16',\n        size: 2,\n    });\n\n/**\n * Returns a codec for encoding and decoding 16-bit signed integers (`i16`).\n *\n * This codec serializes `i16` values using 2 bytes.\n * Values can be provided as either `number` or `bigint`, but the decoded value is always a `number`.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number | bigint, number, 2>` for encoding and decoding `i16` values.\n *\n * @example\n * Encoding and decoding an `i16` value.\n * ```ts\n * const codec = getI16Codec();\n * const bytes = codec.encode(-42); // 0xd6ff\n * const value = codec.decode(bytes); // -42\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getI16Codec({ endian: Endian.Big });\n * const bytes = codec.encode(-42); // 0xffd6\n * ```\n *\n * @remarks\n * This codec supports values between `-2^15` (`-32,768`) and `2^15 - 1` (`32,767`).\n *\n * - If you need a smaller signed integer, consider using {@link getI8Codec}.\n * - If you need a larger signed integer, consider using {@link getI32Codec}.\n * - If you need unsigned integers, consider using {@link getU16Codec}.\n *\n * Separate {@link getI16Encoder} and {@link getI16Decoder} functions are available.\n *\n * ```ts\n * const bytes = getI16Encoder().encode(-42);\n * const value = getI16Decoder().decode(bytes);\n * ```\n *\n * @see {@link getI16Encoder}\n * @see {@link getI16Decoder}\n */\nexport const getI16Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 2> =>\n    combineCodec(getI16Encoder(config), getI16Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 32-bit signed integers (`i32`).\n *\n * This encoder serializes `i32` values using 4 bytes.\n * Values can be provided as either `number` or `bigint`.\n *\n * For more details, see {@link getI32Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeEncoder<number | bigint, 4>` for encoding `i32` values.\n *\n * @example\n * Encoding an `i32` value.\n * ```ts\n * const encoder = getI32Encoder();\n * const bytes = encoder.encode(-42); // 0xd6ffffff\n * ```\n *\n * @see {@link getI32Codec}\n */\nexport const getI32Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 4> =>\n    numberEncoderFactory({\n        config,\n        name: 'i32',\n        range: [-Number('0x7fffffff') - 1, Number('0x7fffffff')],\n        set: (view, value, le) => view.setInt32(0, Number(value), le),\n        size: 4,\n    });\n\n/**\n * Returns a decoder for 32-bit signed integers (`i32`).\n *\n * This decoder deserializes `i32` values from 4 bytes.\n * The decoded value is always a `number`.\n *\n * For more details, see {@link getI32Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeDecoder<number, 4>` for decoding `i32` values.\n *\n * @example\n * Decoding an `i32` value.\n * ```ts\n * const decoder = getI32Decoder();\n * const value = decoder.decode(new Uint8Array([0xd6, 0xff, 0xff, 0xff])); // -42\n * ```\n *\n * @see {@link getI32Codec}\n */\nexport const getI32Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 4> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getInt32(0, le),\n        name: 'i32',\n        size: 4,\n    });\n\n/**\n * Returns a codec for encoding and decoding 32-bit signed integers (`i32`).\n *\n * This codec serializes `i32` values using 4 bytes.\n * Values can be provided as either `number` or `bigint`, but the decoded value is always a `number`.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number | bigint, number, 4>` for encoding and decoding `i32` values.\n *\n * @example\n * Encoding and decoding an `i32` value.\n * ```ts\n * const codec = getI32Codec();\n * const bytes = codec.encode(-42); // 0xd6ffffff\n * const value = codec.decode(bytes); // -42\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getI32Codec({ endian: Endian.Big });\n * const bytes = codec.encode(-42); // 0xffffffd6\n * ```\n *\n * @remarks\n * This codec supports values between `-2^31` (`-2,147,483,648`) and `2^31 - 1` (`2,147,483,647`).\n *\n * - If you need a smaller signed integer, consider using {@link getI16Codec} or {@link getI8Codec}.\n * - If you need a larger signed integer, consider using {@link getI64Codec}.\n * - If you need unsigned integers, consider using {@link getU32Codec}.\n *\n * Separate {@link getI32Encoder} and {@link getI32Decoder} functions are available.\n *\n * ```ts\n * const bytes = getI32Encoder().encode(-42);\n * const value = getI32Decoder().decode(bytes);\n * ```\n *\n * @see {@link getI32Encoder}\n * @see {@link getI32Decoder}\n */\nexport const getI32Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 4> =>\n    combineCodec(getI32Encoder(config), getI32Decoder(config));\n","import { SOLANA_ERROR__MALFORMED_BIGINT_STRING, SolanaError } from '@solana/errors';\nimport { Brand } from '@solana/nominal-types';\n\n/**\n * This type represents a `bigint` which has been encoded as a string for transit over a transport\n * that does not support `bigint` values natively. The JSON-RPC is such a transport.\n */\nexport type StringifiedBigInt = Brand<string, 'StringifiedBigInt'>;\n\n/**\n * A type guard that returns `true` if the input string parses as a `BigInt`, and refines its type\n * for use in your program.\n *\n * @example\n * ```ts\n * import { isStringifiedBigInt } from '@solana/rpc-types';\n *\n * if (isStringifiedBigInt(bigintString)) {\n *     // At this point, `bigintString` has been refined to a `StringifiedBigInt`\n *     bigintString satisfies StringifiedBigInt; // OK\n * } else {\n *     setError(`${bigintString} does not represent a BigInt`);\n * }\n * ```\n */\nexport function isStringifiedBigInt(putativeBigInt: string): putativeBigInt is StringifiedBigInt {\n    try {\n        BigInt(putativeBigInt);\n        return true;\n    } catch {\n        return false;\n    }\n}\n\n/**\n * From time to time you might acquire a string, that you expect to parse as a `BigInt`, from an\n * untrusted network API or user input. Use this function to assert that such an arbitrary string\n * will in fact parse as a `BigInt`.\n *\n * @example\n * ```ts\n * import { assertIsStringifiedBigInt } from '@solana/rpc-types';\n *\n * // Imagine having received a value that you presume represents the supply of some token.\n * // At this point we know only that it conforms to the `string` type.\n * try {\n *     // If this type assertion function doesn't throw, then\n *     // Typescript will upcast `supplyString` to `StringifiedBigInt`.\n *     assertIsStringifiedBigInt(supplyString);\n *     // At this point, `supplyString` is a `StringifiedBigInt`.\n *     supplyString satisfies StringifiedBigInt;\n * } catch (e) {\n *     // `supplyString` turned out not to parse as a `BigInt`\n * }\n * ```\n */\nexport function assertIsStringifiedBigInt(putativeBigInt: string): asserts putativeBigInt is StringifiedBigInt {\n    try {\n        BigInt(putativeBigInt);\n    } catch {\n        throw new SolanaError(SOLANA_ERROR__MALFORMED_BIGINT_STRING, {\n            value: putativeBigInt,\n        });\n    }\n}\n\n/**\n * This helper combines _asserting_ that a string will parse as a `BigInt` with _coercing_ it to the\n * {@link StringifiedBigInt} type. It's best used with untrusted input.\n *\n * @example\n * ```ts\n * import { stringifiedBigInt } from '@solana/rpc-types';\n *\n * const supplyString = stringifiedBigInt('1000000000');\n * ```\n */\nexport function stringifiedBigInt(putativeBigInt: string): StringifiedBigInt {\n    assertIsStringifiedBigInt(putativeBigInt);\n    return putativeBigInt;\n}\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 64-bit signed integers (`i64`).\n *\n * This encoder serializes `i64` values using 8 bytes.\n * Values can be provided as either `number` or `bigint`.\n *\n * For more details, see {@link getI64Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeEncoder<number | bigint, 8>` for encoding `i64` values.\n *\n * @example\n * Encoding an `i64` value.\n * ```ts\n * const encoder = getI64Encoder();\n * const bytes = encoder.encode(-42n); // 0xd6ffffffffffffff\n * ```\n *\n * @see {@link getI64Codec}\n */\nexport const getI64Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 8> =>\n    numberEncoderFactory({\n        config,\n        name: 'i64',\n        range: [-BigInt('0x7fffffffffffffff') - 1n, BigInt('0x7fffffffffffffff')],\n        set: (view, value, le) => view.setBigInt64(0, BigInt(value), le),\n        size: 8,\n    });\n\n/**\n * Returns a decoder for 64-bit signed integers (`i64`).\n *\n * This decoder deserializes `i64` values from 8 bytes.\n * The decoded value is always a `bigint`.\n *\n * For more details, see {@link getI64Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeDecoder<bigint, 8>` for decoding `i64` values.\n *\n * @example\n * Decoding an `i64` value.\n * ```ts\n * const decoder = getI64Decoder();\n * const value = decoder.decode(new Uint8Array([\n *   0xd6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff\n * ])); // -42n\n * ```\n *\n * @see {@link getI64Codec}\n */\nexport const getI64Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<bigint, 8> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getBigInt64(0, le),\n        name: 'i64',\n        size: 8,\n    });\n\n/**\n * Returns a codec for encoding and decoding 64-bit signed integers (`i64`).\n *\n * This codec serializes `i64` values using 8 bytes.\n * Values can be provided as either `number` or `bigint`, but the decoded value is always a `bigint`.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number | bigint, bigint, 8>` for encoding and decoding `i64` values.\n *\n * @example\n * Encoding and decoding an `i64` value.\n * ```ts\n * const codec = getI64Codec();\n * const bytes = codec.encode(-42n); // 0xd6ffffffffffffff\n * const value = codec.decode(bytes); // -42n\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getI64Codec({ endian: Endian.Big });\n * const bytes = codec.encode(-42n); // 0xffffffffffffffd6\n * ```\n *\n * @remarks\n * This codec supports values between `-2^63` and `2^63 - 1`.\n * Since JavaScript `number` cannot safely represent values beyond `2^53 - 1`, the decoded value is always a `bigint`.\n *\n * - If you need a smaller signed integer, consider using {@link getI32Codec} or {@link getI16Codec}.\n * - If you need a larger signed integer, consider using {@link getI128Codec}.\n * - If you need unsigned integers, consider using {@link getU64Codec}.\n *\n * Separate {@link getI64Encoder} and {@link getI64Decoder} functions are available.\n *\n * ```ts\n * const bytes = getI64Encoder().encode(-42);\n * const value = getI64Decoder().decode(bytes);\n * ```\n *\n * @see {@link getI64Encoder}\n * @see {@link getI64Decoder}\n */\nexport const getI64Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, bigint, 8> =>\n    combineCodec(getI64Encoder(config), getI64Decoder(config));\n","import { SOLANA_ERROR__MALFORMED_NUMBER_STRING, SolanaError } from '@solana/errors';\nimport { Brand } from '@solana/nominal-types';\n\n/**\n * This type represents a number which has been encoded as a string for transit over a transport\n * where loss of precision when using the native number type is a concern. The JSON-RPC is such a\n * transport.\n */\nexport type StringifiedNumber = Brand<string, 'StringifiedNumber'>;\n\n/**\n * A type guard that returns `true` if the input string parses as a `Number`, and refines its type\n * for use in your program.\n *\n * @example\n * ```ts\n * import { isStringifiedNumber } from '@solana/rpc-types';\n *\n * if (isStringifiedNumber(numericString)) {\n *     // At this point, `numericString` has been refined to a `StringifiedNumber`\n *     numericString satisfies StringifiedNumber; // OK\n * } else {\n *     setError(`${numericString} does not represent a number`);\n * }\n * ```\n */\nexport function isStringifiedNumber(putativeNumber: string): putativeNumber is StringifiedNumber {\n    return !Number.isNaN(Number(putativeNumber));\n}\n\n/**\n * From time to time you might acquire a string, that you expect to parse as a `Number`, from an\n * untrusted network API or user input. Use this function to assert that such an arbitrary string\n * will in fact parse as a `Number`.\n *\n * @example\n * ```ts\n * import { assertIsStringifiedNumber } from '@solana/rpc-types';\n *\n * // Imagine having received a value that you presume represents some decimal number.\n * // At this point we know only that it conforms to the `string` type.\n * try {\n *     // If this type assertion function doesn't throw, then\n *     // Typescript will upcast `decimalNumberString` to `StringifiedNumber`.\n *     assertIsStringifiedNumber(decimalNumberString);\n *     // At this point, `decimalNumberString` is a `StringifiedNumber`.\n *     decimalNumberString satisfies StringifiedNumber;\n * } catch (e) {\n *     // `decimalNumberString` turned out not to parse as a number.\n * }\n * ```\n */\nexport function assertIsStringifiedNumber(putativeNumber: string): asserts putativeNumber is StringifiedNumber {\n    if (Number.isNaN(Number(putativeNumber))) {\n        throw new SolanaError(SOLANA_ERROR__MALFORMED_NUMBER_STRING, {\n            value: putativeNumber,\n        });\n    }\n}\n\n/**\n * This helper combines _asserting_ that a string will parse as a `Number` with _coercing_ it to the\n * {@link StringifiedNumber} type. It's best used with untrusted input.\n *\n * @example\n * ```ts\n * import { stringifiedNumber } from '@solana/rpc-types';\n *\n * const decimalNumberString = stringifiedNumber('-42.1');\n * ```\n */\nexport function stringifiedNumber(putativeNumber: string): StringifiedNumber {\n    assertIsStringifiedNumber(putativeNumber);\n    return putativeNumber;\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    FixedSizeNumberCodec,\n    FixedSizeNumberDecoder,\n    FixedSizeNumberEncoder,\n    getU8Decoder,\n    getU8Encoder,\n    NumberCodec,\n    NumberDecoder,\n    NumberEncoder,\n} from '@solana/codecs-numbers';\n\n/**\n * Defines the configuration options for boolean codecs.\n *\n * A boolean codec encodes `true` as `1` and `false` as `0`.\n * The `size` option allows customizing the number codec used for storage.\n *\n * @typeParam TSize - A number codec, encoder, or decoder used for boolean representation.\n *\n * @see {@link getBooleanEncoder}\n * @see {@link getBooleanDecoder}\n * @see {@link getBooleanCodec}\n */\nexport type BooleanCodecConfig<TSize extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The number codec used to store boolean values.\n     *\n     * - By default, booleans are stored as a `u8` (`1` for `true`, `0` for `false`).\n     * - A custom number codec can be provided to change the storage size.\n     *\n     * @defaultValue `u8`\n     */\n    size?: TSize;\n};\n\n/**\n * Returns an encoder for boolean values.\n *\n * This encoder converts `true` into `1` and `false` into `0`.\n * The `size` option allows customizing the number codec used for storage.\n *\n * For more details, see {@link getBooleanCodec}.\n *\n * @param config - Configuration options for encoding booleans.\n * @returns A `FixedSizeEncoder<boolean, N>` where `N` is the size of the number codec.\n *\n * @example\n * Encoding booleans.\n * ```ts\n * const encoder = getBooleanEncoder();\n *\n * encoder.encode(false); // 0x00\n * encoder.encode(true);  // 0x01\n * ```\n *\n * @see {@link getBooleanCodec}\n */\nexport function getBooleanEncoder(): FixedSizeEncoder<boolean, 1>;\nexport function getBooleanEncoder<TSize extends number>(\n    config: BooleanCodecConfig<NumberEncoder> & { size: FixedSizeNumberEncoder<TSize> },\n): FixedSizeEncoder<boolean, TSize>;\nexport function getBooleanEncoder(config: BooleanCodecConfig<NumberEncoder>): VariableSizeEncoder<boolean>;\nexport function getBooleanEncoder(config: BooleanCodecConfig<NumberEncoder> = {}): Encoder<boolean> {\n    return transformEncoder(config.size ?? getU8Encoder(), (value: boolean) => (value ? 1 : 0));\n}\n\n/**\n * Returns a decoder for boolean values.\n *\n * This decoder reads a number and interprets `1` as `true` and `0` as `false`.\n * The `size` option allows customizing the number codec used for storage.\n *\n * For more details, see {@link getBooleanCodec}.\n *\n * @param config - Configuration options for decoding booleans.\n * @returns A `FixedSizeDecoder<boolean, N>` where `N` is the size of the number codec.\n *\n * @example\n * Decoding booleans.\n * ```ts\n * const decoder = getBooleanDecoder();\n *\n * decoder.decode(new Uint8Array([0x00])); // false\n * decoder.decode(new Uint8Array([0x01])); // true\n * ```\n *\n * @see {@link getBooleanCodec}\n */\nexport function getBooleanDecoder(): FixedSizeDecoder<boolean, 1>;\nexport function getBooleanDecoder<TSize extends number>(\n    config: BooleanCodecConfig<NumberDecoder> & { size: FixedSizeNumberDecoder<TSize> },\n): FixedSizeDecoder<boolean, TSize>;\nexport function getBooleanDecoder(config: BooleanCodecConfig<NumberDecoder>): VariableSizeDecoder<boolean>;\nexport function getBooleanDecoder(config: BooleanCodecConfig<NumberDecoder> = {}): Decoder<boolean> {\n    return transformDecoder(config.size ?? getU8Decoder(), (value: bigint | number): boolean => Number(value) === 1);\n}\n\n/**\n * Returns a codec for encoding and decoding boolean values.\n *\n * By default, booleans are stored as a `u8` (`1` for `true`, `0` for `false`).\n * The `size` option allows customizing the number codec used for storage.\n *\n * @param config - Configuration options for encoding and decoding booleans.\n * @returns A `FixedSizeCodec<boolean, boolean, N>` where `N` is the size of the number codec.\n *\n * @example\n * Encoding and decoding booleans using a `u8` (default).\n * ```ts\n * const codec = getBooleanCodec();\n *\n * codec.encode(false); // 0x00\n * codec.encode(true);  // 0x01\n *\n * codec.decode(new Uint8Array([0x00])); // false\n * codec.decode(new Uint8Array([0x01])); // true\n * ```\n *\n * @example\n * Encoding and decoding booleans using a custom number codec.\n * ```ts\n * const codec = getBooleanCodec({ size: getU16Codec() });\n *\n * codec.encode(false); // 0x0000\n * codec.encode(true);  // 0x0100\n *\n * codec.decode(new Uint8Array([0x00, 0x00])); // false\n * codec.decode(new Uint8Array([0x01, 0x00])); // true\n * ```\n *\n * @remarks\n * Separate {@link getBooleanEncoder} and {@link getBooleanDecoder} functions are available.\n *\n * ```ts\n * const bytes = getBooleanEncoder().encode(true);\n * const value = getBooleanDecoder().decode(bytes);\n * ```\n *\n * @see {@link getBooleanEncoder}\n * @see {@link getBooleanDecoder}\n */\nexport function getBooleanCodec(): FixedSizeCodec<boolean, boolean, 1>;\nexport function getBooleanCodec<TSize extends number>(\n    config: BooleanCodecConfig<NumberCodec> & { size: FixedSizeNumberCodec<TSize> },\n): FixedSizeCodec<boolean, boolean, TSize>;\nexport function getBooleanCodec(config: BooleanCodecConfig<NumberCodec>): VariableSizeCodec<boolean>;\nexport function getBooleanCodec(config: BooleanCodecConfig<NumberCodec> = {}): Codec<boolean> {\n    return combineCodec(getBooleanEncoder(config), getBooleanDecoder(config));\n}\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 8-bit signed integers (`i8`).\n *\n * This encoder serializes `i8` values using 1 byte.\n * Values can be provided as either `number` or `bigint`.\n *\n * For more details, see {@link getI8Codec}.\n *\n * @returns A `FixedSizeEncoder<number | bigint, 1>` for encoding `i8` values.\n *\n * @example\n * Encoding an `i8` value.\n * ```ts\n * const encoder = getI8Encoder();\n * const bytes = encoder.encode(-42); // 0xd6\n * ```\n *\n * @see {@link getI8Codec}\n */\nexport const getI8Encoder = (): FixedSizeEncoder<bigint | number, 1> =>\n    numberEncoderFactory({\n        name: 'i8',\n        range: [-Number('0x7f') - 1, Number('0x7f')],\n        set: (view, value) => view.setInt8(0, Number(value)),\n        size: 1,\n    });\n\n/**\n * Returns a decoder for 8-bit signed integers (`i8`).\n *\n * This decoder deserializes `i8` values from 1 byte.\n * The decoded value is always a `number`.\n *\n * For more details, see {@link getI8Codec}.\n *\n * @returns A `FixedSizeDecoder<number, 1>` for decoding `i8` values.\n *\n * @example\n * Decoding an `i8` value.\n * ```ts\n * const decoder = getI8Decoder();\n * const value = decoder.decode(new Uint8Array([0xd6])); // -42\n * ```\n *\n * @see {@link getI8Codec}\n */\nexport const getI8Decoder = (): FixedSizeDecoder<number, 1> =>\n    numberDecoderFactory({\n        get: view => view.getInt8(0),\n        name: 'i8',\n        size: 1,\n    });\n\n/**\n * Returns a codec for encoding and decoding 8-bit signed integers (`i8`).\n *\n * This codec serializes `i8` values using 1 byte.\n * Values can be provided as either `number` or `bigint`, but the decoded value is always a `number`.\n *\n * @returns A `FixedSizeCodec<number | bigint, number, 1>` for encoding and decoding `i8` values.\n *\n * @example\n * Encoding and decoding an `i8` value.\n * ```ts\n * const codec = getI8Codec();\n * const bytes = codec.encode(-42); // 0xd6\n * const value = codec.decode(bytes); // -42\n * ```\n *\n * @remarks\n * This codec supports values between `-2^7` (`-128`) and `2^7 - 1` (`127`).\n *\n * - If you need a larger signed integer, consider using {@link getI16Codec}.\n * - If you need an unsigned integer, consider using {@link getU8Codec}.\n *\n * Separate {@link getI8Encoder} and {@link getI8Decoder} functions are available.\n *\n * ```ts\n * const bytes = getI8Encoder().encode(-42);\n * const value = getI8Decoder().decode(bytes);\n * ```\n *\n * @see {@link getI8Encoder}\n * @see {@link getI8Decoder}\n */\nexport const getI8Codec = (): FixedSizeCodec<bigint | number, number, 1> =>\n    combineCodec(getI8Encoder(), getI8Decoder());\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    ReadonlyUint8Array,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\n/**\n * Returns an encoder for raw byte arrays.\n *\n * This encoder writes byte arrays exactly as provided without modification.\n *\n * The size of the encoded byte array is determined by the length of the input.\n * - To enforce a fixed size, consider using {@link fixEncoderSize}.\n * - To add a size prefix, use {@link addEncoderSizePrefix}.\n * - To add a sentinel value, use {@link addEncoderSentinel}.\n *\n * For more details, see {@link getBytesCodec}.\n *\n * @returns A `VariableSizeEncoder<ReadonlyUint8Array | Uint8Array>`.\n *\n * @example\n * Encoding a byte array as-is.\n * ```ts\n * const encoder = getBytesEncoder();\n *\n * encoder.encode(new Uint8Array([1, 2, 3])); // 0x010203\n * encoder.encode(new Uint8Array([255, 0, 127])); // 0xff007f\n * ```\n *\n * @see {@link getBytesCodec}\n */\nexport function getBytesEncoder(): VariableSizeEncoder<ReadonlyUint8Array | Uint8Array> {\n    return createEncoder({\n        getSizeFromValue: value => value.length,\n        write: (value, bytes, offset) => {\n            bytes.set(value, offset);\n            return offset + value.length;\n        },\n    });\n}\n\n/**\n * Returns a decoder for raw byte arrays.\n *\n * This decoder reads byte arrays exactly as provided without modification.\n *\n * The decoded byte array extends from the provided offset to the end of the input.\n * - To enforce a fixed size, consider using {@link fixDecoderSize}.\n * - To add a size prefix, use {@link addDecoderSizePrefix}.\n * - To add a sentinel value, use {@link addDecoderSentinel}.\n *\n * For more details, see {@link getBytesCodec}.\n *\n * @returns A `VariableSizeDecoder<ReadonlyUint8Array>`.\n *\n * @example\n * Decoding a byte array as-is.\n * ```ts\n * const decoder = getBytesDecoder();\n *\n * decoder.decode(new Uint8Array([1, 2, 3])); // Uint8Array([1, 2, 3])\n * decoder.decode(new Uint8Array([255, 0, 127])); // Uint8Array([255, 0, 127])\n * ```\n *\n * @see {@link getBytesCodec}\n */\nexport function getBytesDecoder(): VariableSizeDecoder<ReadonlyUint8Array> {\n    return createDecoder({\n        read: (bytes, offset) => {\n            const slice = bytes.slice(offset);\n            return [slice, offset + slice.length];\n        },\n    });\n}\n\n/**\n * Returns a codec for encoding and decoding raw byte arrays.\n *\n * This codec serializes and deserializes byte arrays without modification.\n *\n * The size of the encoded and decoded byte array is determined dynamically.\n * This means, when reading, the codec will consume all remaining bytes in the input.\n * - To enforce a fixed size, consider using {@link fixCodecSize}.\n * - To add a size prefix, use {@link addCodecSizePrefix}.\n * - To add a sentinel value, use {@link addCodecSentinel}.\n *\n * @returns A `VariableSizeCodec<ReadonlyUint8Array | Uint8Array, ReadonlyUint8Array>`.\n *\n * @example\n * Encoding and decoding a byte array.\n * ```ts\n * const codec = getBytesCodec();\n *\n * codec.encode(new Uint8Array([1, 2, 3])); // 0x010203\n * codec.decode(new Uint8Array([255, 0, 127])); // Uint8Array([255, 0, 127])\n * ```\n *\n * @remarks\n * Separate {@link getBytesEncoder} and {@link getBytesDecoder} functions are available.\n *\n * ```ts\n * const bytes = getBytesEncoder().encode(new Uint8Array([1, 2, 3]));\n * const value = getBytesDecoder().decode(bytes);\n * ```\n *\n * @see {@link getBytesEncoder}\n * @see {@link getBytesDecoder}\n */\nexport function getBytesCodec(): VariableSizeCodec<ReadonlyUint8Array | Uint8Array, ReadonlyUint8Array> {\n    return combineCodec(getBytesEncoder(), getBytesDecoder());\n}\n","import { SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE, SolanaError } from '@solana/errors';\nimport { Brand } from '@solana/nominal-types';\n\n/**\n * This type represents a Unix timestamp in _seconds_.\n *\n * It is represented as a `bigint` in client code and an `i64` in server code.\n */\nexport type UnixTimestamp = Brand<bigint, 'UnixTimestamp'>;\n\n// Largest possible value to be represented by an i64\nconst maxI64Value = 9223372036854775807n; // 2n ** 63n - 1n\nconst minI64Value = -9223372036854775808n; // -(2n ** 63n)\n\n/**\n * This is a type guard that accepts a `bigint` as input. It will both return `true` if the integer\n * conforms to the {@link UnixTimestamp} type and will refine the type for use in your program.\n *\n * @example\n * ```ts\n * import { isUnixTimestamp } from '@solana/rpc-types';\n *\n * if (isUnixTimestamp(timestamp)) {\n *     // At this point, `timestamp` has been refined to a\n *     // `UnixTimestamp` that can be used anywhere timestamps are expected.\n *     timestamp satisfies UnixTimestamp;\n * } else {\n *     setError(`${timestamp} is not a Unix timestamp`);\n * }\n * ```\n */\n\nexport function isUnixTimestamp(putativeTimestamp: bigint): putativeTimestamp is UnixTimestamp {\n    return putativeTimestamp >= minI64Value && putativeTimestamp <= maxI64Value;\n}\n\n/**\n * Timestamp values returned from the RPC API conform to the type {@link UnixTimestamp}. You can use\n * a value of that type wherever a timestamp is expected.\n *\n * @example\n * From time to time you might acquire a number that you expect to be a timestamp, from an untrusted\n * network API or user input. To assert that such an arbitrary number is usable as a Unix timestamp,\n * use this function.\n *\n * ```ts\n * import { assertIsUnixTimestamp } from '@solana/rpc-types';\n *\n * // Imagine having received a value that you presume represents a timestamp.\n * // At this point we know only that it conforms to the `bigint` type.\n * try {\n *     // If this type assertion function doesn't throw, then\n *     // Typescript will upcast `timestamp` to `UnixTimestamp`.\n *     assertIsUnixTimestamp(timestamp);\n *     // At this point, `timestamp` is a `UnixTimestamp`.\n *     timestamp satisfies UnixTimestamp;\n * } catch (e) {\n *     // `timestamp` turned out not to be a valid Unix timestamp\n * }\n * ```\n */\nexport function assertIsUnixTimestamp(putativeTimestamp: bigint): asserts putativeTimestamp is UnixTimestamp {\n    if (putativeTimestamp < minI64Value || putativeTimestamp > maxI64Value) {\n        throw new SolanaError(SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE, {\n            value: putativeTimestamp,\n        });\n    }\n}\n\n/**\n * This helper combines _asserting_ that a `bigint` represents a Unix timestamp with _coercing_ it\n * to the {@link UnixTimestamp} type. It's best used with untrusted input.\n *\n * @example\n * ```ts\n * import { unixTimestamp } from '@solana/rpc-types';\n *\n * const timestamp = unixTimestamp(-42n); // Wednesday, December 31, 1969 3:59:18 PM GMT-08:00\n * ```\n */\nexport function unixTimestamp(putativeTimestamp: bigint): UnixTimestamp {\n    assertIsUnixTimestamp(putativeTimestamp);\n    return putativeTimestamp;\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Offset,\n    ReadonlyUint8Array,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertNumberIsBetweenForCodec } from './assertions';\n\n/**\n * Returns an encoder for `shortU16` values.\n *\n * This encoder serializes `shortU16` values using **1 to 3 bytes**.\n * Smaller values use fewer bytes, while larger values take up more space.\n *\n * For more details, see {@link getShortU16Codec}.\n *\n * @returns A `VariableSizeEncoder<number | bigint>` for encoding `shortU16` values.\n *\n * @example\n * Encoding a `shortU16` value.\n * ```ts\n * const encoder = getShortU16Encoder();\n * encoder.encode(42);    // 0x2a\n * encoder.encode(128);   // 0x8001\n * encoder.encode(16384); // 0x808001\n * ```\n *\n * @see {@link getShortU16Codec}\n */\nexport const getShortU16Encoder = (): VariableSizeEncoder<bigint | number> =>\n    createEncoder({\n        getSizeFromValue: (value: bigint | number): number => {\n            if (value <= 0b01111111) return 1;\n            if (value <= 0b0011111111111111) return 2;\n            return 3;\n        },\n        maxSize: 3,\n        write: (value: bigint | number, bytes: Uint8Array, offset: Offset): Offset => {\n            assertNumberIsBetweenForCodec('shortU16', 0, 65535, value);\n            const shortU16Bytes = [0];\n            for (let ii = 0; ; ii += 1) {\n                // Shift the bits of the value over such that the next 7 bits are at the right edge.\n                const alignedValue = Number(value) >> (ii * 7);\n                if (alignedValue === 0) {\n                    // No more bits to consume.\n                    break;\n                }\n                // Extract those 7 bits using a mask.\n                const nextSevenBits = 0b1111111 & alignedValue;\n                shortU16Bytes[ii] = nextSevenBits;\n                if (ii > 0) {\n                    // Set the continuation bit of the previous slice.\n                    shortU16Bytes[ii - 1] |= 0b10000000;\n                }\n            }\n            bytes.set(shortU16Bytes, offset);\n            return offset + shortU16Bytes.length;\n        },\n    });\n\n/**\n * Returns a decoder for `shortU16` values.\n *\n * This decoder deserializes `shortU16` values from **1 to 3 bytes**.\n * The number of bytes used depends on the encoded value.\n *\n * For more details, see {@link getShortU16Codec}.\n *\n * @returns A `VariableSizeDecoder<number>` for decoding `shortU16` values.\n *\n * @example\n * Decoding a `shortU16` value.\n * ```ts\n * const decoder = getShortU16Decoder();\n * decoder.decode(new Uint8Array([0x2a]));             // 42\n * decoder.decode(new Uint8Array([0x80, 0x01]));       // 128\n * decoder.decode(new Uint8Array([0x80, 0x80, 0x01])); // 16384\n * ```\n *\n * @see {@link getShortU16Codec}\n */\nexport const getShortU16Decoder = (): VariableSizeDecoder<number> =>\n    createDecoder({\n        maxSize: 3,\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset): [number, Offset] => {\n            let value = 0;\n            let byteCount = 0;\n            while (++byteCount) {\n                const byteIndex = byteCount - 1;\n                const currentByte = bytes[offset + byteIndex];\n                const nextSevenBits = 0b1111111 & currentByte;\n                // Insert the next group of seven bits into the correct slot of the output value.\n                value |= nextSevenBits << (byteIndex * 7);\n                if ((currentByte & 0b10000000) === 0) {\n                    // This byte does not have its continuation bit set. We're done.\n                    break;\n                }\n            }\n            return [value, offset + byteCount];\n        },\n    });\n\n/**\n * Returns a codec for encoding and decoding `shortU16` values.\n *\n * It serializes unsigned integers using **1 to 3 bytes** based on the encoded value.\n * The larger the value, the more bytes it uses.\n *\n * - If the value is `<= 0x7f` (127), it is stored in a **single byte**\n *   and the first bit is set to `0` to indicate the end of the value.\n * - Otherwise, the first bit is set to `1` to indicate that the value continues in the next byte, which follows the same pattern.\n * - This process repeats until the value is fully encoded in up to 3 bytes. The third and last byte, if needed, uses all 8 bits to store the remaining value.\n *\n * In other words, the encoding scheme follows this structure:\n *\n * ```txt\n * 0XXXXXXX                   <- Values 0 to 127 (1 byte)\n * 1XXXXXXX 0XXXXXXX          <- Values 128 to 16,383 (2 bytes)\n * 1XXXXXXX 1XXXXXXX XXXXXXXX <- Values 16,384 to 4,194,303 (3 bytes)\n * ```\n *\n * @returns A `VariableSizeCodec<number | bigint, number>` for encoding and decoding `shortU16` values.\n *\n * @example\n * Encoding and decoding `shortU16` values.\n * ```ts\n * const codec = getShortU16Codec();\n * const bytes1 = codec.encode(42);    // 0x2a\n * const bytes2 = codec.encode(128);   // 0x8001\n * const bytes3 = codec.encode(16384); // 0x808001\n *\n * codec.decode(bytes1); // 42\n * codec.decode(bytes2); // 128\n * codec.decode(bytes3); // 16384\n * ```\n *\n * @remarks\n * This codec efficiently stores small numbers, making it useful for transactions and compact representations.\n *\n * If you need a fixed-size `u16` codec, consider using {@link getU16Codec}.\n *\n * Separate {@link getShortU16Encoder} and {@link getShortU16Decoder} functions are available.\n *\n * ```ts\n * const bytes = getShortU16Encoder().encode(42);\n * const value = getShortU16Decoder().decode(bytes);\n * ```\n *\n * @see {@link getShortU16Encoder}\n * @see {@link getShortU16Decoder}\n */\nexport const getShortU16Codec = (): VariableSizeCodec<bigint | number, number> =>\n    combineCodec(getShortU16Encoder(), getShortU16Decoder());\n","import {\n    combineCodec,\n    containsBytes,\n    createDecoder,\n    createEncoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    ReadonlyUint8Array,\n} from '@solana/codecs-core';\nimport { getBase16Decoder } from '@solana/codecs-strings';\nimport { SOLANA_ERROR__CODECS__INVALID_CONSTANT, SolanaError } from '@solana/errors';\n\n/**\n * Returns an encoder that always writes a predefined constant byte sequence.\n *\n * This encoder ensures that encoding always produces the specified byte array,\n * ignoring any input values.\n *\n * For more details, see {@link getConstantCodec}.\n *\n * @typeParam TConstant - The fixed byte sequence that will be written during encoding.\n *\n * @param constant - The predefined byte array to encode.\n * @returns A `FixedSizeEncoder<void, N>` where `N` is the length of the constant.\n *\n * @example\n * Encoding a constant magic number.\n * ```ts\n * const encoder = getConstantEncoder(new Uint8Array([1, 2, 3, 4]));\n *\n * const bytes = encoder.encode();\n * // 0x01020304\n * //    The predefined 4-byte constant.\n * ```\n *\n * @see {@link getConstantCodec}\n */\nexport function getConstantEncoder<TConstant extends ReadonlyUint8Array>(\n    constant: TConstant,\n): FixedSizeEncoder<void, TConstant['length']> {\n    return createEncoder({\n        fixedSize: constant.length,\n        write: (_, bytes, offset) => {\n            bytes.set(constant, offset);\n            return offset + constant.length;\n        },\n    });\n}\n\n/**\n * Returns a decoder that verifies a predefined constant byte sequence.\n *\n * This decoder reads the next bytes and checks that they match the provided constant.\n * If the bytes differ, it throws an error.\n *\n * For more details, see {@link getConstantCodec}.\n *\n * @typeParam TConstant - The fixed byte sequence expected during decoding.\n *\n * @param constant - The predefined byte array to verify.\n * @returns A `FixedSizeDecoder<void, N>` where `N` is the length of the constant.\n *\n * @example\n * Decoding a constant magic number.\n * ```ts\n * const decoder = getConstantDecoder(new Uint8Array([1, 2, 3]));\n *\n * decoder.decode(new Uint8Array([1, 2, 3])); // Passes\n * decoder.decode(new Uint8Array([1, 2, 4])); // Throws an error\n * ```\n *\n * @see {@link getConstantCodec}\n */\nexport function getConstantDecoder<TConstant extends ReadonlyUint8Array>(\n    constant: TConstant,\n): FixedSizeDecoder<void, TConstant['length']> {\n    return createDecoder({\n        fixedSize: constant.length,\n        read: (bytes, offset) => {\n            const base16 = getBase16Decoder();\n            if (!containsBytes(bytes, constant, offset)) {\n                throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_CONSTANT, {\n                    constant,\n                    data: bytes,\n                    hexConstant: base16.decode(constant),\n                    hexData: base16.decode(bytes),\n                    offset,\n                });\n            }\n            return [undefined, offset + constant.length];\n        },\n    });\n}\n\n/**\n * Returns a codec that encodes and decodes a predefined constant byte sequence.\n *\n * - **Encoding:** Always writes the specified byte array.\n * - **Decoding:** Asserts that the next bytes match the constant, throwing an error if they do not.\n *\n * This is useful for encoding fixed byte patterns required in a binary format or to use in\n * conjunction with other codecs such as {@link getHiddenPrefixCodec} or {@link getHiddenSuffixCodec}.\n *\n * @typeParam TConstant - The fixed byte sequence to encode and verify during decoding.\n *\n * @param constant - The predefined byte array to encode and assert during decoding.\n * @returns A `FixedSizeCodec<void, void, N>` where `N` is the length of the constant.\n *\n * @example\n * Encoding and decoding a constant magic number.\n * ```ts\n * const codec = getConstantCodec(new Uint8Array([1, 2, 3]));\n *\n * codec.encode(); // 0x010203\n * codec.decode(new Uint8Array([1, 2, 3])); // Passes\n * codec.decode(new Uint8Array([1, 2, 4])); // Throws an error\n * ```\n *\n * @remarks\n * Separate {@link getConstantEncoder} and {@link getConstantDecoder} functions are available.\n *\n * ```ts\n * const bytes = getConstantEncoder(new Uint8Array([1, 2, 3])).encode();\n * getConstantDecoder(new Uint8Array([1, 2, 3])).decode(bytes);\n * ```\n *\n * @see {@link getConstantEncoder}\n * @see {@link getConstantDecoder}\n */\nexport function getConstantCodec<TConstant extends ReadonlyUint8Array>(\n    constant: TConstant,\n): FixedSizeCodec<void, void, TConstant['length']> {\n    return combineCodec(getConstantEncoder(constant), getConstantDecoder(constant));\n}\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 128-bit unsigned integers (`u128`).\n *\n * This encoder serializes `u128` values using sixteen bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * For more details, see {@link getU128Codec}.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeEncoder<number | bigint, 16>` for encoding `u128` values.\n *\n * @example\n * Encoding a `u128` value.\n * ```ts\n * const encoder = getU128Encoder();\n * const bytes = encoder.encode(42n); // 0x2a000000000000000000000000000000\n * ```\n *\n * @see {@link getU128Codec}\n */\nexport const getU128Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 16> =>\n    numberEncoderFactory({\n        config,\n        name: 'u128',\n        range: [0n, BigInt('0xffffffffffffffffffffffffffffffff')],\n        set: (view, value, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const rightMask = 0xffffffffffffffffn;\n            view.setBigUint64(leftOffset, BigInt(value) >> 64n, le);\n            view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);\n        },\n        size: 16,\n    });\n\n/**\n * Returns a decoder for 128-bit unsigned integers (`u128`).\n *\n * This decoder deserializes `u128` values from sixteen bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * For more details, see {@link getU128Codec}.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeDecoder<bigint, 16>` for decoding `u128` values.\n *\n * @example\n * Decoding a `u128` value.\n * ```ts\n * const decoder = getU128Decoder();\n * const value = decoder.decode(new Uint8Array([0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00])); // 42n\n * ```\n *\n * @see {@link getU128Codec}\n */\nexport const getU128Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<bigint, 16> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const left = view.getBigUint64(leftOffset, le);\n            const right = view.getBigUint64(rightOffset, le);\n            return (left << 64n) + right;\n        },\n        name: 'u128',\n        size: 16,\n    });\n\n/**\n * Returns a codec for encoding and decoding 128-bit unsigned integers (`u128`).\n *\n * This codec serializes `u128` values using 16 bytes.\n * Values can be provided as either `number` or `bigint`, but the decoded value is always a `bigint`.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number | bigint, bigint, 16>` for encoding and decoding `u128` values.\n *\n * @example\n * Encoding and decoding a `u128` value.\n * ```ts\n * const codec = getU128Codec();\n * const bytes = codec.encode(42); // 0x2a000000000000000000000000000000\n * const value = codec.decode(bytes); // 42n\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getU128Codec({ endian: Endian.Big });\n * const bytes = codec.encode(42); // 0x0000000000000000000000000000002a\n * ```\n *\n * @remarks\n * This codec supports values between `0` and `2^128 - 1`.\n * Since JavaScript `number` cannot safely represent values beyond `2^53 - 1`, the decoded value is always a `bigint`.\n *\n * - If you need a smaller unsigned integer, consider using {@link getU64Codec} or {@link getU32Codec}.\n * - If you need signed integers, consider using {@link getI128Codec}.\n *\n * Separate {@link getU128Encoder} and {@link getU128Decoder} functions are available.\n *\n * ```ts\n * const bytes = getU128Encoder().encode(42);\n * const value = getU128Decoder().decode(bytes);\n * ```\n *\n * @see {@link getU128Encoder}\n * @see {@link getU128Decoder}\n */\nexport const getU128Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, bigint, 16> =>\n    combineCodec(getU128Encoder(config), getU128Decoder(config));\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n    Codec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    getEncodedSize,\n    ReadonlyUint8Array,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidNumberOfItemsForCodec } from './assertions';\nimport { DrainOuterGeneric, getFixedSize, getMaxSize, sumCodecSizes } from './utils';\n\n/**\n * Infers the TypeScript type for a tuple that can be encoded using a tuple codec.\n *\n * This type maps each provided item encoder to its corresponding value type.\n *\n * @typeParam TItems - An array of encoders, each corresponding to a tuple element.\n */\ntype GetEncoderTypeFromItems<TItems extends readonly Encoder<any>[]> = DrainOuterGeneric<{\n    [I in keyof TItems]: TItems[I] extends Encoder<infer TFrom> ? TFrom : never;\n}>;\n\n/**\n * Infers the TypeScript type for a tuple that can be decoded using a tuple codec.\n *\n * This type maps each provided item decoder to its corresponding value type.\n *\n * @typeParam TItems - An array of decoders, each corresponding to a tuple element.\n */\ntype GetDecoderTypeFromItems<TItems extends readonly Decoder<any>[]> = DrainOuterGeneric<{\n    [I in keyof TItems]: TItems[I] extends Decoder<infer TTo> ? TTo : never;\n}>;\n\n/**\n * Returns an encoder for tuples.\n *\n * This encoder serializes a fixed-size array (tuple) by encoding its items\n * sequentially using the provided item encoders.\n *\n * For more details, see {@link getTupleCodec}.\n *\n * @typeParam TItems - An array of encoders, each corresponding to a tuple element.\n *\n * @param items - The encoders for each item in the tuple.\n * @returns A `FixedSizeEncoder` or `VariableSizeEncoder` for encoding tuples.\n *\n * @example\n * Encoding a tuple with 2 items.\n * ```ts\n * const encoder = getTupleEncoder([fixCodecSize(getUtf8Encoder(), 5), getU8Encoder()]);\n *\n * const bytes = encoder.encode(['Alice', 42]);\n * // 0x416c6963652a\n * //   |          Second item (42)\n * //    First item (\"Alice\")\n * ```\n *\n * @see {@link getTupleCodec}\n */\nexport function getTupleEncoder<const TItems extends readonly FixedSizeEncoder<any>[]>(\n    items: TItems,\n): FixedSizeEncoder<GetEncoderTypeFromItems<TItems>>;\nexport function getTupleEncoder<const TItems extends readonly Encoder<any>[]>(\n    items: TItems,\n): VariableSizeEncoder<GetEncoderTypeFromItems<TItems>>;\nexport function getTupleEncoder<const TItems extends readonly Encoder<any>[]>(\n    items: TItems,\n): Encoder<GetEncoderTypeFromItems<TItems>> {\n    type TFrom = GetEncoderTypeFromItems<TItems>;\n    const fixedSize = sumCodecSizes(items.map(getFixedSize));\n    const maxSize = sumCodecSizes(items.map(getMaxSize)) ?? undefined;\n\n    return createEncoder({\n        ...(fixedSize === null\n            ? {\n                  getSizeFromValue: (value: TFrom) =>\n                      items.map((item, index) => getEncodedSize(value[index], item)).reduce((all, one) => all + one, 0),\n                  maxSize,\n              }\n            : { fixedSize }),\n        write: (value: TFrom, bytes, offset) => {\n            assertValidNumberOfItemsForCodec('tuple', items.length, value.length);\n            items.forEach((item, index) => {\n                offset = item.write(value[index], bytes, offset);\n            });\n            return offset;\n        },\n    });\n}\n\n/**\n * Returns a decoder for tuples.\n *\n * This decoder deserializes a fixed-size array (tuple) by decoding its items\n * sequentially using the provided item decoders.\n *\n * For more details, see {@link getTupleCodec}.\n *\n * @typeParam TItems - An array of decoders, each corresponding to a tuple element.\n *\n * @param items - The decoders for each item in the tuple.\n * @returns A `FixedSizeDecoder` or `VariableSizeDecoder` for decoding tuples.\n *\n * @example\n * Decoding a tuple with 2 items.\n * ```ts\n * const decoder = getTupleDecoder([fixCodecSize(getUtf8Decoder(), 5), getU8Decoder()]);\n *\n * const tuple = decoder.decode(new Uint8Array([\n *   0x41,0x6c,0x69,0x63,0x65,0x2a\n * ]));\n * // ['Alice', 42]\n * ```\n *\n * @see {@link getTupleCodec}\n */\nexport function getTupleDecoder<const TItems extends readonly FixedSizeDecoder<any>[]>(\n    items: TItems,\n): FixedSizeDecoder<GetDecoderTypeFromItems<TItems>>;\nexport function getTupleDecoder<const TItems extends readonly Decoder<any>[]>(\n    items: TItems,\n): VariableSizeDecoder<GetDecoderTypeFromItems<TItems>>;\nexport function getTupleDecoder<const TItems extends readonly Decoder<any>[]>(\n    items: TItems,\n): Decoder<GetDecoderTypeFromItems<TItems>> {\n    type TTo = GetDecoderTypeFromItems<TItems>;\n    const fixedSize = sumCodecSizes(items.map(getFixedSize));\n    const maxSize = sumCodecSizes(items.map(getMaxSize)) ?? undefined;\n\n    return createDecoder({\n        ...(fixedSize === null ? { maxSize } : { fixedSize }),\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset) => {\n            const values = [] as Array<any> & TTo;\n            items.forEach(item => {\n                const [newValue, newOffset] = item.read(bytes, offset);\n                values.push(newValue);\n                offset = newOffset;\n            });\n            return [values, offset];\n        },\n    });\n}\n\n/**\n * Returns a codec for encoding and decoding tuples.\n *\n * This codec serializes tuples by encoding and decoding each item sequentially.\n *\n * Unlike the {@link getArrayCodec} codec, each item in the tuple has its own codec\n * and, therefore, can be of a different type.\n *\n * @typeParam TItems - An array of codecs, each corresponding to a tuple element.\n *\n * @param items - The codecs for each item in the tuple.\n * @returns A `FixedSizeCodec` or `VariableSizeCodec` for encoding and decoding tuples.\n *\n * @example\n * Encoding and decoding a tuple with 2 items.\n * ```ts\n * const codec = getTupleCodec([fixCodecSize(getUtf8Codec(), 5), getU8Codec()]);\n *\n * const bytes = codec.encode(['Alice', 42]);\n * // 0x416c6963652a\n * //   |          Second item (42)\n * //    First item (\"Alice\")\n *\n * const tuple = codec.decode(bytes);\n * // ['Alice', 42]\n * ```\n *\n * @remarks\n * Separate {@link getTupleEncoder} and {@link getTupleDecoder} functions are available.\n *\n * ```ts\n * const bytes = getTupleEncoder([fixCodecSize(getUtf8Encoder(), 5), getU8Encoder()])\n *   .encode(['Alice', 42]);\n *\n * const tuple = getTupleDecoder([fixCodecSize(getUtf8Decoder(), 5), getU8Decoder()])\n *   .decode(bytes);\n * ```\n *\n * @see {@link getTupleEncoder}\n * @see {@link getTupleDecoder}\n */\nexport function getTupleCodec<const TItems extends readonly FixedSizeCodec<any>[]>(\n    items: TItems,\n): FixedSizeCodec<GetEncoderTypeFromItems<TItems>, GetDecoderTypeFromItems<TItems> & GetEncoderTypeFromItems<TItems>>;\nexport function getTupleCodec<const TItems extends readonly Codec<any>[]>(\n    items: TItems,\n): VariableSizeCodec<\n    GetEncoderTypeFromItems<TItems>,\n    GetDecoderTypeFromItems<TItems> & GetEncoderTypeFromItems<TItems>\n>;\nexport function getTupleCodec<const TItems extends readonly Codec<any>[]>(\n    items: TItems,\n): Codec<GetEncoderTypeFromItems<TItems>, GetDecoderTypeFromItems<TItems> & GetEncoderTypeFromItems<TItems>> {\n    return combineCodec(\n        getTupleEncoder(items),\n        getTupleDecoder(items) as Decoder<GetDecoderTypeFromItems<TItems> & GetEncoderTypeFromItems<TItems>>,\n    );\n}\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 16-bit unsigned integers (`u16`).\n *\n * This encoder serializes `u16` values using two bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * For more details, see {@link getU16Codec}.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeEncoder<number | bigint, 2>` for encoding `u16` values.\n *\n * @example\n * Encoding a `u16` value.\n * ```ts\n * const encoder = getU16Encoder();\n * const bytes = encoder.encode(42); // 0x2a00\n * ```\n *\n * @see {@link getU16Codec}\n */\nexport const getU16Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 2> =>\n    numberEncoderFactory({\n        config,\n        name: 'u16',\n        range: [0, Number('0xffff')],\n        set: (view, value, le) => view.setUint16(0, Number(value), le),\n        size: 2,\n    });\n\n/**\n * Returns a decoder for 16-bit unsigned integers (`u16`).\n *\n * This decoder deserializes `u16` values from two bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * For more details, see {@link getU16Codec}.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeDecoder<number, 2>` for decoding `u16` values.\n *\n * @example\n * Decoding a `u16` value.\n * ```ts\n * const decoder = getU16Decoder();\n * const value = decoder.decode(new Uint8Array([0x2a, 0x00])); // 42\n * ```\n *\n * @see {@link getU16Codec}\n */\nexport const getU16Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 2> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getUint16(0, le),\n        name: 'u16',\n        size: 2,\n    });\n\n/**\n * Returns a codec for encoding and decoding 16-bit unsigned integers (`u16`).\n *\n * This codec serializes `u16` values using two bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeCodec<number | bigint, number, 2>` for encoding and decoding `u16` values.\n *\n * @example\n * Encoding and decoding a `u16` value.\n * ```ts\n * const codec = getU16Codec();\n * const bytes = codec.encode(42); // 0x2a00 (little-endian)\n * const value = codec.decode(bytes); // 42\n * ```\n *\n * @example\n * Storing values in big-endian format.\n * ```ts\n * const codec = getU16Codec({ endian: Endian.Big });\n * const bytes = codec.encode(42); // 0x002a\n * ```\n *\n * @remarks\n * This codec supports values between `0` and `2^16 - 1`.\n * If you need a larger range, consider using {@link getU32Codec} or {@link getU64Codec}.\n * For signed integers, use {@link getI16Codec}.\n *\n * Separate {@link getU16Encoder} and {@link getU16Decoder} functions are available.\n *\n * ```ts\n * const bytes = getU16Encoder().encode(42);\n * const value = getU16Decoder().decode(bytes);\n * ```\n *\n * @see {@link getU16Encoder}\n * @see {@link getU16Decoder}\n */\nexport const getU16Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 2> =>\n    combineCodec(getU16Encoder(config), getU16Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 32-bit unsigned integers (`u32`).\n *\n * This encoder serializes `u32` values using four bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * For more details, see {@link getU32Codec}.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeEncoder<bigint | number, 4>` for encoding `u32` values.\n *\n * @example\n * Encoding a `u32` value.\n * ```ts\n * const encoder = getU32Encoder();\n * const bytes = encoder.encode(42); // 0x2a000000\n * ```\n *\n * @see {@link getU32Codec}\n */\nexport const getU32Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 4> =>\n    numberEncoderFactory({\n        config,\n        name: 'u32',\n        range: [0, Number('0xffffffff')],\n        set: (view, value, le) => view.setUint32(0, Number(value), le),\n        size: 4,\n    });\n\n/**\n * Returns a decoder for 32-bit unsigned integers (`u32`).\n *\n * This decoder deserializes `u32` values from four bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * For more details, see {@link getU32Codec}.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeDecoder<number, 4>` for decoding `u32` values.\n *\n * @example\n * Decoding a `u32` value.\n * ```ts\n * const decoder = getU32Decoder();\n * const value = decoder.decode(new Uint8Array([0x2a, 0x00, 0x00, 0x00])); // 42\n * ```\n *\n * @see {@link getU32Codec}\n */\nexport const getU32Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 4> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getUint32(0, le),\n        name: 'u32',\n        size: 4,\n    });\n\n/**\n * Returns a codec for encoding and decoding 32-bit unsigned integers (`u32`).\n *\n * This codec serializes `u32` values using four bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeCodec<bigint | number, number, 4>` for encoding and decoding `u32` values.\n *\n * @example\n * Encoding and decoding a `u32` value.\n * ```ts\n * const codec = getU32Codec();\n * const bytes = codec.encode(42); // 0x2a000000 (little-endian)\n * const value = codec.decode(bytes); // 42\n * ```\n *\n * @example\n * Storing values in big-endian format.\n * ```ts\n * const codec = getU32Codec({ endian: Endian.Big });\n * const bytes = codec.encode(42); // 0x0000002a\n * ```\n *\n * @remarks\n * This codec only supports values between `0` and `2^32 - 1`.\n * If you need a larger range, consider using {@link getU64Codec} or {@link getU128Codec}.\n * For signed integers, use {@link getI32Codec}.\n *\n * Separate {@link getU32Encoder} and {@link getU32Decoder} functions are available.\n *\n * ```ts\n * const bytes = getU32Encoder().encode(42);\n * const value = getU32Decoder().decode(bytes);\n * ```\n *\n * @see {@link getU32Encoder}\n * @see {@link getU32Decoder}\n */\nexport const getU32Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 4> =>\n    combineCodec(getU32Encoder(config), getU32Decoder(config));\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n    Codec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    getEncodedSize,\n    isFixedSize,\n    Offset,\n    ReadonlyUint8Array,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE, SolanaError } from '@solana/errors';\n\nimport { DrainOuterGeneric, getMaxSize, maxCodecSizes } from './utils';\n\n/**\n * Infers the TypeScript type for values that can be encoded using a union codec.\n *\n * This type maps the provided variant encoders to their corresponding value types.\n *\n * @typeParam TVariants - An array of encoders, each corresponding to a union variant.\n */\ntype GetEncoderTypeFromVariants<TVariants extends readonly Encoder<any>[]> = DrainOuterGeneric<{\n    [I in keyof TVariants]: TVariants[I] extends Encoder<infer TFrom> ? TFrom : never;\n}>[number];\n\n/**\n * Infers the TypeScript type for values that can be decoded using a union codec.\n *\n * This type maps the provided variant decoders to their corresponding value types.\n *\n * @typeParam TVariants - An array of decoders, each corresponding to a union variant.\n */\ntype GetDecoderTypeFromVariants<TVariants extends readonly Decoder<any>[]> = DrainOuterGeneric<{\n    [I in keyof TVariants]: TVariants[I] extends Decoder<infer TFrom> ? TFrom : never;\n}>[number];\n\ntype UnionEncoder<TVariants extends readonly Encoder<unknown>[]> = TVariants extends readonly FixedSizeEncoder<any>[]\n    ? FixedSizeEncoder<GetEncoderTypeFromVariants<TVariants>>\n    : Encoder<GetEncoderTypeFromVariants<TVariants>>;\n\ntype UnionDecoder<TVariants extends readonly Decoder<unknown>[]> = TVariants extends readonly FixedSizeDecoder<any>[]\n    ? FixedSizeDecoder<GetDecoderTypeFromVariants<TVariants>>\n    : Decoder<GetDecoderTypeFromVariants<TVariants>>;\n\ntype UnionCodec<TVariants extends readonly Codec<unknown>[]> = TVariants extends readonly FixedSizeCodec<any>[]\n    ? FixedSizeCodec<\n          GetEncoderTypeFromVariants<TVariants>,\n          GetDecoderTypeFromVariants<TVariants> & GetEncoderTypeFromVariants<TVariants>\n      >\n    : Codec<\n          GetEncoderTypeFromVariants<TVariants>,\n          GetDecoderTypeFromVariants<TVariants> & GetEncoderTypeFromVariants<TVariants>\n      >;\n\n/**\n * Returns an encoder for union types.\n *\n * This encoder serializes values by selecting the correct variant encoder\n * based on the `getIndexFromValue` function.\n *\n * Unlike other codecs, this encoder does not store the variant index.\n * It is the user's responsibility to manage discriminators separately.\n *\n * For more details, see {@link getUnionCodec}.\n *\n * @typeParam TVariants - An array of encoders, each corresponding to a union variant.\n *\n * @param variants - The encoders for each variant of the union.\n * @param getIndexFromValue - A function that determines the variant index from the provided value.\n * @returns An `Encoder` for encoding union values.\n *\n * @example\n * Encoding a union of numbers and booleans.\n * ```ts\n * const encoder = getUnionEncoder(\n *   [getU16Encoder(), getBooleanEncoder()],\n *   value => (typeof value === 'number' ? 0 : 1)\n * );\n *\n * encoder.encode(42);\n * // 0x2a00\n * //    Encoded number (42) as `u16`\n *\n * encoder.encode(true);\n * // 0x01\n * //    Encoded boolean (`true`) as `u8`\n * ```\n *\n * @see {@link getUnionCodec}\n */\nexport function getUnionEncoder<const TVariants extends readonly Encoder<any>[]>(\n    variants: TVariants,\n    getIndexFromValue: (value: GetEncoderTypeFromVariants<TVariants>) => number,\n): UnionEncoder<TVariants> {\n    type TFrom = GetEncoderTypeFromVariants<TVariants>;\n    const fixedSize = getUnionFixedSize(variants);\n    const write: Encoder<TFrom>['write'] = (variant, bytes, offset) => {\n        const index = getIndexFromValue(variant);\n        assertValidVariantIndex(variants, index);\n        return variants[index].write(variant, bytes, offset);\n    };\n\n    if (fixedSize !== null) {\n        return createEncoder({ fixedSize, write }) as UnionEncoder<TVariants>;\n    }\n\n    const maxSize = getUnionMaxSize(variants);\n    return createEncoder({\n        ...(maxSize !== null ? { maxSize } : {}),\n        getSizeFromValue: variant => {\n            const index = getIndexFromValue(variant);\n            assertValidVariantIndex(variants, index);\n            return getEncodedSize(variant, variants[index]);\n        },\n        write,\n    }) as UnionEncoder<TVariants>;\n}\n\n/**\n * Returns a decoder for union types.\n *\n * This decoder deserializes values by selecting the correct variant decoder\n * based on the `getIndexFromBytes` function.\n *\n * Unlike other codecs, this decoder does not assume a stored discriminator.\n * It is the user's responsibility to manage discriminators separately.\n *\n * For more details, see {@link getUnionCodec}.\n *\n * @typeParam TVariants - An array of decoders, each corresponding to a union variant.\n *\n * @param variants - The decoders for each variant of the union.\n * @param getIndexFromBytes - A function that determines the variant index from the byte array.\n * @returns A `Decoder` for decoding union values.\n *\n * @example\n * Decoding a union of numbers and booleans.\n * ```ts\n * const decoder = getUnionDecoder(\n *   [getU16Decoder(), getBooleanDecoder()],\n *   (bytes, offset) => (bytes.length - offset > 1 ? 0 : 1)\n * );\n *\n * decoder.decode(new Uint8Array([0x2a, 0x00])); // 42\n * decoder.decode(new Uint8Array([0x01]));       // true\n * // Type is inferred as `number | boolean`\n * ```\n *\n * @see {@link getUnionCodec}\n */\nexport function getUnionDecoder<const TVariants extends readonly Decoder<any>[]>(\n    variants: TVariants,\n    getIndexFromBytes: (bytes: ReadonlyUint8Array, offset: Offset) => number,\n): UnionDecoder<TVariants> {\n    type TTo = GetDecoderTypeFromVariants<TVariants>;\n    const fixedSize = getUnionFixedSize(variants);\n    const read: Decoder<TTo>['read'] = (bytes, offset) => {\n        const index = getIndexFromBytes(bytes, offset);\n        assertValidVariantIndex(variants, index);\n        return variants[index].read(bytes, offset);\n    };\n\n    if (fixedSize !== null) {\n        return createDecoder({ fixedSize, read }) as UnionDecoder<TVariants>;\n    }\n\n    const maxSize = getUnionMaxSize(variants);\n    return createDecoder({ ...(maxSize !== null ? { maxSize } : {}), read }) as UnionDecoder<TVariants>;\n}\n\n/**\n * Returns a codec for encoding and decoding union types.\n *\n * This codec serializes and deserializes union values by selecting the correct variant\n * based on the provided index functions.\n *\n * Unlike the {@link getDiscriminatedUnionCodec}, this codec does not assume a stored\n * discriminator and must be used with an explicit mechanism for managing discriminators.\n *\n * @typeParam TVariants - An array of codecs, each corresponding to a union variant.\n *\n * @param variants - The codecs for each variant of the union.\n * @param getIndexFromValue - A function that determines the variant index from the provided value.\n * @param getIndexFromBytes - A function that determines the variant index from the byte array.\n * @returns A `Codec` for encoding and decoding union values.\n *\n * @example\n * Encoding and decoding a union of numbers and booleans.\n * ```ts\n * const codec = getUnionCodec(\n *   [getU16Codec(), getBooleanCodec()],\n *   value => (typeof value === 'number' ? 0 : 1),\n *   (bytes, offset) => (bytes.length - offset > 1 ? 0 : 1)\n * );\n *\n * const bytes1 = codec.encode(42); // 0x2a00\n * const value1: number | boolean = codec.decode(bytes1); // 42\n *\n * const bytes2 = codec.encode(true); // 0x01\n * const value2: number | boolean = codec.decode(bytes2); // true\n * ```\n *\n * @remarks\n * If you need a codec that includes a stored discriminator,\n * consider using {@link getDiscriminatedUnionCodec}.\n *\n * Separate {@link getUnionEncoder} and {@link getUnionDecoder} functions are also available.\n *\n * ```ts\n * const bytes = getUnionEncoder(variantEncoders, getIndexFromValue).encode(42);\n * const value = getUnionDecoder(variantDecoders, getIndexFromBytes).decode(bytes);\n * ```\n *\n * @see {@link getUnionEncoder}\n * @see {@link getUnionDecoder}\n * @see {@link getDiscriminatedUnionCodec}\n */\nexport function getUnionCodec<const TVariants extends readonly Codec<any>[]>(\n    variants: TVariants,\n    getIndexFromValue: (value: GetEncoderTypeFromVariants<TVariants>) => number,\n    getIndexFromBytes: (bytes: ReadonlyUint8Array, offset: Offset) => number,\n): UnionCodec<TVariants> {\n    return combineCodec(\n        getUnionEncoder(variants, getIndexFromValue),\n        getUnionDecoder(variants as readonly Decoder<any>[], getIndexFromBytes) as Decoder<\n            GetDecoderTypeFromVariants<TVariants> & GetEncoderTypeFromVariants<TVariants>\n        >,\n    ) as UnionCodec<TVariants>;\n}\n\nfunction assertValidVariantIndex(variants: readonly unknown[], index: number) {\n    if (typeof variants[index] === 'undefined') {\n        throw new SolanaError(SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE, {\n            maxRange: variants.length - 1,\n            minRange: 0,\n            variant: index,\n        });\n    }\n}\n\nfunction getUnionFixedSize<const TVariants extends readonly (Decoder<any> | Encoder<any>)[]>(variants: TVariants) {\n    if (variants.length === 0) return 0;\n    if (!isFixedSize(variants[0])) return null;\n    const variantSize = variants[0].fixedSize;\n    const sameSizedVariants = variants.every(variant => isFixedSize(variant) && variant.fixedSize === variantSize);\n    return sameSizedVariants ? variantSize : null;\n}\n\nfunction getUnionMaxSize<const TVariants extends readonly (Decoder<any> | Encoder<any>)[]>(variants: TVariants) {\n    return maxCodecSizes(variants.map(variant => getMaxSize(variant)));\n}\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 64-bit unsigned integers (`u64`).\n *\n * This encoder serializes `u64` values using 8 bytes.\n * Values can be provided as either `number` or `bigint`.\n *\n * For more details, see {@link getU64Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeEncoder<number | bigint, 8>` for encoding `u64` values.\n *\n * @example\n * Encoding a `u64` value.\n * ```ts\n * const encoder = getU64Encoder();\n * const bytes = encoder.encode(42); // 0x2a00000000000000\n * ```\n *\n * @see {@link getU64Codec}\n */\nexport const getU64Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 8> =>\n    numberEncoderFactory({\n        config,\n        name: 'u64',\n        range: [0n, BigInt('0xffffffffffffffff')],\n        set: (view, value, le) => view.setBigUint64(0, BigInt(value), le),\n        size: 8,\n    });\n\n/**\n * Returns a decoder for 64-bit unsigned integers (`u64`).\n *\n * This decoder deserializes `u64` values from 8 bytes.\n * The decoded value is always a `bigint`.\n *\n * For more details, see {@link getU64Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeDecoder<bigint, 8>` for decoding `u64` values.\n *\n * @example\n * Decoding a `u64` value.\n * ```ts\n * const decoder = getU64Decoder();\n * const value = decoder.decode(new Uint8Array([0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00])); // 42n\n * ```\n *\n * @see {@link getU64Codec}\n */\nexport const getU64Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<bigint, 8> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getBigUint64(0, le),\n        name: 'u64',\n        size: 8,\n    });\n\n/**\n * Returns a codec for encoding and decoding 64-bit unsigned integers (`u64`).\n *\n * This codec serializes `u64` values using 8 bytes.\n * Values can be provided as either `number` or `bigint`, but the decoded value is always a `bigint`.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number | bigint, bigint, 8>` for encoding and decoding `u64` values.\n *\n * @example\n * Encoding and decoding a `u64` value.\n * ```ts\n * const codec = getU64Codec();\n * const bytes = codec.encode(42); // 0x2a00000000000000\n * const value = codec.decode(bytes); // 42n\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getU64Codec({ endian: Endian.Big });\n * const bytes = codec.encode(42); // 0x000000000000002a\n * ```\n *\n * @remarks\n * This codec supports values between `0` and `2^64 - 1`.\n * Since JavaScript `number` cannot safely represent values beyond `2^53 - 1`, the decoded value is always a `bigint`.\n *\n * - If you need a smaller unsigned integer, consider using {@link getU32Codec} or {@link getU16Codec}.\n * - If you need a larger unsigned integer, consider using {@link getU128Codec}.\n * - If you need signed integers, consider using {@link getI64Codec}.\n *\n * Separate {@link getU64Encoder} and {@link getU64Decoder} functions are available.\n *\n * ```ts\n * const bytes = getU64Encoder().encode(42);\n * const value = getU64Decoder().decode(bytes);\n * ```\n *\n * @see {@link getU64Encoder}\n * @see {@link getU64Decoder}\n */\nexport const getU64Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, bigint, 8> =>\n    combineCodec(getU64Encoder(config), getU64Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 8-bit unsigned integers (`u8`).\n *\n * This encoder serializes `u8` values using a single byte.\n *\n * For more details, see {@link getU8Codec}.\n *\n * @returns A `FixedSizeEncoder<number | bigint, 1>` for encoding `u8` values.\n *\n * @example\n * Encoding a `u8` value.\n * ```ts\n * const encoder = getU8Encoder();\n * const bytes = encoder.encode(42); // 0x2a\n * ```\n *\n * @see {@link getU8Codec}\n */\nexport const getU8Encoder = (): FixedSizeEncoder<bigint | number, 1> =>\n    numberEncoderFactory({\n        name: 'u8',\n        range: [0, Number('0xff')],\n        set: (view, value) => view.setUint8(0, Number(value)),\n        size: 1,\n    });\n\n/**\n * Returns a decoder for 8-bit unsigned integers (`u8`).\n *\n * This decoder deserializes `u8` values from a single byte.\n *\n * For more details, see {@link getU8Codec}.\n *\n * @returns A `FixedSizeDecoder<number, 1>` for decoding `u8` values.\n *\n * @example\n * Decoding a `u8` value.\n * ```ts\n * const decoder = getU8Decoder();\n * const value = decoder.decode(new Uint8Array([0xff])); // 255\n * ```\n *\n * @see {@link getU8Codec}\n */\nexport const getU8Decoder = (): FixedSizeDecoder<number, 1> =>\n    numberDecoderFactory({\n        get: view => view.getUint8(0),\n        name: 'u8',\n        size: 1,\n    });\n\n/**\n * Returns a codec for encoding and decoding 8-bit unsigned integers (`u8`).\n *\n * This codec serializes `u8` values using a single byte.\n *\n * @returns A `FixedSizeCodec<number | bigint, number, 1>` for encoding and decoding `u8` values.\n *\n * @example\n * Encoding and decoding a `u8` value.\n * ```ts\n * const codec = getU8Codec();\n * const bytes = codec.encode(255); // 0xff\n * const value = codec.decode(bytes); // 255\n * ```\n *\n * @remarks\n * This codec supports values between `0` and `2^8 - 1` (0 to 255).\n * If you need larger integers, consider using {@link getU16Codec}, {@link getU32Codec}, or {@link getU64Codec}.\n * For signed integers, use {@link getI8Codec}.\n *\n * Separate {@link getU8Encoder} and {@link getU8Decoder} functions are available.\n *\n * ```ts\n * const bytes = getU8Encoder().encode(42);\n * const value = getU8Decoder().decode(bytes);\n * ```\n *\n * @see {@link getU8Encoder}\n * @see {@link getU8Decoder}\n */\nexport const getU8Codec = (): FixedSizeCodec<bigint | number, number, 1> =>\n    combineCodec(getU8Encoder(), getU8Decoder());\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n} from '@solana/codecs-core';\nimport { getU8Decoder, getU8Encoder, NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\nimport { SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT, SolanaError } from '@solana/errors';\n\nimport { getTupleDecoder, getTupleEncoder } from './tuple';\nimport { getUnionDecoder, getUnionEncoder } from './union';\nimport { DrainOuterGeneric } from './utils';\n\n/**\n * Represents a discriminated union using a specific discriminator property.\n *\n * A discriminated union is a TypeScript-friendly way to represent Rust-like enums.\n * Each variant in the union is distinguished by a shared discriminator property.\n *\n * @typeParam TDiscriminatorProperty - The name of the discriminator property.\n * @typeParam TDiscriminatorValue - The type of the discriminator value.\n *\n * @example\n * ```ts\n * type Message =\n *   | { __kind: 'Quit' } // Empty variant\n *   | { __kind: 'Write'; fields: [string] } // Tuple variant\n *   | { __kind: 'Move'; x: number; y: number }; // Struct variant\n * ```\n */\nexport type DiscriminatedUnion<\n    TDiscriminatorProperty extends string = '__kind',\n    TDiscriminatorValue extends string = string,\n> = {\n    [P in TDiscriminatorProperty]: TDiscriminatorValue;\n};\n\n/**\n * Extracts a variant from a discriminated union based on its discriminator value.\n *\n * @typeParam TUnion - The discriminated union type.\n * @typeParam TDiscriminatorProperty - The property used as the discriminator.\n * @typeParam TDiscriminatorValue - The specific variant to extract.\n *\n * @example\n * ```ts\n * type Message =\n *   | { __kind: 'Quit' }\n *   | { __kind: 'Write'; fields: [string] }\n *   | { __kind: 'Move'; x: number; y: number };\n *\n * type ClickEvent = GetDiscriminatedUnionVariant<Message, '__kind', 'Move'>;\n * // -> { __kind: 'Move'; x: number; y: number }\n * ```\n */\nexport type GetDiscriminatedUnionVariant<\n    TUnion extends DiscriminatedUnion<TDiscriminatorProperty>,\n    TDiscriminatorProperty extends string,\n    TDiscriminatorValue extends TUnion[TDiscriminatorProperty],\n> = Extract<TUnion, DiscriminatedUnion<TDiscriminatorProperty, TDiscriminatorValue>>;\n\n/**\n * Extracts a variant from a discriminated union without its discriminator property.\n *\n * @typeParam TUnion - The discriminated union type.\n * @typeParam TDiscriminatorProperty - The property used as the discriminator.\n * @typeParam TDiscriminatorValue - The specific variant to extract.\n *\n * @example\n * ```ts\n * type Message =\n *   | { __kind: 'Quit' }\n *   | { __kind: 'Write'; fields: [string] }\n *   | { __kind: 'Move'; x: number; y: number };\n *\n * type MoveContent = GetDiscriminatedUnionVariantContent<Message, '__kind', 'Move'>;\n * // -> { x: number; y: number }\n * ```\n */\nexport type GetDiscriminatedUnionVariantContent<\n    TUnion extends DiscriminatedUnion<TDiscriminatorProperty>,\n    TDiscriminatorProperty extends string,\n    TDiscriminatorValue extends TUnion[TDiscriminatorProperty],\n> = Omit<GetDiscriminatedUnionVariant<TUnion, TDiscriminatorProperty, TDiscriminatorValue>, TDiscriminatorProperty>;\n\n/**\n * Defines the configuration for discriminated union codecs.\n *\n * This configuration controls how the discriminator is stored and named.\n *\n * @typeParam TDiscriminatorProperty - The property name of the discriminator.\n * @typeParam TDiscriminatorSize - The codec used for the discriminator prefix.\n */\nexport type DiscriminatedUnionCodecConfig<\n    TDiscriminatorProperty extends string = '__kind',\n    TDiscriminatorSize = NumberCodec | NumberDecoder | NumberEncoder,\n> = {\n    /**\n     * The property name of the discriminator.\n     * @defaultValue `__kind`\n     */\n    discriminator?: TDiscriminatorProperty;\n    /**\n     * The codec used to encode/decode the discriminator prefix.\n     * @defaultValue `u8` prefix\n     */\n    size?: TDiscriminatorSize;\n};\n\ntype DiscriminatorValue = bigint | boolean | number | string | null | undefined;\ntype Variants<T> = readonly (readonly [DiscriminatorValue, T])[];\ntype ArrayIndices<T extends readonly unknown[]> = Exclude<Partial<T>['length'], T['length']> & number;\n\ntype GetEncoderTypeFromVariants<\n    TVariants extends Variants<Encoder<any>>,\n    TDiscriminatorProperty extends string,\n> = DrainOuterGeneric<{\n    [I in ArrayIndices<TVariants>]: (TVariants[I][1] extends Encoder<infer TFrom>\n        ? TFrom extends object\n            ? TFrom\n            : object\n        : never) & { [P in TDiscriminatorProperty]: TVariants[I][0] };\n}>[ArrayIndices<TVariants>];\n\ntype GetDecoderTypeFromVariants<\n    TVariants extends Variants<Decoder<any>>,\n    TDiscriminatorProperty extends string,\n> = DrainOuterGeneric<{\n    [I in ArrayIndices<TVariants>]: (TVariants[I][1] extends Decoder<infer TTo>\n        ? TTo extends object\n            ? TTo\n            : object\n        : never) & { [P in TDiscriminatorProperty]: TVariants[I][0] };\n}>[ArrayIndices<TVariants>];\n\ntype UnionEncoder<TVariants extends Variants<Encoder<unknown>>, TDiscriminatorProperty extends string> =\n    TVariants extends Variants<FixedSizeEncoder<any>>\n        ? FixedSizeEncoder<GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>>\n        : Encoder<GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>>;\n\ntype UnionDecoder<TVariants extends Variants<Decoder<unknown>>, TDiscriminatorProperty extends string> =\n    TVariants extends Variants<FixedSizeDecoder<any>>\n        ? FixedSizeDecoder<GetDecoderTypeFromVariants<TVariants, TDiscriminatorProperty>>\n        : Decoder<GetDecoderTypeFromVariants<TVariants, TDiscriminatorProperty>>;\n\ntype UnionCodec<TVariants extends Variants<Codec<unknown, unknown>>, TDiscriminatorProperty extends string> =\n    TVariants extends Variants<FixedSizeCodec<any, any>>\n        ? FixedSizeCodec<\n              GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>,\n              GetDecoderTypeFromVariants<TVariants, TDiscriminatorProperty> &\n                  GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>\n          >\n        : Codec<\n              GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>,\n              GetDecoderTypeFromVariants<TVariants, TDiscriminatorProperty> &\n                  GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>\n          >;\n\n/**\n * Returns an encoder for discriminated unions.\n *\n * This encoder serializes objects that follow the discriminated union pattern\n * by prefixing them with a numerical discriminator that represents their variant.\n *\n * Unlike {@link getUnionEncoder}, this encoder automatically extracts and processes\n * the discriminator property (default: `__kind`) from each variant.\n *\n * For more details, see {@link getDiscriminatedUnionCodec}.\n *\n * @typeParam TVariants - The variants of the discriminated union.\n * @typeParam TDiscriminatorProperty - The property used as the discriminator.\n *\n * @param variants - The variant encoders as `[discriminator, encoder]` pairs.\n * @param config - Configuration options for encoding.\n * @returns An `Encoder` for encoding discriminated union objects.\n *\n * @example\n * Encoding a discriminated union.\n * ```ts\n * type Message =\n *   | { __kind: 'Quit' } // Empty variant.\n *   | { __kind: 'Write'; fields: [string] } // Tuple variant.\n *   | { __kind: 'Move'; x: number; y: number }; // Struct variant.\n *\n * const messageEncoder = getDiscriminatedUnionEncoder([\n *   ['Quit', getUnitEncoder()],\n *   ['Write', getStructEncoder([['fields', getTupleEncoder([addCodecSizePrefix(getUtf8Encoder(), getU32Encoder())])]])],\n *   ['Move', getStructEncoder([['x', getI32Encoder()], ['y', getI32Encoder()]])]\n * ]);\n *\n * messageEncoder.encode({ __kind: 'Move', x: 5, y: 6 });\n * // 0x020500000006000000\n * //   | |        Field y (6)\n * //   |  Field x (5)\n * //    1-byte discriminator (Index 2  the \"Move\" variant)\n * ```\n *\n * @see {@link getDiscriminatedUnionCodec}\n */\nexport function getDiscriminatedUnionEncoder<\n    const TVariants extends Variants<Encoder<any>>,\n    const TDiscriminatorProperty extends string = '__kind',\n>(\n    variants: TVariants,\n    config: DiscriminatedUnionCodecConfig<TDiscriminatorProperty, NumberEncoder> = {},\n): UnionEncoder<TVariants, TDiscriminatorProperty> {\n    type TFrom = GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>;\n    const discriminatorProperty = (config.discriminator ?? '__kind') as TDiscriminatorProperty;\n    const prefix = config.size ?? getU8Encoder();\n    return getUnionEncoder(\n        variants.map(([, variant], index) =>\n            transformEncoder(getTupleEncoder([prefix, variant]), (value: TFrom): [number, TFrom] => [index, value]),\n        ),\n        value => getVariantDiscriminator(variants, value[discriminatorProperty]),\n    ) as UnionEncoder<TVariants, TDiscriminatorProperty>;\n}\n\n/**\n * Returns a decoder for discriminated unions.\n *\n * This decoder deserializes objects that follow the discriminated union pattern\n * by **reading a numerical discriminator** and mapping it to the corresponding variant.\n *\n * Unlike {@link getUnionDecoder}, this decoder automatically inserts the discriminator\n * property (default: `__kind`) into the decoded object.\n *\n * For more details, see {@link getDiscriminatedUnionCodec}.\n *\n * @typeParam TVariants - The variants of the discriminated union.\n * @typeParam TDiscriminatorProperty - The property used as the discriminator.\n *\n * @param variants - The variant decoders as `[discriminator, decoder]` pairs.\n * @param config - Configuration options for decoding.\n * @returns A `Decoder` for decoding discriminated union objects.\n *\n * @example\n * Decoding a discriminated union.\n * ```ts\n * type Message =\n *   | { __kind: 'Quit' } // Empty variant.\n *   | { __kind: 'Write'; fields: [string] } // Tuple variant.\n *   | { __kind: 'Move'; x: number; y: number }; // Struct variant.\n *\n * const messageDecoder = getDiscriminatedUnionDecoder([\n *   ['Quit', getUnitDecoder()],\n *   ['Write', getStructDecoder([['fields', getTupleDecoder([addCodecSizePrefix(getUtf8Decoder(), getU32Decoder())])]])],\n *   ['Move', getStructDecoder([['x', getI32Decoder()], ['y', getI32Decoder()]])]\n * ]);\n *\n * messageDecoder.decode(new Uint8Array([0x02,0x05,0x00,0x00,0x00,0x06,0x00,0x00,0x00]));\n * // { __kind: 'Move', x: 5, y: 6 }\n * ```\n *\n * @see {@link getDiscriminatedUnionCodec}\n */\nexport function getDiscriminatedUnionDecoder<\n    const TVariants extends Variants<Decoder<any>>,\n    const TDiscriminatorProperty extends string = '__kind',\n>(\n    variants: TVariants,\n    config: DiscriminatedUnionCodecConfig<TDiscriminatorProperty, NumberDecoder> = {},\n): UnionDecoder<TVariants, TDiscriminatorProperty> {\n    const discriminatorProperty = config.discriminator ?? '__kind';\n    const prefix = config.size ?? getU8Decoder();\n    return getUnionDecoder(\n        variants.map(([discriminator, variant]) =>\n            transformDecoder(getTupleDecoder([prefix, variant]), ([, value]) => ({\n                [discriminatorProperty]: discriminator,\n                ...value,\n            })),\n        ),\n        (bytes, offset) => Number(prefix.read(bytes, offset)[0]),\n    ) as UnionDecoder<TVariants, TDiscriminatorProperty>;\n}\n\n/**\n * Returns a codec for encoding and decoding {@link DiscriminatedUnion}.\n *\n * A {@link DiscriminatedUnion} is a TypeScript representation of Rust-like enums, where\n * each variant is distinguished by a discriminator field (default: `__kind`).\n *\n * This codec inserts a numerical prefix to represent the variant index.\n *\n * @typeParam TVariants - The variants of the discriminated union.\n * @typeParam TDiscriminatorProperty - The property used as the discriminator.\n *\n * @param variants - The variant codecs as `[discriminator, codec]` pairs.\n * @param config - Configuration options for encoding/decoding.\n * @returns A `Codec` for encoding and decoding discriminated union objects.\n *\n * @example\n * Encoding and decoding a discriminated union.\n * ```ts\n * type Message =\n *   | { __kind: 'Quit' } // Empty variant.\n *   | { __kind: 'Write'; fields: [string] } // Tuple variant.\n *   | { __kind: 'Move'; x: number; y: number }; // Struct variant.\n *\n * const messageCodec = getDiscriminatedUnionCodec([\n *   ['Quit', getUnitCodec()],\n *   ['Write', getStructCodec([['fields', getTupleCodec([addCodecSizePrefix(getUtf8Codec(), getU32Codec())])]])],\n *   ['Move', getStructCodec([['x', getI32Codec()], ['y', getI32Codec()]])]\n * ]);\n *\n * messageCodec.encode({ __kind: 'Move', x: 5, y: 6 });\n * // 0x020500000006000000\n * //   | |        Field y (6)\n * //   |  Field x (5)\n * //    1-byte discriminator (Index 2  the \"Move\" variant)\n *\n * const value = messageCodec.decode(bytes);\n * // { __kind: 'Move', x: 5, y: 6 }\n * ```\n *\n * @example\n * Using a `u32` discriminator instead of `u8`.\n * ```ts\n * const codec = getDiscriminatedUnionCodec([...], { size: getU32Codec() });\n *\n * codec.encode({ __kind: 'Quit' });\n * // 0x00000000\n * //   ------ 4-byte discriminator (Index 0)\n *\n * codec.decode(new Uint8Array([0x00, 0x00, 0x00, 0x00]));\n * // { __kind: 'Quit' }\n * ```\n *\n * @example\n * Customizing the discriminator property.\n * ```ts\n * const codec = getDiscriminatedUnionCodec([...], { discriminator: 'message' });\n *\n * codec.encode({ message: 'Quit' }); // 0x00\n * codec.decode(new Uint8Array([0x00])); // { message: 'Quit' }\n * ```\n *\n * @remarks\n * Separate `getDiscriminatedUnionEncoder` and `getDiscriminatedUnionDecoder` functions are available.\n *\n * ```ts\n * const bytes = getDiscriminatedUnionEncoder(variantEncoders).encode({ __kind: 'Quit' });\n * const message = getDiscriminatedUnionDecoder(variantDecoders).decode(bytes);\n * ```\n *\n * @see {@link getDiscriminatedUnionEncoder}\n * @see {@link getDiscriminatedUnionDecoder}\n */\nexport function getDiscriminatedUnionCodec<\n    const TVariants extends Variants<Codec<any, any>>,\n    const TDiscriminatorProperty extends string = '__kind',\n>(\n    variants: TVariants,\n    config: DiscriminatedUnionCodecConfig<TDiscriminatorProperty, NumberCodec> = {},\n): UnionCodec<TVariants, TDiscriminatorProperty> {\n    return combineCodec(\n        getDiscriminatedUnionEncoder(variants, config) as Encoder<\n            GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>\n        >,\n        getDiscriminatedUnionDecoder(variants, config) as Decoder<\n            GetDecoderTypeFromVariants<TVariants, TDiscriminatorProperty> &\n                GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>\n        >,\n    ) as UnionCodec<TVariants, TDiscriminatorProperty>;\n}\n\nfunction getVariantDiscriminator<const TVariants extends Variants<Decoder<any> | Encoder<any>>>(\n    variants: TVariants,\n    discriminatorValue: DiscriminatorValue,\n) {\n    const discriminator = variants.findIndex(([key]) => discriminatorValue === key);\n    if (discriminator < 0) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT, {\n            value: discriminatorValue,\n            variants: variants.map(([key]) => key),\n        });\n    }\n    return discriminator;\n}\n","/**\n * Defines the \"lookup object\" of an enum.\n *\n * @example\n * ```ts\n * enum Direction { Left, Right };\n * ```\n */\nexport type EnumLookupObject = { [key: string]: number | string };\n\n/**\n * Returns the allowed input for an enum.\n *\n * @example\n * ```ts\n * enum Direction { Left, Right };\n * type DirectionInput = GetEnumFrom<Direction>; // \"Left\" | \"Right\" | 0 | 1\n * ```\n */\nexport type GetEnumFrom<TEnum extends EnumLookupObject> = TEnum[keyof TEnum] | keyof TEnum;\n\n/**\n * Returns all the available variants of an enum.\n *\n * @example\n * ```ts\n * enum Direction { Left, Right };\n * type DirectionOutput = GetEnumTo<Direction>; // 0 | 1\n * ```\n */\nexport type GetEnumTo<TEnum extends EnumLookupObject> = TEnum[keyof TEnum];\n\nexport function getEnumStats(constructor: EnumLookupObject) {\n    const numericalValues = [...new Set(Object.values(constructor).filter(v => typeof v === 'number'))].sort();\n    const enumRecord = Object.fromEntries(Object.entries(constructor).slice(numericalValues.length)) as Record<\n        string,\n        number | string\n    >;\n    const enumKeys = Object.keys(enumRecord);\n    const enumValues = Object.values(enumRecord);\n    const stringValues: string[] = [\n        ...new Set([...enumKeys, ...enumValues.filter((v): v is string => typeof v === 'string')]),\n    ];\n\n    return { enumKeys, enumRecord, enumValues, numericalValues, stringValues };\n}\n\nexport function getEnumIndexFromVariant({\n    enumKeys,\n    enumValues,\n    variant,\n}: {\n    enumKeys: string[];\n    enumValues: (number | string)[];\n    variant: number | string | symbol;\n}): number {\n    const valueIndex = findLastIndex(enumValues, value => value === variant);\n    if (valueIndex >= 0) return valueIndex;\n    return enumKeys.findIndex(key => key === variant);\n}\n\nexport function getEnumIndexFromDiscriminator({\n    discriminator,\n    enumKeys,\n    enumValues,\n    useValuesAsDiscriminators,\n}: {\n    discriminator: number;\n    enumKeys: string[];\n    enumValues: (number | string)[];\n    useValuesAsDiscriminators: boolean;\n}): number {\n    if (!useValuesAsDiscriminators) {\n        return discriminator >= 0 && discriminator < enumKeys.length ? discriminator : -1;\n    }\n    return findLastIndex(enumValues, value => value === discriminator);\n}\n\nfunction findLastIndex<T>(array: Array<T>, predicate: (value: T, index: number, obj: T[]) => boolean): number {\n    let l = array.length;\n    while (l--) {\n        if (predicate(array[l], l, array)) return l;\n    }\n    return -1;\n}\n\nexport function formatNumericalValues(values: number[]): string {\n    if (values.length === 0) return '';\n    let range: [number, number] = [values[0], values[0]];\n    const ranges: string[] = [];\n    for (let index = 1; index < values.length; index++) {\n        const value = values[index];\n        if (range[1] + 1 === value) {\n            range[1] = value;\n        } else {\n            ranges.push(range[0] === range[1] ? `${range[0]}` : `${range[0]}-${range[1]}`);\n            range = [value, value];\n        }\n    }\n    ranges.push(range[0] === range[1] ? `${range[0]}` : `${range[0]}-${range[1]}`);\n    return ranges.join(', ');\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    FixedSizeNumberCodec,\n    FixedSizeNumberDecoder,\n    FixedSizeNumberEncoder,\n    getU8Decoder,\n    getU8Encoder,\n    NumberCodec,\n    NumberDecoder,\n    NumberEncoder,\n} from '@solana/codecs-numbers';\nimport {\n    SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS,\n    SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT,\n    SolanaError,\n} from '@solana/errors';\n\nimport {\n    EnumLookupObject,\n    formatNumericalValues,\n    GetEnumFrom,\n    getEnumIndexFromDiscriminator,\n    getEnumIndexFromVariant,\n    getEnumStats,\n    GetEnumTo,\n} from './enum-helpers';\n\n/**\n * Defines the configuration options for enum codecs.\n *\n * The `size` option determines the numerical encoding used for the enum's discriminant.\n * By default, enums are stored as a `u8` (1 byte).\n *\n * The `useValuesAsDiscriminators` option allows mapping the actual enum values\n * as discriminators instead of using their positional index.\n *\n * @typeParam TDiscriminator - A number codec, encoder, or decoder used for the discriminant.\n */\nexport type EnumCodecConfig<TDiscriminator extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The codec used to encode/decode the enum discriminator.\n     * @defaultValue `u8` discriminator.\n     */\n    size?: TDiscriminator;\n\n    /**\n     * If set to `true`, the enum values themselves will be used as discriminators.\n     * This is only valid for numerical enum values.\n     *\n     * @defaultValue `false`\n     */\n    useValuesAsDiscriminators?: boolean;\n};\n\n/**\n * Returns an encoder for enums.\n *\n * This encoder serializes enums as a numerical discriminator.\n * By default, the discriminator is based on the positional index of the enum variants.\n *\n * For more details, see {@link getEnumCodec}.\n *\n * @typeParam TEnum - The TypeScript enum or object mapping enum keys to values.\n *\n * @param constructor - The constructor of the enum.\n * @param config - Configuration options for encoding the enum.\n * @returns A `FixedSizeEncoder` or `VariableSizeEncoder` for encoding enums.\n *\n * @example\n * Encoding enum values.\n * ```ts\n * enum Direction { Up,  Down, Left, Right }\n * const encoder = getEnumEncoder(Direction);\n *\n * encoder.encode(Direction.Up);    // 0x00\n * encoder.encode(Direction.Down);  // 0x01\n * encoder.encode(Direction.Left);  // 0x02\n * encoder.encode(Direction.Right); // 0x03\n * ```\n *\n * @see {@link getEnumCodec}\n */\nexport function getEnumEncoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: Omit<EnumCodecConfig<NumberEncoder>, 'size'>,\n): FixedSizeEncoder<GetEnumFrom<TEnum>, 1>;\nexport function getEnumEncoder<TEnum extends EnumLookupObject, TSize extends number>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberEncoder> & { size: FixedSizeNumberEncoder<TSize> },\n): FixedSizeEncoder<GetEnumFrom<TEnum>, TSize>;\nexport function getEnumEncoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: EnumCodecConfig<NumberEncoder>,\n): VariableSizeEncoder<GetEnumFrom<TEnum>>;\nexport function getEnumEncoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberEncoder> = {},\n): Encoder<GetEnumFrom<TEnum>> {\n    const prefix = config.size ?? getU8Encoder();\n    const useValuesAsDiscriminators = config.useValuesAsDiscriminators ?? false;\n    const { enumKeys, enumValues, numericalValues, stringValues } = getEnumStats(constructor);\n    if (useValuesAsDiscriminators && enumValues.some(value => typeof value === 'string')) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS, {\n            stringValues: enumValues.filter((v): v is string => typeof v === 'string'),\n        });\n    }\n    return transformEncoder(prefix, (variant: GetEnumFrom<TEnum>): number => {\n        const index = getEnumIndexFromVariant({ enumKeys, enumValues, variant });\n        if (index < 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT, {\n                formattedNumericalValues: formatNumericalValues(numericalValues),\n                numericalValues,\n                stringValues,\n                variant,\n            });\n        }\n        return useValuesAsDiscriminators ? (enumValues[index] as number) : index;\n    });\n}\n\n/**\n * Returns a decoder for enums.\n *\n * This decoder deserializes enums from a numerical discriminator.\n * By default, the discriminator is based on the positional index of the enum variants.\n *\n * For more details, see {@link getEnumCodec}.\n *\n * @typeParam TEnum - The TypeScript enum or object mapping enum keys to values.\n *\n * @param constructor - The constructor of the enum.\n * @param config - Configuration options for decoding the enum.\n * @returns A `FixedSizeDecoder` or `VariableSizeDecoder` for decoding enums.\n *\n * @example\n * Decoding enum values.\n * ```ts\n * enum Direction { Up,  Down, Left, Right }\n * const decoder = getEnumDecoder(Direction);\n *\n * decoder.decode(new Uint8Array([0x00])); // Direction.Up\n * decoder.decode(new Uint8Array([0x01])); // Direction.Down\n * decoder.decode(new Uint8Array([0x02])); // Direction.Left\n * decoder.decode(new Uint8Array([0x03])); // Direction.Right\n * ```\n *\n * @see {@link getEnumCodec}\n */\nexport function getEnumDecoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: Omit<EnumCodecConfig<NumberDecoder>, 'size'>,\n): FixedSizeDecoder<GetEnumTo<TEnum>, 1>;\nexport function getEnumDecoder<TEnum extends EnumLookupObject, TSize extends number>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberDecoder> & { size: FixedSizeNumberDecoder<TSize> },\n): FixedSizeDecoder<GetEnumTo<TEnum>, TSize>;\nexport function getEnumDecoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: EnumCodecConfig<NumberDecoder>,\n): VariableSizeDecoder<GetEnumTo<TEnum>>;\nexport function getEnumDecoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberDecoder> = {},\n): Decoder<GetEnumTo<TEnum>> {\n    const prefix = config.size ?? getU8Decoder();\n    const useValuesAsDiscriminators = config.useValuesAsDiscriminators ?? false;\n    const { enumKeys, enumValues, numericalValues } = getEnumStats(constructor);\n    if (useValuesAsDiscriminators && enumValues.some(value => typeof value === 'string')) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS, {\n            stringValues: enumValues.filter((v): v is string => typeof v === 'string'),\n        });\n    }\n    return transformDecoder(prefix, (value: bigint | number): GetEnumTo<TEnum> => {\n        const discriminator = Number(value);\n        const index = getEnumIndexFromDiscriminator({\n            discriminator,\n            enumKeys,\n            enumValues,\n            useValuesAsDiscriminators,\n        });\n        if (index < 0) {\n            const validDiscriminators = useValuesAsDiscriminators\n                ? numericalValues\n                : [...Array(enumKeys.length).keys()];\n            throw new SolanaError(SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE, {\n                discriminator,\n                formattedValidDiscriminators: formatNumericalValues(validDiscriminators),\n                validDiscriminators,\n            });\n        }\n        return enumValues[index] as GetEnumTo<TEnum>;\n    });\n}\n\n/**\n * Returns a codec for encoding and decoding enums.\n *\n * This codec serializes enums as a numerical discriminator, allowing them\n * to be efficiently stored and reconstructed from binary data.\n *\n * By default, the discriminator is derived from the positional index\n * of the enum variant, but it can be configured to use the enum's numeric values instead.\n *\n * @typeParam TEnum - The TypeScript enum or object mapping enum keys to values.\n *\n * @param constructor - The constructor of the enum.\n * @param config - Configuration options for encoding and decoding the enum.\n * @returns A `FixedSizeCodec` or `VariableSizeCodec` for encoding and decoding enums.\n *\n * @example\n * Encoding and decoding enums using positional indexes.\n * ```ts\n * enum Direction { Up, Down, Left, Right }\n * const codec = getEnumCodec(Direction);\n *\n * codec.encode(Direction.Up);    // 0x00\n * codec.encode(Direction.Down);  // 0x01\n * codec.encode(Direction.Left);  // 0x02\n * codec.encode(Direction.Right); // 0x03\n *\n * codec.decode(new Uint8Array([0x00])); // Direction.Up\n * codec.decode(new Uint8Array([0x01])); // Direction.Down\n * codec.decode(new Uint8Array([0x02])); // Direction.Left\n * codec.decode(new Uint8Array([0x03])); // Direction.Right\n * ```\n *\n * @example\n * Encoding and decoding enums using their numeric values.\n * ```ts\n * enum GameDifficulty { Easy = 1, Normal = 4, Hard = 7, Expert = 9 }\n * const codec = getEnumCodec(GameDifficulty, { useValuesAsDiscriminators: true });\n *\n * codec.encode(GameDifficulty.Easy);   // 0x01\n * codec.encode(GameDifficulty.Normal); // 0x04\n * codec.encode(GameDifficulty.Hard);   // 0x07\n * codec.encode(GameDifficulty.Expert); // 0x09\n *\n * codec.decode(new Uint8Array([0x01])); // GameDifficulty.Easy\n * codec.decode(new Uint8Array([0x04])); // GameDifficulty.Normal\n * codec.decode(new Uint8Array([0x07])); // GameDifficulty.Hard\n * codec.decode(new Uint8Array([0x09])); // GameDifficulty.Expert\n * ```\n *\n * Note that, when using values as discriminators, the enum values must be numerical.\n * Otherwise, an error will be thrown.\n *\n * ```ts\n * enum GameDifficulty { Easy = 'EASY', Normal = 'NORMAL', Hard = 'HARD' }\n * getEnumCodec(GameDifficulty, { useValuesAsDiscriminators: true }); // Throws an error.\n * ```\n *\n * @example\n * Using a custom discriminator size.\n * ```ts\n * enum Status { Pending, Approved, Rejected }\n * const codec = getEnumCodec(Status, { size: getU16Codec() });\n *\n * codec.encode(Status.Pending);  // 0x0000\n * codec.encode(Status.Approved); // 0x0100\n * codec.encode(Status.Rejected); // 0x0200\n *\n * codec.decode(new Uint8Array([0x00, 0x00])); // Status.Pending\n * codec.decode(new Uint8Array([0x01, 0x00])); // Status.Approved\n * codec.decode(new Uint8Array([0x02, 0x00])); // Status.Rejected\n * ```\n *\n * @remarks\n * Separate {@link getEnumEncoder} and {@link getEnumDecoder} functions are available.\n *\n * ```ts\n * const bytes = getEnumEncoder(Direction).encode(Direction.Up);\n * const value = getEnumDecoder(Direction).decode(bytes);\n * ```\n *\n * @see {@link getEnumEncoder}\n * @see {@link getEnumDecoder}\n */\nexport function getEnumCodec<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: Omit<EnumCodecConfig<NumberCodec>, 'size'>,\n): FixedSizeCodec<GetEnumFrom<TEnum>, GetEnumTo<TEnum>, 1>;\nexport function getEnumCodec<TEnum extends EnumLookupObject, TSize extends number>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberCodec> & { size: FixedSizeNumberCodec<TSize> },\n): FixedSizeCodec<GetEnumFrom<TEnum>, GetEnumTo<TEnum>, TSize>;\nexport function getEnumCodec<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: EnumCodecConfig<NumberCodec>,\n): VariableSizeCodec<GetEnumFrom<TEnum>, GetEnumTo<TEnum>>;\nexport function getEnumCodec<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberCodec> = {},\n): Codec<GetEnumFrom<TEnum>, GetEnumTo<TEnum>> {\n    return combineCodec(getEnumEncoder(constructor, config), getEnumDecoder(constructor, config));\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { getTupleDecoder, getTupleEncoder } from './tuple';\n\n/**\n * Returns an encoder that prefixes encoded values with hidden data.\n *\n * This encoder applies a list of void encoders before encoding the main value.\n * The prefixed data is encoded before the main value without being exposed to the user.\n *\n * For more details, see {@link getHiddenPrefixCodec}.\n *\n * @typeParam TFrom - The type of the main value being encoded.\n *\n * @param encoder - The encoder for the main value.\n * @param prefixedEncoders - A list of void encoders that produce the hidden prefix.\n * @returns A `FixedSizeEncoder` or `VariableSizeEncoder` that encodes the value with a hidden prefix.\n *\n * @example\n * Prefixing a value with constants.\n * ```ts\n * const encoder = getHiddenPrefixEncoder(getUtf8Encoder(), [\n *   getConstantCodec(new Uint8Array([1, 2, 3])),\n *   getConstantCodec(new Uint8Array([4, 5, 6])),\n * ]);\n *\n * encoder.encode('Hello');\n * // 0x01020304050648656c6c6f\n * //   |     |     -- Our encoded value (\"Hello\").\n * //   |     -- Our second hidden prefix.\n * //   -- Our first hidden prefix.\n * ```\n *\n * @see {@link getHiddenPrefixCodec}\n */\nexport function getHiddenPrefixEncoder<TFrom>(\n    encoder: FixedSizeEncoder<TFrom>,\n    prefixedEncoders: readonly FixedSizeEncoder<void>[],\n): FixedSizeEncoder<TFrom>;\nexport function getHiddenPrefixEncoder<TFrom>(\n    encoder: Encoder<TFrom>,\n    prefixedEncoders: readonly Encoder<void>[],\n): VariableSizeEncoder<TFrom>;\nexport function getHiddenPrefixEncoder<TFrom>(\n    encoder: Encoder<TFrom>,\n    prefixedEncoders: readonly Encoder<void>[],\n): Encoder<TFrom> {\n    return transformEncoder(\n        getTupleEncoder([...prefixedEncoders, encoder]) as Encoder<readonly [...void[], TFrom]>,\n        (value: TFrom) => [...prefixedEncoders.map(() => undefined), value] as const,\n    );\n}\n\n/**\n * Returns a decoder that skips hidden prefixed data before decoding the main value.\n *\n * This decoder applies a list of void decoders before decoding the main value.\n * The prefixed data is skipped during decoding without being exposed to the user.\n *\n * For more details, see {@link getHiddenPrefixCodec}.\n *\n * @typeParam TTo - The type of the main value being decoded.\n *\n * @param decoder - The decoder for the main value.\n * @param prefixedDecoders - A list of void decoders that produce the hidden prefix.\n * @returns A `FixedSizeDecoder` or `VariableSizeDecoder` that decodes values while ignoring the hidden prefix.\n *\n * @example\n * Decoding a value with prefixed constants.\n * ```ts\n * const decoder = getHiddenPrefixDecoder(getUtf8Decoder(), [\n *   getConstantCodec(new Uint8Array([1, 2, 3])),\n *   getConstantCodec(new Uint8Array([4, 5, 6])),\n * ]);\n *\n * decoder.decode(new Uint8Array([1, 2, 3, 4, 5, 6, 0x48, 0x65, 0x6C, 0x6C, 0x6F]));\n * // 'Hello'\n * ```\n *\n * @see {@link getHiddenPrefixCodec}\n */\nexport function getHiddenPrefixDecoder<TTo>(\n    decoder: FixedSizeDecoder<TTo>,\n    prefixedDecoders: readonly FixedSizeDecoder<void>[],\n): FixedSizeDecoder<TTo>;\nexport function getHiddenPrefixDecoder<TTo>(\n    decoder: Decoder<TTo>,\n    prefixedDecoders: readonly Decoder<void>[],\n): VariableSizeDecoder<TTo>;\nexport function getHiddenPrefixDecoder<TTo>(\n    decoder: Decoder<TTo>,\n    prefixedDecoders: readonly Decoder<void>[],\n): Decoder<TTo> {\n    return transformDecoder(\n        getTupleDecoder([...prefixedDecoders, decoder]) as Decoder<readonly [...void[], TTo]>,\n        tuple => tuple[tuple.length - 1] as TTo,\n    );\n}\n\n/**\n * Returns a codec that encodes and decodes values with a hidden prefix.\n *\n * - **Encoding:** Prefixes the value with hidden data before encoding.\n * - **Decoding:** Skips the hidden prefix before decoding the main value.\n *\n * This is useful for any implicit metadata that should be present in\n * binary formats but omitted from the API.\n *\n * @typeParam TFrom - The type of the main value being encoded.\n * @typeParam TTo - The type of the main value being decoded.\n *\n * @param codec - The codec for the main value.\n * @param prefixedCodecs - A list of void codecs that produce the hidden prefix.\n * @returns A `FixedSizeCodec` or `VariableSizeCodec` for encoding and decoding values with a hidden prefix.\n *\n * @example\n * Encoding and decoding a value with prefixed constants.\n * ```ts\n * const codec = getHiddenPrefixCodec(getUtf8Codec(), [\n *   getConstantCodec(new Uint8Array([1, 2, 3])),\n *   getConstantCodec(new Uint8Array([4, 5, 6])),\n * ]);\n *\n * const bytes = codec.encode('Hello');\n * // 0x01020304050648656c6c6f\n * //   |     |     -- Our encoded value (\"Hello\").\n * //   |     -- Our second hidden prefix.\n * //   -- Our first hidden prefix.\n *\n * codec.decode(bytes);\n * // 'Hello'\n * ```\n *\n * @remarks\n * If all you need is padding zeroes before a value, consider using {@link padLeftCodec} instead.\n *\n * Separate {@link getHiddenPrefixEncoder} and {@link getHiddenPrefixDecoder} functions are available.\n *\n * ```ts\n * const bytes = getHiddenPrefixEncoder(getUtf8Encoder(), [\n *   getConstantEncoder(new Uint8Array([1, 2, 3])),\n *   getConstantEncoder(new Uint8Array([4, 5, 6])),\n * ]).encode('Hello');\n *\n * const value = getHiddenPrefixDecoder(getUtf8Decoder(), [\n *   getConstantDecoder(new Uint8Array([1, 2, 3])),\n *   getConstantDecoder(new Uint8Array([4, 5, 6])),\n * ]).decode(bytes);\n * ```\n *\n * @see {@link getHiddenPrefixEncoder}\n * @see {@link getHiddenPrefixDecoder}\n */\nexport function getHiddenPrefixCodec<TFrom, TTo extends TFrom>(\n    codec: FixedSizeCodec<TFrom, TTo>,\n    prefixedCodecs: readonly FixedSizeCodec<void>[],\n): FixedSizeCodec<TFrom, TTo>;\nexport function getHiddenPrefixCodec<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    prefixedCodecs: readonly Codec<void>[],\n): VariableSizeCodec<TFrom, TTo>;\nexport function getHiddenPrefixCodec<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    prefixedCodecs: readonly Codec<void>[],\n): Codec<TFrom, TTo> {\n    return combineCodec(getHiddenPrefixEncoder(codec, prefixedCodecs), getHiddenPrefixDecoder(codec, prefixedCodecs));\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { getTupleDecoder, getTupleEncoder } from './tuple';\n\n/**\n * Returns an encoder that appends hidden data after the encoded value.\n *\n * This encoder applies a list of void encoders after encoding the main value.\n * The suffixed data is encoded after the main value without being exposed to the user.\n *\n * For more details, see {@link getHiddenSuffixCodec}.\n *\n * @typeParam TFrom - The type of the main value being encoded.\n *\n * @param encoder - The encoder for the main value.\n * @param suffixedEncoders - A list of void encoders that produce the hidden suffix.\n * @returns A `FixedSizeEncoder` or `VariableSizeEncoder` that encodes the value with a hidden suffix.\n *\n * @example\n * Suffixing a value with constants.\n * ```ts\n * const encoder = getHiddenSuffixEncoder(getUtf8Encoder(), [\n *   getConstantCodec(new Uint8Array([1, 2, 3])),\n *   getConstantCodec(new Uint8Array([4, 5, 6])),\n * ]);\n *\n * encoder.encode('Hello');\n * // 0x48656c6c6f010203040506\n * //   |         |     -- Our second hidden suffix.\n * //   |         -- Our first hidden suffix.\n * //   -- Our encoded value (\"Hello\").\n * ```\n *\n * @see {@link getHiddenSuffixCodec}\n */\nexport function getHiddenSuffixEncoder<TFrom>(\n    encoder: FixedSizeEncoder<TFrom>,\n    suffixedEncoders: readonly FixedSizeEncoder<void>[],\n): FixedSizeEncoder<TFrom>;\nexport function getHiddenSuffixEncoder<TFrom>(\n    encoder: Encoder<TFrom>,\n    suffixedEncoders: readonly Encoder<void>[],\n): VariableSizeEncoder<TFrom>;\nexport function getHiddenSuffixEncoder<TFrom>(\n    encoder: Encoder<TFrom>,\n    suffixedEncoders: readonly Encoder<void>[],\n): Encoder<TFrom> {\n    return transformEncoder(\n        getTupleEncoder([encoder, ...suffixedEncoders]) as Encoder<readonly [TFrom, ...void[]]>,\n        (value: TFrom) => [value, ...suffixedEncoders.map(() => undefined)] as const,\n    );\n}\n\n/**\n * Returns a decoder that skips hidden suffixed data after decoding the main value.\n *\n * This decoder applies a list of void decoders after decoding the main value.\n * The suffixed data is skipped during decoding without being exposed to the user.\n *\n * For more details, see {@link getHiddenSuffixCodec}.\n *\n * @typeParam TTo - The type of the main value being decoded.\n *\n * @param decoder - The decoder for the main value.\n * @param suffixedDecoders - A list of void decoders that produce the hidden suffix.\n * @returns A `FixedSizeDecoder` or `VariableSizeDecoder` that decodes values while ignoring the hidden suffix.\n *\n * @example\n * Decoding a value with suffixed constants.\n * ```ts\n * const decoder = getHiddenSuffixDecoder(getUtf8Decoder(), [\n *   getConstantCodec(new Uint8Array([1, 2, 3])),\n *   getConstantCodec(new Uint8Array([4, 5, 6])),\n * ]);\n *\n * decoder.decode(new Uint8Array([0x48, 0x65, 0x6C, 0x6C, 0x6F, 1, 2, 3, 4, 5, 6]));\n * // 'Hello'\n * ```\n *\n * @see {@link getHiddenSuffixCodec}\n */\nexport function getHiddenSuffixDecoder<TTo>(\n    decoder: FixedSizeDecoder<TTo>,\n    suffixedDecoders: readonly FixedSizeDecoder<void>[],\n): FixedSizeDecoder<TTo>;\nexport function getHiddenSuffixDecoder<TTo>(\n    decoder: Decoder<TTo>,\n    suffixedDecoders: readonly Decoder<void>[],\n): VariableSizeDecoder<TTo>;\nexport function getHiddenSuffixDecoder<TTo>(\n    decoder: Decoder<TTo>,\n    suffixedDecoders: readonly Decoder<void>[],\n): Decoder<TTo> {\n    return transformDecoder(\n        getTupleDecoder([decoder, ...suffixedDecoders]) as Decoder<readonly [TTo, ...void[]]>,\n        tuple => tuple[0],\n    );\n}\n\n/**\n * Returns a codec that encodes and decodes values with a hidden suffix.\n *\n * - **Encoding:** Appends hidden data after encoding the main value.\n * - **Decoding:** Skips the hidden suffix after decoding the main value.\n *\n * This is useful for any implicit metadata that should be present in\n * binary formats but omitted from the API.\n *\n * @typeParam TFrom - The type of the main value being encoded.\n * @typeParam TTo - The type of the main value being decoded.\n *\n * @param codec - The codec for the main value.\n * @param suffixedCodecs - A list of void codecs that produce the hidden suffix.\n * @returns A `FixedSizeCodec` or `VariableSizeCodec` for encoding and decoding values with a hidden suffix.\n *\n * @example\n * Encoding and decoding a value with suffixed constants.\n * ```ts\n * const codec = getHiddenSuffixCodec(getUtf8Codec(), [\n *   getConstantCodec(new Uint8Array([1, 2, 3])),\n *   getConstantCodec(new Uint8Array([4, 5, 6])),\n * ]);\n *\n * const bytes = codec.encode('Hello');\n * // 0x48656c6c6f010203040506\n * //   |         |     -- Our second hidden suffix.\n * //   |         -- Our first hidden suffix.\n * //   -- Our encoded value (\"Hello\").\n *\n * codec.decode(bytes);\n * // 'Hello'\n * ```\n *\n * @remarks\n * If all you need is padding zeroes after a value, consider using {@link padRightCodec} instead.\n *\n * Separate {@link getHiddenSuffixEncoder} and {@link getHiddenSuffixDecoder} functions are available.\n *\n * ```ts\n * const bytes = getHiddenSuffixEncoder(getUtf8Encoder(), [\n *   getConstantEncoder(new Uint8Array([1, 2, 3])),\n *   getConstantEncoder(new Uint8Array([4, 5, 6])),\n * ]).encode('Hello');\n *\n * const value = getHiddenSuffixDecoder(getUtf8Decoder(), [\n *   getConstantDecoder(new Uint8Array([1, 2, 3])),\n *   getConstantDecoder(new Uint8Array([4, 5, 6])),\n * ]).decode(bytes);\n * ```\n *\n * @see {@link getHiddenSuffixEncoder}\n * @see {@link getHiddenSuffixDecoder}\n */\nexport function getHiddenSuffixCodec<TFrom, TTo extends TFrom>(\n    codec: FixedSizeCodec<TFrom, TTo>,\n    suffixedCodecs: readonly FixedSizeCodec<void>[],\n): FixedSizeCodec<TFrom, TTo>;\nexport function getHiddenSuffixCodec<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    suffixedCodecs: readonly Codec<void>[],\n): VariableSizeCodec<TFrom, TTo>;\nexport function getHiddenSuffixCodec<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    suffixedCodecs: readonly Codec<void>[],\n): Codec<TFrom, TTo> {\n    return combineCodec(getHiddenSuffixEncoder(codec, suffixedCodecs), getHiddenSuffixDecoder(codec, suffixedCodecs));\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    FixedSizeNumberCodec,\n    FixedSizeNumberDecoder,\n    FixedSizeNumberEncoder,\n    getU8Decoder,\n    getU8Encoder,\n    NumberCodec,\n    NumberDecoder,\n    NumberEncoder,\n} from '@solana/codecs-numbers';\nimport {\n    SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT,\n    SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE,\n    SolanaError,\n} from '@solana/errors';\n\n/**\n * Defines the configuration options for literal union codecs.\n *\n * A literal union codec encodes values from a predefined set of literals.\n * The `size` option determines the numerical encoding used for the discriminant.\n * By default, literals are stored as a `u8` (1 byte).\n *\n * @typeParam TDiscriminator - A number codec, encoder, or decoder used for the discriminant.\n */\nexport type LiteralUnionCodecConfig<TDiscriminator = NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The codec used to encode/decode the discriminator.\n     * @defaultValue `u8` discriminator.\n     */\n    size?: TDiscriminator;\n};\n\ntype Variant = bigint | boolean | number | string | null | undefined;\ntype GetTypeFromVariants<TVariants extends readonly Variant[]> = TVariants[number];\n\n/**\n * Returns an encoder for literal unions.\n *\n * This encoder serializes a value from a predefined set of literals\n * as a numerical index representing its position in the `variants` array.\n *\n * For more details, see {@link getLiteralUnionCodec}.\n *\n * @typeParam TVariants - A tuple of allowed literal values.\n *\n * @param variants - The possible literal values for the union.\n * @param config - Configuration options for encoding the literal union.\n * @returns A `FixedSizeEncoder` or `VariableSizeEncoder` for encoding literal unions.\n *\n * @example\n * Encoding a union of string literals.\n * ```ts\n * type Size = 'small' | 'medium' | 'large';\n * const sizeEncoder = getLiteralUnionEncoder(['small', 'medium', 'large']);\n *\n * sizeEncoder.encode('small');  // 0x00\n * sizeEncoder.encode('medium'); // 0x01\n * sizeEncoder.encode('large');  // 0x02\n * ```\n *\n * @see {@link getLiteralUnionCodec}\n */\nexport function getLiteralUnionEncoder<const TVariants extends readonly Variant[]>(\n    variants: TVariants,\n): FixedSizeEncoder<GetTypeFromVariants<TVariants>, 1>;\nexport function getLiteralUnionEncoder<const TVariants extends readonly Variant[], TSize extends number>(\n    variants: TVariants,\n    config: LiteralUnionCodecConfig<NumberEncoder> & { size: FixedSizeNumberEncoder<TSize> },\n): FixedSizeEncoder<GetTypeFromVariants<TVariants>, TSize>;\nexport function getLiteralUnionEncoder<const TVariants extends readonly Variant[]>(\n    variants: TVariants,\n    config?: LiteralUnionCodecConfig<NumberEncoder>,\n): VariableSizeEncoder<GetTypeFromVariants<TVariants>>;\nexport function getLiteralUnionEncoder<const TVariants extends readonly Variant[]>(\n    variants: TVariants,\n    config: LiteralUnionCodecConfig<NumberEncoder> = {},\n): Encoder<GetTypeFromVariants<TVariants>> {\n    const discriminator = config.size ?? getU8Encoder();\n    return transformEncoder(discriminator, variant => {\n        const index = variants.indexOf(variant);\n        if (index < 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT, {\n                value: variant,\n                variants,\n            });\n        }\n        return index;\n    });\n}\n\n/**\n * Returns a decoder for literal unions.\n *\n * This decoder deserializes a numerical index into a corresponding\n * value from a predefined set of literals.\n *\n * For more details, see {@link getLiteralUnionCodec}.\n *\n * @typeParam TVariants - A tuple of allowed literal values.\n *\n * @param variants - The possible literal values for the union.\n * @param config - Configuration options for decoding the literal union.\n * @returns A `FixedSizeDecoder` or `VariableSizeDecoder` for decoding literal unions.\n *\n * @example\n * Decoding a union of string literals.\n * ```ts\n * type Size = 'small' | 'medium' | 'large';\n * const sizeDecoder = getLiteralUnionDecoder(['small', 'medium', 'large']);\n *\n * sizeDecoder.decode(new Uint8Array([0x00])); // 'small'\n * sizeDecoder.decode(new Uint8Array([0x01])); // 'medium'\n * sizeDecoder.decode(new Uint8Array([0x02])); // 'large'\n * ```\n *\n * @see {@link getLiteralUnionCodec}\n */\nexport function getLiteralUnionDecoder<const TVariants extends readonly Variant[]>(\n    variants: TVariants,\n): FixedSizeDecoder<GetTypeFromVariants<TVariants>, 1>;\nexport function getLiteralUnionDecoder<const TVariants extends readonly Variant[], TSize extends number>(\n    variants: TVariants,\n    config: LiteralUnionCodecConfig<NumberDecoder> & { size: FixedSizeNumberDecoder<TSize> },\n): FixedSizeDecoder<GetTypeFromVariants<TVariants>, TSize>;\nexport function getLiteralUnionDecoder<const TVariants extends readonly Variant[]>(\n    variants: TVariants,\n    config?: LiteralUnionCodecConfig<NumberDecoder>,\n): VariableSizeDecoder<GetTypeFromVariants<TVariants>>;\nexport function getLiteralUnionDecoder<const TVariants extends readonly Variant[]>(\n    variants: TVariants,\n    config: LiteralUnionCodecConfig<NumberDecoder> = {},\n): Decoder<GetTypeFromVariants<TVariants>> {\n    const discriminator = config.size ?? getU8Decoder();\n    return transformDecoder(discriminator, (index: bigint | number) => {\n        if (index < 0 || index >= variants.length) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE, {\n                discriminator: index,\n                maxRange: variants.length - 1,\n                minRange: 0,\n            });\n        }\n        return variants[Number(index)];\n    });\n}\n\n/**\n * Returns a codec for encoding and decoding literal unions.\n *\n * A literal union codec serializes and deserializes values\n * from a predefined set of literals, using a numerical index\n * to represent each value in the `variants` array.\n *\n * This allows efficient storage and retrieval of common\n * predefined values such as enum-like structures in TypeScript.\n *\n * @typeParam TVariants - A tuple of allowed literal values.\n *\n * @param variants - The possible literal values for the union.\n * @param config - Configuration options for encoding and decoding the literal union.\n * @returns A `FixedSizeCodec` or `VariableSizeCodec` for encoding and decoding literal unions.\n *\n * @example\n * Encoding and decoding a union of string literals.\n * ```ts\n * type Size = 'small' | 'medium' | 'large';\n * const sizeCodec = getLiteralUnionCodec(['small', 'medium', 'large']);\n *\n * sizeCodec.encode('small');  // 0x00\n * sizeCodec.encode('medium'); // 0x01\n * sizeCodec.encode('large');  // 0x02\n *\n * sizeCodec.decode(new Uint8Array([0x00])); // 'small'\n * sizeCodec.decode(new Uint8Array([0x01])); // 'medium'\n * sizeCodec.decode(new Uint8Array([0x02])); // 'large'\n * ```\n *\n * @example\n * Encoding and decoding a union of number literals.\n * ```ts\n * type Level = 10 | 20 | 30;\n * const levelCodec = getLiteralUnionCodec([10, 20, 30]);\n *\n * levelCodec.encode(10);  // 0x00\n * levelCodec.encode(20);  // 0x01\n * levelCodec.encode(30);  // 0x02\n *\n * levelCodec.decode(new Uint8Array([0x00])); // 10\n * levelCodec.decode(new Uint8Array([0x01])); // 20\n * levelCodec.decode(new Uint8Array([0x02])); // 30\n * ```\n *\n * @example\n * Using a custom discriminator size with different variant types.\n * ```ts\n * type MaybeBoolean = false | true | \"either\";\n * const codec = getLiteralUnionCodec([false, true, 'either'], { size: getU16Codec() });\n *\n * codec.encode(false);    // 0x0000\n * codec.encode(true);     // 0x0100\n * codec.encode('either'); // 0x0200\n *\n * codec.decode(new Uint8Array([0x00, 0x00])); // false\n * codec.decode(new Uint8Array([0x01, 0x00])); // true\n * codec.decode(new Uint8Array([0x02, 0x00])); // 'either'\n * ```\n *\n * @remarks\n * Separate {@link getLiteralUnionEncoder} and {@link getLiteralUnionDecoder} functions are available.\n *\n * ```ts\n * const bytes = getLiteralUnionEncoder(['red', 'green', 'blue']).encode('green');\n * const value = getLiteralUnionDecoder(['red', 'green', 'blue']).decode(bytes);\n * ```\n *\n * @see {@link getLiteralUnionEncoder}\n * @see {@link getLiteralUnionDecoder}\n */\nexport function getLiteralUnionCodec<const TVariants extends readonly Variant[]>(\n    variants: TVariants,\n): FixedSizeCodec<GetTypeFromVariants<TVariants>, GetTypeFromVariants<TVariants>, 1>;\nexport function getLiteralUnionCodec<const TVariants extends readonly Variant[], TSize extends number>(\n    variants: TVariants,\n    config: LiteralUnionCodecConfig<NumberCodec> & { size: FixedSizeNumberCodec<TSize> },\n): FixedSizeCodec<GetTypeFromVariants<TVariants>, GetTypeFromVariants<TVariants>, TSize>;\nexport function getLiteralUnionCodec<const TVariants extends readonly Variant[]>(\n    variants: TVariants,\n    config?: LiteralUnionCodecConfig<NumberCodec>,\n): VariableSizeCodec<GetTypeFromVariants<TVariants>>;\nexport function getLiteralUnionCodec<const TVariants extends readonly Variant[]>(\n    variants: TVariants,\n    config: LiteralUnionCodecConfig<NumberCodec> = {},\n): Codec<GetTypeFromVariants<TVariants>> {\n    return combineCodec(getLiteralUnionEncoder(variants, config), getLiteralUnionDecoder(variants, config));\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\n\nimport { ArrayLikeCodecSize, getArrayDecoder, getArrayEncoder } from './array';\nimport { getTupleDecoder, getTupleEncoder } from './tuple';\n\n/**\n * Defines the configuration options for map codecs.\n *\n * The `size` option determines how the number of entries in the map is stored.\n * It can be:\n * - A {@link NumberCodec} to prefix the map with its size.\n * - A fixed number of entries.\n * - `'remainder'`, which infers the number of entries based on the remaining bytes.\n *   This option is only available for fixed-size keys and values.\n *\n * @typeParam TPrefix - A number codec, encoder, or decoder used for the size prefix.\n */\nexport type MapCodecConfig<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The size of the map.\n     * @defaultValue u32 prefix.\n     */\n    size?: ArrayLikeCodecSize<TPrefix>;\n};\n\n/**\n * Returns an encoder for maps.\n *\n * This encoder serializes maps where the keys and values are encoded\n * using the provided key and value encoders. The number of entries\n * is determined by the `size` configuration.\n *\n * For more details, see {@link getMapCodec}.\n *\n * @typeParam TFromKey - The type of the keys before encoding.\n * @typeParam TFromValue - The type of the values before encoding.\n *\n * @param key - The encoder for the map's keys.\n * @param value - The encoder for the map's values.\n * @param config - Configuration options for encoding the map.\n * @returns A `FixedSizeEncoder` or `VariableSizeEncoder` for encoding maps.\n *\n * @example\n * Encoding a map with a `u32` size prefix.\n * ```ts\n * const encoder = getMapEncoder(fixCodecSize(getUtf8Encoder(), 5), getU8Encoder());\n * const bytes = encoder.encode(new Map([['alice', 42], ['bob', 5]]));\n * // 0x02000000616c6963652a626f62000005\n * //   |       |         | |          Value (5)\n * //   |       |         |  Key (\"bob\", 5 bytes fixed, null-padded)\n * //   |       |          Value (42)\n * //   |        Key (\"alice\", 5 bytes fixed)\n * //    4-byte prefix (2 entries)\n * ```\n *\n * @see {@link getMapCodec}\n */\nexport function getMapEncoder<TFromKey, TFromValue>(\n    key: Encoder<TFromKey>,\n    value: Encoder<TFromValue>,\n    config: MapCodecConfig<NumberEncoder> & { size: 0 },\n): FixedSizeEncoder<Map<TFromKey, TFromValue>, 0>;\nexport function getMapEncoder<TFromKey, TFromValue>(\n    key: FixedSizeEncoder<TFromKey>,\n    value: FixedSizeEncoder<TFromValue>,\n    config: MapCodecConfig<NumberEncoder> & { size: number },\n): FixedSizeEncoder<Map<TFromKey, TFromValue>>;\nexport function getMapEncoder<TFromKey, TFromValue>(\n    key: Encoder<TFromKey>,\n    value: Encoder<TFromValue>,\n    config?: MapCodecConfig<NumberEncoder>,\n): VariableSizeEncoder<Map<TFromKey, TFromValue>>;\nexport function getMapEncoder<TFromKey, TFromValue>(\n    key: Encoder<TFromKey>,\n    value: Encoder<TFromValue>,\n    config: MapCodecConfig<NumberEncoder> = {},\n): Encoder<Map<TFromKey, TFromValue>> {\n    return transformEncoder(\n        getArrayEncoder(getTupleEncoder([key, value]), config as object),\n        (map: Map<TFromKey, TFromValue>): [TFromKey, TFromValue][] => [...map.entries()],\n    );\n}\n\n/**\n * Returns a decoder for maps.\n *\n * This decoder deserializes maps where the keys and values are decoded\n * using the provided key and value decoders. The number of entries\n * is determined by the `size` configuration.\n *\n * For more details, see {@link getMapCodec}.\n *\n * @typeParam TToKey - The type of the keys after decoding.\n * @typeParam TToValue - The type of the values after decoding.\n *\n * @param key - The decoder for the map's keys.\n * @param value - The decoder for the map's values.\n * @param config - Configuration options for decoding the map.\n * @returns A `FixedSizeDecoder` or `VariableSizeDecoder` for decoding maps.\n *\n * @example\n * Decoding a map with a `u32` size prefix.\n * ```ts\n * const decoder = getMapDecoder(fixCodecSize(getUtf8Decoder(), 5), getU8Decoder());\n * const map = decoder.decode(new Uint8Array([\n *   0x02,0x00,0x00,0x00,0x61,0x6c,0x69,0x63,0x65,0x2a,0x62,0x6f,0x62,0x00,0x00,0x05\n * ]));\n * // new Map([['alice', 42], ['bob', 5]])\n * ```\n *\n * @see {@link getMapCodec}\n */\nexport function getMapDecoder<TToKey, TToValue>(\n    key: Decoder<TToKey>,\n    value: Decoder<TToValue>,\n    config: MapCodecConfig<NumberDecoder> & { size: 0 },\n): FixedSizeDecoder<Map<TToKey, TToValue>, 0>;\nexport function getMapDecoder<TToKey, TToValue>(\n    key: FixedSizeDecoder<TToKey>,\n    value: FixedSizeDecoder<TToValue>,\n    config: MapCodecConfig<NumberDecoder> & { size: number },\n): FixedSizeDecoder<Map<TToKey, TToValue>>;\nexport function getMapDecoder<TToKey, TToValue>(\n    key: Decoder<TToKey>,\n    value: Decoder<TToValue>,\n    config?: MapCodecConfig<NumberDecoder>,\n): VariableSizeDecoder<Map<TToKey, TToValue>>;\nexport function getMapDecoder<TToKey, TToValue>(\n    key: Decoder<TToKey>,\n    value: Decoder<TToValue>,\n    config: MapCodecConfig<NumberDecoder> = {},\n): Decoder<Map<TToKey, TToValue>> {\n    return transformDecoder(\n        getArrayDecoder(getTupleDecoder([key, value]), config as object) as Decoder<[TToKey, TToValue][]>,\n        (entries: [TToKey, TToValue][]): Map<TToKey, TToValue> => new Map(entries),\n    );\n}\n\n/**\n * Returns a codec for encoding and decoding maps.\n *\n * This codec serializes maps where the key/value pairs are encoded\n * and decoded one after another using the provided key and value codecs.\n * The number of entries is determined by the `size` configuration and\n * defaults to a `u32` size prefix.\n *\n * @typeParam TFromKey - The type of the keys before encoding.\n * @typeParam TFromValue - The type of the values before encoding.\n * @typeParam TToKey - The type of the keys after decoding.\n * @typeParam TToValue - The type of the values after decoding.\n *\n * @param key - The codec for the map's keys.\n * @param value - The codec for the map's values.\n * @param config - Configuration options for encoding and decoding the map.\n * @returns A `FixedSizeCodec` or `VariableSizeCodec` for encoding and decoding maps.\n *\n * @example\n * Encoding and decoding a map with a `u32` size prefix (default).\n * ```ts\n * const codec = getMapCodec(fixCodecSize(getUtf8Codec(), 5), getU8Codec());\n * const bytes = codec.encode(new Map([['alice', 42], ['bob', 5]]));\n * // 0x02000000616c6963652a626f62000005\n * //   |       |         | |          Value (5)\n * //   |       |         |  Key (\"bob\", 5 bytes fixed, null-padded)\n * //   |       |          Value (42)\n * //   |        Key (\"alice\", 5 bytes fixed)\n * //    4-byte prefix (2 entries)\n *\n * const map = codec.decode(bytes);\n * // new Map([['alice', 42], ['bob', 5]])\n * ```\n *\n * @example\n * Encoding and decoding a map with a `u16` size prefix.\n * ```ts\n * const codec = getMapCodec(fixCodecSize(getUtf8Codec(), 5), getU8Codec(), { size: getU16Codec() });\n * const bytes = codec.encode(new Map([['alice', 42], ['bob', 5]]));\n * // 0x0200616c6963652a626f62000005\n * //   |   |         | |          Value (5)\n * //   |   |         |  Key (\"bob\", 5 bytes fixed, null-padded)\n * //   |   |          Value (42)\n * //   |    Key (\"alice\", 5 bytes fixed)\n * //    2-byte prefix (2 entries)\n *\n * const map = codec.decode(bytes);\n * // new Map([['alice', 42], ['bob', 5]])\n * ```\n *\n * @example\n * Encoding and decoding a fixed-size map.\n * ```ts\n * const codec = getMapCodec(fixCodecSize(getUtf8Codec(), 5), getU8Codec(), { size: 2 });\n * const bytes = codec.encode(new Map([['alice', 42], ['bob', 5]]));\n * // 0x616c6963652a626f62000005\n * //   |         | |          Value (5)\n * //   |         |  Key (\"bob\", 5 bytes fixed, null-padded)\n * //   |          Value (42)\n * //    Key (\"alice\", 5 bytes fixed)\n *\n * const map = codec.decode(bytes);\n * // new Map([['alice', 42], ['bob', 5]])\n * ```\n *\n * @example\n * Encoding and decoding a map with remainder size.\n * ```ts\n * const codec = getMapCodec(fixCodecSize(getUtf8Codec(), 5), getU8Codec(), { size: 'remainder' });\n * const bytes = codec.encode(new Map([['alice', 42], ['bob', 5]]));\n * // 0x616c6963652a626f62000005\n * //   |         | |          Value (5)\n * //   |         |  Key (\"bob\", 5 bytes fixed, null-padded)\n * //   |          Value (42)\n * //    Key (\"alice\", 5 bytes fixed)\n * // No size prefix, the size is inferred from the remaining bytes.\n *\n * const map = codec.decode(bytes);\n * // new Map([['alice', 42], ['bob', 5]])\n * ```\n *\n * @remarks\n * Separate {@link getMapEncoder} and {@link getMapDecoder} functions are available.\n * ```ts\n * const bytes = getMapEncoder(fixCodecSize(getUtf8Encoder(), 5), getU8Encoder()).encode(new Map([['alice', 42]]));\n * const map = getMapDecoder(fixCodecSize(getUtf8Decoder(), 5), getU8Decoder()).decode(bytes);\n * ```\n *\n * @see {@link getMapEncoder}\n * @see {@link getMapDecoder}\n */\nexport function getMapCodec<\n    TFromKey,\n    TFromValue,\n    TToKey extends TFromKey = TFromKey,\n    TToValue extends TFromValue = TFromValue,\n>(\n    key: Codec<TFromKey, TToKey>,\n    value: Codec<TFromValue, TToValue>,\n    config: MapCodecConfig<NumberCodec> & { size: 0 },\n): FixedSizeCodec<Map<TFromKey, TFromValue>, Map<TToKey, TToValue>, 0>;\nexport function getMapCodec<\n    TFromKey,\n    TFromValue,\n    TToKey extends TFromKey = TFromKey,\n    TToValue extends TFromValue = TFromValue,\n>(\n    key: FixedSizeCodec<TFromKey, TToKey>,\n    value: FixedSizeCodec<TFromValue, TToValue>,\n    config: MapCodecConfig<NumberCodec> & { size: number },\n): FixedSizeCodec<Map<TFromKey, TFromValue>, Map<TToKey, TToValue>>;\nexport function getMapCodec<\n    TFromKey,\n    TFromValue,\n    TToKey extends TFromKey = TFromKey,\n    TToValue extends TFromValue = TFromValue,\n>(\n    key: Codec<TFromKey, TToKey>,\n    value: Codec<TFromValue, TToValue>,\n    config?: MapCodecConfig<NumberCodec>,\n): VariableSizeCodec<Map<TFromKey, TFromValue>, Map<TToKey, TToValue>>;\nexport function getMapCodec<\n    TFromKey,\n    TFromValue,\n    TToKey extends TFromKey = TFromKey,\n    TToValue extends TFromValue = TFromValue,\n>(\n    key: Codec<TFromKey, TToKey>,\n    value: Codec<TFromValue, TToValue>,\n    config: MapCodecConfig<NumberCodec> = {},\n): Codec<Map<TFromKey, TFromValue>, Map<TToKey, TToValue>> {\n    return combineCodec(getMapEncoder(key, value, config as object), getMapDecoder(key, value, config as object));\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    ReadonlyUint8Array,\n} from '@solana/codecs-core';\n\n/**\n * Returns an encoder for `void` values.\n *\n * This encoder writes nothing to the byte array and has a fixed size of 0 bytes.\n * It is useful when working with structures that require a no-op encoder,\n * such as empty variants in {@link getDiscriminatedUnionEncoder}.\n *\n * For more details, see {@link getUnitCodec}.\n *\n * @returns A `FixedSizeEncoder<void, 0>`, representing an empty encoder.\n *\n * @example\n * Encoding a `void` value.\n * ```ts\n * getUnitEncoder().encode(undefined); // Produces an empty byte array.\n * ```\n *\n * @see {@link getUnitCodec}\n */\nexport function getUnitEncoder(): FixedSizeEncoder<void, 0> {\n    return createEncoder({\n        fixedSize: 0,\n        write: (_value, _bytes, offset) => offset,\n    });\n}\n\n/**\n * Returns a decoder for `void` values.\n *\n * This decoder always returns `undefined` and has a fixed size of 0 bytes.\n * It is useful when working with structures that require a no-op decoder,\n * such as empty variants in {@link getDiscriminatedUnionDecoder}.\n *\n * For more details, see {@link getUnitCodec}.\n *\n * @returns A `FixedSizeDecoder<void, 0>`, representing an empty decoder.\n *\n * @example\n * Decoding a `void` value.\n * ```ts\n * getUnitDecoder().decode(anyBytes); // Returns `undefined`.\n * ```\n *\n * @see {@link getUnitCodec}\n */\nexport function getUnitDecoder(): FixedSizeDecoder<void, 0> {\n    return createDecoder({\n        fixedSize: 0,\n        read: (_bytes: ReadonlyUint8Array | Uint8Array, offset) => [undefined, offset],\n    });\n}\n\n/**\n * Returns a codec for `void` values.\n *\n * This codec does nothing when encoding or decoding and has a fixed size of 0 bytes.\n * Namely, it always returns `undefined` when decoding and produces an empty byte array when encoding.\n *\n * This can be useful when working with structures that require a no-op codec,\n * such as empty variants in {@link getDiscriminatedUnionCodec}.\n *\n * @returns A `FixedSizeCodec<void, void, 0>`, representing an empty codec.\n *\n * @example\n * Encoding and decoding a `void` value.\n * ```ts\n * const codec = getUnitCodec();\n *\n * codec.encode(undefined); // Produces an empty byte array.\n * codec.decode(new Uint8Array([])); // Returns `undefined`.\n * ```\n *\n * @example\n * Using unit codecs as empty variants in a discriminated union.\n * ```ts\n * type Message =\n *   | { __kind: 'Enter' }\n *   | { __kind: 'Leave' }\n *   | { __kind: 'Move'; x: number; y: number };\n *\n * const messageCodec = getDiscriminatedUnionCodec([\n *   ['Enter', getUnitCodec()], // <- No-op codec for empty data\n *   ['Leave', getUnitCodec()], // <- No-op codec for empty data\n *   ['Move', getStructCodec([...])]\n * ]);\n * ```\n *\n * @remarks\n * Separate {@link getUnitEncoder} and {@link getUnitDecoder} functions are available.\n *\n * ```ts\n * const bytes = getUnitEncoder().encode();\n * const value = getUnitDecoder().decode(bytes);\n * ```\n *\n * @see {@link getUnitEncoder}\n * @see {@link getUnitDecoder}\n */\nexport function getUnitCodec(): FixedSizeCodec<void, void, 0> {\n    return combineCodec(getUnitEncoder(), getUnitDecoder());\n}\n","import {\n    assertIsFixedSize,\n    Codec,\n    combineCodec,\n    containsBytes,\n    Decoder,\n    Encoder,\n    fixDecoderSize,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    fixEncoderSize,\n    ReadonlyUint8Array,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    FixedSizeNumberCodec,\n    FixedSizeNumberDecoder,\n    FixedSizeNumberEncoder,\n    getU8Decoder,\n    getU8Encoder,\n    NumberCodec,\n    NumberDecoder,\n    NumberEncoder,\n} from '@solana/codecs-numbers';\n\nimport { getBooleanDecoder, getBooleanEncoder } from './boolean';\nimport { getConstantDecoder, getConstantEncoder } from './constant';\nimport { getTupleDecoder, getTupleEncoder } from './tuple';\nimport { getUnionDecoder, getUnionEncoder } from './union';\nimport { getUnitDecoder, getUnitEncoder } from './unit';\n\n/**\n * Defines the configuration options for nullable codecs.\n *\n * This configuration controls how nullable values are encoded and decoded.\n *\n * By default, nullable values are prefixed with a `u8` (0 = `null`, 1 = present).\n * The `noneValue` and `prefix` options allow customizing this behavior.\n *\n * @typeParam TPrefix - A number codec, encoder, or decoder used as the presence prefix.\n *\n * @see {@link getNullableEncoder}\n * @see {@link getNullableDecoder}\n * @see {@link getNullableCodec}\n */\nexport type NullableCodecConfig<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * Specifies how `null` values are represented in the encoded data.\n     *\n     * - By default, `null` values are omitted from encoding.\n     * - `'zeroes'`: The bytes allocated for the value are filled with zeroes. This requires a fixed-size codec.\n     * - Custom byte array: `null` values are replaced with a predefined byte sequence. This results in a variable-size codec.\n     *\n     * @defaultValue No explicit `noneValue` is used; `null` values are omitted.\n     */\n    noneValue?: ReadonlyUint8Array | 'zeroes';\n\n    /**\n     * The presence prefix used to distinguish between `null` and present values.\n     *\n     * - By default, a `u8` prefix is used (`0 = null`, `1 = present`).\n     * - Custom number codec: Allows defining a different number size for the prefix.\n     * - `null`: No prefix is used; `noneValue` (if provided) determines `null`.\n     *   If no `noneValue` is set, `null` is identified by the absence of bytes.\n     *\n     * @defaultValue `u8` prefix.\n     */\n    prefix?: TPrefix | null;\n};\n\n/**\n * Returns an encoder for optional values, allowing `null` values to be encoded.\n *\n * This encoder serializes an optional value using a configurable approach:\n * - By default, a `u8` prefix is used (0 = `null`, 1 = present). This can be customized or disabled.\n * - If `noneValue: 'zeroes'` is set, `null` values are encoded as zeroes.\n * - If `noneValue` is a byte array, `null` values are replaced with the provided constant.\n *\n * For more details, see {@link getNullableCodec}.\n *\n * @typeParam TFrom - The type of the main value being encoded.\n *\n * @param item - The encoder for the value that may be present.\n * @param config - Configuration options for encoding optional values.\n * @returns A `FixedSizeEncoder` or `VariableSizeEncoder` for encoding nullable values.\n *\n * @example\n * Encoding an optional number.\n * ```ts\n * const encoder = getNullableEncoder(getU32Encoder());\n *\n * encoder.encode(null); // 0x00\n * encoder.encode(42);   // 0x012a000000\n * ```\n *\n * @see {@link getNullableCodec}\n */\nexport function getNullableEncoder<TFrom, TSize extends number>(\n    item: FixedSizeEncoder<TFrom, TSize>,\n    config: NullableCodecConfig<NumberEncoder> & { noneValue: 'zeroes'; prefix: null },\n): FixedSizeEncoder<TFrom | null, TSize>;\nexport function getNullableEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: NullableCodecConfig<FixedSizeNumberEncoder> & { noneValue: 'zeroes' },\n): FixedSizeEncoder<TFrom | null>;\nexport function getNullableEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: NullableCodecConfig<NumberEncoder> & { noneValue: 'zeroes' },\n): VariableSizeEncoder<TFrom | null>;\nexport function getNullableEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config?: NullableCodecConfig<NumberEncoder> & { noneValue?: ReadonlyUint8Array },\n): VariableSizeEncoder<TFrom | null>;\nexport function getNullableEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: NullableCodecConfig<NumberEncoder> = {},\n): Encoder<TFrom | null> {\n    const prefix = (() => {\n        if (config.prefix === null) {\n            return transformEncoder(getUnitEncoder(), (_boolean: boolean) => undefined);\n        }\n        return getBooleanEncoder({ size: config.prefix ?? getU8Encoder() });\n    })();\n    const noneValue = (() => {\n        if (config.noneValue === 'zeroes') {\n            assertIsFixedSize(item);\n            return fixEncoderSize(getUnitEncoder(), item.fixedSize);\n        }\n        if (!config.noneValue) {\n            return getUnitEncoder();\n        }\n        return getConstantEncoder(config.noneValue);\n    })();\n\n    return getUnionEncoder(\n        [\n            transformEncoder(getTupleEncoder([prefix, noneValue]), (_value: null): [boolean, void] => [\n                false,\n                undefined,\n            ]),\n            transformEncoder(getTupleEncoder([prefix, item]), (value: TFrom): [boolean, TFrom] => [true, value]),\n        ],\n        variant => Number(variant !== null),\n    );\n}\n\n/**\n * Returns a decoder for optional values, allowing `null` values to be recognized.\n *\n * This decoder deserializes an optional value using a configurable approach:\n * - By default, a `u8` prefix is used (0 = `null`, 1 = present). This can be customized or disabled.\n * - If `noneValue: 'zeroes'` is set, `null` values are identified by zeroes.\n * - If `noneValue` is a byte array, `null` values match the provided constant.\n *\n * For more details, see {@link getNullableCodec}.\n *\n * @typeParam TTo - The type of the main value being decoded.\n *\n * @param item - The decoder for the value that may be present.\n * @param config - Configuration options for decoding optional values.\n * @returns A `FixedSizeDecoder` or `VariableSizeDecoder` for decoding nullable values.\n *\n * @example\n * Decoding an optional number.\n * ```ts\n * const decoder = getNullableDecoder(getU32Decoder());\n *\n * decoder.decode(new Uint8Array([0x00])); // null\n * decoder.decode(new Uint8Array([0x01, 0x2a, 0x00, 0x00, 0x00])); // 42\n * ```\n *\n * @see {@link getNullableCodec}\n */\nexport function getNullableDecoder<TTo, TSize extends number>(\n    item: FixedSizeDecoder<TTo, TSize>,\n    config: NullableCodecConfig<NumberDecoder> & { noneValue: 'zeroes'; prefix: null },\n): FixedSizeDecoder<TTo | null, TSize>;\nexport function getNullableDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: NullableCodecConfig<FixedSizeNumberDecoder> & { noneValue: 'zeroes' },\n): FixedSizeDecoder<TTo | null>;\nexport function getNullableDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: NullableCodecConfig<NumberDecoder> & { noneValue: 'zeroes' },\n): VariableSizeDecoder<TTo | null>;\nexport function getNullableDecoder<TTo>(\n    item: Decoder<TTo>,\n    config?: NullableCodecConfig<NumberDecoder> & { noneValue?: ReadonlyUint8Array },\n): VariableSizeDecoder<TTo | null>;\nexport function getNullableDecoder<TTo>(\n    item: Decoder<TTo>,\n    config: NullableCodecConfig<NumberDecoder> = {},\n): Decoder<TTo | null> {\n    const prefix = (() => {\n        if (config.prefix === null) {\n            return transformDecoder(getUnitDecoder(), () => false);\n        }\n        return getBooleanDecoder({ size: config.prefix ?? getU8Decoder() });\n    })();\n    const noneValue = (() => {\n        if (config.noneValue === 'zeroes') {\n            assertIsFixedSize(item);\n            return fixDecoderSize(getUnitDecoder(), item.fixedSize);\n        }\n        if (!config.noneValue) {\n            return getUnitDecoder();\n        }\n        return getConstantDecoder(config.noneValue);\n    })();\n\n    return getUnionDecoder(\n        [\n            transformDecoder(getTupleDecoder([prefix, noneValue]), () => null),\n            transformDecoder(getTupleDecoder([prefix, item]), ([, value]): TTo => value),\n        ],\n        (bytes, offset) => {\n            if (config.prefix === null && !config.noneValue) {\n                return Number(offset < bytes.length);\n            }\n            if (config.prefix === null && config.noneValue != null) {\n                const zeroValue =\n                    config.noneValue === 'zeroes' ? new Uint8Array(noneValue.fixedSize).fill(0) : config.noneValue;\n                return containsBytes(bytes, zeroValue, offset) ? 0 : 1;\n            }\n            return Number(prefix.read(bytes, offset)[0]);\n        },\n    );\n}\n\n/**\n * Returns a codec for encoding and decoding optional values, allowing `null` values to be handled.\n *\n * This codec serializes and deserializes optional values using a configurable approach:\n * - By default, a `u8` prefix is used (0 = `null`, 1 = present).\n *    This can be customized using a custom number codec or even disabled by setting\n *    the `prefix` to `null`.\n * - If `noneValue: 'zeroes'` is set, `null` values are encoded/decoded as zeroes.\n * - If `noneValue` is a byte array, `null` values are represented by the provided constant.\n *\n * For more details on the configuration options, see {@link NullableCodecConfig}.\n *\n * @typeParam TFrom - The type of the main value being encoded.\n * @typeParam TTo - The type of the main value being decoded.\n *\n * @param item - The codec for the value that may be present.\n * @param config - Configuration options for encoding and decoding optional values.\n * @returns A `FixedSizeCodec` or `VariableSizeCodec` for encoding and decoding nullable values.\n *\n * @example\n * Encoding and decoding an optional number using a `u8` prefix (default).\n * ```ts\n * const codec = getNullableCodec(getU32Codec());\n *\n * codec.encode(null); // 0x00\n * codec.encode(42);   // 0x012a000000\n *\n * codec.decode(new Uint8Array([0x00])); // null\n * codec.decode(new Uint8Array([0x01, 0x2a, 0x00, 0x00, 0x00])); // 42\n * ```\n *\n * @example\n * Encoding and decoding an optional number using a fixed-size codec, by filling `null` values with zeroes.\n * ```ts\n * const codec = getNullableCodec(getU32Codec(), { noneValue: 'zeroes' });\n *\n * codec.encode(null); // 0x0000000000\n * codec.encode(42);   // 0x012a000000\n *\n * codec.decode(new Uint8Array([0x00, 0x00, 0x00, 0x00, 0x00])); // null\n * codec.decode(new Uint8Array([0x01, 0x2a, 0x00, 0x00, 0x00])); // 42\n * ```\n *\n * @example\n * Encoding and decoding `null` values with zeroes and no prefix.\n * ```ts\n * const codec = getNullableCodec(getU32Codec(), {\n *   noneValue: 'zeroes',\n *   prefix: null,\n * });\n *\n * codec.encode(null); // 0x00000000\n * codec.encode(42);   // 0x2a000000\n *\n * codec.decode(new Uint8Array([0x00, 0x00, 0x00, 0x00])); // null\n * codec.decode(new Uint8Array([0x2a, 0x00, 0x00, 0x00])); // 42\n * ```\n *\n * @example\n * Encoding and decoding `null` values with a custom byte sequence and no prefix.\n * ```ts\n * const codec = getNullableCodec(getU16Codec(), {\n *   noneValue: new Uint8Array([0xff, 0xff]),\n *   prefix: null,\n * });\n *\n * codec.encode(null); // 0xffff\n * codec.encode(42); // 0x2a00\n *\n * codec.decode(new Uint8Array([0xff, 0xff])); // null\n * codec.decode(new Uint8Array([0x2a, 0x00])); // 42\n * ```\n *\n * @example\n * Identifying `null` values by the absence of bytes.\n * ```ts\n * const codec = getNullableCodec(getU16Codec(), { prefix: null });\n *\n * codec.encode(null); // Empty bytes\n * codec.encode(42); // 0x2a00\n *\n * codec.decode(new Uint8Array([])); // null\n * codec.decode(new Uint8Array([0x2a, 0x00])); // 42\n * ```\n *\n * @remarks\n * Separate {@link getNullableEncoder} and {@link getNullableDecoder} functions are available.\n *\n * ```ts\n * const bytes = getNullableEncoder(getU32Encoder()).encode(42);\n * const value = getNullableDecoder(getU32Decoder()).decode(bytes);\n * ```\n *\n * @see {@link getNullableEncoder}\n * @see {@link getNullableDecoder}\n */\nexport function getNullableCodec<TFrom, TTo extends TFrom, TSize extends number>(\n    item: FixedSizeCodec<TFrom, TTo, TSize>,\n    config: NullableCodecConfig<NumberCodec> & { noneValue: 'zeroes'; prefix: null },\n): FixedSizeCodec<TFrom | null, TTo | null, TSize>;\nexport function getNullableCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: NullableCodecConfig<FixedSizeNumberCodec> & { noneValue: 'zeroes' },\n): FixedSizeCodec<TFrom | null, TTo | null>;\nexport function getNullableCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: NullableCodecConfig<NumberCodec> & { noneValue: 'zeroes' },\n): VariableSizeCodec<TFrom | null, TTo | null>;\nexport function getNullableCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config?: NullableCodecConfig<NumberCodec> & { noneValue?: ReadonlyUint8Array },\n): VariableSizeCodec<TFrom | null, TTo | null>;\nexport function getNullableCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: NullableCodecConfig<NumberCodec> = {},\n): Codec<TFrom | null, TTo | null> {\n    type ConfigCast = NullableCodecConfig<NumberCodec> & { noneValue?: ReadonlyUint8Array };\n    return combineCodec(\n        getNullableEncoder<TFrom>(item, config as ConfigCast),\n        getNullableDecoder<TTo>(item, config as ConfigCast),\n    );\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\n\nimport { ArrayLikeCodecSize, getArrayDecoder, getArrayEncoder } from './array';\n\n/**\n * Defines the configuration options for set codecs.\n *\n * This configuration allows specifying how the size of the set is encoded.\n * The `size` option can be:\n *\n * - A {@link NumberCodec}, {@link NumberEncoder}, or {@link NumberDecoder} to store the size as a prefix.\n * - A fixed number of items, enforcing a strict length.\n * - The string `'remainder'` to infer the set size from the remaining bytes (only for fixed-size items).\n *\n * @typeParam TPrefix - The type used for encoding the size of the set.\n */\nexport type SetCodecConfig<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The size encoding strategy for the set.\n     * @defaultValue Uses a `u32` prefix.\n     */\n    size?: ArrayLikeCodecSize<TPrefix>;\n};\n\n/**\n * Returns an encoder for sets of items.\n *\n * This encoder serializes `Set<T>` values by encoding each item using the provided item encoder.\n * The number of items is stored as a prefix using a `u32` codec by default.\n *\n * For more details, see {@link getSetCodec}.\n *\n * @typeParam TFrom - The type of the items in the set before encoding.\n *\n * @param item - The encoder to use for each set item.\n * @param config - Optional configuration specifying the size strategy.\n * @returns An `Encoder<Set<TFrom>>` for encoding sets of items.\n *\n * @example\n * Encoding a set of `u8` numbers.\n * ```ts\n * const encoder = getSetEncoder(getU8Encoder());\n * const bytes = encoder.encode(new Set([1, 2, 3]));\n * // 0x03000000010203\n * //   |       -- 3 items of 1 byte each.\n * //   -- 4-byte prefix indicating 3 items.\n * ```\n *\n * @see {@link getSetCodec}\n */\nexport function getSetEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: SetCodecConfig<NumberEncoder> & { size: 0 },\n): FixedSizeEncoder<Set<TFrom>, 0>;\nexport function getSetEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: SetCodecConfig<NumberEncoder> & { size: number },\n): FixedSizeEncoder<Set<TFrom>>;\nexport function getSetEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config?: SetCodecConfig<NumberEncoder>,\n): VariableSizeEncoder<Set<TFrom>>;\nexport function getSetEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: SetCodecConfig<NumberEncoder> = {},\n): Encoder<Set<TFrom>> {\n    return transformEncoder(getArrayEncoder(item, config as object), (set: Set<TFrom>): TFrom[] => [...set]);\n}\n\n/**\n * Returns a decoder for sets of items.\n *\n * This decoder deserializes a `Set<T>` from a byte array by decoding each item using the provided item decoder.\n * The number of items is determined by a `u32` size prefix by default.\n *\n * For more details, see {@link getSetCodec}.\n *\n * @typeParam TTo - The type of the items in the set after decoding.\n *\n * @param item - The decoder to use for each set item.\n * @param config - Optional configuration specifying the size strategy.\n * @returns A `Decoder<Set<TTo>>` for decoding sets of items.\n *\n * @example\n * Decoding a set of `u8` numbers.\n * ```ts\n * const decoder = getSetDecoder(getU8Decoder());\n * const value = decoder.decode(new Uint8Array([0x03, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03]));\n * // new Set([1, 2, 3])\n * ```\n *\n * @see {@link getSetCodec}\n */\nexport function getSetDecoder<TTo>(\n    item: Decoder<TTo>,\n    config: SetCodecConfig<NumberDecoder> & { size: 0 },\n): FixedSizeDecoder<Set<TTo>, 0>;\nexport function getSetDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: SetCodecConfig<NumberDecoder> & { size: number },\n): FixedSizeDecoder<Set<TTo>>;\nexport function getSetDecoder<TTo>(\n    item: Decoder<TTo>,\n    config?: SetCodecConfig<NumberDecoder>,\n): VariableSizeDecoder<Set<TTo>>;\nexport function getSetDecoder<TTo>(item: Decoder<TTo>, config: SetCodecConfig<NumberDecoder> = {}): Decoder<Set<TTo>> {\n    return transformDecoder(getArrayDecoder(item, config as object), (entries: TTo[]): Set<TTo> => new Set(entries));\n}\n\n/**\n * Returns a codec for encoding and decoding sets of items.\n *\n * This codec serializes `Set<T>` values by encoding each item using the provided item codec.\n * The number of items is stored as a prefix using a `u32` codec by default.\n *\n * @typeParam TFrom - The type of the items in the set before encoding.\n * @typeParam TTo - The type of the items in the set after decoding.\n *\n * @param item - The codec to use for each set item.\n * @param config - Optional configuration specifying the size strategy.\n * @returns A `Codec<Set<TFrom>, Set<TTo>>` for encoding and decoding sets.\n *\n * @example\n * Encoding and decoding a set of `u8` numbers.\n * ```ts\n * const codec = getSetCodec(getU8Codec());\n * const bytes = codec.encode(new Set([1, 2, 3]));\n * // 0x03000000010203\n * //   |       -- 3 items of 1 byte each.\n * //   -- 4-byte prefix indicating 3 items.\n *\n * const value = codec.decode(bytes);\n * // new Set([1, 2, 3])\n * ```\n *\n * @example\n * Using a `u16` prefix for size.\n * ```ts\n * const codec = getSetCodec(getU8Codec(), { size: getU16Codec() });\n * const bytes = codec.encode(new Set([1, 2, 3]));\n * // 0x0300010203\n * //   |   -- 3 items of 1 byte each.\n * //   -- 2-byte prefix indicating 3 items.\n * ```\n *\n * @example\n * Using a fixed-size set.\n * ```ts\n * const codec = getSetCodec(getU8Codec(), { size: 3 });\n * const bytes = codec.encode(new Set([1, 2, 3]));\n * // 0x010203\n * //   -- Exactly 3 items of 1 byte each.\n * ```\n *\n * @example\n * Using remainder to infer set size.\n * ```ts\n * const codec = getSetCodec(getU8Codec(), { size: 'remainder' });\n * const bytes = codec.encode(new Set([1, 2, 3]));\n * // 0x010203\n * //   -- 3 items of 1 byte each. The size is inferred from the remaining bytes.\n * ```\n *\n * @remarks\n * Separate {@link getSetEncoder} and {@link getSetDecoder} functions are available.\n *\n * ```ts\n * const bytes = getSetEncoder(getU8Encoder()).encode(new Set([1, 2, 3]));\n * const value = getSetDecoder(getU8Decoder()).decode(bytes);\n * ```\n *\n * @see {@link getSetEncoder}\n * @see {@link getSetDecoder}\n */\nexport function getSetCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: SetCodecConfig<NumberCodec> & { size: 0 },\n): FixedSizeCodec<Set<TFrom>, Set<TTo>, 0>;\nexport function getSetCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: SetCodecConfig<NumberCodec> & { size: number },\n): FixedSizeCodec<Set<TFrom>, Set<TTo>>;\nexport function getSetCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config?: SetCodecConfig<NumberCodec>,\n): VariableSizeCodec<Set<TFrom>, Set<TTo>>;\nexport function getSetCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: SetCodecConfig<NumberCodec> = {},\n): Codec<Set<TFrom>, Set<TTo>> {\n    return combineCodec(getSetEncoder(item, config as object), getSetDecoder(item, config as object));\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n    Codec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    getEncodedSize,\n    ReadonlyUint8Array,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { DrainOuterGeneric, getFixedSize, getMaxSize, sumCodecSizes } from './utils';\n\n/**\n * Represents a collection of named fields used in struct codecs.\n *\n * Each field is defined as a tuple containing:\n * - A string key representing the field name.\n * - A codec used to encode and decode the field's value.\n *\n * @typeParam T - The codec type used for each field.\n */\ntype Fields<T> = readonly (readonly [string, T])[];\n\ntype ArrayIndices<T extends readonly unknown[]> = Exclude<Partial<T>['length'], T['length']> & number;\n\n/**\n * Infers the TypeScript type for an object that can be encoded using a struct codec.\n *\n * This type maps the provided field encoders to their corresponding values.\n *\n * @typeParam TFields - The fields of the struct, each paired with an encoder.\n */\ntype GetEncoderTypeFromFields<TFields extends Fields<Encoder<any>>> = DrainOuterGeneric<{\n    [I in ArrayIndices<TFields> as TFields[I][0]]: TFields[I][1] extends Encoder<infer TFrom> ? TFrom : never;\n}>;\n\n/**\n * Infers the TypeScript type for an object that can be decoded using a struct codec.\n *\n * This type maps the provided field decoders to their corresponding values.\n *\n * @typeParam TFields - The fields of the struct, each paired with a decoder.\n */\ntype GetDecoderTypeFromFields<TFields extends Fields<Decoder<any>>> = DrainOuterGeneric<{\n    [I in ArrayIndices<TFields> as TFields[I][0]]: TFields[I][1] extends Decoder<infer TTo> ? TTo : never;\n}>;\n\n/**\n * Returns an encoder for custom objects.\n *\n * This encoder serializes an object by encoding its fields sequentially,\n * using the provided field encoders.\n *\n * For more details, see {@link getStructCodec}.\n *\n * @typeParam TFields - The fields of the struct, each paired with an encoder.\n *\n * @param fields - The name and encoder of each field.\n * @returns A `FixedSizeEncoder` or `VariableSizeEncoder` for encoding custom objects.\n *\n * @example\n * Encoding a custom struct.\n * ```ts\n * const encoder = getStructEncoder([\n *   ['name', fixCodecSize(getUtf8Encoder(), 5)],\n *   ['age', getU8Encoder()]\n * ]);\n *\n * const bytes = encoder.encode({ name: 'Alice', age: 42 });\n * // 0x416c6963652a\n * //   |          Age (42)\n * //    Name (\"Alice\")\n * ```\n *\n * @see {@link getStructCodec}\n */\nexport function getStructEncoder<const TFields extends Fields<FixedSizeEncoder<any>>>(\n    fields: TFields,\n): FixedSizeEncoder<GetEncoderTypeFromFields<TFields>>;\nexport function getStructEncoder<const TFields extends Fields<Encoder<any>>>(\n    fields: TFields,\n): VariableSizeEncoder<GetEncoderTypeFromFields<TFields>>;\nexport function getStructEncoder<const TFields extends Fields<Encoder<any>>>(\n    fields: TFields,\n): Encoder<GetEncoderTypeFromFields<TFields>> {\n    type TFrom = GetEncoderTypeFromFields<TFields>;\n    const fieldCodecs = fields.map(([, codec]) => codec);\n    const fixedSize = sumCodecSizes(fieldCodecs.map(getFixedSize));\n    const maxSize = sumCodecSizes(fieldCodecs.map(getMaxSize)) ?? undefined;\n\n    return createEncoder({\n        ...(fixedSize === null\n            ? {\n                  getSizeFromValue: (value: TFrom) =>\n                      fields\n                          .map(([key, codec]) => getEncodedSize(value[key as keyof TFrom], codec))\n                          .reduce((all, one) => all + one, 0),\n                  maxSize,\n              }\n            : { fixedSize }),\n        write: (struct: TFrom, bytes, offset) => {\n            fields.forEach(([key, codec]) => {\n                offset = codec.write(struct[key as keyof TFrom], bytes, offset);\n            });\n            return offset;\n        },\n    });\n}\n\n/**\n * Returns a decoder for custom objects.\n *\n * This decoder deserializes an object by decoding its fields sequentially,\n * using the provided field decoders.\n *\n * For more details, see {@link getStructCodec}.\n *\n * @typeParam TFields - The fields of the struct, each paired with a decoder.\n *\n * @param fields - The name and decoder of each field.\n * @returns A `FixedSizeDecoder` or `VariableSizeDecoder` for decoding custom objects.\n *\n * @example\n * Decoding a custom struct.\n * ```ts\n * const decoder = getStructDecoder([\n *   ['name', fixCodecSize(getUtf8Decoder(), 5)],\n *   ['age', getU8Decoder()]\n * ]);\n *\n * const struct = decoder.decode(new Uint8Array([\n *   0x41,0x6c,0x69,0x63,0x65,0x2a\n * ]));\n * // { name: 'Alice', age: 42 }\n * ```\n *\n * @see {@link getStructCodec}\n */\nexport function getStructDecoder<const TFields extends Fields<FixedSizeDecoder<any>>>(\n    fields: TFields,\n): FixedSizeDecoder<GetDecoderTypeFromFields<TFields>>;\nexport function getStructDecoder<const TFields extends Fields<Decoder<any>>>(\n    fields: TFields,\n): VariableSizeDecoder<GetDecoderTypeFromFields<TFields>>;\nexport function getStructDecoder<const TFields extends Fields<Decoder<any>>>(\n    fields: TFields,\n): Decoder<GetDecoderTypeFromFields<TFields>> {\n    type TTo = GetDecoderTypeFromFields<TFields>;\n    const fieldCodecs = fields.map(([, codec]) => codec);\n    const fixedSize = sumCodecSizes(fieldCodecs.map(getFixedSize));\n    const maxSize = sumCodecSizes(fieldCodecs.map(getMaxSize)) ?? undefined;\n\n    return createDecoder({\n        ...(fixedSize === null ? { maxSize } : { fixedSize }),\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset) => {\n            const struct = {} as TTo;\n            fields.forEach(([key, codec]) => {\n                const [value, newOffset] = codec.read(bytes, offset);\n                offset = newOffset;\n                struct[key as keyof TTo] = value;\n            });\n            return [struct, offset];\n        },\n    });\n}\n\n/**\n * Returns a codec for encoding and decoding custom objects.\n *\n * This codec serializes objects by encoding and decoding each field sequentially.\n *\n * @typeParam TFields - The fields of the struct, each paired with a codec.\n *\n * @param fields - The name and codec of each field.\n * @returns A `FixedSizeCodec` or `VariableSizeCodec` for encoding and decoding custom objects.\n *\n * @example\n * Encoding and decoding a custom struct.\n * ```ts\n * const codec = getStructCodec([\n *   ['name', fixCodecSize(getUtf8Codec(), 5)],\n *   ['age', getU8Codec()]\n * ]);\n *\n * const bytes = codec.encode({ name: 'Alice', age: 42 });\n * // 0x416c6963652a\n * //   |          Age (42)\n * //    Name (\"Alice\")\n *\n * const struct = codec.decode(bytes);\n * // { name: 'Alice', age: 42 }\n * ```\n *\n * @remarks\n * Separate {@link getStructEncoder} and {@link getStructDecoder} functions are available.\n *\n * ```ts\n * const bytes = getStructEncoder([\n *   ['name', fixCodecSize(getUtf8Encoder(), 5)],\n *   ['age', getU8Encoder()]\n * ]).encode({ name: 'Alice', age: 42 });\n *\n * const struct = getStructDecoder([\n *   ['name', fixCodecSize(getUtf8Decoder(), 5)],\n *   ['age', getU8Decoder()]\n * ]).decode(bytes);\n * ```\n *\n * @see {@link getStructEncoder}\n * @see {@link getStructDecoder}\n */\nexport function getStructCodec<const TFields extends Fields<FixedSizeCodec<any>>>(\n    fields: TFields,\n): FixedSizeCodec<\n    GetEncoderTypeFromFields<TFields>,\n    GetDecoderTypeFromFields<TFields> & GetEncoderTypeFromFields<TFields>\n>;\nexport function getStructCodec<const TFields extends Fields<Codec<any>>>(\n    fields: TFields,\n): VariableSizeCodec<\n    GetEncoderTypeFromFields<TFields>,\n    GetDecoderTypeFromFields<TFields> & GetEncoderTypeFromFields<TFields>\n>;\nexport function getStructCodec<const TFields extends Fields<Codec<any>>>(\n    fields: TFields,\n): Codec<GetEncoderTypeFromFields<TFields>, GetDecoderTypeFromFields<TFields> & GetEncoderTypeFromFields<TFields>> {\n    return combineCodec(\n        getStructEncoder(fields),\n        getStructDecoder(fields) as Decoder<GetDecoderTypeFromFields<TFields> & GetEncoderTypeFromFields<TFields>>,\n    );\n}\n","/**\n * A pipeline is a solution that allows you to perform successive transforms of a value using functions. This is useful when building up a transaction message.\n *\n * Until the [pipeline operator](https://github.com/tc39/proposal-pipeline-operator) becomes part of JavaScript you can use this utility to create pipelines.\n *\n * Following common implementations of pipe functions that use TypeScript, this function supports a maximum arity of 10 for type safety.\n *\n * Note you can use nested pipes to extend this limitation, like so:\n * ```ts\n * const myValue = pipe(\n *      pipe(\n *          1,\n *          (x) => x + 1,\n *          (x) => x * 2,\n *          (x) => x - 1,\n *      ),\n *      (y) => y / 3,\n *      (y) => y + 1,\n * );\n * ```\n *\n * @see https://github.com/ramda/ramda/blob/master/source/pipe.js\n * @see https://github.com/darky/rocket-pipes/blob/master/index.ts\n *\n * @example Basic\n * ```ts\n * const add = (a, b) => a + b;\n * const add10 = x => add(x, 10);\n * const add100 = x => add(x, 100);\n * const sum = pipe(1, add10, add100);\n * sum === 111; // true\n * ```\n *\n * @example Building a Solana transaction message\n * ```ts\n * const transferTransactionMessage = pipe(\n *     // The result of the first expression...\n *     createTransactionMessage({ version: 0 }),\n *     // ...gets passed as the sole argument to the next function in the pipeline.\n *     tx => setTransactionMessageFeePayer(myAddress, tx),\n *     // The return value of that function gets passed to the next...\n *     tx => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx),\n *     // ...and so on.\n *     tx => appendTransactionMessageInstruction(createTransferInstruction(myAddress, toAddress, amountInLamports), tx),\n * );\n * ```\n *\n * @returns The initial value\n */\nexport function pipe<TInitial>(\n    /** The initial value */\n    init: TInitial,\n): TInitial;\n/**\n * @returns The return value of the final transform function\n */\nexport function pipe<TInitial, R1>(\n    /** The initial value */\n    init: TInitial,\n    /** The function with which to transform the initial value */\n    init_r1: (init: TInitial) => R1,\n): R1;\n/**\n * @returns The return value of the final transform function\n */\nexport function pipe<TInitial, R1, R2>(\n    /** The initial value */\n    init: TInitial,\n    /** The function with which to transform the initial value */\n    init_r1: (init: TInitial) => R1,\n    /** The function with which to transform the return value of the prior function */\n    r1_r2: (r1: R1) => R2,\n): R2;\n/**\n * @returns The return value of the final transform function\n */\nexport function pipe<TInitial, R1, R2, R3>(\n    /** The initial value */\n    init: TInitial,\n    /** The function with which to transform the initial value */\n    init_r1: (init: TInitial) => R1,\n    /** The function with which to transform the return value of the prior function */\n    r1_r2: (r1: R1) => R2,\n    /** The function with which to transform the return value of the prior function */\n    r2_r3: (r2: R2) => R3,\n): R3;\n/**\n * @returns The return value of the final transform function\n */\nexport function pipe<TInitial, R1, R2, R3, R4>(\n    /** The initial value */\n    init: TInitial,\n    /** The function with which to transform the initial value */\n    init_r1: (init: TInitial) => R1,\n    /** The function with which to transform the return value of the prior function */\n    r1_r2: (r1: R1) => R2,\n    /** The function with which to transform the return value of the prior function */\n    r2_r3: (r2: R2) => R3,\n    /** The function with which to transform the return value of the prior function */\n    r3_r4: (r3: R3) => R4,\n): R4;\n/**\n * @returns The return value of the final transform function\n */\nexport function pipe<TInitial, R1, R2, R3, R4, R5>(\n    /** The initial value */\n    init: TInitial,\n    /** The function with which to transform the initial value */\n    init_r1: (init: TInitial) => R1,\n    /** The function with which to transform the return value of the prior function */\n    r1_r2: (r1: R1) => R2,\n    /** The function with which to transform the return value of the prior function */\n    r2_r3: (r2: R2) => R3,\n    /** The function with which to transform the return value of the prior function */\n    r3_r4: (r3: R3) => R4,\n    /** The function with which to transform the return value of the prior function */\n    r4_r5: (r4: R4) => R5,\n): R5;\n/**\n * @returns The return value of the final transform function\n */\nexport function pipe<TInitial, R1, R2, R3, R4, R5, R6>(\n    /** The initial value */\n    init: TInitial,\n    /** The function with which to transform the initial value */\n    init_r1: (init: TInitial) => R1,\n    /** The function with which to transform the return value of the prior function */\n    r1_r2: (r1: R1) => R2,\n    /** The function with which to transform the return value of the prior function */\n    r2_r3: (r2: R2) => R3,\n    /** The function with which to transform the return value of the prior function */\n    r3_r4: (r3: R3) => R4,\n    /** The function with which to transform the return value of the prior function */\n    r4_r5: (r4: R4) => R5,\n    /** The function with which to transform the return value of the prior function */\n    r5_r6: (r5: R5) => R6,\n): R6;\n/**\n * @returns The return value of the final transform function\n */\nexport function pipe<TInitial, R1, R2, R3, R4, R5, R6, R7>(\n    /** The initial value */\n    init: TInitial,\n    /** The function with which to transform the initial value */\n    init_r1: (init: TInitial) => R1,\n    /** The function with which to transform the return value of the prior function */\n    r1_r2: (r1: R1) => R2,\n    /** The function with which to transform the return value of the prior function */\n    r2_r3: (r2: R2) => R3,\n    /** The function with which to transform the return value of the prior function */\n    r3_r4: (r3: R3) => R4,\n    /** The function with which to transform the return value of the prior function */\n    r4_r5: (r4: R4) => R5,\n    /** The function with which to transform the return value of the prior function */\n    r5_r6: (r5: R5) => R6,\n    /** The function with which to transform the return value of the prior function */\n    r6_r7: (r6: R6) => R7,\n): R7;\n/**\n * @returns The return value of the final transform function\n */\nexport function pipe<TInitial, R1, R2, R3, R4, R5, R6, R7, R8>(\n    /** The initial value */\n    init: TInitial,\n    /** The function with which to transform the initial value */\n    init_r1: (init: TInitial) => R1,\n    /** The function with which to transform the return value of the prior function */\n    r1_r2: (r1: R1) => R2,\n    /** The function with which to transform the return value of the prior function */\n    r2_r3: (r2: R2) => R3,\n    /** The function with which to transform the return value of the prior function */\n    r3_r4: (r3: R3) => R4,\n    /** The function with which to transform the return value of the prior function */\n    r4_r5: (r4: R4) => R5,\n    /** The function with which to transform the return value of the prior function */\n    r5_r6: (r5: R5) => R6,\n    /** The function with which to transform the return value of the prior function */\n    r6_r7: (r6: R6) => R7,\n    /** The function with which to transform the return value of the prior function */\n    r7_r8: (r7: R7) => R8,\n): R8;\n/**\n * @returns The return value of the final transform function\n */\nexport function pipe<TInitial, R1, R2, R3, R4, R5, R6, R7, R8, R9>(\n    /** The initial value */\n    init: TInitial,\n    /** The function with which to transform the initial value */\n    init_r1: (init: TInitial) => R1,\n    /** The function with which to transform the return value of the prior function */\n    r1_r2: (r1: R1) => R2,\n    /** The function with which to transform the return value of the prior function */\n    r2_r3: (r2: R2) => R3,\n    /** The function with which to transform the return value of the prior function */\n    r3_r4: (r3: R3) => R4,\n    /** The function with which to transform the return value of the prior function */\n    r4_r5: (r4: R4) => R5,\n    /** The function with which to transform the return value of the prior function */\n    r5_r6: (r5: R5) => R6,\n    /** The function with which to transform the return value of the prior function */\n    r6_r7: (r6: R6) => R7,\n    /** The function with which to transform the return value of the prior function */\n    r7_r8: (r7: R7) => R8,\n    /** The function with which to transform the return value of the prior function */\n    r8_r9: (r8: R8) => R9,\n): R9;\n/**\n * @returns The return value of the final transform function\n */\nexport function pipe<TInitial, R1, R2, R3, R4, R5, R6, R7, R8, R9, R10>(\n    /** The initial value */\n    init: TInitial,\n    /** The function with which to transform the initial value */\n    init_r1: (init: TInitial) => R1,\n    /** The function with which to transform the return value of the prior function */\n    r1_r2: (r1: R1) => R2,\n    /** The function with which to transform the return value of the prior function */\n    r2_r3: (r2: R2) => R3,\n    /** The function with which to transform the return value of the prior function */\n    r3_r4: (r3: R3) => R4,\n    /** The function with which to transform the return value of the prior function */\n    r4_r5: (r4: R4) => R5,\n    /** The function with which to transform the return value of the prior function */\n    r5_r6: (r5: R5) => R6,\n    /** The function with which to transform the return value of the prior function */\n    r6_r7: (r6: R6) => R7,\n    /** The function with which to transform the return value of the prior function */\n    r7_r8: (r7: R7) => R8,\n    /** The function with which to transform the return value of the prior function */\n    r8_r9: (r8: R8) => R9,\n    /** The function with which to transform the return value of the prior function */\n    r9_r10: (r9: R9) => R10,\n): R10;\nexport function pipe<TInitial>(init: TInitial, ...fns: CallableFunction[]) {\n    return fns.reduce((acc, fn) => fn(acc), init);\n}\n","import { SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME, SolanaError } from '@solana/errors';\nimport { type Blockhash, isBlockhash } from '@solana/rpc-types';\n\nimport { ExcludeTransactionMessageLifetime, TransactionMessageWithLifetime } from './lifetime';\nimport { BaseTransactionMessage } from './transaction-message';\n\n/**\n * A constraint which, when applied to a transaction message, makes that transaction message\n * eligible to land on the network. The transaction message will continue to be eligible to land\n * until the network considers the `blockhash` to be expired.\n *\n * This can happen when the network proceeds past the `lastValidBlockHeight` for which the blockhash\n * is considered valid, or when the network switches to a fork where that blockhash is not present.\n */\ntype BlockhashLifetimeConstraint = Readonly<{\n    /**\n     * A recent blockhash observed by the transaction proposer.\n     *\n     * The transaction message will be considered eligible to land until the network determines this\n     * blockhash to be too old, or has switched to a fork where it is not present.\n     */\n    blockhash: Blockhash;\n    /**\n     * This is the block height beyond which the network will consider the blockhash to be too old\n     * to make a transaction message eligible to land.\n     */\n    lastValidBlockHeight: bigint;\n}>;\n\n/**\n * Represents a transaction message whose lifetime is defined by the age of the blockhash it\n * includes.\n *\n * Such a transaction can only be landed on the network if the current block height of the network\n * is less than or equal to the value of\n * `TransactionMessageWithBlockhashLifetime['lifetimeConstraint']['lastValidBlockHeight']`.\n */\nexport interface TransactionMessageWithBlockhashLifetime {\n    readonly lifetimeConstraint: BlockhashLifetimeConstraint;\n}\n\n/**\n * A type guard that returns `true` if the transaction message conforms to the\n * {@link TransactionMessageWithBlockhashLifetime} type, and refines its type for use in your\n * program.\n *\n * @example\n * ```ts\n * import { isTransactionMessageWithBlockhashLifetime } from '@solana/transaction-messages';\n *\n * if (isTransactionMessageWithBlockhashLifetime(message)) {\n *     // At this point, `message` has been refined to a `TransactionMessageWithBlockhashLifetime`.\n *     const { blockhash } = message.lifetimeConstraint;\n *     const { value: blockhashIsValid } = await rpc.isBlockhashValid(blockhash).send();\n *     setBlockhashIsValid(blockhashIsValid);\n * } else {\n *     setError(\n *         `${getSignatureFromTransaction(transaction)} does not have a blockhash-based lifetime`,\n *     );\n * }\n * ```\n */\nexport function isTransactionMessageWithBlockhashLifetime(\n    transactionMessage: BaseTransactionMessage | (BaseTransactionMessage & TransactionMessageWithBlockhashLifetime),\n): transactionMessage is BaseTransactionMessage & TransactionMessageWithBlockhashLifetime {\n    return (\n        'lifetimeConstraint' in transactionMessage &&\n        typeof transactionMessage.lifetimeConstraint.blockhash === 'string' &&\n        typeof transactionMessage.lifetimeConstraint.lastValidBlockHeight === 'bigint' &&\n        isBlockhash(transactionMessage.lifetimeConstraint.blockhash)\n    );\n}\n\n/**\n * From time to time you might acquire a transaction message, that you expect to have a\n * blockhash-based lifetime, from an untrusted network API or user input. Use this function to\n * assert that such a transaction message actually has a blockhash-based lifetime.\n *\n * @example\n * ```ts\n * import { assertIsTransactionMessageWithBlockhashLifetime } from '@solana/transaction-messages';\n *\n * try {\n *     // If this type assertion function doesn't throw, then\n *     // Typescript will upcast `message` to `TransactionMessageWithBlockhashLifetime`.\n *     assertIsTransactionMessageWithBlockhashLifetime(message);\n *     // At this point, `message` is a `TransactionMessageWithBlockhashLifetime` that can be used\n *     // with the RPC.\n *     const { blockhash } = message.lifetimeConstraint;\n *     const { value: blockhashIsValid } = await rpc.isBlockhashValid(blockhash).send();\n * } catch (e) {\n *     // `message` turned out not to have a blockhash-based lifetime\n * }\n * ```\n */\nexport function assertIsTransactionMessageWithBlockhashLifetime(\n    transactionMessage: BaseTransactionMessage | (BaseTransactionMessage & TransactionMessageWithBlockhashLifetime),\n): asserts transactionMessage is BaseTransactionMessage & TransactionMessageWithBlockhashLifetime {\n    if (!isTransactionMessageWithBlockhashLifetime(transactionMessage)) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME);\n    }\n}\n\n/**\n * Given a blockhash and the last block height at which that blockhash is considered usable to land\n * transactions, this method will return a new transaction message having the same type as the one\n * supplied plus the `TransactionMessageWithBlockhashLifetime` type.\n *\n * @example\n * ```ts\n * import { setTransactionMessageLifetimeUsingBlockhash } from '@solana/transaction-messages';\n *\n * const { value: latestBlockhash } = await rpc.getLatestBlockhash().send();\n * const txMessageWithBlockhashLifetime = setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, txMessage);\n * ```\n */\nexport function setTransactionMessageLifetimeUsingBlockhash<\n    TTransactionMessage extends BaseTransactionMessage & Partial<TransactionMessageWithLifetime>,\n>(\n    blockhashLifetimeConstraint: BlockhashLifetimeConstraint,\n    transactionMessage: TTransactionMessage,\n): ExcludeTransactionMessageLifetime<TTransactionMessage> & TransactionMessageWithBlockhashLifetime {\n    type ReturnType = ExcludeTransactionMessageLifetime<TTransactionMessage> & TransactionMessageWithBlockhashLifetime;\n\n    if (\n        'lifetimeConstraint' in transactionMessage &&\n        transactionMessage.lifetimeConstraint &&\n        'blockhash' in transactionMessage.lifetimeConstraint &&\n        transactionMessage.lifetimeConstraint.blockhash === blockhashLifetimeConstraint.blockhash &&\n        transactionMessage.lifetimeConstraint.lastValidBlockHeight === blockhashLifetimeConstraint.lastValidBlockHeight\n    ) {\n        return transactionMessage as ReturnType;\n    }\n\n    return Object.freeze({\n        ...transactionMessage,\n        lifetimeConstraint: Object.freeze(blockhashLifetimeConstraint),\n    }) as ReturnType;\n}\n","import { getAddressDecoder, getAddressEncoder } from '@solana/addresses';\nimport {\n    combineCodec,\n    type Encoder,\n    type VariableSizeCodec,\n    type VariableSizeDecoder,\n    type VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { getArrayDecoder, getArrayEncoder, getStructDecoder, getStructEncoder } from '@solana/codecs-data-structures';\nimport { getShortU16Decoder, getShortU16Encoder, getU8Decoder, getU8Encoder } from '@solana/codecs-numbers';\n\nimport type { getCompiledAddressTableLookups } from '../compile/address-table-lookups';\n\ntype AddressTableLookup = ReturnType<typeof getCompiledAddressTableLookups>[number];\n\nlet memoizedAddressTableLookupEncoder: VariableSizeEncoder<AddressTableLookup> | undefined;\nexport function getAddressTableLookupEncoder(): VariableSizeEncoder<AddressTableLookup> {\n    if (!memoizedAddressTableLookupEncoder) {\n        const indexEncoder = getArrayEncoder(getU8Encoder(), { size: getShortU16Encoder() }) as Encoder<\n            readonly number[]\n        >;\n        memoizedAddressTableLookupEncoder = getStructEncoder([\n            ['lookupTableAddress', getAddressEncoder()],\n            ['writableIndexes', indexEncoder],\n            ['readonlyIndexes', indexEncoder],\n        ]);\n    }\n\n    return memoizedAddressTableLookupEncoder;\n}\n\nlet memoizedAddressTableLookupDecoder: VariableSizeDecoder<AddressTableLookup> | undefined;\nexport function getAddressTableLookupDecoder(): VariableSizeDecoder<AddressTableLookup> {\n    if (!memoizedAddressTableLookupDecoder) {\n        const indexEncoder = getArrayDecoder(getU8Decoder(), { size: getShortU16Decoder() });\n        memoizedAddressTableLookupDecoder = getStructDecoder([\n            ['lookupTableAddress', getAddressDecoder()],\n            ['writableIndexes', indexEncoder],\n            ['readonlyIndexes', indexEncoder],\n        ]);\n    }\n\n    return memoizedAddressTableLookupDecoder;\n}\n\nexport function getAddressTableLookupCodec(): VariableSizeCodec<AddressTableLookup> {\n    return combineCodec(getAddressTableLookupEncoder(), getAddressTableLookupDecoder());\n}\n","import { FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\nimport { getStructCodec, getStructDecoder, getStructEncoder } from '@solana/codecs-data-structures';\nimport { getU8Codec, getU8Decoder, getU8Encoder } from '@solana/codecs-numbers';\n\nimport { getCompiledMessageHeader } from '../compile/header';\n\ntype MessageHeader = ReturnType<typeof getCompiledMessageHeader>;\n\nlet memoizedU8Encoder: FixedSizeEncoder<number, 1> | undefined;\nfunction getMemoizedU8Encoder(): FixedSizeEncoder<number, 1> {\n    if (!memoizedU8Encoder) memoizedU8Encoder = getU8Encoder();\n    return memoizedU8Encoder;\n}\n\nlet memoizedU8Decoder: FixedSizeDecoder<number, 1> | undefined;\nfunction getMemoizedU8Decoder(): FixedSizeDecoder<number, 1> {\n    if (!memoizedU8Decoder) memoizedU8Decoder = getU8Decoder();\n    return memoizedU8Decoder;\n}\n\nlet memoizedU8Codec: FixedSizeCodec<number, number, 1> | undefined;\nfunction getMemoizedU8Codec(): FixedSizeCodec<number, number, 1> {\n    if (!memoizedU8Codec) memoizedU8Codec = getU8Codec();\n    return memoizedU8Codec;\n}\n\nexport function getMessageHeaderEncoder(): FixedSizeEncoder<MessageHeader, 3> {\n    return getStructEncoder([\n        ['numSignerAccounts', getMemoizedU8Encoder()],\n        ['numReadonlySignerAccounts', getMemoizedU8Encoder()],\n        ['numReadonlyNonSignerAccounts', getMemoizedU8Encoder()],\n    ]) as FixedSizeEncoder<MessageHeader, 3>;\n}\n\nexport function getMessageHeaderDecoder(): FixedSizeDecoder<MessageHeader, 3> {\n    return getStructDecoder([\n        ['numSignerAccounts', getMemoizedU8Decoder()],\n        ['numReadonlySignerAccounts', getMemoizedU8Decoder()],\n        ['numReadonlyNonSignerAccounts', getMemoizedU8Decoder()],\n    ]) as FixedSizeDecoder<MessageHeader, 3>;\n}\n\nexport function getMessageHeaderCodec(): FixedSizeCodec<MessageHeader, MessageHeader, 3> {\n    return getStructCodec([\n        ['numSignerAccounts', getMemoizedU8Codec()],\n        ['numReadonlySignerAccounts', getMemoizedU8Codec()],\n        ['numReadonlyNonSignerAccounts', getMemoizedU8Codec()],\n    ]) as FixedSizeCodec<MessageHeader, MessageHeader, 3>;\n}\n","import {\n    addDecoderSizePrefix,\n    addEncoderSizePrefix,\n    combineCodec,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    getArrayDecoder,\n    getArrayEncoder,\n    getBytesDecoder,\n    getBytesEncoder,\n    getStructDecoder,\n    getStructEncoder,\n} from '@solana/codecs-data-structures';\nimport { getShortU16Decoder, getShortU16Encoder, getU8Decoder, getU8Encoder } from '@solana/codecs-numbers';\n\nimport { getCompiledInstructions } from '../compile/instructions';\n\ntype Instruction = ReturnType<typeof getCompiledInstructions>[number];\n\nlet memoizedGetInstructionEncoder: VariableSizeEncoder<Instruction> | undefined;\nexport function getInstructionEncoder(): VariableSizeEncoder<Instruction> {\n    if (!memoizedGetInstructionEncoder) {\n        memoizedGetInstructionEncoder = transformEncoder<Required<Instruction>, Instruction>(\n            getStructEncoder([\n                ['programAddressIndex', getU8Encoder()],\n                ['accountIndices', getArrayEncoder(getU8Encoder(), { size: getShortU16Encoder() })],\n                ['data', addEncoderSizePrefix(getBytesEncoder(), getShortU16Encoder())],\n            ]),\n            // Convert an instruction to have all fields defined\n            (instruction: Instruction): Required<Instruction> => {\n                if (instruction.accountIndices !== undefined && instruction.data !== undefined) {\n                    return instruction as Required<Instruction>;\n                }\n                return {\n                    ...instruction,\n                    accountIndices: instruction.accountIndices ?? [],\n                    data: instruction.data ?? new Uint8Array(0),\n                } as Required<Instruction>;\n            },\n        );\n    }\n\n    return memoizedGetInstructionEncoder;\n}\n\nlet memoizedGetInstructionDecoder: VariableSizeDecoder<Instruction> | undefined;\nexport function getInstructionDecoder(): VariableSizeDecoder<Instruction> {\n    if (!memoizedGetInstructionDecoder) {\n        memoizedGetInstructionDecoder = transformDecoder<Required<Instruction>, Instruction>(\n            getStructDecoder([\n                ['programAddressIndex', getU8Decoder()],\n                ['accountIndices', getArrayDecoder(getU8Decoder(), { size: getShortU16Decoder() })],\n                [\n                    'data',\n                    addDecoderSizePrefix(getBytesDecoder(), getShortU16Decoder()) as VariableSizeDecoder<Uint8Array>,\n                ],\n            ]),\n            // Convert an instruction to exclude optional fields if they are empty\n            (instruction: Required<Instruction>): Instruction => {\n                if (instruction.accountIndices.length && instruction.data.byteLength) {\n                    return instruction;\n                }\n                const { accountIndices, data, ...rest } = instruction;\n                return {\n                    ...rest,\n                    ...(accountIndices.length ? { accountIndices } : null),\n                    ...(data.byteLength ? { data } : null),\n                };\n            },\n        );\n    }\n    return memoizedGetInstructionDecoder;\n}\n\nexport function getInstructionCodec(): VariableSizeCodec<Instruction> {\n    return combineCodec(getInstructionEncoder(), getInstructionDecoder());\n}\n","import { AccountMeta, Instruction } from '@solana/instructions';\n\nexport type BaseTransactionMessage<\n    TVersion extends TransactionVersion = TransactionVersion,\n    TInstruction extends Instruction = Instruction,\n> = Readonly<{\n    instructions: readonly TInstruction[];\n    version: TVersion;\n}>;\n\nexport const MAX_SUPPORTED_TRANSACTION_VERSION = 0;\n\ntype LegacyInstruction<TProgramAddress extends string = string> = Instruction<TProgramAddress, readonly AccountMeta[]>;\ntype LegacyTransactionMessage = BaseTransactionMessage<'legacy', LegacyInstruction>;\ntype V0TransactionMessage = BaseTransactionMessage<0, Instruction>;\n\nexport type TransactionMessage = LegacyTransactionMessage | V0TransactionMessage;\nexport type TransactionVersion = 'legacy' | 0;\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_NOT_SUPPORTED,\n    SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE,\n    SolanaError,\n} from '@solana/errors';\n\nimport { MAX_SUPPORTED_TRANSACTION_VERSION, TransactionVersion } from '../transaction-message';\n\nconst VERSION_FLAG_MASK = 0x80;\n\n/**\n * Returns an encoder that you can use to encode a {@link TransactionVersion} to a byte array.\n *\n * Legacy messages will produce an empty array and will not advance the offset. Versioned messages\n * will produce an array with a single byte.\n */\nexport function getTransactionVersionEncoder(): VariableSizeEncoder<TransactionVersion> {\n    return createEncoder({\n        getSizeFromValue: value => (value === 'legacy' ? 0 : 1),\n        maxSize: 1,\n        write: (value, bytes, offset) => {\n            if (value === 'legacy') {\n                return offset;\n            }\n            if (value < 0 || value > 127) {\n                throw new SolanaError(SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE, {\n                    actualVersion: value,\n                });\n            }\n\n            if (value > MAX_SUPPORTED_TRANSACTION_VERSION) {\n                throw new SolanaError(SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_NOT_SUPPORTED, {\n                    unsupportedVersion: value,\n                });\n            }\n            bytes.set([value | VERSION_FLAG_MASK], offset);\n            return offset + 1;\n        },\n    });\n}\n\n/**\n * Returns a decoder that you can use to decode a byte array representing a\n * {@link TransactionVersion}.\n *\n * When the byte at the current offset is determined to represent a legacy transaction, this decoder\n * will return `'legacy'` and will not advance the offset.\n */\nexport function getTransactionVersionDecoder(): VariableSizeDecoder<TransactionVersion> {\n    return createDecoder({\n        maxSize: 1,\n        read: (bytes, offset) => {\n            const firstByte = bytes[offset];\n            if ((firstByte & VERSION_FLAG_MASK) === 0) {\n                // No version flag set; it's a legacy (unversioned) transaction.\n                return ['legacy', offset];\n            } else {\n                const version = firstByte ^ VERSION_FLAG_MASK;\n                if (version > MAX_SUPPORTED_TRANSACTION_VERSION) {\n                    throw new SolanaError(SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_NOT_SUPPORTED, {\n                        unsupportedVersion: version,\n                    });\n                }\n                return [version as TransactionVersion, offset + 1];\n            }\n        },\n    });\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to {@link TransactionVersion}\n *\n * @see {@link getTransactionVersionDecoder}\n * @see {@link getTransactionVersionEncoder}\n */\nexport function getTransactionVersionCodec(): VariableSizeCodec<TransactionVersion> {\n    return combineCodec(getTransactionVersionEncoder(), getTransactionVersionDecoder());\n}\n","import { getAddressDecoder, getAddressEncoder } from '@solana/addresses';\nimport {\n    combineCodec,\n    createEncoder,\n    Decoder,\n    fixDecoderSize,\n    fixEncoderSize,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    getArrayDecoder,\n    getArrayEncoder,\n    getConstantEncoder,\n    getStructDecoder,\n    getStructEncoder,\n    getUnionEncoder,\n} from '@solana/codecs-data-structures';\nimport { getShortU16Decoder, getShortU16Encoder } from '@solana/codecs-numbers';\nimport { getBase58Decoder, getBase58Encoder } from '@solana/codecs-strings';\n\nimport { getCompiledAddressTableLookups } from '../compile/address-table-lookups';\nimport { CompiledTransactionMessage, CompiledTransactionMessageWithLifetime } from '../compile/message';\nimport { getAddressTableLookupDecoder, getAddressTableLookupEncoder } from './address-table-lookup';\nimport { getMessageHeaderDecoder, getMessageHeaderEncoder } from './header';\nimport { getInstructionDecoder, getInstructionEncoder } from './instruction';\nimport { getTransactionVersionDecoder, getTransactionVersionEncoder } from './transaction-version';\n\nfunction getCompiledMessageLegacyEncoder(): VariableSizeEncoder<\n    CompiledTransactionMessage | (CompiledTransactionMessage & CompiledTransactionMessageWithLifetime)\n> {\n    return getStructEncoder(getPreludeStructEncoderTuple()) as VariableSizeEncoder<\n        CompiledTransactionMessage | (CompiledTransactionMessage & CompiledTransactionMessageWithLifetime)\n    >;\n}\n\nfunction getCompiledMessageVersionedEncoder(): VariableSizeEncoder<\n    CompiledTransactionMessage | (CompiledTransactionMessage & CompiledTransactionMessageWithLifetime)\n> {\n    return transformEncoder(\n        getStructEncoder([\n            ...getPreludeStructEncoderTuple(),\n            ['addressTableLookups', getAddressTableLookupArrayEncoder()],\n        ]) as VariableSizeEncoder<\n            CompiledTransactionMessage | (CompiledTransactionMessage & CompiledTransactionMessageWithLifetime)\n        >,\n        value => {\n            if (value.version === 'legacy') {\n                return value;\n            }\n            return {\n                ...value,\n                addressTableLookups: value.addressTableLookups ?? [],\n            };\n        },\n    );\n}\n\nfunction getPreludeStructEncoderTuple() {\n    const lifetimeTokenEncoder = getUnionEncoder(\n        [\n            // Use a 32-byte constant encoder for a missing lifetime token (index 0).\n            getConstantEncoder(new Uint8Array(32)),\n            // Use a 32-byte base58 encoder for a valid lifetime token (index 1).\n            fixEncoderSize(getBase58Encoder(), 32),\n        ],\n        value => (value === undefined ? 0 : 1),\n    );\n\n    return [\n        ['version', getTransactionVersionEncoder()],\n        ['header', getMessageHeaderEncoder()],\n        ['staticAccounts', getArrayEncoder(getAddressEncoder(), { size: getShortU16Encoder() })],\n        ['lifetimeToken', lifetimeTokenEncoder],\n        ['instructions', getArrayEncoder(getInstructionEncoder(), { size: getShortU16Encoder() })],\n    ] as const;\n}\n\nfunction getPreludeStructDecoderTuple() {\n    return [\n        ['version', getTransactionVersionDecoder() as Decoder<number>],\n        ['header', getMessageHeaderDecoder()],\n        ['staticAccounts', getArrayDecoder(getAddressDecoder(), { size: getShortU16Decoder() })],\n        ['lifetimeToken', fixDecoderSize(getBase58Decoder(), 32)],\n        ['instructions', getArrayDecoder(getInstructionDecoder(), { size: getShortU16Decoder() })],\n        ['addressTableLookups', getAddressTableLookupArrayDecoder()],\n    ] as const;\n}\n\nfunction getAddressTableLookupArrayEncoder() {\n    return getArrayEncoder(getAddressTableLookupEncoder(), { size: getShortU16Encoder() });\n}\n\nfunction getAddressTableLookupArrayDecoder() {\n    return getArrayDecoder(getAddressTableLookupDecoder(), { size: getShortU16Decoder() });\n}\n\n/**\n * Returns an encoder that you can use to encode a {@link CompiledTransactionMessage} to a byte\n * array.\n *\n * The wire format of a Solana transaction consists of signatures followed by a compiled transaction\n * message. The byte array produced by this encoder is the message part.\n */\nexport function getCompiledTransactionMessageEncoder(): VariableSizeEncoder<\n    CompiledTransactionMessage | (CompiledTransactionMessage & CompiledTransactionMessageWithLifetime)\n> {\n    return createEncoder({\n        getSizeFromValue: compiledMessage => {\n            if (compiledMessage.version === 'legacy') {\n                return getCompiledMessageLegacyEncoder().getSizeFromValue(compiledMessage);\n            } else {\n                return getCompiledMessageVersionedEncoder().getSizeFromValue(compiledMessage);\n            }\n        },\n        write: (compiledMessage, bytes, offset) => {\n            if (compiledMessage.version === 'legacy') {\n                return getCompiledMessageLegacyEncoder().write(compiledMessage, bytes, offset);\n            } else {\n                return getCompiledMessageVersionedEncoder().write(compiledMessage, bytes, offset);\n            }\n        },\n    });\n}\n\n/**\n * Returns a decoder that you can use to decode a byte array representing a\n * {@link CompiledTransactionMessage}.\n *\n * The wire format of a Solana transaction consists of signatures followed by a compiled transaction\n * message. You can use this decoder to decode the message part.\n */\nexport function getCompiledTransactionMessageDecoder(): VariableSizeDecoder<\n    CompiledTransactionMessage & CompiledTransactionMessageWithLifetime\n> {\n    return transformDecoder(\n        getStructDecoder(getPreludeStructDecoderTuple()) as VariableSizeDecoder<\n            CompiledTransactionMessage &\n                CompiledTransactionMessageWithLifetime & {\n                    addressTableLookups?: ReturnType<typeof getCompiledAddressTableLookups>;\n                }\n        >,\n        ({ addressTableLookups, ...restOfMessage }) => {\n            if (restOfMessage.version === 'legacy' || !addressTableLookups?.length) {\n                return restOfMessage;\n            }\n            return { ...restOfMessage, addressTableLookups };\n        },\n    );\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to {@link CompiledTransactionMessage}\n *\n * @see {@link getCompiledTransactionMessageDecoder}\n * @see {@link getCompiledTransactionMessageEncoder}\n */\nexport function getCompiledTransactionMessageCodec(): VariableSizeCodec<\n    CompiledTransactionMessage | (CompiledTransactionMessage & CompiledTransactionMessageWithLifetime),\n    CompiledTransactionMessage & CompiledTransactionMessageWithLifetime\n> {\n    return combineCodec(getCompiledTransactionMessageEncoder(), getCompiledTransactionMessageDecoder());\n}\n","import { Address, getAddressComparator } from '@solana/addresses';\nimport {\n    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES,\n    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE,\n    SolanaError,\n} from '@solana/errors';\nimport {\n    AccountLookupMeta,\n    AccountMeta,\n    AccountRole,\n    Instruction,\n    isSignerRole,\n    isWritableRole,\n    mergeRoles,\n    ReadonlyAccount,\n    ReadonlyAccountLookup,\n    ReadonlySignerAccount,\n    WritableAccount,\n    WritableAccountLookup,\n    WritableSignerAccount,\n} from '@solana/instructions';\nimport { Brand } from '@solana/nominal-types';\n\nexport const enum AddressMapEntryType {\n    FEE_PAYER,\n    LOOKUP_TABLE,\n    STATIC,\n}\n\ntype AddressMap = {\n    [address: string]: FeePayerAccountEntry | LookupTableAccountEntry | StaticAccountEntry;\n};\ntype FeePayerAccountEntry = Omit<WritableSignerAccount, 'address'> & {\n    [TYPE]: AddressMapEntryType.FEE_PAYER;\n};\ntype LookupTableAccountEntry = Omit<ReadonlyAccountLookup | WritableAccountLookup, 'address'> & {\n    [TYPE]: AddressMapEntryType.LOOKUP_TABLE;\n};\nexport type OrderedAccounts = Brand<(AccountLookupMeta | AccountMeta)[], 'OrderedAccounts'>;\ntype StaticAccountEntry = Omit<\n    ReadonlyAccount | ReadonlySignerAccount | WritableAccount | WritableSignerAccount,\n    'address'\n> & { [TYPE]: AddressMapEntryType.STATIC };\n\nfunction upsert(\n    addressMap: AddressMap,\n    address: Address,\n    update: (\n        entry: FeePayerAccountEntry | LookupTableAccountEntry | Record<never, never> | StaticAccountEntry,\n    ) => AddressMap[Address],\n) {\n    addressMap[address] = update(addressMap[address] ?? { role: AccountRole.READONLY });\n}\n\nconst TYPE = Symbol('AddressMapTypeProperty');\nexport const ADDRESS_MAP_TYPE_PROPERTY: typeof TYPE = TYPE;\n\nexport function getAddressMapFromInstructions(feePayer: Address, instructions: readonly Instruction[]): AddressMap {\n    const addressMap: AddressMap = {\n        [feePayer]: { [TYPE]: AddressMapEntryType.FEE_PAYER, role: AccountRole.WRITABLE_SIGNER },\n    };\n    const addressesOfInvokedPrograms = new Set<Address>();\n    for (const instruction of instructions) {\n        upsert(addressMap, instruction.programAddress, entry => {\n            addressesOfInvokedPrograms.add(instruction.programAddress);\n            if (TYPE in entry) {\n                if (isWritableRole(entry.role)) {\n                    switch (entry[TYPE]) {\n                        case AddressMapEntryType.FEE_PAYER:\n                            throw new SolanaError(SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES, {\n                                programAddress: instruction.programAddress,\n                            });\n                        default:\n                            throw new SolanaError(SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE, {\n                                programAddress: instruction.programAddress,\n                            });\n                    }\n                }\n                if (entry[TYPE] === AddressMapEntryType.STATIC) {\n                    return entry;\n                }\n            }\n            return { [TYPE]: AddressMapEntryType.STATIC, role: AccountRole.READONLY };\n        });\n        let addressComparator: ReturnType<typeof getAddressComparator>;\n        if (!instruction.accounts) {\n            continue;\n        }\n        for (const account of instruction.accounts) {\n            upsert(addressMap, account.address, entry => {\n                const {\n                    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                    address: _,\n                    ...accountMeta\n                } = account;\n                if (TYPE in entry) {\n                    switch (entry[TYPE]) {\n                        case AddressMapEntryType.FEE_PAYER:\n                            // The fee payer already has the highest rank -- it is by definition\n                            // writable-signer. Return it, no matter how `account` is configured\n                            return entry;\n                        case AddressMapEntryType.LOOKUP_TABLE: {\n                            const nextRole = mergeRoles(entry.role, accountMeta.role);\n                            if ('lookupTableAddress' in accountMeta) {\n                                const shouldReplaceEntry =\n                                    // Consider using the new LOOKUP_TABLE if its address is different...\n                                    entry.lookupTableAddress !== accountMeta.lookupTableAddress &&\n                                    // ...and sorts before the existing one.\n                                    (addressComparator ||= getAddressComparator())(\n                                        accountMeta.lookupTableAddress,\n                                        entry.lookupTableAddress,\n                                    ) < 0;\n                                if (shouldReplaceEntry) {\n                                    return {\n                                        [TYPE]: AddressMapEntryType.LOOKUP_TABLE,\n                                        ...accountMeta,\n                                        role: nextRole,\n                                    } as LookupTableAccountEntry;\n                                }\n                            } else if (isSignerRole(accountMeta.role)) {\n                                // Upgrade this LOOKUP_TABLE entry to a static entry if it must sign.\n                                return {\n                                    [TYPE]: AddressMapEntryType.STATIC,\n                                    role: nextRole,\n                                } as StaticAccountEntry;\n                            }\n                            if (entry.role !== nextRole) {\n                                return {\n                                    ...entry,\n                                    role: nextRole,\n                                } as LookupTableAccountEntry;\n                            } else {\n                                return entry;\n                            }\n                        }\n                        case AddressMapEntryType.STATIC: {\n                            const nextRole = mergeRoles(entry.role, accountMeta.role);\n                            if (\n                                // Check to see if this address represents a program that is invoked\n                                // in this transaction.\n                                addressesOfInvokedPrograms.has(account.address)\n                            ) {\n                                if (isWritableRole(accountMeta.role)) {\n                                    throw new SolanaError(\n                                        SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE,\n                                        {\n                                            programAddress: account.address,\n                                        },\n                                    );\n                                }\n                                if (entry.role !== nextRole) {\n                                    return {\n                                        ...entry,\n                                        role: nextRole,\n                                    } as StaticAccountEntry;\n                                } else {\n                                    return entry;\n                                }\n                            } else if (\n                                'lookupTableAddress' in accountMeta &&\n                                // Static accounts can be 'upgraded' to lookup table accounts as\n                                // long as they are not require to sign the transaction.\n                                !isSignerRole(entry.role)\n                            ) {\n                                return {\n                                    ...accountMeta,\n                                    [TYPE]: AddressMapEntryType.LOOKUP_TABLE,\n                                    role: nextRole,\n                                } as LookupTableAccountEntry;\n                            } else {\n                                if (entry.role !== nextRole) {\n                                    // The account's role ranks higher than the current entry's.\n                                    return {\n                                        ...entry,\n                                        role: nextRole,\n                                    } as StaticAccountEntry;\n                                } else {\n                                    return entry;\n                                }\n                            }\n                        }\n                    }\n                }\n                if ('lookupTableAddress' in accountMeta) {\n                    return {\n                        ...accountMeta,\n                        [TYPE]: AddressMapEntryType.LOOKUP_TABLE,\n                    };\n                } else {\n                    return {\n                        ...accountMeta,\n                        [TYPE]: AddressMapEntryType.STATIC,\n                    };\n                }\n            });\n        }\n    }\n    return addressMap;\n}\n\nexport function getOrderedAccountsFromAddressMap(addressMap: AddressMap): OrderedAccounts {\n    let addressComparator: ReturnType<typeof getAddressComparator>;\n    const orderedAccounts: (AccountLookupMeta | AccountMeta)[] = Object.entries(addressMap)\n        .sort(([leftAddress, leftEntry], [rightAddress, rightEntry]) => {\n            // STEP 1: Rapid precedence check. Fee payer, then static addresses, then lookups.\n            if (leftEntry[TYPE] !== rightEntry[TYPE]) {\n                if (leftEntry[TYPE] === AddressMapEntryType.FEE_PAYER) {\n                    return -1;\n                } else if (rightEntry[TYPE] === AddressMapEntryType.FEE_PAYER) {\n                    return 1;\n                } else if (leftEntry[TYPE] === AddressMapEntryType.STATIC) {\n                    return -1;\n                } else if (rightEntry[TYPE] === AddressMapEntryType.STATIC) {\n                    return 1;\n                }\n            }\n            // STEP 2: Sort by signer-writability.\n            const leftIsSigner = isSignerRole(leftEntry.role);\n            if (leftIsSigner !== isSignerRole(rightEntry.role)) {\n                return leftIsSigner ? -1 : 1;\n            }\n            const leftIsWritable = isWritableRole(leftEntry.role);\n            if (leftIsWritable !== isWritableRole(rightEntry.role)) {\n                return leftIsWritable ? -1 : 1;\n            }\n            // STEP 3: Sort by address.\n            addressComparator ||= getAddressComparator();\n            if (\n                leftEntry[TYPE] === AddressMapEntryType.LOOKUP_TABLE &&\n                rightEntry[TYPE] === AddressMapEntryType.LOOKUP_TABLE &&\n                leftEntry.lookupTableAddress !== rightEntry.lookupTableAddress\n            ) {\n                return addressComparator(leftEntry.lookupTableAddress, rightEntry.lookupTableAddress);\n            } else {\n                return addressComparator(leftAddress, rightAddress);\n            }\n        })\n        .map(([address, addressMeta]) => ({\n            address: address as Address<typeof address>,\n            ...addressMeta,\n        }));\n    return orderedAccounts as unknown as OrderedAccounts;\n}\n","import { Address, getAddressComparator } from '@solana/addresses';\nimport { AccountRole } from '@solana/instructions';\n\nimport { OrderedAccounts } from '../compile/accounts';\n\ntype AddressTableLookup = Readonly<{\n    /** The address of the address lookup table account. */\n    lookupTableAddress: Address;\n    /** Indexes of accounts in a lookup table to load as read-only. */\n    readonlyIndexes: readonly number[];\n    /** Indexes of accounts in a lookup table to load as writable. */\n    writableIndexes: readonly number[];\n}>;\n\nexport function getCompiledAddressTableLookups(orderedAccounts: OrderedAccounts): AddressTableLookup[] {\n    const index: Record<\n        Address,\n        Readonly<{\n            [K in keyof Omit<AddressTableLookup, 'lookupTableAddress'>]: number[];\n        }>\n    > = {};\n    for (const account of orderedAccounts) {\n        if (!('lookupTableAddress' in account)) {\n            continue;\n        }\n        const entry = (index[account.lookupTableAddress] ||= {\n            readonlyIndexes: [],\n            writableIndexes: [],\n        });\n        if (account.role === AccountRole.WRITABLE) {\n            entry.writableIndexes.push(account.addressIndex);\n        } else {\n            entry.readonlyIndexes.push(account.addressIndex);\n        }\n    }\n    return Object.keys(index)\n        .sort(getAddressComparator())\n        .map(lookupTableAddress => ({\n            lookupTableAddress: lookupTableAddress as Address,\n            ...index[lookupTableAddress as unknown as Address],\n        }));\n}\n","import { isSignerRole, isWritableRole } from '@solana/instructions';\n\nimport { OrderedAccounts } from '../compile/accounts';\n\ntype MessageHeader = Readonly<{\n    /**\n     * The number of accounts in the static accounts list that are neither writable nor\n     * signers.\n     *\n     * Adding this number to `numSignerAccounts` yields the index of the first read-only non-signer\n     * account in the static accounts list.\n     */\n    numReadonlyNonSignerAccounts: number;\n    /**\n     * The number of read-only accounts in the static accounts list that must sign this\n     * transaction.\n     *\n     * Subtracting this number from `numSignerAccounts` yields the index of the first read-only\n     * signer account in the static accounts list.\n     */\n    numReadonlySignerAccounts: number;\n    /**\n     * The number of accounts in the static accounts list that must sign this transaction.\n     *\n     * Subtracting `numReadonlySignerAccounts` from this number yields the number of\n     * writable signer accounts in the static accounts list. Writable signer accounts always\n     * begin at index zero in the static accounts list.\n     *\n     * This number itself is the index of the first non-signer account in the static\n     * accounts list.\n     */\n    numSignerAccounts: number;\n}>;\n\nexport function getCompiledMessageHeader(orderedAccounts: OrderedAccounts): MessageHeader {\n    let numReadonlyNonSignerAccounts = 0;\n    let numReadonlySignerAccounts = 0;\n    let numSignerAccounts = 0;\n    for (const account of orderedAccounts) {\n        if ('lookupTableAddress' in account) {\n            break;\n        }\n        const accountIsWritable = isWritableRole(account.role);\n        if (isSignerRole(account.role)) {\n            numSignerAccounts++;\n            if (!accountIsWritable) {\n                numReadonlySignerAccounts++;\n            }\n        } else if (!accountIsWritable) {\n            numReadonlyNonSignerAccounts++;\n        }\n    }\n    return {\n        numReadonlyNonSignerAccounts,\n        numReadonlySignerAccounts,\n        numSignerAccounts,\n    };\n}\n","import { Address } from '@solana/addresses';\nimport { ReadonlyUint8Array } from '@solana/codecs-core';\nimport { Instruction } from '@solana/instructions';\n\nimport { OrderedAccounts } from './accounts';\n\ntype CompiledInstruction = Readonly<{\n    /**\n     * An ordered list of indices that indicate which accounts in the transaction message's\n     * accounts list are loaded by this instruction.\n     */\n    accountIndices?: number[];\n    /** The input to the invoked program */\n    data?: ReadonlyUint8Array;\n    /**\n     * The index of the address in the transaction message's accounts list associated with the\n     * program to invoke.\n     */\n    programAddressIndex: number;\n}>;\n\nfunction getAccountIndex(orderedAccounts: OrderedAccounts) {\n    const out: Record<Address, number> = {};\n    for (const [index, account] of orderedAccounts.entries()) {\n        out[account.address] = index;\n    }\n    return out;\n}\n\nexport function getCompiledInstructions(\n    instructions: readonly Instruction[],\n    orderedAccounts: OrderedAccounts,\n): CompiledInstruction[] {\n    const accountIndex = getAccountIndex(orderedAccounts);\n    return instructions.map(({ accounts, data, programAddress }) => {\n        return {\n            programAddressIndex: accountIndex[programAddress],\n            ...(accounts ? { accountIndices: accounts.map(({ address }) => accountIndex[address]) } : null),\n            ...(data ? { data } : null),\n        };\n    });\n}\n","import { TransactionMessageWithBlockhashLifetime, TransactionMessageWithDurableNonceLifetime } from '../index';\n\nexport function getCompiledLifetimeToken(\n    lifetimeConstraint: (\n        | TransactionMessageWithBlockhashLifetime\n        | TransactionMessageWithDurableNonceLifetime\n    )['lifetimeConstraint'],\n): string {\n    if ('nonce' in lifetimeConstraint) {\n        return lifetimeConstraint.nonce;\n    }\n    return lifetimeConstraint.blockhash;\n}\n","import { Address } from '@solana/addresses';\n\nimport { OrderedAccounts } from './accounts';\n\nexport function getCompiledStaticAccounts(orderedAccounts: OrderedAccounts): Address[] {\n    const firstLookupTableAccountIndex = orderedAccounts.findIndex(account => 'lookupTableAddress' in account);\n    const orderedStaticAccounts =\n        firstLookupTableAccountIndex === -1 ? orderedAccounts : orderedAccounts.slice(0, firstLookupTableAccountIndex);\n    return orderedStaticAccounts.map(({ address }) => address);\n}\n","import { TransactionMessageWithFeePayer } from '../fee-payer';\nimport { TransactionMessageWithLifetime } from '../lifetime';\nimport { BaseTransactionMessage } from '../transaction-message';\nimport { getAddressMapFromInstructions, getOrderedAccountsFromAddressMap } from './accounts';\nimport { getCompiledAddressTableLookups } from './address-table-lookups';\nimport { getCompiledMessageHeader } from './header';\nimport { getCompiledInstructions } from './instructions';\nimport { getCompiledLifetimeToken } from './lifetime-token';\nimport { getCompiledStaticAccounts } from './static-accounts';\n\ntype BaseCompiledTransactionMessage = Readonly<{\n    /**\n     * Information about the version of the transaction message and the role of the accounts it\n     * loads.\n     */\n    header: ReturnType<typeof getCompiledMessageHeader>;\n    instructions: ReturnType<typeof getCompiledInstructions>;\n    /** A list of addresses indicating which accounts to load */\n    staticAccounts: ReturnType<typeof getCompiledStaticAccounts>;\n}>;\n\n/**\n * A transaction message in a form suitable for encoding for execution on the network.\n *\n * You can not fully reconstruct a source message from a compiled message without extra information.\n * In particular, supporting details about the lifetime constraint and the concrete addresses of\n * accounts sourced from account lookup tables are lost to compilation.\n */\nexport type CompiledTransactionMessage = LegacyCompiledTransactionMessage | VersionedCompiledTransactionMessage;\n\nexport type CompiledTransactionMessageWithLifetime = Readonly<{\n    /**\n     * 32 bytes of data observed by the transaction proposed that makes a transaction eligible to\n     * land on the network.\n     *\n     * In the case of a transaction message with a nonce lifetime constraint, this will be the value\n     * of the nonce itself. In all other cases this will be a recent blockhash.\n     */\n    lifetimeToken: ReturnType<typeof getCompiledLifetimeToken>;\n}>;\n\ntype LegacyCompiledTransactionMessage = BaseCompiledTransactionMessage &\n    Readonly<{\n        version: 'legacy';\n    }>;\n\ntype VersionedCompiledTransactionMessage = BaseCompiledTransactionMessage &\n    Readonly<{\n        /** A list of address tables and the accounts that this transaction loads from them */\n        addressTableLookups?: ReturnType<typeof getCompiledAddressTableLookups>;\n        version: 0;\n    }>;\n\n/**\n * Converts the type of transaction message data structure that you create in your application to\n * the type of transaction message data structure that can be encoded for execution on the network.\n *\n * This is a lossy process; you can not fully reconstruct a source message from a compiled message\n * without extra information. In particular, supporting details about the lifetime constraint and\n * the concrete addresses of accounts sourced from account lookup tables will be lost to\n * compilation.\n *\n * @see {@link decompileTransactionMessage}\n */\nexport function compileTransactionMessage<\n    TTransactionMessage extends BaseTransactionMessage & TransactionMessageWithFeePayer,\n>(transactionMessage: TTransactionMessage): CompiledTransactionMessageFromTransactionMessage<TTransactionMessage> {\n    type ReturnType = CompiledTransactionMessageFromTransactionMessage<TTransactionMessage>;\n\n    const addressMap = getAddressMapFromInstructions(\n        transactionMessage.feePayer.address,\n        transactionMessage.instructions,\n    );\n    const orderedAccounts = getOrderedAccountsFromAddressMap(addressMap);\n    const lifetimeConstraint = (transactionMessage as Partial<TransactionMessageWithLifetime>).lifetimeConstraint;\n\n    return {\n        ...(transactionMessage.version !== 'legacy'\n            ? { addressTableLookups: getCompiledAddressTableLookups(orderedAccounts) }\n            : null),\n        ...(lifetimeConstraint ? { lifetimeToken: getCompiledLifetimeToken(lifetimeConstraint) } : null),\n        header: getCompiledMessageHeader(orderedAccounts),\n        instructions: getCompiledInstructions(transactionMessage.instructions, orderedAccounts),\n        staticAccounts: getCompiledStaticAccounts(orderedAccounts),\n        version: transactionMessage.version,\n    } as ReturnType;\n}\n\ntype CompiledTransactionMessageFromTransactionMessage<TTransactionMessage extends BaseTransactionMessage> =\n    ForwardTransactionMessageLifetime<ForwardTransactionMessageVersion<TTransactionMessage>, TTransactionMessage>;\n\ntype ForwardTransactionMessageVersion<TTransactionMessage extends BaseTransactionMessage> =\n    TTransactionMessage extends Readonly<{ version: 'legacy' }>\n        ? LegacyCompiledTransactionMessage\n        : VersionedCompiledTransactionMessage;\n\ntype ForwardTransactionMessageLifetime<\n    TCompiledTransactionMessage extends CompiledTransactionMessage,\n    TTransactionMessage extends BaseTransactionMessage,\n> = TTransactionMessage extends TransactionMessageWithLifetime\n    ? CompiledTransactionMessageWithLifetime & TCompiledTransactionMessage\n    : TCompiledTransactionMessage;\n","import { Address } from '@solana/addresses';\nimport { AccountLookupMeta, AccountMeta, AccountRole, Instruction, isSignerRole } from '@solana/instructions';\n\nimport { AddressesByLookupTableAddress } from './addresses-by-lookup-table-address';\nimport { BaseTransactionMessage, TransactionMessage } from './transaction-message';\n\ntype Mutable<T> = {\n    -readonly [P in keyof T]: T[P];\n};\n\n// Look up the address in lookup tables, return a lookup meta if it is found in any of them\nfunction findAddressInLookupTables(\n    address: Address,\n    role: AccountRole.READONLY | AccountRole.WRITABLE,\n    addressesByLookupTableAddress: AddressesByLookupTableAddress,\n): AccountLookupMeta | undefined {\n    for (const [lookupTableAddress, addresses] of Object.entries(addressesByLookupTableAddress)) {\n        for (let i = 0; i < addresses.length; i++) {\n            if (address === addresses[i]) {\n                return {\n                    address,\n                    addressIndex: i,\n                    lookupTableAddress: lookupTableAddress as Address,\n                    role,\n                };\n            }\n        }\n    }\n}\n\ntype TransactionMessageNotLegacy = Exclude<TransactionMessage, { version: 'legacy' }>;\n\n// Each account can be AccountLookupMeta | AccountMeta\ntype WidenInstructionAccounts<TInstruction extends Instruction> =\n    TInstruction extends Instruction<infer TProgramAddress, infer TAccounts>\n        ? Instruction<\n              TProgramAddress,\n              {\n                  [K in keyof TAccounts]: TAccounts[K] extends AccountMeta<infer TAddress>\n                      ? AccountLookupMeta<TAddress> | AccountMeta<TAddress>\n                      : TAccounts[K];\n              }\n          >\n        : TInstruction;\n\ntype ExtractAdditionalProps<T, U> = Omit<T, keyof U>;\n\ntype WidenTransactionMessageInstructions<TTransactionMessage extends TransactionMessage> =\n    TTransactionMessage extends BaseTransactionMessage<infer TVersion, infer TInstruction>\n        ? BaseTransactionMessage<TVersion, WidenInstructionAccounts<TInstruction>> &\n              ExtractAdditionalProps<\n                  TTransactionMessage,\n                  BaseTransactionMessage<TVersion, WidenInstructionAccounts<TInstruction>>\n              >\n        : TTransactionMessage;\n\n/**\n * Given a transaction message and a mapping of lookup tables to the addresses stored in them, this\n * function will return a new transaction message with the same instructions but with all non-signer\n * accounts that are found in the given lookup tables represented by an {@link AccountLookupMeta}\n * instead of an {@link AccountMeta}.\n *\n * This means that these accounts will take up less space in the compiled transaction message. This\n * size reduction is most significant when the transaction includes many accounts from the same\n * lookup table.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import {\n *     AddressesByLookupTableAddress,\n *     compressTransactionMessageUsingAddressLookupTables,\n * } from '@solana/transaction-messages';\n * import { fetchAddressLookupTable } from '@solana-program/address-lookup-table';\n *\n * const lookupTableAddress = address('4QwSwNriKPrz8DLW4ju5uxC2TN5cksJx6tPUPj7DGLAW');\n * const {\n *     data: { addresses },\n * } = await fetchAddressLookupTable(rpc, lookupTableAddress);\n * const addressesByAddressLookupTable: AddressesByLookupTableAddress = {\n *     [lookupTableAddress]: addresses,\n * };\n *\n * const compressedTransactionMessage = compressTransactionMessageUsingAddressLookupTables(\n *     transactionMessage,\n *     addressesByAddressLookupTable,\n * );\n * ```\n */\nexport function compressTransactionMessageUsingAddressLookupTables<\n    TTransactionMessage extends TransactionMessageNotLegacy = TransactionMessageNotLegacy,\n>(\n    transactionMessage: TTransactionMessage,\n    addressesByLookupTableAddress: AddressesByLookupTableAddress,\n): TTransactionMessage | WidenTransactionMessageInstructions<TTransactionMessage> {\n    const programAddresses = new Set(transactionMessage.instructions.map(ix => ix.programAddress));\n    const eligibleLookupAddresses = new Set(\n        Object.values(addressesByLookupTableAddress)\n            .flatMap(a => a)\n            .filter(address => !programAddresses.has(address)),\n    );\n    const newInstructions: Instruction[] = [];\n    let updatedAnyInstructions = false;\n    for (const instruction of transactionMessage.instructions) {\n        if (!instruction.accounts) {\n            newInstructions.push(instruction);\n            continue;\n        }\n\n        const newAccounts: Mutable<NonNullable<Instruction['accounts']>> = [];\n        let updatedAnyAccounts = false;\n        for (const account of instruction.accounts) {\n            // If the address is already a lookup, is not in any lookup tables, or is a signer role, return as-is\n            if (\n                'lookupTableAddress' in account ||\n                !eligibleLookupAddresses.has(account.address) ||\n                isSignerRole(account.role)\n            ) {\n                newAccounts.push(account);\n                continue;\n            }\n\n            // We already checked it's in one of the lookup tables\n            const lookupMetaAccount = findAddressInLookupTables(\n                account.address,\n                account.role,\n                addressesByLookupTableAddress,\n            )!;\n            newAccounts.push(Object.freeze(lookupMetaAccount));\n            updatedAnyAccounts = true;\n            updatedAnyInstructions = true;\n        }\n\n        newInstructions.push(\n            Object.freeze(updatedAnyAccounts ? { ...instruction, accounts: newAccounts } : instruction),\n        );\n    }\n\n    return Object.freeze(\n        updatedAnyInstructions ? { ...transactionMessage, instructions: newInstructions } : transactionMessage,\n    );\n}\n","import { TransactionMessage, TransactionVersion } from './transaction-message';\nimport { TransactionMessageWithinSizeLimit } from './transaction-message-size';\n\ntype TransactionConfig<TVersion extends TransactionVersion> = Readonly<{\n    version: TVersion;\n}>;\n\ntype EmptyTransactionMessage<TVersion extends TransactionVersion> = Omit<\n    Extract<TransactionMessage, { version: TVersion }>,\n    'instructions'\n> &\n    TransactionMessageWithinSizeLimit & { instructions: readonly [] };\n\n/**\n * Given a {@link TransactionVersion} this method will return an empty transaction having the\n * capabilities of that version.\n *\n * @example\n * ```ts\n * import { createTransactionMessage } from '@solana/transaction-messages';\n *\n * const message = createTransactionMessage({ version: 0 });\n * ```\n */\nexport function createTransactionMessage<TVersion extends TransactionVersion>(\n    config: TransactionConfig<TVersion>,\n): EmptyTransactionMessage<TVersion> {\n    return Object.freeze({\n        instructions: Object.freeze([]),\n        version: config.version,\n    }) as EmptyTransactionMessage<TVersion>;\n}\n","import { Address } from '@solana/addresses';\nimport { ReadonlyUint8Array } from '@solana/codecs-core';\nimport {\n    AccountRole,\n    Instruction,\n    InstructionWithAccounts,\n    InstructionWithData,\n    isSignerRole,\n    ReadonlyAccount,\n    ReadonlySignerAccount,\n    WritableAccount,\n    WritableSignerAccount,\n} from '@solana/instructions';\nimport { Brand } from '@solana/nominal-types';\n\nexport type AdvanceNonceAccountInstruction<\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n> = Instruction<'11111111111111111111111111111111'> &\n    InstructionWithAccounts<\n        readonly [\n            WritableAccount<TNonceAccountAddress>,\n            ReadonlyAccount<'SysvarRecentB1ockHashes11111111111111111111'>,\n            ReadonlySignerAccount<TNonceAuthorityAddress> | WritableSignerAccount<TNonceAuthorityAddress>,\n        ]\n    > &\n    InstructionWithData<AdvanceNonceAccountInstructionData>;\n\ntype AdvanceNonceAccountInstructionData = Brand<Uint8Array, 'AdvanceNonceAccountInstructionData'>;\n\nconst RECENT_BLOCKHASHES_SYSVAR_ADDRESS =\n    'SysvarRecentB1ockHashes11111111111111111111' as Address<'SysvarRecentB1ockHashes11111111111111111111'>;\nconst SYSTEM_PROGRAM_ADDRESS = '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n\n/**\n * Creates an instruction for the System program to advance a nonce.\n *\n * This instruction is a prerequisite for a transaction with a nonce-based lifetime to be landed on\n * the network. In order to be considered valid, the transaction must meet all of these criteria.\n *\n * 1. Its lifetime constraint must be a {@link NonceLifetimeConstraint}.\n * 2. The value contained in the on-chain account at the address `nonceAccountAddress` must be equal\n *    to {@link NonceLifetimeConstraint.nonce} at the time the transaction is landed.\n * 3. The first instruction in that transaction message must be the one returned by this function.\n *\n * You could also use the `getAdvanceNonceAccountInstruction` method of `@solana-program/system`.\n */\nexport function createAdvanceNonceAccountInstruction<\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n>(\n    nonceAccountAddress: Address<TNonceAccountAddress>,\n    nonceAuthorityAddress: Address<TNonceAuthorityAddress>,\n): AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress> {\n    return {\n        accounts: [\n            { address: nonceAccountAddress, role: AccountRole.WRITABLE },\n            {\n                address: RECENT_BLOCKHASHES_SYSVAR_ADDRESS,\n                role: AccountRole.READONLY,\n            },\n            { address: nonceAuthorityAddress, role: AccountRole.READONLY_SIGNER },\n        ],\n        data: new Uint8Array([4, 0, 0, 0]) as AdvanceNonceAccountInstructionData,\n        programAddress: SYSTEM_PROGRAM_ADDRESS,\n    };\n}\n\n/**\n * A type guard that returns `true` if the instruction conforms to the\n * {@link AdvanceNonceAccountInstruction} type, and refines its type for use in your program.\n *\n * @example\n * ```ts\n * import { isAdvanceNonceAccountInstruction } from '@solana/transaction-messages';\n *\n * if (isAdvanceNonceAccountInstruction(message.instructions[0])) {\n *     // At this point, the first instruction in the message has been refined to a\n *     // `AdvanceNonceAccountInstruction`.\n *     setNonceAccountAddress(message.instructions[0].accounts[0].address);\n * } else {\n *     setError('The first instruction is not an `AdvanceNonce` instruction');\n * }\n * ```\n */\nexport function isAdvanceNonceAccountInstruction(\n    instruction: Instruction,\n): instruction is AdvanceNonceAccountInstruction {\n    return (\n        instruction.programAddress === SYSTEM_PROGRAM_ADDRESS &&\n        // Test for `AdvanceNonceAccount` instruction data\n        instruction.data != null &&\n        isAdvanceNonceAccountInstructionData(instruction.data) &&\n        // Test for exactly 3 accounts\n        instruction.accounts?.length === 3 &&\n        // First account is nonce account address\n        instruction.accounts[0].address != null &&\n        instruction.accounts[0].role === AccountRole.WRITABLE &&\n        // Second account is recent blockhashes sysvar\n        instruction.accounts[1].address === RECENT_BLOCKHASHES_SYSVAR_ADDRESS &&\n        instruction.accounts[1].role === AccountRole.READONLY &&\n        // Third account is nonce authority account\n        instruction.accounts[2].address != null &&\n        isSignerRole(instruction.accounts[2].role)\n    );\n}\n\nfunction isAdvanceNonceAccountInstructionData(data: ReadonlyUint8Array): data is AdvanceNonceAccountInstructionData {\n    // AdvanceNonceAccount is the fifth instruction in the System Program (index 4)\n    return data.byteLength === 4 && data[0] === 4 && data[1] === 0 && data[2] === 0 && data[3] === 0;\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME, SolanaError } from '@solana/errors';\nimport { Instruction } from '@solana/instructions';\nimport { Brand } from '@solana/nominal-types';\n\nimport {\n    AdvanceNonceAccountInstruction,\n    createAdvanceNonceAccountInstruction,\n    isAdvanceNonceAccountInstruction,\n} from './durable-nonce-instruction';\nimport { ExcludeTransactionMessageLifetime } from './lifetime';\nimport { BaseTransactionMessage } from './transaction-message';\nimport { ExcludeTransactionMessageWithinSizeLimit } from './transaction-message-size';\n\ntype DurableNonceConfig<\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n    TNonceValue extends string = string,\n> = Readonly<{\n    readonly nonce: Nonce<TNonceValue>;\n    readonly nonceAccountAddress: Address<TNonceAccountAddress>;\n    readonly nonceAuthorityAddress: Address<TNonceAuthorityAddress>;\n}>;\n\n/** Represents a string that is particularly known to be the base58-encoded value of a nonce. */\nexport type Nonce<TNonceValue extends string = string> = Brand<TNonceValue, 'Nonce'>;\n\n/**\n * A constraint which, when applied to a transaction message, makes that transaction message\n * eligible to land on the network.\n *\n * The transaction message will continue to be eligible to land until the network considers the\n * `nonce` to have advanced. This can happen when the nonce account in which this nonce is found is\n * destroyed, or the nonce value within changes.\n */\ntype NonceLifetimeConstraint<TNonceValue extends string = string> = Readonly<{\n    /**\n     * A value contained in the related nonce account at the time the transaction was prepared.\n     *\n     * The transaction will be considered eligible to land until the nonce account ceases to exist\n     * or contain this value.\n     */\n    nonce: Nonce<TNonceValue>;\n}>;\n\n/**\n * Represents a transaction message whose lifetime is defined by the value of a nonce it includes.\n *\n * Such a transaction can only be landed on the network if the nonce is known to the network and has\n * not already been used to land a different transaction.\n */\nexport interface TransactionMessageWithDurableNonceLifetime<\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n    TNonceValue extends string = string,\n> {\n    readonly instructions: readonly [\n        // The first instruction *must* be the system program's `AdvanceNonceAccount` instruction.\n        AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress>,\n        ...Instruction[],\n    ];\n    readonly lifetimeConstraint: NonceLifetimeConstraint<TNonceValue>;\n}\n\n/**\n * A helper type to exclude the durable nonce lifetime constraint from a transaction message.\n */\nexport type ExcludeTransactionMessageDurableNonceLifetime<TTransactionMessage extends BaseTransactionMessage> =\n    TTransactionMessage extends TransactionMessageWithDurableNonceLifetime\n        ? ExcludeTransactionMessageLifetime<TTransactionMessage>\n        : TTransactionMessage;\n\n/**\n * A type guard that returns `true` if the transaction message conforms to the\n * {@link TransactionMessageWithDurableNonceLifetime} type, and refines its type for use in your\n * program.\n *\n * @example\n * ```ts\n * import { isTransactionMessageWithDurableNonceLifetime } from '@solana/transaction-messages';\n * import { fetchNonce } from \"@solana-program/system\";\n *\n * if (isTransactionMessageWithDurableNonceLifetime(message)) {\n *     // At this point, `message` has been refined to a\n *     // `TransactionMessageWithDurableNonceLifetime`.\n *     const { nonce, nonceAccountAddress } = message.lifetimeConstraint;\n *     const { data: { blockhash: actualNonce } } = await fetchNonce(nonceAccountAddress);\n *     setNonceIsValid(nonce === actualNonce);\n * } else {\n *     setError(\n *         `${getSignatureFromTransaction(transaction)} does not have a nonce-based lifetime`,\n *     );\n * }\n * ```\n */\nexport function isTransactionMessageWithDurableNonceLifetime(\n    transactionMessage: BaseTransactionMessage | (BaseTransactionMessage & TransactionMessageWithDurableNonceLifetime),\n): transactionMessage is BaseTransactionMessage & TransactionMessageWithDurableNonceLifetime {\n    return (\n        'lifetimeConstraint' in transactionMessage &&\n        typeof transactionMessage.lifetimeConstraint.nonce === 'string' &&\n        transactionMessage.instructions[0] != null &&\n        isAdvanceNonceAccountInstruction(transactionMessage.instructions[0])\n    );\n}\n\n/**\n * From time to time you might acquire a transaction message, that you expect to have a\n * nonce-based lifetime, from an untrusted network API or user input. Use this function to assert\n * that such a transaction message actually has a nonce-based lifetime.\n *\n * @example\n * ```ts\n * import { assertIsTransactionMessageWithDurableNonceLifetime } from '@solana/transaction-messages';\n *\n * try {\n *     // If this type assertion function doesn't throw, then\n *     // Typescript will upcast `message` to `TransactionMessageWithDurableNonceLifetime`.\n *     assertIsTransactionMessageWithDurableNonceLifetime(message);\n *     // At this point, `message` is a `TransactionMessageWithDurableNonceLifetime` that can be used\n *     // with the RPC.\n *     const { nonce, nonceAccountAddress } = message.lifetimeConstraint;\n *     const { data: { blockhash: actualNonce } } = await fetchNonce(nonceAccountAddress);\n * } catch (e) {\n *     // `message` turned out not to have a nonce-based lifetime\n * }\n * ```\n */\nexport function assertIsTransactionMessageWithDurableNonceLifetime(\n    transactionMessage: BaseTransactionMessage | (BaseTransactionMessage & TransactionMessageWithDurableNonceLifetime),\n): asserts transactionMessage is BaseTransactionMessage & TransactionMessageWithDurableNonceLifetime {\n    if (!isTransactionMessageWithDurableNonceLifetime(transactionMessage)) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME);\n    }\n}\n\nfunction isAdvanceNonceAccountInstructionForNonce<\n    TNonceAccountAddress extends Address = Address,\n    TNonceAuthorityAddress extends Address = Address,\n>(\n    instruction: AdvanceNonceAccountInstruction,\n    nonceAccountAddress: TNonceAccountAddress,\n    nonceAuthorityAddress: TNonceAuthorityAddress,\n): instruction is AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress> {\n    return (\n        instruction.accounts[0].address === nonceAccountAddress &&\n        instruction.accounts[2].address === nonceAuthorityAddress\n    );\n}\n\n/**\n * Given a nonce, the account where the value of the nonce is stored, and the address of the account\n * authorized to consume that nonce, this method will return a new transaction having the same type\n * as the one supplied plus the {@link TransactionMessageWithDurableNonceLifetime} type.\n *\n * In particular, this method _prepends_ an instruction to the transaction message designed to\n * consume (or 'advance') the nonce in the same transaction whose lifetime is defined by it.\n *\n * @param config\n *\n * @example\n * ```ts\n * import { Nonce, setTransactionMessageLifetimeUsingDurableNonce } from '@solana/transaction-messages';\n * import { fetchNonce } from '@solana-program/system';\n *\n * const nonceAccountAddress = address('EGtMh4yvXswwHhwVhyPxGrVV2TkLTgUqGodbATEPvojZ');\n * const nonceAuthorityAddress = address('4KD1Rdrd89NG7XbzW3xsX9Aqnx2EExJvExiNme6g9iAT');\n *\n * const {\n *     data: { blockhash },\n * } = await fetchNonce(rpc, nonceAccountAddress);\n * const nonce = blockhash as string as Nonce;\n *\n * const durableNonceTransactionMessage = setTransactionMessageLifetimeUsingDurableNonce(\n *     { nonce, nonceAccountAddress, nonceAuthorityAddress },\n *     tx,\n * );\n * ```\n */\nexport function setTransactionMessageLifetimeUsingDurableNonce<\n    TTransactionMessage extends BaseTransactionMessage,\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n    TNonceValue extends string = string,\n>(\n    {\n        nonce,\n        nonceAccountAddress,\n        nonceAuthorityAddress,\n    }: DurableNonceConfig<TNonceAccountAddress, TNonceAuthorityAddress, TNonceValue>,\n    transactionMessage: TTransactionMessage,\n): SetTransactionMessageWithDurableNonceLifetime<\n    TTransactionMessage,\n    TNonceAccountAddress,\n    TNonceAuthorityAddress,\n    TNonceValue\n> {\n    type ReturnType = SetTransactionMessageWithDurableNonceLifetime<\n        TTransactionMessage,\n        TNonceAccountAddress,\n        TNonceAuthorityAddress,\n        TNonceValue\n    >;\n\n    let newInstructions: [\n        AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress>,\n        ...Instruction[],\n    ];\n\n    const firstInstruction = transactionMessage.instructions[0];\n    if (firstInstruction && isAdvanceNonceAccountInstruction(firstInstruction)) {\n        if (isAdvanceNonceAccountInstructionForNonce(firstInstruction, nonceAccountAddress, nonceAuthorityAddress)) {\n            if (\n                isTransactionMessageWithDurableNonceLifetime(transactionMessage) &&\n                transactionMessage.lifetimeConstraint.nonce === nonce\n            ) {\n                return transactionMessage as unknown as ReturnType;\n            } else {\n                // we already have the right first instruction, leave it as-is\n                newInstructions = [firstInstruction, ...transactionMessage.instructions.slice(1)];\n            }\n        } else {\n            // we have a different advance nonce instruction as the first instruction, replace it\n            newInstructions = [\n                Object.freeze(createAdvanceNonceAccountInstruction(nonceAccountAddress, nonceAuthorityAddress)),\n                ...transactionMessage.instructions.slice(1),\n            ];\n        }\n    } else {\n        // we don't have an existing advance nonce instruction as the first instruction, prepend one\n        newInstructions = [\n            Object.freeze(createAdvanceNonceAccountInstruction(nonceAccountAddress, nonceAuthorityAddress)),\n            ...transactionMessage.instructions,\n        ];\n    }\n\n    return Object.freeze({\n        ...transactionMessage,\n        instructions: Object.freeze(newInstructions),\n        lifetimeConstraint: Object.freeze({ nonce }),\n    }) as unknown as ReturnType;\n}\n\n/**\n * Helper type that transforms a given transaction message type into a new one that has the\n * `AdvanceNonceAccount` instruction as the first instruction and a lifetime constraint\n * representing the nonce value.\n */\ntype SetTransactionMessageWithDurableNonceLifetime<\n    TTransactionMessage extends BaseTransactionMessage,\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n    TNonceValue extends string = string,\n> = Omit<\n    // 1. The transaction message only grows in size if it currently has a different (or no) lifetime.\n    TTransactionMessage extends TransactionMessageWithDurableNonceLifetime\n        ? TTransactionMessage\n        : ExcludeTransactionMessageWithinSizeLimit<TTransactionMessage>,\n    // 2. Remove the instructions array as we are going to replace it with a new one.\n    'instructions'\n> & {\n    // 3. Replace or prepend the first instruction with the advance nonce account instruction.\n    readonly instructions: TTransactionMessage['instructions'] extends readonly [\n        AdvanceNonceAccountInstruction,\n        ...infer TTail extends readonly Instruction[],\n    ]\n        ? readonly [AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress>, ...TTail]\n        : readonly [\n              AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress>,\n              ...TTransactionMessage['instructions'],\n          ];\n    // 4. Set the lifetime constraint to the nonce value.\n    readonly lifetimeConstraint: NonceLifetimeConstraint<TNonceValue>;\n};\n","import { Address } from '@solana/addresses';\n\nimport { BaseTransactionMessage } from './transaction-message';\n\n/**\n * Represents a transaction message for which a fee payer has been declared. A transaction must\n * conform to this type to be compiled and landed on the network.\n */\nexport interface TransactionMessageWithFeePayer<TAddress extends string = string> {\n    readonly feePayer: Readonly<{ address: Address<TAddress> }>;\n}\n\n/**\n * A helper type to exclude the fee payer from a transaction message.\n */\ntype ExcludeTransactionMessageFeePayer<TTransactionMessage extends BaseTransactionMessage> = Omit<\n    TTransactionMessage,\n    'feePayer'\n>;\n\n/**\n * Given a base58-encoded address of a system account, this method will return a new transaction\n * message having the same type as the one supplied plus the {@link TransactionMessageWithFeePayer}\n * type.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { setTransactionMessageFeePayer } from '@solana/transaction-messages';\n *\n * const myAddress = address('mpngsFd4tmbUfzDYJayjKZwZcaR7aWb2793J6grLsGu');\n * const txPaidByMe = setTransactionMessageFeePayer(myAddress, tx);\n * ```\n */\nexport function setTransactionMessageFeePayer<\n    TFeePayerAddress extends string,\n    TTransactionMessage extends BaseTransactionMessage & Partial<TransactionMessageWithFeePayer>,\n>(\n    feePayer: Address<TFeePayerAddress>,\n    transactionMessage: TTransactionMessage,\n): ExcludeTransactionMessageFeePayer<TTransactionMessage> & TransactionMessageWithFeePayer<TFeePayerAddress> {\n    if (\n        'feePayer' in transactionMessage &&\n        feePayer === transactionMessage.feePayer?.address &&\n        isAddressOnlyFeePayer(transactionMessage.feePayer)\n    ) {\n        return transactionMessage as unknown as Omit<TTransactionMessage, 'feePayer'> &\n            TransactionMessageWithFeePayer<TFeePayerAddress>;\n    }\n    const out = {\n        ...transactionMessage,\n        feePayer: Object.freeze({ address: feePayer }),\n    };\n    Object.freeze(out);\n    return out;\n}\n\nfunction isAddressOnlyFeePayer(\n    feePayer: Partial<TransactionMessageWithFeePayer>['feePayer'],\n): feePayer is { address: Address } {\n    return (\n        !!feePayer &&\n        'address' in feePayer &&\n        typeof feePayer.address === 'string' &&\n        Object.keys(feePayer).length === 1\n    );\n}\n","import { Instruction } from '@solana/instructions';\n\nimport { ExcludeTransactionMessageDurableNonceLifetime } from './durable-nonce';\nimport { BaseTransactionMessage } from './transaction-message';\nimport { ExcludeTransactionMessageWithinSizeLimit } from './transaction-message-size';\n\n/**\n * A helper type to append instructions to a transaction message\n * without losing type information about the current instructions.\n */\ntype AppendTransactionMessageInstructions<\n    TTransactionMessage extends BaseTransactionMessage,\n    TInstructions extends readonly Instruction[],\n> = Omit<ExcludeTransactionMessageWithinSizeLimit<TTransactionMessage>, 'instructions'> & {\n    readonly instructions: readonly [...TTransactionMessage['instructions'], ...TInstructions];\n};\n\n/**\n * A helper type to prepend instructions to a transaction message\n * without losing type information about the current instructions.\n */\ntype PrependTransactionMessageInstructions<\n    TTransactionMessage extends BaseTransactionMessage,\n    TInstructions extends readonly Instruction[],\n> = Omit<\n    ExcludeTransactionMessageWithinSizeLimit<ExcludeTransactionMessageDurableNonceLifetime<TTransactionMessage>>,\n    'instructions'\n> & {\n    readonly instructions: readonly [...TInstructions, ...TTransactionMessage['instructions']];\n};\n\n/**\n * Given an instruction, this method will return a new transaction message with that instruction\n * having been added to the end of the list of existing instructions.\n *\n * @see {@link appendTransactionInstructions} if you need to append multiple instructions to a\n * transaction message.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { getUtf8Encoder } from '@solana/codecs-strings';\n * import { appendTransactionMessageInstruction } from '@solana/transaction-messages';\n *\n * const memoTransactionMessage = appendTransactionMessageInstruction(\n *     {\n *         data: getUtf8Encoder().encode('Hello world!'),\n *         programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *     },\n *     transactionMessage,\n * );\n * ```\n */\nexport function appendTransactionMessageInstruction<\n    TTransactionMessage extends BaseTransactionMessage,\n    TInstruction extends Instruction,\n>(\n    instruction: TInstruction,\n    transactionMessage: TTransactionMessage,\n): AppendTransactionMessageInstructions<TTransactionMessage, [TInstruction]> {\n    return appendTransactionMessageInstructions([instruction], transactionMessage);\n}\n\n/**\n * Given an array of instructions, this method will return a new transaction message with those\n * instructions having been added to the end of the list of existing instructions.\n *\n * @see {@link appendTransactionInstruction} if you only need to append one instruction to a\n * transaction message.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { appendTransactionMessageInstructions } from '@solana/transaction-messages';\n *\n * const memoTransaction = appendTransactionMessageInstructions(\n *     [\n *         {\n *             data: new TextEncoder().encode('Hello world!'),\n *             programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *         },\n *         {\n *             data: new TextEncoder().encode('How are you?'),\n *             programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *         },\n *     ],\n *     tx,\n * );\n * ```\n */\nexport function appendTransactionMessageInstructions<\n    TTransactionMessage extends BaseTransactionMessage,\n    const TInstructions extends readonly Instruction[],\n>(\n    instructions: TInstructions,\n    transactionMessage: TTransactionMessage,\n): AppendTransactionMessageInstructions<TTransactionMessage, TInstructions> {\n    return Object.freeze({\n        ...transactionMessage,\n        instructions: Object.freeze([\n            ...(transactionMessage.instructions as TTransactionMessage['instructions']),\n            ...instructions,\n        ] as readonly [...TTransactionMessage['instructions'], ...TInstructions]),\n    });\n}\n\n/**\n * Given an instruction, this method will return a new transaction message with that instruction\n * having been added to the beginning of the list of existing instructions.\n *\n * @see {@link prependTransactionInstructions} if you need to prepend multiple instructions to a\n * transaction message.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { prependTransactionMessageInstruction } from '@solana/transaction-messages';\n *\n * const memoTransaction = prependTransactionMessageInstruction(\n *     {\n *         data: new TextEncoder().encode('Hello world!'),\n *         programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *     },\n *     tx,\n * );\n * ```\n */\nexport function prependTransactionMessageInstruction<\n    TTransactionMessage extends BaseTransactionMessage,\n    TInstruction extends Instruction,\n>(\n    instruction: TInstruction,\n    transactionMessage: TTransactionMessage,\n): PrependTransactionMessageInstructions<TTransactionMessage, [TInstruction]> {\n    return prependTransactionMessageInstructions([instruction], transactionMessage);\n}\n\n/**\n * Given an array of instructions, this method will return a new transaction message with those\n * instructions having been added to the beginning of the list of existing instructions.\n *\n * @see {@link prependTransactionInstruction} if you only need to prepend one instruction to a\n * transaction message.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { prependTransactionMessageInstructions } from '@solana/transaction-messages';\n *\n * const memoTransaction = prependTransactionMessageInstructions(\n *     [\n *         {\n *             data: new TextEncoder().encode('Hello world!'),\n *             programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *         },\n *         {\n *             data: new TextEncoder().encode('How are you?'),\n *             programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *         },\n *     ],\n *     tx,\n * );\n * ```\n */\nexport function prependTransactionMessageInstructions<\n    TTransactionMessage extends BaseTransactionMessage,\n    const TInstructions extends readonly Instruction[],\n>(\n    instructions: TInstructions,\n    transactionMessage: TTransactionMessage,\n): PrependTransactionMessageInstructions<TTransactionMessage, TInstructions> {\n    return Object.freeze({\n        ...(transactionMessage as ExcludeTransactionMessageDurableNonceLifetime<TTransactionMessage>),\n        instructions: Object.freeze([\n            ...instructions,\n            ...(transactionMessage.instructions as TTransactionMessage['instructions']),\n        ] as readonly [...TInstructions, ...TTransactionMessage['instructions']]),\n    });\n}\n","import { Address, assertIsAddress } from '@solana/addresses';\nimport {\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND,\n    SolanaError,\n} from '@solana/errors';\nimport { pipe } from '@solana/functional';\nimport { AccountLookupMeta, AccountMeta, AccountRole, Instruction } from '@solana/instructions';\nimport type { Blockhash } from '@solana/rpc-types';\n\nimport { AddressesByLookupTableAddress } from './addresses-by-lookup-table-address';\nimport { setTransactionMessageLifetimeUsingBlockhash } from './blockhash';\nimport { CompiledTransactionMessage, CompiledTransactionMessageWithLifetime } from './compile';\nimport type { getCompiledAddressTableLookups } from './compile/address-table-lookups';\nimport { createTransactionMessage } from './create-transaction-message';\nimport { Nonce, setTransactionMessageLifetimeUsingDurableNonce } from './durable-nonce';\nimport { isAdvanceNonceAccountInstruction } from './durable-nonce-instruction';\nimport { setTransactionMessageFeePayer, TransactionMessageWithFeePayer } from './fee-payer';\nimport { appendTransactionMessageInstruction } from './instructions';\nimport { TransactionMessageWithLifetime } from './lifetime';\nimport { BaseTransactionMessage, TransactionVersion } from './transaction-message';\n\nfunction getAccountMetas(message: CompiledTransactionMessage): AccountMeta[] {\n    const { header } = message;\n    const numWritableSignerAccounts = header.numSignerAccounts - header.numReadonlySignerAccounts;\n    const numWritableNonSignerAccounts =\n        message.staticAccounts.length - header.numSignerAccounts - header.numReadonlyNonSignerAccounts;\n\n    const accountMetas: AccountMeta[] = [];\n\n    let accountIndex = 0;\n    for (let i = 0; i < numWritableSignerAccounts; i++) {\n        accountMetas.push({\n            address: message.staticAccounts[accountIndex],\n            role: AccountRole.WRITABLE_SIGNER,\n        });\n        accountIndex++;\n    }\n\n    for (let i = 0; i < header.numReadonlySignerAccounts; i++) {\n        accountMetas.push({\n            address: message.staticAccounts[accountIndex],\n            role: AccountRole.READONLY_SIGNER,\n        });\n        accountIndex++;\n    }\n\n    for (let i = 0; i < numWritableNonSignerAccounts; i++) {\n        accountMetas.push({\n            address: message.staticAccounts[accountIndex],\n            role: AccountRole.WRITABLE,\n        });\n        accountIndex++;\n    }\n\n    for (let i = 0; i < header.numReadonlyNonSignerAccounts; i++) {\n        accountMetas.push({\n            address: message.staticAccounts[accountIndex],\n            role: AccountRole.READONLY,\n        });\n        accountIndex++;\n    }\n\n    return accountMetas;\n}\n\nfunction getAddressLookupMetas(\n    compiledAddressTableLookups: ReturnType<typeof getCompiledAddressTableLookups>,\n    addressesByLookupTableAddress: AddressesByLookupTableAddress,\n): AccountLookupMeta[] {\n    // check that all message lookups are known\n    const compiledAddressTableLookupAddresses = compiledAddressTableLookups.map(l => l.lookupTableAddress);\n    const missing = compiledAddressTableLookupAddresses.filter(a => addressesByLookupTableAddress[a] === undefined);\n    if (missing.length > 0) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING, {\n            lookupTableAddresses: missing,\n        });\n    }\n\n    const readOnlyMetas: AccountLookupMeta[] = [];\n    const writableMetas: AccountLookupMeta[] = [];\n\n    // we know that for each lookup, knownLookups[lookup.lookupTableAddress] is defined\n    for (const lookup of compiledAddressTableLookups) {\n        const addresses = addressesByLookupTableAddress[lookup.lookupTableAddress];\n        const readonlyIndexes = lookup.readonlyIndexes;\n        const writableIndexes = lookup.writableIndexes;\n\n        const highestIndex = Math.max(...readonlyIndexes, ...writableIndexes);\n        if (highestIndex >= addresses.length) {\n            throw new SolanaError(\n                SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE,\n                {\n                    highestKnownIndex: addresses.length - 1,\n                    highestRequestedIndex: highestIndex,\n                    lookupTableAddress: lookup.lookupTableAddress,\n                },\n            );\n        }\n\n        const readOnlyForLookup: AccountLookupMeta[] = readonlyIndexes.map(r => ({\n            address: addresses[r],\n            addressIndex: r,\n            lookupTableAddress: lookup.lookupTableAddress,\n            role: AccountRole.READONLY,\n        }));\n        readOnlyMetas.push(...readOnlyForLookup);\n\n        const writableForLookup: AccountLookupMeta[] = writableIndexes.map(w => ({\n            address: addresses[w],\n            addressIndex: w,\n            lookupTableAddress: lookup.lookupTableAddress,\n            role: AccountRole.WRITABLE,\n        }));\n        writableMetas.push(...writableForLookup);\n    }\n\n    return [...writableMetas, ...readOnlyMetas];\n}\n\nfunction convertInstruction(\n    instruction: CompiledTransactionMessage['instructions'][0],\n    accountMetas: AccountMeta[],\n): Instruction {\n    const programAddress = accountMetas[instruction.programAddressIndex]?.address;\n    if (!programAddress) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND, {\n            index: instruction.programAddressIndex,\n        });\n    }\n\n    const accounts = instruction.accountIndices?.map(accountIndex => accountMetas[accountIndex]);\n    const { data } = instruction;\n\n    return Object.freeze({\n        programAddress,\n        ...(accounts && accounts.length ? { accounts: Object.freeze(accounts) } : {}),\n        ...(data && data.length ? { data } : {}),\n    });\n}\n\ntype LifetimeConstraint =\n    | {\n          blockhash: Blockhash;\n          lastValidBlockHeight: bigint;\n      }\n    | {\n          nonce: Nonce;\n          nonceAccountAddress: Address;\n          nonceAuthorityAddress: Address;\n      };\n\nfunction getLifetimeConstraint(\n    messageLifetimeToken: string,\n    firstInstruction?: Instruction,\n    lastValidBlockHeight?: bigint,\n): LifetimeConstraint {\n    if (!firstInstruction || !isAdvanceNonceAccountInstruction(firstInstruction)) {\n        // first instruction is not advance durable nonce, so use blockhash lifetime constraint\n        return {\n            blockhash: messageLifetimeToken as Blockhash,\n            lastValidBlockHeight: lastValidBlockHeight ?? 2n ** 64n - 1n, // U64 MAX\n        };\n    } else {\n        // We know these accounts are defined because we checked `isAdvanceNonceAccountInstruction`\n        const nonceAccountAddress = firstInstruction.accounts[0].address;\n        assertIsAddress(nonceAccountAddress);\n\n        const nonceAuthorityAddress = firstInstruction.accounts[2].address;\n        assertIsAddress(nonceAuthorityAddress);\n\n        return {\n            nonce: messageLifetimeToken as Nonce,\n            nonceAccountAddress,\n            nonceAuthorityAddress,\n        };\n    }\n}\n\nexport type DecompileTransactionMessageConfig = {\n    /**\n     * If the compiled message loads addresses from one or more address lookup tables, you will have\n     * to supply a map of those tables to an array of the addresses they contained at the time that\n     * the transaction message was constructed.\n     *\n     * @see {@link decompileTransactionMessageFetchingLookupTables} if you do not already have this.\n     */\n    addressesByLookupTableAddress?: AddressesByLookupTableAddress;\n    /**\n     * If the compiled message has a blockhash-based lifetime constraint, you will have to supply\n     * the block height after which that blockhash is no longer valid for use as a lifetime\n     * constraint.\n     */\n    lastValidBlockHeight?: bigint;\n};\n\n/**\n * Converts the type of transaction message data structure appropriate for execution on the network\n * to the type of transaction message data structure designed for use in your application.\n *\n * Because compilation is a lossy process, you can not fully reconstruct a source message from a\n * compiled message without extra information. In order to faithfully reconstruct the original\n * source message you will need to supply supporting details about the lifetime constraint and the\n * concrete addresses of any accounts sourced from account lookup tables.\n *\n * @see {@link compileTransactionMessage}\n */\nexport function decompileTransactionMessage(\n    compiledTransactionMessage: CompiledTransactionMessage & CompiledTransactionMessageWithLifetime,\n    config?: DecompileTransactionMessageConfig,\n): BaseTransactionMessage & TransactionMessageWithFeePayer & TransactionMessageWithLifetime {\n    const feePayer = compiledTransactionMessage.staticAccounts[0];\n    if (!feePayer) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING);\n    }\n\n    const accountMetas = getAccountMetas(compiledTransactionMessage);\n    const accountLookupMetas =\n        'addressTableLookups' in compiledTransactionMessage &&\n        compiledTransactionMessage.addressTableLookups !== undefined &&\n        compiledTransactionMessage.addressTableLookups.length > 0\n            ? getAddressLookupMetas(\n                  compiledTransactionMessage.addressTableLookups,\n                  config?.addressesByLookupTableAddress ?? {},\n              )\n            : [];\n    const transactionMetas = [...accountMetas, ...accountLookupMetas];\n\n    const instructions: Instruction[] = compiledTransactionMessage.instructions.map(compiledInstruction =>\n        convertInstruction(compiledInstruction, transactionMetas),\n    );\n\n    const firstInstruction = instructions[0];\n    const lifetimeConstraint = getLifetimeConstraint(\n        compiledTransactionMessage.lifetimeToken,\n        firstInstruction,\n        config?.lastValidBlockHeight,\n    );\n\n    return pipe(\n        createTransactionMessage({ version: compiledTransactionMessage.version as TransactionVersion }),\n        m => setTransactionMessageFeePayer(feePayer, m),\n        m =>\n            instructions.reduce(\n                (acc, instruction) => appendTransactionMessageInstruction(instruction, acc),\n                m as BaseTransactionMessage & TransactionMessageWithFeePayer,\n            ),\n        m =>\n            'blockhash' in lifetimeConstraint\n                ? setTransactionMessageLifetimeUsingBlockhash(lifetimeConstraint, m)\n                : setTransactionMessageLifetimeUsingDurableNonce(lifetimeConstraint, m),\n    );\n}\n","import { fixEncoderSize, transformEncoder, VariableSizeEncoder } from '@solana/codecs-core';\nimport { getArrayEncoder, getBytesEncoder } from '@solana/codecs-data-structures';\nimport { getShortU16Encoder } from '@solana/codecs-numbers';\nimport { SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES, SolanaError } from '@solana/errors';\nimport { SignatureBytes } from '@solana/keys';\n\nimport { SignaturesMap } from '../transaction';\n\nfunction getSignaturesToEncode(signaturesMap: SignaturesMap): SignatureBytes[] {\n    const signatures = Object.values(signaturesMap);\n    if (signatures.length === 0) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES);\n    }\n\n    return signatures.map(signature => {\n        if (!signature) {\n            return new Uint8Array(64).fill(0) as SignatureBytes;\n        }\n        return signature;\n    });\n}\n\nexport function getSignaturesEncoder(): VariableSizeEncoder<SignaturesMap> {\n    return transformEncoder(\n        getArrayEncoder(fixEncoderSize(getBytesEncoder(), 64), { size: getShortU16Encoder() }),\n        getSignaturesToEncode,\n    );\n}\n","import { getAddressDecoder } from '@solana/addresses';\nimport {\n    combineCodec,\n    fixDecoderSize,\n    padRightDecoder,\n    ReadonlyUint8Array,\n    transformDecoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    getArrayDecoder,\n    getBytesDecoder,\n    getBytesEncoder,\n    getStructDecoder,\n    getStructEncoder,\n    getTupleDecoder,\n} from '@solana/codecs-data-structures';\nimport { getShortU16Decoder, getU8Decoder } from '@solana/codecs-numbers';\nimport { SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH, SolanaError } from '@solana/errors';\nimport { SignatureBytes } from '@solana/keys';\nimport { getTransactionVersionDecoder } from '@solana/transaction-messages';\n\nimport { SignaturesMap, Transaction, TransactionMessageBytes } from '../transaction';\nimport { getSignaturesEncoder } from './signatures-encoder';\n\n/**\n * Returns an encoder that you can use to encode a {@link Transaction} to a byte array in a wire\n * format appropriate for sending to the Solana network for execution.\n */\nexport function getTransactionEncoder(): VariableSizeEncoder<Transaction> {\n    return getStructEncoder([\n        ['signatures', getSignaturesEncoder()],\n        ['messageBytes', getBytesEncoder()],\n    ]);\n}\n\n/**\n * Returns a decoder that you can use to convert a byte array in the Solana transaction wire format\n * to a {@link Transaction} object.\n *\n * @example\n * ```ts\n * import { getTransactionDecoder } from '@solana/transactions';\n *\n * const transactionDecoder = getTransactionDecoder();\n * const transaction = transactionDecoder.decode(wireTransactionBytes);\n * for (const [address, signature] in Object.entries(transaction.signatures)) {\n *     console.log(`Signature by ${address}`, signature);\n * }\n * ```\n */\n\nexport function getTransactionDecoder(): VariableSizeDecoder<Transaction> {\n    return transformDecoder(\n        getStructDecoder([\n            ['signatures', getArrayDecoder(fixDecoderSize(getBytesDecoder(), 64), { size: getShortU16Decoder() })],\n            ['messageBytes', getBytesDecoder()],\n        ]),\n        decodePartiallyDecodedTransaction,\n    );\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to a {@link Transaction}\n *\n * @see {@link getTransactionDecoder}\n * @see {@link getTransactionEncoder}\n */\nexport function getTransactionCodec(): VariableSizeCodec<Transaction> {\n    return combineCodec(getTransactionEncoder(), getTransactionDecoder());\n}\n\ntype PartiallyDecodedTransaction = {\n    messageBytes: ReadonlyUint8Array;\n    signatures: ReadonlyUint8Array[];\n};\n\nfunction decodePartiallyDecodedTransaction(transaction: PartiallyDecodedTransaction): Transaction {\n    const { messageBytes, signatures } = transaction;\n\n    /*\n    Relevant message structure is at the start:\n    - transaction version (0 bytes for legacy transactions, 1 byte for versioned transactions)\n    - `numRequiredSignatures` (1 byte, we verify this matches the length of signatures)\n    - `numReadOnlySignedAccounts` (1 byte, not used here)\n    - `numReadOnlyUnsignedAccounts` (1 byte, not used here)\n    - static addresses, with signers first. This is an array of addresses, prefixed with a short-u16 length\n    */\n\n    const signerAddressesDecoder = getTupleDecoder([\n        // read transaction version\n        getTransactionVersionDecoder(),\n        // read first byte of header, `numSignerAccounts`\n        // padRight to skip the next 2 bytes, `numReadOnlySignedAccounts` and `numReadOnlyUnsignedAccounts` which we don't need\n        padRightDecoder(getU8Decoder(), 2),\n        // read static addresses\n        getArrayDecoder(getAddressDecoder(), { size: getShortU16Decoder() }),\n    ]);\n    const [_txVersion, numRequiredSignatures, staticAddresses] = signerAddressesDecoder.decode(messageBytes);\n\n    const signerAddresses = staticAddresses.slice(0, numRequiredSignatures);\n\n    // signer addresses and signatures must be the same length\n    // we encode an all-zero signature when the signature is missing\n    if (signerAddresses.length !== signatures.length) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH, {\n            numRequiredSignatures,\n            signaturesLength: signatures.length,\n            signerAddresses,\n        });\n    }\n\n    // combine the signer addresses + signatures into the signatures map\n    const signaturesMap: SignaturesMap = {};\n    signerAddresses.forEach((address, index) => {\n        const signatureForAddress = signatures[index];\n        if (signatureForAddress.every(b => b === 0)) {\n            signaturesMap[address] = null;\n        } else {\n            signaturesMap[address] = signatureForAddress as SignatureBytes;\n        }\n    });\n\n    return {\n        messageBytes: messageBytes as TransactionMessageBytes,\n        signatures: Object.freeze(signaturesMap),\n    };\n}\n","import { type Address, isAddress } from '@solana/addresses';\nimport { ReadonlyUint8Array } from '@solana/codecs-core';\nimport {\n    SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME,\n    SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME,\n    SOLANA_ERROR__TRANSACTION__NONCE_ACCOUNT_CANNOT_BE_IN_LOOKUP_TABLE,\n    SolanaError,\n} from '@solana/errors';\nimport { type Blockhash, isBlockhash, type Slot } from '@solana/rpc-types';\nimport type {\n    CompiledTransactionMessage,\n    CompiledTransactionMessageWithLifetime,\n    Nonce,\n    TransactionMessage,\n    TransactionMessageWithBlockhashLifetime,\n    TransactionMessageWithDurableNonceLifetime,\n} from '@solana/transaction-messages';\n\nimport type { Transaction } from './transaction';\n\n/**\n * A constraint which, when applied to a transaction, makes that transaction eligible to land on the\n * network. The transaction will continue to be eligible to land until the network considers the\n * `blockhash` to be expired.\n *\n * This can happen when the network proceeds past the `lastValidBlockHeight` for which the blockhash\n * is considered valid, or when the network switches to a fork where that blockhash is not present.\n */\nexport type TransactionBlockhashLifetime = {\n    /**\n     * A recent blockhash observed by the transaction proposer.\n     *\n     * The transaction will be considered eligible to land until the network determines this\n     * blockhash to be too old, or has switched to a fork where it is not present.\n     */\n    blockhash: Blockhash;\n    /**\n     * This is the block height beyond which the network will consider the blockhash to be too old\n     * to make a transaction eligible to land.\n     */\n    lastValidBlockHeight: Slot;\n};\n\n/**\n * A constraint which, when applied to a transaction, makes that transaction eligible to land on the\n * network.\n *\n * The transaction will continue to be eligible to land until the network considers the `nonce` to\n * have advanced. This can happen when the nonce account in which this nonce is found is destroyed,\n * or the nonce value within changes.\n */\nexport type TransactionDurableNonceLifetime = {\n    /**\n     * A value contained in the account with address `nonceAccountAddress` at the time the\n     * transaction was prepared.\n     *\n     * The transaction will be considered eligible to land until the nonce account ceases to exist\n     * or contain this value.\n     */\n    nonce: Nonce;\n    /** The account that contains the `nonce` value */\n    nonceAccountAddress: Address;\n};\n\n/**\n * A transaction whose ability to land on the network is determined by some evanescent criteria.\n *\n * This describes a window of time after which a transaction is constructed and before which it will\n * no longer be accepted by the network.\n *\n * No transaction can land on Solana without having a `lifetimeConstraint` set.\n */\nexport type TransactionWithLifetime = {\n    readonly lifetimeConstraint: TransactionBlockhashLifetime | TransactionDurableNonceLifetime;\n};\n\n/**\n * A transaction whose lifetime is determined by the age of a blockhash observed on the network.\n *\n * The transaction will continue to be eligible to land until the network considers the `blockhash`\n * to be expired.\n */\nexport type TransactionWithBlockhashLifetime = {\n    readonly lifetimeConstraint: TransactionBlockhashLifetime;\n};\n\n/**\n * A transaction whose lifetime is determined by a nonce.\n *\n * The transaction will continue to be eligible to land until the network considers the `nonce` to\n * have advanced. This can happen when the nonce account in which this nonce is found is destroyed,\n * or the nonce value within changes.\n */\nexport type TransactionWithDurableNonceLifetime = {\n    readonly lifetimeConstraint: TransactionDurableNonceLifetime;\n};\n\n/**\n * Helper type that sets the lifetime constraint of a transaction to be the same as the\n * lifetime constraint of the provided transaction message.\n *\n * If the transaction message has no explicit lifetime constraint, neither will the transaction.\n */\nexport type SetTransactionLifetimeFromTransactionMessage<\n    TTransaction extends Transaction,\n    TTransactionMessage extends TransactionMessage,\n> = TTransactionMessage extends { lifetimeConstraint: unknown }\n    ? TTransactionMessage['lifetimeConstraint'] extends TransactionMessageWithBlockhashLifetime['lifetimeConstraint']\n        ? TransactionWithBlockhashLifetime & TTransaction\n        : TTransactionMessage['lifetimeConstraint'] extends TransactionMessageWithDurableNonceLifetime['lifetimeConstraint']\n          ? TransactionWithDurableNonceLifetime & TTransaction\n          : TransactionWithLifetime & TTransaction\n    : TTransaction;\n\nconst SYSTEM_PROGRAM_ADDRESS = '11111111111111111111111111111111' as Address;\n\nfunction compiledInstructionIsAdvanceNonceInstruction(\n    instruction: CompiledTransactionMessage['instructions'][number],\n    staticAddresses: Address[],\n): instruction is typeof instruction & { accountIndices: [number, number, number] } {\n    return (\n        staticAddresses[instruction.programAddressIndex] === SYSTEM_PROGRAM_ADDRESS &&\n        // Test for `AdvanceNonceAccount` instruction data\n        instruction.data != null &&\n        isAdvanceNonceAccountInstructionData(instruction.data) &&\n        // Test for exactly 3 accounts\n        instruction.accountIndices?.length === 3\n    );\n}\n\nfunction isAdvanceNonceAccountInstructionData(data: ReadonlyUint8Array): boolean {\n    // AdvanceNonceAccount is the fifth instruction in the System Program (index 4)\n    return data.byteLength === 4 && data[0] === 4 && data[1] === 0 && data[2] === 0 && data[3] === 0;\n}\n\n/**\n * Get the lifetime constraint for a transaction from a compiled transaction message that includes a lifetime token.\n * @param compiledTransactionMessage A compiled transaction message that includes a lifetime token\n * @returns A lifetime constraint for the transaction\n * Note that this is less precise than checking a decompiled instruction, as we can't inspect\n * the address or role of input accounts (which may be in lookup tables). However, this is\n * sufficient for all valid advance durable nonce instructions.\n * Note that the program address must not be in a lookup table, see [this answer on StackExchange](https://solana.stackexchange.com/a/16224/289)\n * @see {@link isAdvanceNonceAccountInstruction}\n * Note that this function is async to allow for future implementations that may fetch `lastValidBlockHeight` using an RPC\n */\n// eslint-disable-next-line @typescript-eslint/require-await\nexport async function getTransactionLifetimeConstraintFromCompiledTransactionMessage(\n    compiledTransactionMessage: CompiledTransactionMessage & CompiledTransactionMessageWithLifetime,\n): Promise<TransactionBlockhashLifetime | TransactionDurableNonceLifetime> {\n    const firstInstruction = compiledTransactionMessage.instructions[0];\n    const { staticAccounts } = compiledTransactionMessage;\n\n    // We need to check if the first instruction is an AdvanceNonceAccount instruction\n    if (firstInstruction && compiledInstructionIsAdvanceNonceInstruction(firstInstruction, staticAccounts)) {\n        const nonceAccountAddress = staticAccounts[firstInstruction.accountIndices[0]];\n        if (!nonceAccountAddress) {\n            throw new SolanaError(SOLANA_ERROR__TRANSACTION__NONCE_ACCOUNT_CANNOT_BE_IN_LOOKUP_TABLE, {\n                nonce: compiledTransactionMessage.lifetimeToken,\n            });\n        }\n        return {\n            nonce: compiledTransactionMessage.lifetimeToken as Nonce,\n            nonceAccountAddress,\n        };\n    } else {\n        return {\n            blockhash: compiledTransactionMessage.lifetimeToken as Blockhash,\n            // This is not known from the compiled message, so we set it to the maximum possible value\n            lastValidBlockHeight: 0xffffffffffffffffn,\n        };\n    }\n}\n\n/**\n * A type guard that returns `true` if the transaction conforms to the\n * {@link TransactionWithBlockhashLifetime} type, and refines its type for use in your\n * program.\n *\n * @example\n * ```ts\n * import { isTransactionWithBlockhashLifetime } from '@solana/transactions';\n *\n * if (isTransactionWithBlockhashLifetime(transaction)) {\n *     // At this point, `transaction` has been refined to a `TransactionWithBlockhashLifetime`.\n *     const { blockhash } = transaction.lifetimeConstraint;\n *     const { value: blockhashIsValid } = await rpc.isBlockhashValid(blockhash).send();\n *     setBlockhashIsValid(blockhashIsValid);\n * } else {\n *     setError(\n *         `${getSignatureFromTransaction(transaction)} does not have a blockhash-based lifetime`,\n *     );\n * }\n * ```\n */\nexport function isTransactionWithBlockhashLifetime(\n    transaction: Transaction | (Transaction & TransactionWithLifetime),\n): transaction is Transaction & TransactionWithBlockhashLifetime {\n    return (\n        'lifetimeConstraint' in transaction &&\n        'blockhash' in transaction.lifetimeConstraint &&\n        typeof transaction.lifetimeConstraint.blockhash === 'string' &&\n        typeof transaction.lifetimeConstraint.lastValidBlockHeight === 'bigint' &&\n        isBlockhash(transaction.lifetimeConstraint.blockhash)\n    );\n}\n\n/**\n * From time to time you might acquire a transaction, that you expect to have a\n * blockhash-based lifetime, from for example a wallet. Use this function to\n * assert that such a transaction actually has a blockhash-based lifetime.\n *\n * @example\n * ```ts\n * import { assertIsTransactionWithBlockhashLifetime } from '@solana/transactions';\n *\n * try {\n *     // If this type assertion function doesn't throw, then\n *     // Typescript will upcast `transaction` to `TransactionWithBlockhashLifetime`.\n *     assertIsTransactionWithBlockhashLifetime(transaction);\n *     // At this point, `transaction` is a `TransactionWithBlockhashLifetime` that can be used\n *     // with the RPC.\n *     const { blockhash } = transaction.lifetimeConstraint;\n *     const { value: blockhashIsValid } = await rpc.isBlockhashValid(blockhash).send();\n * } catch (e) {\n *     // `transaction` turned out not to have a blockhash-based lifetime\n * }\n * ```\n */\nexport function assertIsTransactionWithBlockhashLifetime(\n    transaction: Transaction | (Transaction & TransactionWithLifetime),\n): asserts transaction is Transaction & TransactionWithBlockhashLifetime {\n    if (!isTransactionWithBlockhashLifetime(transaction)) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME);\n    }\n}\n\n/**\n * A type guard that returns `true` if the transaction conforms to the\n * {@link TransactionWithDurableNonceLifetime} type, and refines its type for use in your\n * program.\n *\n * @example\n * ```ts\n * import { isTransactionWithDurableNonceLifetime } from '@solana/transactions';\n * import { fetchNonce } from \"@solana-program/system\";\n *\n * if (isTransactionWithDurableNonceLifetime(transaction)) {\n *     // At this point, `transaction` has been refined to a\n *     // `TransactionWithDurableNonceLifetime`.\n *     const { nonce, nonceAccountAddress } = transaction.lifetimeConstraint;\n *     const { data: { blockhash: actualNonce } } = await fetchNonce(nonceAccountAddress);\n *     setNonceIsValid(nonce === actualNonce);\n * } else {\n *     setError(\n *         `${getSignatureFromTransaction(transaction)} does not have a nonce-based lifetime`,\n *     );\n * }\n * ```\n */\nexport function isTransactionWithDurableNonceLifetime(\n    transaction: Transaction | (Transaction & TransactionWithLifetime),\n): transaction is Transaction & TransactionWithDurableNonceLifetime {\n    return (\n        'lifetimeConstraint' in transaction &&\n        'nonce' in transaction.lifetimeConstraint &&\n        typeof transaction.lifetimeConstraint.nonce === 'string' &&\n        typeof transaction.lifetimeConstraint.nonceAccountAddress === 'string' &&\n        isAddress(transaction.lifetimeConstraint.nonceAccountAddress)\n    );\n}\n\n/**\n * From time to time you might acquire a transaction, that you expect to have a\n * nonce-based lifetime, from for example a wallet. Use this function to assert\n * that such a transaction actually has a nonce-based lifetime.\n *\n * @example\n * ```ts\n * import { assertIsTransactionWithDurableNonceLifetime } from '@solana/transactions';\n *\n * try {\n *     // If this type assertion function doesn't throw, then\n *     // Typescript will upcast `transaction` to `TransactionWithDurableNonceLifetime`.\n *     assertIsTransactionWithDurableNonceLifetime(transaction);\n *     // At this point, `transaction` is a `TransactionWithDurableNonceLifetime` that can be used\n *     // with the RPC.\n *     const { nonce, nonceAccountAddress } = transaction.lifetimeConstraint;\n *     const { data: { blockhash: actualNonce } } = await fetchNonce(nonceAccountAddress);\n * } catch (e) {\n *     // `transaction` turned out not to have a nonce-based lifetime\n * }\n * ```\n */\nexport function assertIsTransactionWithDurableNonceLifetime(\n    transaction: Transaction | (Transaction & TransactionWithLifetime),\n): asserts transaction is Transaction & TransactionWithDurableNonceLifetime {\n    if (!isTransactionWithDurableNonceLifetime(transaction)) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME);\n    }\n}\n","import {\n    BaseTransactionMessage,\n    compileTransactionMessage,\n    getCompiledTransactionMessageEncoder,\n    isTransactionMessageWithBlockhashLifetime,\n    isTransactionMessageWithDurableNonceLifetime,\n    TransactionMessageWithFeePayer,\n} from '@solana/transaction-messages';\n\nimport type { TransactionWithLifetime } from './lifetime';\nimport type { SignaturesMap, TransactionFromTransactionMessage, TransactionMessageBytes } from './transaction';\n\n/**\n * Returns a {@link Transaction} object for a given {@link TransactionMessage}.\n *\n * This includes the compiled bytes of the transaction message, and a map of signatures. This map\n * will have a key for each address that is required to sign the transaction. The transaction will\n * not yet have signatures for any of these addresses.\n *\n * Whether a transaction message is ready to be compiled or not is enforced for you at the type\n * level. In order to be signable, a transaction message must:\n *\n * - have a version and a list of zero or more instructions (ie. conform to\n *   {@link BaseTransactionMessage})\n * - have a fee payer set (ie. conform to {@link TransactionMessageWithFeePayer})\n * - have a lifetime specified (ie. conform to {@link TransactionMessageWithBlockhashLifetime} or\n *   {@link TransactionMessageWithDurableNonceLifetime})\n */\nexport function compileTransaction<TTransactionMessage extends BaseTransactionMessage & TransactionMessageWithFeePayer>(\n    transactionMessage: TTransactionMessage,\n): Readonly<TransactionFromTransactionMessage<TTransactionMessage>> {\n    type ReturnType = Readonly<TransactionFromTransactionMessage<TTransactionMessage>>;\n\n    const compiledMessage = compileTransactionMessage(transactionMessage);\n    const messageBytes = getCompiledTransactionMessageEncoder().encode(compiledMessage) as TransactionMessageBytes;\n\n    const transactionSigners = compiledMessage.staticAccounts.slice(0, compiledMessage.header.numSignerAccounts);\n    const signatures: SignaturesMap = {};\n    for (const signerAddress of transactionSigners) {\n        signatures[signerAddress] = null;\n    }\n\n    let lifetimeConstraint: TransactionWithLifetime['lifetimeConstraint'] | undefined;\n    if (isTransactionMessageWithBlockhashLifetime(transactionMessage)) {\n        lifetimeConstraint = {\n            blockhash: transactionMessage.lifetimeConstraint.blockhash,\n            lastValidBlockHeight: transactionMessage.lifetimeConstraint.lastValidBlockHeight,\n        };\n    } else if (isTransactionMessageWithDurableNonceLifetime(transactionMessage)) {\n        lifetimeConstraint = {\n            nonce: transactionMessage.lifetimeConstraint.nonce,\n            nonceAccountAddress: transactionMessage.instructions[0].accounts[0].address,\n        };\n    }\n\n    return Object.freeze({\n        ...(lifetimeConstraint ? { lifetimeConstraint } : undefined),\n        messageBytes: messageBytes,\n        signatures: Object.freeze(signatures),\n    }) as ReturnType;\n}\n","import { Address, getAddressFromPublicKey } from '@solana/addresses';\nimport { Decoder } from '@solana/codecs-core';\nimport { getBase58Decoder } from '@solana/codecs-strings';\nimport {\n    SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION,\n    SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING,\n    SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING,\n    SolanaError,\n} from '@solana/errors';\nimport { Signature, SignatureBytes, signBytes } from '@solana/keys';\nimport { NominalType } from '@solana/nominal-types';\n\nimport { TransactionWithLifetime } from './lifetime';\nimport { Transaction } from './transaction';\n\n/**\n * Represents a transaction that is signed by all of its required signers. Being fully signed is a\n * prerequisite of functions designed to land transactions on the network.\n */\nexport type FullySignedTransaction = NominalType<'transactionSignedness', 'fullySigned'>;\n\nlet base58Decoder: Decoder<string> | undefined;\n\n/**\n * Given a transaction signed by its fee payer, this method will return the {@link Signature} that\n * uniquely identifies it. This string can be used to look up transactions at a later date, for\n * example on a Solana block explorer.\n *\n * @example\n * ```ts\n * import { getSignatureFromTransaction } from '@solana/transactions';\n *\n * const signature = getSignatureFromTransaction(tx);\n * console.debug(`Inspect this transaction at https://explorer.solana.com/tx/${signature}`);\n * ```\n */\nexport function getSignatureFromTransaction(transaction: Transaction): Signature {\n    if (!base58Decoder) base58Decoder = getBase58Decoder();\n\n    // We have ordered signatures from the compiled message accounts\n    // first signature is the fee payer\n    const signatureBytes = Object.values(transaction.signatures)[0];\n    if (!signatureBytes) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING);\n    }\n    const transactionSignature = base58Decoder.decode(signatureBytes);\n    return transactionSignature as Signature;\n}\n\nfunction uint8ArraysEqual(arr1: Uint8Array, arr2: Uint8Array) {\n    return arr1.length === arr2.length && arr1.every((value, index) => value === arr2[index]);\n}\n\n/**\n * Given an array of `CryptoKey` objects which are private keys pertaining to addresses that are\n * required to sign a transaction, this method will return a new signed transaction of type\n * {@link Transaction}.\n *\n * Though the resulting transaction might have every signature it needs to land on the network, this\n * function will not assert that it does. A partially signed transaction cannot be landed on the\n * network, but can be serialized and deserialized.\n *\n * @example\n * ```ts\n * import { generateKeyPair } from '@solana/keys';\n * import { partiallySignTransaction } from '@solana/transactions';\n *\n * const partiallySignedTransaction = await partiallySignTransaction([myPrivateKey], tx);\n * ```\n *\n * @see {@link signTransaction} if you want to assert that the transaction has all of its required\n * signatures after signing.\n */\nexport async function partiallySignTransaction<TTransaction extends Transaction & TransactionWithLifetime>(\n    keyPairs: CryptoKeyPair[],\n    transaction: TTransaction,\n): Promise<TTransaction> {\n    let newSignatures: Record<Address, SignatureBytes> | undefined;\n    let unexpectedSigners: Set<Address> | undefined;\n\n    await Promise.all(\n        keyPairs.map(async keyPair => {\n            const address = await getAddressFromPublicKey(keyPair.publicKey);\n            const existingSignature = transaction.signatures[address];\n\n            // Check if the address is expected to sign the transaction\n            if (existingSignature === undefined) {\n                // address is not an expected signer for this transaction\n                unexpectedSigners ||= new Set();\n                unexpectedSigners.add(address);\n                return;\n            }\n\n            // Return if there are any unexpected signers already since we won't be using signatures\n            if (unexpectedSigners) {\n                return;\n            }\n\n            const newSignature = await signBytes(keyPair.privateKey, transaction.messageBytes);\n\n            if (existingSignature !== null && uint8ArraysEqual(newSignature, existingSignature)) {\n                // already have the same signature set\n                return;\n            }\n\n            newSignatures ||= {};\n            newSignatures[address] = newSignature;\n        }),\n    );\n\n    if (unexpectedSigners && unexpectedSigners.size > 0) {\n        const expectedSigners = Object.keys(transaction.signatures);\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION, {\n            expectedAddresses: expectedSigners,\n            unexpectedAddresses: [...unexpectedSigners],\n        });\n    }\n\n    if (!newSignatures) {\n        return transaction;\n    }\n\n    return Object.freeze({\n        ...transaction,\n        signatures: Object.freeze({\n            ...transaction.signatures,\n            ...newSignatures,\n        }),\n    });\n}\n\n/**\n * Given an array of `CryptoKey` objects which are private keys pertaining to addresses that are\n * required to sign a transaction, this method will return a new signed transaction of type\n * {@link FullySignedTransaction}.\n *\n * This function will throw unless the resulting transaction is fully signed.\n *\n * @example\n * ```ts\n * import { generateKeyPair } from '@solana/keys';\n * import { signTransaction } from '@solana/transactions';\n *\n * const signedTransaction = await signTransaction([myPrivateKey], tx);\n * ```\n *\n * @see {@link partiallySignTransaction} if you want to sign the transaction without asserting that\n * the resulting transaction is fully signed.\n */\nexport async function signTransaction<TTransaction extends Transaction & TransactionWithLifetime>(\n    keyPairs: CryptoKeyPair[],\n    transaction: TTransaction,\n): Promise<FullySignedTransaction & TTransaction> {\n    const out = await partiallySignTransaction(keyPairs, transaction);\n    assertIsFullySignedTransaction(out);\n    Object.freeze(out);\n    return out;\n}\n\n/**\n * Checks whether a given {@link Transaction} is fully signed.\n *\n * @example\n * ```ts\n * import { isFullySignedTransaction } from '@solana/transactions';\n *\n * const transaction = getTransactionDecoder().decode(transactionBytes);\n * if (isFullySignedTransaction(transaction)) {\n *   // At this point we know that the transaction is signed and can be sent to the network.\n * }\n * ```\n */\nexport function isFullySignedTransaction<TTransaction extends Transaction>(\n    transaction: TTransaction,\n): transaction is FullySignedTransaction & TTransaction {\n    return Object.entries(transaction.signatures).every(([_, signatureBytes]) => !!signatureBytes);\n}\n\n/**\n * From time to time you might acquire a {@link Transaction}, that you expect to be fully signed,\n * from an untrusted network API or user input. Use this function to assert that such a transaction\n * is fully signed.\n *\n * @example\n * ```ts\n * import { assertIsFullySignedTransaction } from '@solana/transactions';\n *\n * const transaction = getTransactionDecoder().decode(transactionBytes);\n * try {\n *     // If this type assertion function doesn't throw, then Typescript will upcast `transaction`\n *     // to `FullySignedTransaction`.\n *     assertIsFullySignedTransaction(transaction);\n *     // At this point we know that the transaction is signed and can be sent to the network.\n *     await sendAndConfirmTransaction(transaction, { commitment: 'confirmed' });\n * } catch(e) {\n *     if (isSolanaError(e, SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING)) {\n *         setError(`Missing signatures for ${e.context.addresses.join(', ')}`);\n *     }\n *     throw;\n * }\n * ```\n */\nexport function assertIsFullySignedTransaction<TTransaction extends Transaction>(\n    transaction: TTransaction,\n): asserts transaction is FullySignedTransaction & TTransaction {\n    const missingSigs: Address[] = [];\n    Object.entries(transaction.signatures).forEach(([address, signatureBytes]) => {\n        if (!signatureBytes) {\n            missingSigs.push(address as Address);\n        }\n    });\n\n    if (missingSigs.length > 0) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING, {\n            addresses: missingSigs,\n        });\n    }\n}\n","import { getBase64Decoder } from '@solana/codecs-strings';\nimport { Brand, EncodedString } from '@solana/nominal-types';\n\nimport { getTransactionEncoder } from './codecs';\nimport { Transaction } from './transaction';\n\n/** Represents the wire format of a transaction as a base64-encoded string. */\nexport type Base64EncodedWireTransaction = Brand<EncodedString<string, 'base64'>, 'Base64EncodedWireTransaction'>;\n\n/**\n * Given a signed transaction, this method returns the transaction as a string that conforms to the\n * {@link Base64EncodedWireTransaction} type.\n *\n * @example\n * ```ts\n * import { getBase64EncodedWireTransaction, signTransaction } from '@solana/transactions';\n *\n * const serializedTransaction = getBase64EncodedWireTransaction(signedTransaction);\n * const signature = await rpc.sendTransaction(serializedTransaction, { encoding: 'base64' }).send();\n * ```\n */\nexport function getBase64EncodedWireTransaction(transaction: Transaction): Base64EncodedWireTransaction {\n    const wireTransactionBytes = getTransactionEncoder().encode(transaction);\n    return getBase64Decoder().decode(wireTransactionBytes) as Base64EncodedWireTransaction;\n}\n","import { SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT, SolanaError } from '@solana/errors';\nimport type { NominalType } from '@solana/nominal-types';\nimport type { BaseTransactionMessage, TransactionMessageWithinSizeLimit } from '@solana/transaction-messages';\n\nimport { getTransactionEncoder } from './codecs';\nimport { Transaction } from './transaction';\n\n/**\n * The maximum size of a transaction packet in bytes.\n */\nexport const TRANSACTION_PACKET_SIZE = 1280;\n\n/**\n * The size of the transaction packet header in bytes.\n * This includes the IPv6 header and the fragment header.\n */\nexport const TRANSACTION_PACKET_HEADER =\n    40 /* 40 bytes is the size of the IPv6 header. */ + 8; /* 8 bytes is the size of the fragment header. */\n\n/**\n * The maximum size of a transaction in bytes.\n *\n * Note that this excludes the transaction packet header.\n * In other words, this is how much content we can fit in a transaction packet.\n */\nexport const TRANSACTION_SIZE_LIMIT = TRANSACTION_PACKET_SIZE - TRANSACTION_PACKET_HEADER;\n\n/**\n * Gets the size of a given transaction in bytes.\n *\n * @example\n * ```ts\n * const transactionSize = getTransactionSize(transaction);\n * ```\n */\nexport function getTransactionSize(transaction: Transaction): number {\n    return getTransactionEncoder().getSizeFromValue(transaction);\n}\n\n/**\n * A type guard that checks if a transaction is within the size limit.\n */\nexport type TransactionWithinSizeLimit = NominalType<'transactionSize', 'withinLimit'>;\n\n/**\n * Helper type that adds the `TransactionWithinSizeLimit` flag to\n * a transaction if and only if the provided transaction message\n * is also within the size limit.\n */\nexport type SetTransactionWithinSizeLimitFromTransactionMessage<\n    TTransaction extends Transaction,\n    TTransactionMessage extends BaseTransactionMessage,\n> = TTransactionMessage extends TransactionMessageWithinSizeLimit\n    ? TransactionWithinSizeLimit & TTransaction\n    : TTransaction;\n\n/**\n * Checks if a transaction is within the size limit.\n *\n * @typeParam TTransaction - The type of the given transaction.\n *\n * @example\n * ```ts\n * if (isTransactionWithinSizeLimit(transaction)) {\n *    transaction satisfies TransactionWithinSizeLimit;\n * }\n * ```\n */\nexport function isTransactionWithinSizeLimit<TTransaction extends Transaction>(\n    transaction: TTransaction,\n): transaction is TransactionWithinSizeLimit & TTransaction {\n    return getTransactionSize(transaction) <= TRANSACTION_SIZE_LIMIT;\n}\n\n/**\n * Asserts that a given transaction is within the size limit.\n *\n * Throws a {@link SolanaError} of code {@link SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT}\n * if the transaction exceeds the size limit.\n *\n * @typeParam TTransaction - The type of the given transaction.\n *\n * @example\n * ```ts\n * assertIsTransactionWithinSizeLimit(transaction);\n * transaction satisfies TransactionWithinSizeLimit;\n * ```\n */\nexport function assertIsTransactionWithinSizeLimit<TTransaction extends Transaction>(\n    transaction: TTransaction,\n): asserts transaction is TransactionWithinSizeLimit & TTransaction {\n    const transactionSize = getTransactionSize(transaction);\n    if (transactionSize > TRANSACTION_SIZE_LIMIT) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT, {\n            transactionSize,\n            transactionSizeLimit: TRANSACTION_SIZE_LIMIT,\n        });\n    }\n}\n","import { assertIsFullySignedTransaction, FullySignedTransaction, isFullySignedTransaction } from './signatures';\nimport { Transaction } from './transaction';\nimport {\n    assertIsTransactionWithinSizeLimit,\n    isTransactionWithinSizeLimit,\n    TransactionWithinSizeLimit,\n} from './transaction-size';\n\n/**\n * Helper type that includes all transaction types required\n * for the transaction to be sent to the network.\n *\n * @see {@link isSendableTransaction}\n * @see {@link assertIsSendableTransaction}\n */\nexport type SendableTransaction = FullySignedTransaction & TransactionWithinSizeLimit;\n\n/**\n * Checks if a transaction has all the required\n * conditions to be sent to the network.\n *\n * @example\n * ```ts\n * import { isSendableTransaction } from '@solana/transactions';\n *\n * const transaction = getTransactionDecoder().decode(transactionBytes);\n * if (isSendableTransaction(transaction)) {\n *   // At this point we know that the transaction can be sent to the network.\n * }\n * ```\n *\n * @see {@link assertIsSendableTransaction}\n */\nexport function isSendableTransaction<TTransaction extends Transaction>(\n    transaction: TTransaction,\n): transaction is SendableTransaction & TTransaction {\n    return isFullySignedTransaction(transaction) && isTransactionWithinSizeLimit(transaction);\n}\n\n/**\n * Asserts that a given transaction has all the\n * required conditions to be sent to the network.\n *\n * From time to time you might acquire a {@link Transaction}\n * from an untrusted network API or user input and you are not sure\n * that it has all the required conditions to be sent to the network\n *  such as being fully signed and within the size limit.\n * This function can be used to assert that such a transaction\n * is in fact sendable.\n *\n * @example\n * ```ts\n * import { assertIsSendableTransaction } from '@solana/transactions';\n *\n * const transaction = getTransactionDecoder().decode(transactionBytes);\n * try {\n *     // If this type assertion function doesn't throw, then Typescript will upcast `transaction`\n *     // to `SendableTransaction`.\n *     assertIsSendableTransaction(transaction);\n *     // At this point we know that the transaction can be sent to the network.\n *     await sendAndConfirmTransaction(transaction, { commitment: 'confirmed' });\n * } catch(e) {\n *     if (isSolanaError(e, SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING)) {\n *         setError(`Missing signatures for ${e.context.addresses.join(', ')}`);\n *     } else if (isSolanaError(e, SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT)) {\n *         setError(`Transaction exceeds size limit of ${e.context.transactionSizeLimit} bytes`);\n *     }\n *     throw;\n * }\n * ```\n */\nexport function assertIsSendableTransaction<TTransaction extends Transaction>(\n    transaction: TTransaction,\n): asserts transaction is SendableTransaction & TTransaction {\n    assertIsFullySignedTransaction(transaction);\n    assertIsTransactionWithinSizeLimit(transaction);\n}\n","import { SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT, SolanaError } from '@solana/errors';\nimport type {\n    BaseTransactionMessage,\n    TransactionMessageWithFeePayer,\n    TransactionMessageWithinSizeLimit,\n} from '@solana/transaction-messages';\n\nimport { compileTransaction } from './compile-transaction';\nimport { getTransactionSize, TRANSACTION_SIZE_LIMIT } from './transaction-size';\n\n/**\n * Gets the compiled transaction size of a given transaction message in bytes.\n *\n * @example\n * ```ts\n * const transactionSize = getTransactionMessageSize(transactionMessage);\n * ```\n */\nexport function getTransactionMessageSize(\n    transactionMessage: BaseTransactionMessage & TransactionMessageWithFeePayer,\n): number {\n    return getTransactionSize(compileTransaction(transactionMessage));\n}\n\n/**\n * Checks if a transaction message is within the size limit\n * when compiled into a transaction.\n *\n * @typeParam TTransactionMessage - The type of the given transaction message.\n *\n * @example\n * ```ts\n * if (isTransactionMessageWithinSizeLimit(transactionMessage)) {\n *    transactionMessage satisfies TransactionMessageWithinSizeLimit;\n * }\n * ```\n */\nexport function isTransactionMessageWithinSizeLimit<\n    TTransactionMessage extends BaseTransactionMessage & TransactionMessageWithFeePayer,\n>(\n    transactionMessage: TTransactionMessage,\n): transactionMessage is TransactionMessageWithinSizeLimit & TTransactionMessage {\n    return getTransactionMessageSize(transactionMessage) <= TRANSACTION_SIZE_LIMIT;\n}\n\n/**\n * Asserts that a given transaction message is within the size limit\n * when compiled into a transaction.\n *\n * Throws a {@link SolanaError} of code {@link SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT}\n * if the transaction message exceeds the size limit.\n *\n * @typeParam TTransactionMessage - The type of the given transaction message.\n *\n * @example\n * ```ts\n * assertIsTransactionMessageWithinSizeLimit(transactionMessage);\n * transactionMessage satisfies TransactionMessageWithinSizeLimit;\n * ```\n */\nexport function assertIsTransactionMessageWithinSizeLimit<\n    TTransactionMessage extends BaseTransactionMessage & TransactionMessageWithFeePayer,\n>(\n    transactionMessage: TTransactionMessage,\n): asserts transactionMessage is TransactionMessageWithinSizeLimit & TTransactionMessage {\n    const transactionSize = getTransactionMessageSize(transactionMessage);\n    if (transactionSize > TRANSACTION_SIZE_LIMIT) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT, {\n            transactionSize,\n            transactionSizeLimit: TRANSACTION_SIZE_LIMIT,\n        });\n    }\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS, SolanaError } from '@solana/errors';\n\nimport { MessageSigner } from './message-signer';\nimport { TransactionSigner } from './transaction-signer';\n\n/**\n * Removes all duplicated {@link MessageSigner | MessageSigners} and\n * {@link TransactionSigner | TransactionSigners} from a provided array\n * by comparing their {@link Address | addresses}.\n *\n * @internal\n */\nexport function deduplicateSigners<TSigner extends MessageSigner | TransactionSigner>(\n    signers: readonly TSigner[],\n): readonly TSigner[] {\n    const deduplicated: Record<Address, TSigner> = {};\n    signers.forEach(signer => {\n        if (!deduplicated[signer.address]) {\n            deduplicated[signer.address] = signer;\n        } else if (deduplicated[signer.address] !== signer) {\n            throw new SolanaError(SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS, {\n                address: signer.address,\n            });\n        }\n    });\n    return Object.values(deduplicated);\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER, SolanaError } from '@solana/errors';\nimport { Transaction, TransactionWithinSizeLimit, TransactionWithLifetime } from '@solana/transactions';\n\nimport { BaseTransactionSignerConfig } from './types';\n\n/**\n * The configuration to optionally provide when calling the\n * {@link TransactionModifyingSigner#modifyAndSignTransactions | modifyAndSignTransactions} method.\n *\n * @see {@link BaseTransactionSignerConfig}\n */\nexport type TransactionModifyingSignerConfig = BaseTransactionSignerConfig;\n\n/**\n * A signer interface that potentially modifies the provided {@link Transaction | Transactions}\n * before signing them.\n *\n * For instance, this enables wallets to inject additional instructions into the\n * transaction before signing them. For each transaction, instead of returning a\n * {@link SignatureDictionary}, its\n * {@link TransactionModifyingSigner#modifyAndSignTransactions | modifyAndSignTransactions} function\n * returns an updated {@link Transaction} with a potentially modified set of instructions and\n * signature dictionary. The returned transaction must be within the transaction size limit,\n * and include a `lifetimeConstraint`.\n *\n * @typeParam TAddress - Supply a string literal to define a signer having a particular address.\n *\n * @example\n * ```ts\n * const signer: TransactionModifyingSigner<'1234..5678'> = {\n *     address: address('1234..5678'),\n *     modifyAndSignTransactions: async (\n *         transactions: Transaction[]\n *     ): Promise<(Transaction & TransactionWithinSizeLimit & TransactionWithLifetime)[]> => {\n *         // My custom signing logic.\n *     },\n * };\n * ```\n *\n * @remarks\n * Here are the main characteristics of this signer interface:\n *\n * - **Sequential**. Contrary to partial signers, these cannot be executed in\n *   parallel as each call can modify the provided transactions.\n * - **First signers**. For a given transaction, a modifying signer must always\n *   be used before a partial signer as the former will likely modify the\n *   transaction and thus impact the outcome of the latter.\n * - **Potential conflicts**. If more than one modifying signer is provided,\n *   the second signer may invalidate the signature of the first one. However,\n *   modifying signers may decide not to modify a transaction based on the\n *   existence of signatures for that transaction.\n *\n * @see {@link isTransactionModifyingSigner}\n * @see {@link assertIsTransactionModifyingSigner}\n */\nexport type TransactionModifyingSigner<TAddress extends string = string> = Readonly<{\n    address: Address<TAddress>;\n    modifyAndSignTransactions(\n        transactions: readonly (Transaction | (Transaction & TransactionWithLifetime))[],\n        config?: TransactionModifyingSignerConfig,\n    ): Promise<readonly (Transaction & TransactionWithinSizeLimit & TransactionWithLifetime)[]>;\n}>;\n\n/**\n * Checks whether the provided value implements the {@link TransactionModifyingSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { isTransactionModifyingSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * isTransactionModifyingSigner({ address, modifyAndSignTransactions: async () => {} }); // true\n * isTransactionModifyingSigner({ address }); // false\n * ```\n *\n * @see {@link assertIsTransactionModifyingSigner}\n */\nexport function isTransactionModifyingSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is TransactionModifyingSigner<TAddress> {\n    return 'modifyAndSignTransactions' in value && typeof value.modifyAndSignTransactions === 'function';\n}\n\n/**\n * Asserts that the provided value implements the {@link TransactionModifyingSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { assertIsTransactionModifyingSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * assertIsTransactionModifyingSigner({ address, modifyAndSignTransactions: async () => {} }); // void\n * assertIsTransactionModifyingSigner({ address }); // Throws an error.\n * ```\n *\n * @see {@link isTransactionModifyingSigner}\n */\nexport function assertIsTransactionModifyingSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is TransactionModifyingSigner<TAddress> {\n    if (!isTransactionModifyingSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER, SolanaError } from '@solana/errors';\nimport { Transaction, TransactionWithinSizeLimit, TransactionWithLifetime } from '@solana/transactions';\n\nimport { BaseTransactionSignerConfig, SignatureDictionary } from './types';\n\n/**\n * The configuration to optionally provide when calling the\n * {@link TransactionPartialSigner#signTransactions | signTransactions} method.\n *\n * @see {@link BaseTransactionSignerConfig}\n */\nexport type TransactionPartialSignerConfig = BaseTransactionSignerConfig;\n\n/**\n * A signer interface that signs an array of {@link Transaction | Transactions}\n *  without modifying their content. It defines a\n * {@link TransactionPartialSigner#signTransactions | signTransactions}\n * function that returns a {@link SignatureDictionary} for each provided transaction.\n *\n * Such signature dictionaries are expected to be merged with the existing ones if any.\n *\n * @typeParam TAddress - Supply a string literal to define a signer having a particular address.\n *\n * @example\n * ```ts\n * const signer: TransactionPartialSigner<'1234..5678'> = {\n *     address: address('1234..5678'),\n *     signTransactions: async (\n *         transactions: Transaction[]\n *     ): Promise<SignatureDictionary[]> => {\n *         // My custom signing logic.\n *     },\n * };\n * ```\n *\n * @remarks\n * Here are the main characteristics of this signer interface:\n *\n * - **Parallel**. It returns a signature dictionary for each provided\n *   transaction without modifying them, making it possible for multiple\n *   partial signers to sign the same transaction in parallel.\n * - **Flexible order**. The order in which we use these signers for\n *   a given transaction doesnt matter.\n *\n * @see {@link isTransactionPartialSigner}\n * @see {@link assertIsTransactionPartialSigner}\n */\nexport type TransactionPartialSigner<TAddress extends string = string> = Readonly<{\n    address: Address<TAddress>;\n    signTransactions(\n        transactions: readonly (Transaction & TransactionWithinSizeLimit & TransactionWithLifetime)[],\n        config?: TransactionPartialSignerConfig,\n    ): Promise<readonly SignatureDictionary[]>;\n}>;\n\n/**\n * Checks whether the provided value implements the {@link TransactionPartialSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { isTransactionPartialSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * isTransactionPartialSigner({ address, signTransactions: async () => {} }); // true\n * isTransactionPartialSigner({ address }); // false\n * ```\n *\n * @see {@link assertIsTransactionPartialSigner}\n */\nexport function isTransactionPartialSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is TransactionPartialSigner<TAddress> {\n    return 'signTransactions' in value && typeof value.signTransactions === 'function';\n}\n\n/**\n * Asserts that the provided value implements the {@link TransactionPartialSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { assertIsTransactionPartialSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * assertIsTransactionPartialSigner({ address, signTransactions: async () => {} }); // void\n * assertIsTransactionPartialSigner({ address }); // Throws an error.\n * ```\n *\n * @see {@link isTransactionPartialSigner}\n */\nexport function assertIsTransactionPartialSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is TransactionPartialSigner<TAddress> {\n    if (!isTransactionPartialSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER, SolanaError } from '@solana/errors';\nimport { SignatureBytes } from '@solana/keys';\nimport { Transaction, TransactionWithLifetime } from '@solana/transactions';\n\nimport { BaseTransactionSignerConfig } from './types';\n\n/**\n * The configuration to optionally provide when calling the\n * {@link TransactionSendingSignerConfig#signAndSendTransactions | signAndSendTransactions} method.\n *\n * @see {@link BaseTransactionSignerConfig}\n */\nexport type TransactionSendingSignerConfig = BaseTransactionSignerConfig;\n\n/**\n * A signer interface that signs one or multiple transactions\n * before sending them immediately to the blockchain.\n *\n * It defines a {@link TransactionSendingSignerConfig#signAndSendTransactions | signAndSendTransactions}\n * function that returns the transaction signature (i.e. its identifier) for each provided\n * {@link Transaction}.\n *\n * This interface is required for PDA wallets and other types of wallets that don't provide an\n * interface for signing transactions without sending them.\n *\n * Note that it is also possible for such signers to modify the provided transactions\n * before signing and sending them. This enables use cases where the modified transactions\n * cannot be shared with the app and thus must be sent directly.\n *\n * @typeParam TAddress - Supply a string literal to define a signer having a particular address.\n *\n * @example\n * ```ts\n * const myTransactionSendingSigner: TransactionSendingSigner<'1234..5678'> = {\n *     address: address('1234..5678'),\n *     signAndSendTransactions: async (transactions: Transaction[]): Promise<SignatureBytes[]> => {\n *         // My custom signing logic.\n *     },\n * };\n * ```\n *\n * @remarks\n * Here are the main characteristics of this signer interface:\n *\n * - **Single signer**. Since this signer also sends the provided transactions,\n *   we can only use a single {@link TransactionSendingSigner} for a given set of transactions.\n * - **Last signer**. Trivially, that signer must also be the last one used.\n * - **Potential conflicts**. Since signers may decide to modify the given\n *   transactions before sending them, they may invalidate previous signatures.\n *   However, signers may decide not to modify a transaction based\n *   on the existence of signatures for that transaction.\n * - **Potential confirmation**. Whilst this is not required by this interface,\n *   it is also worth noting that most wallets will also wait for the transaction\n *   to be confirmed (typically with a `confirmed` commitment)\n *   before notifying the app that they are done.\n *\n * @see {@link isTransactionSendingSigner}\n * @see {@link assertIsTransactionSendingSigner}\n */\nexport type TransactionSendingSigner<TAddress extends string = string> = Readonly<{\n    address: Address<TAddress>;\n    signAndSendTransactions(\n        transactions: readonly (Transaction | (Transaction & TransactionWithLifetime))[],\n        config?: TransactionSendingSignerConfig,\n    ): Promise<readonly SignatureBytes[]>;\n}>;\n\n/**\n * Checks whether the provided value implements the {@link TransactionSendingSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { isTransactionSendingSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * isTransactionSendingSigner({ address, signAndSendTransactions: async () => {} }); // true\n * isTransactionSendingSigner({ address }); // false\n * ```\n *\n * @see {@link assertIsTransactionSendingSigner}\n */\nexport function isTransactionSendingSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is TransactionSendingSigner<TAddress> {\n    return 'signAndSendTransactions' in value && typeof value.signAndSendTransactions === 'function';\n}\n\n/**\n * Asserts that the provided value implements the {@link TransactionSendingSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { assertIsTransactionSendingSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * assertIsTransactionSendingSigner({ address, signAndSendTransactions: async () => {} }); // void\n * assertIsTransactionSendingSigner({ address }); // Throws an error.\n * ```\n *\n * @see {@link isTransactionSendingSigner}\n */\nexport function assertIsTransactionSendingSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is TransactionSendingSigner<TAddress> {\n    if (!isTransactionSendingSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER, SolanaError } from '@solana/errors';\n\nimport { isTransactionModifyingSigner, TransactionModifyingSigner } from './transaction-modifying-signer';\nimport { isTransactionPartialSigner, TransactionPartialSigner } from './transaction-partial-signer';\nimport { isTransactionSendingSigner, TransactionSendingSigner } from './transaction-sending-signer';\n\n/**\n * Defines a signer capable of signing transactions.\n *\n * @see {@link TransactionModifyingSigner} For signers that can modify transactions before signing them.\n * @see {@link TransactionPartialSigner} For signers that can be used in parallel.\n * @see {@link TransactionSendingSigner} For signers that send transactions after signing them.\n * @see {@link isTransactionSigner}\n * @see {@link assertIsTransactionSigner}\n */\nexport type TransactionSigner<TAddress extends string = string> =\n    | TransactionModifyingSigner<TAddress>\n    | TransactionPartialSigner<TAddress>\n    | TransactionSendingSigner<TAddress>;\n\n/**\n * Checks whether the provided value implements the {@link TransactionSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { isTransactionSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * isTransactionSigner({ address, signTransactions: async () => {} }); // true\n * isTransactionSigner({ address, modifyAndSignTransactions: async () => {} }); // true\n * isTransactionSigner({ address, signAndSendTransactions: async () => {} }); // true\n * isTransactionSigner({ address }); // false\n * ```\n *\n * @see {@link assertIsTransactionSigner}\n */\nexport function isTransactionSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is TransactionSigner<TAddress> {\n    return (\n        isTransactionPartialSigner(value) || isTransactionModifyingSigner(value) || isTransactionSendingSigner(value)\n    );\n}\n\n/**\n * Asserts that the provided value implements the {@link TransactionSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { assertIsTransactionSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * assertIsTransactionSigner({ address, signTransactions: async () => {} }); // void\n * assertIsTransactionSigner({ address, modifyAndSignTransactions: async () => {} }); // void\n * assertIsTransactionSigner({ address, signAndSendTransactions: async () => {} }); // void\n * assertIsTransactionSigner({ address }); // Throws an error.\n * ```\n *\n * @see {@link isTransactionSigner}\n */\nexport function assertIsTransactionSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is TransactionSigner<TAddress> {\n    if (!isTransactionSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n","import { AccountLookupMeta, AccountMeta, AccountRole, Instruction } from '@solana/instructions';\nimport {\n    BaseTransactionMessage,\n    TransactionMessageWithFeePayer,\n    TransactionVersion,\n} from '@solana/transaction-messages';\n\nimport { deduplicateSigners } from './deduplicate-signers';\nimport { TransactionMessageWithFeePayerSigner } from './fee-payer-signer';\nimport { isTransactionSigner, TransactionSigner } from './transaction-signer';\n\n/**\n * An extension of the {@link AccountMeta} type that allows us to store {@link TransactionSigner | TransactionSigners} inside it.\n *\n * Note that, because this type represents a signer, it must use one the following two roles:\n * - {@link AccountRole.READONLY_SIGNER}\n * - {@link AccountRole.WRITABLE_SIGNER}\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TSigner - Optionally provide a narrower type for the {@link TransactionSigner} to use within the account meta.\n *\n * @interface\n *\n * @example\n * ```ts\n * import { AccountRole } from '@solana/instructions';\n * import { generateKeyPairSigner, AccountSignerMeta } from '@solana/signers';\n *\n * const signer = await generateKeyPairSigner();\n * const account: AccountSignerMeta = {\n *     address: signer.address,\n *     role: AccountRole.READONLY_SIGNER,\n *     signer,\n * };\n * ```\n */\nexport interface AccountSignerMeta<\n    TAddress extends string = string,\n    TSigner extends TransactionSigner<TAddress> = TransactionSigner<TAddress>,\n> extends AccountMeta<TAddress> {\n    readonly role: AccountRole.READONLY_SIGNER | AccountRole.WRITABLE_SIGNER;\n    readonly signer: TSigner;\n}\n\n/**\n * A union type that supports base account metas as well as {@link AccountSignerMeta | signer account metas}.\n */\ntype AccountMetaWithSigner<TSigner extends TransactionSigner = TransactionSigner> =\n    | AccountLookupMeta\n    | AccountMeta\n    | AccountSignerMeta<string, TSigner>;\n\n/**\n * Composable type that allows {@link AccountSignerMeta | AccountSignerMetas} to be used inside the instruction's `accounts` array\n *\n * @typeParam TSigner - Optionally provide a narrower type for {@link TransactionSigner | TransactionSigners}.\n * @typeParam TAccounts - Optionally provide a narrower type for the account metas.\n *\n * @interface\n *\n * @example\n * ```ts\n * import { AccountRole, Instruction } from '@solana/instructions';\n * import { generateKeyPairSigner, InstructionWithSigners } from '@solana/signers';\n *\n * const [authority, buffer] = await Promise.all([\n *     generateKeyPairSigner(),\n *     generateKeyPairSigner(),\n * ]);\n * const instruction: Instruction & InstructionWithSigners = {\n *     programAddress: address('1234..5678'),\n *     accounts: [\n *         // The authority is a signer account.\n *         {\n *             address: authority.address,\n *             role: AccountRole.READONLY_SIGNER,\n *             signer: authority,\n *         },\n *         // The buffer is a writable account.\n *         { address: buffer.address, role: AccountRole.WRITABLE },\n *     ],\n * };\n * ```\n */\nexport type InstructionWithSigners<\n    TSigner extends TransactionSigner = TransactionSigner,\n    TAccounts extends readonly AccountMetaWithSigner<TSigner>[] = readonly AccountMetaWithSigner<TSigner>[],\n> = Pick<Instruction<string, TAccounts>, 'accounts'>;\n\n/**\n * A {@link BaseTransactionMessage} type extension that accept {@link TransactionSigner | TransactionSigners}.\n *\n * Namely, it allows:\n * - a {@link TransactionSigner} to be used as the fee payer and\n * - {@link InstructionWithSigners} to be used in its instructions.\n *\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TSigner - Optionally provide a narrower type for {@link TransactionSigner | TransactionSigners}.\n * @typeParam TAccounts - Optionally provide a narrower type for the account metas.\n *\n * @example\n * ```ts\n * import { Instruction } from '@solana/instructions';\n * import { BaseTransactionMessage } from '@solana/transaction-messages';\n * import { generateKeyPairSigner, InstructionWithSigners, TransactionMessageWithSigners } from '@solana/signers';\n *\n * const signer = await generateKeyPairSigner();\n * const firstInstruction: Instruction = { ... };\n * const secondInstruction: InstructionWithSigners = { ... };\n * const transactionMessage: BaseTransactionMessage & TransactionMessageWithSigners = {\n *     feePayer: signer,\n *     instructions: [firstInstruction, secondInstruction],\n * }\n * ```\n */\nexport type TransactionMessageWithSigners<\n    TAddress extends string = string,\n    TSigner extends TransactionSigner<TAddress> = TransactionSigner<TAddress>,\n    TAccounts extends readonly AccountMetaWithSigner<TSigner>[] = readonly AccountMetaWithSigner<TSigner>[],\n> = Partial<TransactionMessageWithFeePayer<TAddress> | TransactionMessageWithFeePayerSigner<TAddress, TSigner>> &\n    Pick<\n        BaseTransactionMessage<TransactionVersion, Instruction & InstructionWithSigners<TSigner, TAccounts>>,\n        'instructions'\n    >;\n\n/**\n * Extracts and deduplicates all {@link TransactionSigner | TransactionSigners} stored\n * inside the account metas of an {@link InstructionWithSigners | instruction}.\n *\n * Any extracted signers that share the same {@link Address} will be de-duplicated.\n *\n * @typeParam TSigner - Optionally provide a narrower type for {@link TransactionSigner | TransactionSigners}.\n *\n * @example\n * ```ts\n * import { InstructionWithSigners, getSignersFromInstruction } from '@solana/signers';\n *\n * const signerA = { address: address('1111..1111'), signTransactions: async () => {} };\n * const signerB = { address: address('2222..2222'), signTransactions: async () => {} };\n * const instructionWithSigners: InstructionWithSigners = {\n *     accounts: [\n *         { address: signerA.address, signer: signerA, ... },\n *         { address: signerB.address, signer: signerB, ... },\n *         { address: signerA.address, signer: signerA, ... },\n *     ],\n * };\n *\n * const instructionSigners = getSignersFromInstruction(instructionWithSigners);\n * // ^ [signerA, signerB]\n * ```\n */\nexport function getSignersFromInstruction<TSigner extends TransactionSigner = TransactionSigner>(\n    instruction: InstructionWithSigners<TSigner>,\n): readonly TSigner[] {\n    return deduplicateSigners(\n        (instruction.accounts ?? []).flatMap(account => ('signer' in account ? account.signer : [])),\n    );\n}\n\n/**\n * Extracts and deduplicates all {@link TransactionSigner | TransactionSigners} stored\n * inside a given {@link TransactionMessageWithSigners | transaction message}.\n *\n * This includes any {@link TransactionSigner | TransactionSigners} stored\n * as the fee payer or in the instructions of the transaction message.\n *\n * Any extracted signers that share the same {@link Address} will be de-duplicated.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TSigner - Optionally provide a narrower type for {@link TransactionSigner | TransactionSigners}.\n * @typeParam TTransactionMessage - The inferred type of the transaction message provided.\n *\n * @example\n * ```ts\n * import { Instruction } from '@solana/instructions';\n * import { InstructionWithSigners, TransactionMessageWithSigners, getSignersFromTransactionMessage } from '@solana/signers';\n *\n * const signerA = { address: address('1111..1111'), signTransactions: async () => {} };\n * const signerB = { address: address('2222..2222'), signTransactions: async () => {} };\n * const firstInstruction: Instruction & InstructionWithSigners = {\n *     programAddress: address('1234..5678'),\n *     accounts: [{ address: signerA.address, signer: signerA, ... }],\n * };\n * const secondInstruction: Instruction & InstructionWithSigners = {\n *     programAddress: address('1234..5678'),\n *     accounts: [{ address: signerB.address, signer: signerB, ... }],\n * };\n * const transactionMessage: TransactionMessageWithSigners = {\n *     feePayer: signerA,\n *     instructions: [firstInstruction, secondInstruction],\n * }\n *\n * const transactionSigners = getSignersFromTransactionMessage(transactionMessage);\n * // ^ [signerA, signerB]\n * ```\n */\nexport function getSignersFromTransactionMessage<\n    TAddress extends string = string,\n    TSigner extends TransactionSigner<TAddress> = TransactionSigner<TAddress>,\n    TTransactionMessage extends TransactionMessageWithSigners<TAddress, TSigner> = TransactionMessageWithSigners<\n        TAddress,\n        TSigner\n    >,\n>(transaction: TTransactionMessage): readonly TSigner[] {\n    return deduplicateSigners([\n        ...(transaction.feePayer && isTransactionSigner(transaction.feePayer) ? [transaction.feePayer as TSigner] : []),\n        ...transaction.instructions.flatMap(getSignersFromInstruction),\n    ]);\n}\n","import { Address } from '@solana/addresses';\nimport { Instruction, isSignerRole } from '@solana/instructions';\nimport { BaseTransactionMessage, TransactionMessageWithFeePayer } from '@solana/transaction-messages';\n\nimport { AccountSignerMeta, InstructionWithSigners, TransactionMessageWithSigners } from './account-signer-meta';\nimport { deduplicateSigners } from './deduplicate-signers';\nimport { isTransactionSigner, TransactionSigner } from './transaction-signer';\n\n/**\n * Attaches the provided {@link TransactionSigner | TransactionSigners} to the\n * account metas of an instruction when applicable.\n *\n * For an account meta to match a provided signer it:\n * - Must have a signer role ({@link AccountRole.READONLY_SIGNER} or {@link AccountRole.WRITABLE_SIGNER}).\n * - Must have the same address as the provided signer.\n * - Must not have an attached signer already.\n *\n * @typeParam TInstruction - The inferred type of the instruction provided.\n *\n * @example\n * ```ts\n * import { AccountRole, Instruction } from '@solana/instructions';\n * import { addSignersToInstruction, TransactionSigner } from '@solana/signers';\n *\n * const instruction: Instruction = {\n *     accounts: [\n *         { address: '1111' as Address, role: AccountRole.READONLY_SIGNER },\n *         { address: '2222' as Address, role: AccountRole.WRITABLE_SIGNER },\n *     ],\n *     // ...\n * };\n *\n * const signerA: TransactionSigner<'1111'>;\n * const signerB: TransactionSigner<'2222'>;\n * const instructionWithSigners = addSignersToInstruction(\n *     [signerA, signerB],\n *     instruction\n * );\n *\n * // instructionWithSigners.accounts[0].signer === signerA\n * // instructionWithSigners.accounts[1].signer === signerB\n * ```\n */\nexport function addSignersToInstruction<TInstruction extends Instruction>(\n    signers: TransactionSigner[],\n    instruction: TInstruction | (InstructionWithSigners & TInstruction),\n): InstructionWithSigners & TInstruction {\n    if (!instruction.accounts || instruction.accounts.length === 0) {\n        return instruction as InstructionWithSigners & TInstruction;\n    }\n\n    const signerByAddress = new Map(deduplicateSigners(signers).map(signer => [signer.address, signer]));\n    return Object.freeze({\n        ...instruction,\n        accounts: instruction.accounts.map(account => {\n            const signer = signerByAddress.get(account.address);\n            if (!isSignerRole(account.role) || 'signer' in account || !signer) {\n                return account;\n            }\n            return Object.freeze({ ...account, signer } as AccountSignerMeta);\n        }),\n    });\n}\n\n/**\n * Attaches the provided {@link TransactionSigner | TransactionSigners} to the\n * account metas of all instructions inside a transaction message and/or\n * the transaction message fee payer, when applicable.\n *\n * For an account meta to match a provided signer it:\n * - Must have a signer role ({@link AccountRole.READONLY_SIGNER} or {@link AccountRole.WRITABLE_SIGNER}).\n * - Must have the same address as the provided signer.\n * - Must not have an attached signer already.\n *\n * @typeParam TTransactionMessage - The inferred type of the transaction message provided.\n *\n * @example\n * ```ts\n * import { AccountRole, Instruction } from '@solana/instructions';\n * import { BaseTransactionMessage } from '@solana/transaction-messages';\n * import { addSignersToTransactionMessage, TransactionSigner } from '@solana/signers';\n *\n * const instructionA: Instruction = {\n *     accounts: [{ address: '1111' as Address, role: AccountRole.READONLY_SIGNER }],\n *     // ...\n * };\n * const instructionB: Instruction = {\n *     accounts: [{ address: '2222' as Address, role: AccountRole.WRITABLE_SIGNER }],\n *     // ...\n * };\n * const transactionMessage: BaseTransactionMessage = {\n *     instructions: [instructionA, instructionB],\n *     // ...\n * }\n *\n * const signerA: TransactionSigner<'1111'>;\n * const signerB: TransactionSigner<'2222'>;\n * const transactionMessageWithSigners = addSignersToTransactionMessage(\n *     [signerA, signerB],\n *     transactionMessage\n * );\n *\n * // transactionMessageWithSigners.instructions[0].accounts[0].signer === signerA\n * // transactionMessageWithSigners.instructions[1].accounts[0].signer === signerB\n * ```\n */\nexport function addSignersToTransactionMessage<TTransactionMessage extends BaseTransactionMessage>(\n    signers: TransactionSigner[],\n    transactionMessage: TTransactionMessage | (TransactionMessageWithSigners & TTransactionMessage),\n): TransactionMessageWithSigners & TTransactionMessage {\n    const feePayerSigner = hasAddressOnlyFeePayer(transactionMessage)\n        ? signers.find(signer => signer.address === transactionMessage.feePayer.address)\n        : undefined;\n\n    if (!feePayerSigner && transactionMessage.instructions.length === 0) {\n        return transactionMessage as TransactionMessageWithSigners & TTransactionMessage;\n    }\n\n    return Object.freeze({\n        ...transactionMessage,\n        ...(feePayerSigner ? { feePayer: feePayerSigner } : null),\n        instructions: transactionMessage.instructions.map(instruction => addSignersToInstruction(signers, instruction)),\n    });\n}\n\nfunction hasAddressOnlyFeePayer(\n    message: BaseTransactionMessage & Partial<TransactionMessageWithFeePayer>,\n): message is BaseTransactionMessage & { feePayer: { address: Address } } {\n    return (\n        !!message &&\n        'feePayer' in message &&\n        !!message.feePayer &&\n        typeof message.feePayer.address === 'string' &&\n        !isTransactionSigner(message.feePayer)\n    );\n}\n","import { BaseTransactionMessage, TransactionMessageWithFeePayer } from '@solana/transaction-messages';\n\nimport { TransactionSigner } from './transaction-signer';\n\n/**\n * Alternative to {@link TransactionMessageWithFeePayer} that uses a {@link TransactionSigner} for the fee payer.\n *\n * @typeParam TAddress - Supply a string literal to define a fee payer having a particular address.\n * @typeParam TSigner - Optionally provide a narrower type for the {@link TransactionSigner}.\n *\n * @example\n * ```ts\n * import { BaseTransactionMessage } from '@solana/transaction-messages';\n * import { generateKeyPairSigner, TransactionMessageWithFeePayerSigner } from '@solana/signers';\n *\n * const transactionMessage: BaseTransactionMessage & TransactionMessageWithFeePayerSigner = {\n *     feePayer: await generateKeyPairSigner(),\n *     instructions: [],\n *     version: 0,\n * };\n * ```\n */\nexport interface TransactionMessageWithFeePayerSigner<\n    TAddress extends string = string,\n    TSigner extends TransactionSigner<TAddress> = TransactionSigner<TAddress>,\n> {\n    readonly feePayer: TSigner;\n}\n\n/**\n * Sets the fee payer of a {@link BaseTransactionMessage | transaction message}\n * using a {@link TransactionSigner}.\n *\n * @typeParam TFeePayerAddress - Supply a string literal to define a fee payer having a particular address.\n * @typeParam TTransactionMessage - The inferred type of the transaction message provided.\n *\n * @example\n * ```ts\n * import { pipe } from '@solana/functional';\n * import { generateKeyPairSigner, setTransactionMessageFeePayerSigner } from '@solana/signers';\n * import { createTransactionMessage } from '@solana/transaction-messages';\n *\n * const feePayer = await generateKeyPairSigner();\n * const transactionMessage = pipe(\n *     createTransactionMessage({ version: 0 }),\n *     message => setTransactionMessageFeePayerSigner(signer, message),\n * );\n * ```\n */\nexport function setTransactionMessageFeePayerSigner<\n    TFeePayerAddress extends string,\n    TTransactionMessage extends BaseTransactionMessage &\n        Partial<TransactionMessageWithFeePayer | TransactionMessageWithFeePayerSigner>,\n>(\n    feePayer: TransactionSigner<TFeePayerAddress>,\n    transactionMessage: TTransactionMessage,\n): Omit<TTransactionMessage, 'feePayer'> & TransactionMessageWithFeePayerSigner<TFeePayerAddress> {\n    Object.freeze(feePayer);\n    const out = { ...transactionMessage, feePayer };\n    Object.freeze(out);\n    return out;\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER, SolanaError } from '@solana/errors';\n\nimport { SignableMessage } from './signable-message';\nimport { BaseSignerConfig, SignatureDictionary } from './types';\n\n/**\n * The configuration to optionally provide when calling the\n * {@link MessagePartialSigner#signMessages | signMessages} method.\n *\n * @see {@link BaseSignerConfig}\n */\nexport type MessagePartialSignerConfig = BaseSignerConfig;\n\n/**\n * A signer interface that signs an array of {@link SignableMessage | SignableMessages}\n * without modifying their content.\n *\n * It defines a {@link MessagePartialSigner#signMessages | signMessages} function\n * that returns a {@link SignatureDictionary} for each provided message.\n * Such signature dictionaries are expected to be merged with the existing ones if any.\n *\n * @typeParam TAddress - Supply a string literal to define a signer having a particular address.\n *\n * @example\n * ```ts\n * const signer: MessagePartialSigner<'1234..5678'> = {\n *     address: address('1234..5678'),\n *     signMessages: async (\n *         messages: SignableMessage[]\n *     ): Promise<SignatureDictionary[]> => {\n *         // My custom signing logic.\n *     },\n * };\n * ```\n *\n * @remarks\n * Here are the main characteristics of this signer interface:\n *\n * - **Parallel**. When multiple signers sign the same message, we can\n *   perform this operation in parallel to obtain all their signatures.\n * - **Flexible order**. The order in which we use these signers\n *   for a given message doesnt matter.\n *\n * @see {@link SignableMessage}\n * @see {@link createSignableMessage}\n * @see {@link isMessagePartialSigner}\n * @see {@link assertIsMessagePartialSigner}\n */\nexport type MessagePartialSigner<TAddress extends string = string> = Readonly<{\n    address: Address<TAddress>;\n    signMessages(\n        messages: readonly SignableMessage[],\n        config?: MessagePartialSignerConfig,\n    ): Promise<readonly SignatureDictionary[]>;\n}>;\n\n/**\n * Checks whether the provided value implements the {@link MessagePartialSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { isMessagePartialSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * isMessagePartialSigner({ address, signMessages: async () => {} }); // true\n * isMessagePartialSigner({ address }); // false\n * ```\n *\n * @see {@link assertIsMessagePartialSigner}\n */\nexport function isMessagePartialSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is MessagePartialSigner<TAddress> {\n    return 'signMessages' in value && typeof value.signMessages === 'function';\n}\n\n/**\n * Asserts that the provided value implements the {@link MessagePartialSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { assertIsMessagePartialSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * assertIsMessagePartialSigner({ address, signMessages: async () => {} }); // void\n * assertIsMessagePartialSigner({ address }); // Throws an error.\n * ```\n *\n * @see {@link isMessagePartialSigner}\n */\nexport function assertIsMessagePartialSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is MessagePartialSigner<TAddress> {\n    if (!isMessagePartialSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n","import { Address, getAddressFromPublicKey } from '@solana/addresses';\nimport { ReadonlyUint8Array } from '@solana/codecs-core';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER, SolanaError } from '@solana/errors';\nimport { createKeyPairFromBytes, createKeyPairFromPrivateKeyBytes, generateKeyPair, signBytes } from '@solana/keys';\nimport { partiallySignTransaction } from '@solana/transactions';\n\nimport { isMessagePartialSigner, MessagePartialSigner } from './message-partial-signer';\nimport { isTransactionPartialSigner, TransactionPartialSigner } from './transaction-partial-signer';\n\n/**\n * Defines a signer that uses a {@link CryptoKeyPair} to sign messages and transactions.\n *\n * It implements both the {@link MessagePartialSigner} and {@link TransactionPartialSigner}\n * interfaces and keeps track of the {@link CryptoKeyPair} instance used\n * to sign messages and transactions.\n *\n * @typeParam TAddress - Supply a string literal to define a signer having a particular address.\n *\n * @example\n * ```ts\n * import { generateKeyPairSigner } from '@solana/signers';\n *\n * const signer = generateKeyPairSigner();\n * signer.address; // Address;\n * signer.keyPair; // CryptoKeyPair;\n * const [messageSignatures] = await signer.signMessages([message]);\n * const [transactionSignatures] = await signer.signTransactions([transaction]);\n * ```\n *\n * @see {@link generateKeyPairSigner}\n * @see {@link createSignerFromKeyPair}\n * @see {@link createKeyPairSignerFromBytes}\n * @see {@link createKeyPairSignerFromPrivateKeyBytes}\n * @see {@link isKeyPairSigner}\n * @see {@link assertIsKeyPairSigner}\n */\nexport type KeyPairSigner<TAddress extends string = string> = MessagePartialSigner<TAddress> &\n    TransactionPartialSigner<TAddress> & { keyPair: CryptoKeyPair };\n\n/**\n * Checks whether the provided value implements the {@link KeyPairSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { generateKeyPairSigner, isKeyPairSigner } from '@solana/signers';\n *\n * const signer = await generateKeyPairSigner();\n * isKeyPairSigner(signer); // true\n * isKeyPairSigner({ address: address('1234..5678') }); // false\n * ```\n */\nexport function isKeyPairSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is KeyPairSigner<TAddress> {\n    return (\n        'keyPair' in value &&\n        typeof value.keyPair === 'object' &&\n        isMessagePartialSigner(value) &&\n        isTransactionPartialSigner(value)\n    );\n}\n\n/**\n * Asserts that the provided value implements the {@link KeyPairSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { generateKeyPairSigner, assertIsKeyPairSigner } from '@solana/signers';\n *\n * const signer = await generateKeyPairSigner();\n * assertIsKeyPairSigner(signer); // void\n * assertIsKeyPairSigner({ address: address('1234..5678') }); // Throws an error.\n * ```\n */\nexport function assertIsKeyPairSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is KeyPairSigner<TAddress> {\n    if (!isKeyPairSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n\n/**\n * Creates a {@link KeyPairSigner} from a provided {@link CryptoKeyPair}.\n *\n * The {@link MessagePartialSigner#signMessages | signMessages} and\n * {@link TransactionPartialSigner#signTransactions | signTransactions}\n * functions of the returned signer will use the private key of the provided\n * key pair to sign messages and transactions.\n *\n * Note that both the {@link MessagePartialSigner#signMessages | signMessages} and\n * {@link TransactionPartialSigner#signTransactions | signTransactions} implementations\n * are parallelized, meaning that they will sign all provided messages and transactions in parallel.\n *\n * @example\n * ```ts\n * import { generateKeyPair } from '@solana/keys';\n * import { createSignerFromKeyPair, KeyPairSigner } from '@solana/signers';\n *\n * const keyPair: CryptoKeyPair = await generateKeyPair();\n * const signer: KeyPairSigner = await createSignerFromKeyPair(keyPair);\n * ```\n */\nexport async function createSignerFromKeyPair(keyPair: CryptoKeyPair): Promise<KeyPairSigner> {\n    const address = await getAddressFromPublicKey(keyPair.publicKey);\n    const out: KeyPairSigner = {\n        address,\n        keyPair,\n        signMessages: messages =>\n            Promise.all(\n                messages.map(async message =>\n                    Object.freeze({ [address]: await signBytes(keyPair.privateKey, message.content) }),\n                ),\n            ),\n        signTransactions: transactions =>\n            Promise.all(\n                transactions.map(async transaction => {\n                    const signedTransaction = await partiallySignTransaction([keyPair], transaction);\n                    // we know that the address has signed `signedTransaction` because it comes from the keypair\n                    return Object.freeze({ [address]: signedTransaction.signatures[address]! });\n                }),\n            ),\n    };\n\n    return Object.freeze(out);\n}\n\n/**\n * Generates a signer capable of signing messages and transactions by generating\n * a {@link CryptoKeyPair} and creating a {@link KeyPairSigner} from it.\n *\n * @example\n * ```ts\n * import { generateKeyPairSigner } from '@solana/signers';\n *\n * const signer = await generateKeyPairSigner();\n * ```\n *\n * @see {@link createSignerFromKeyPair}\n */\nexport async function generateKeyPairSigner(): Promise<KeyPairSigner> {\n    return await createSignerFromKeyPair(await generateKeyPair());\n}\n\n/**\n * Creates a new {@link KeyPairSigner} from a 64-bytes `Uint8Array` secret key (private key and public key).\n *\n * @example\n * ```ts\n * import fs from 'fs';\n * import { createKeyPairSignerFromBytes } from '@solana/signers';\n *\n * // Get bytes from local keypair file.\n * const keypairFile = fs.readFileSync('~/.config/solana/id.json');\n * const keypairBytes = new Uint8Array(JSON.parse(keypairFile.toString()));\n *\n * // Create a KeyPairSigner from the bytes.\n * const signer = await createKeyPairSignerFromBytes(keypairBytes);\n * ```\n *\n * @see {@link createKeyPairSignerFromPrivateKeyBytes} if you only have the 32-bytes private key instead.\n */\nexport async function createKeyPairSignerFromBytes(\n    bytes: ReadonlyUint8Array,\n    extractable?: boolean,\n): Promise<KeyPairSigner> {\n    return await createSignerFromKeyPair(await createKeyPairFromBytes(bytes, extractable));\n}\n\n/**\n * Creates a new {@link KeyPairSigner} from a 32-bytes `Uint8Array` private key.\n *\n * @example\n * ```ts\n * import { getUtf8Encoder } from '@solana/codecs-strings';\n * import { createKeyPairSignerFromPrivateKeyBytes } from '@solana/signers';\n *\n * const message = getUtf8Encoder().encode('Hello, World!');\n * const seed = new Uint8Array(await crypto.subtle.digest('SHA-256', message));\n *\n * const derivedSigner = await createKeyPairSignerFromPrivateKeyBytes(seed);\n * ```\n *\n * @see {@link createKeyPairSignerFromBytes} if you have the 64-bytes secret key instead (private key and public key).\n */\nexport async function createKeyPairSignerFromPrivateKeyBytes(\n    bytes: ReadonlyUint8Array,\n    extractable?: boolean,\n): Promise<KeyPairSigner> {\n    return await createSignerFromKeyPair(await createKeyPairFromPrivateKeyBytes(bytes, extractable));\n}\n","import { Address, isAddress } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER, SolanaError } from '@solana/errors';\n\nimport { SignableMessage } from './signable-message';\nimport { BaseSignerConfig } from './types';\n\n/**\n * The configuration to optionally provide when calling the\n * {@link MessageModifyingSigner#modifyAndSignMessages | modifyAndSignMessages} method.\n *\n * @see {@link BaseSignerConfig}\n */\nexport type MessageModifyingSignerConfig = BaseSignerConfig;\n\n/**\n * A signer interface that _potentially_ modifies the content\n * of the provided {@link SignableMessage | SignableMessages} before signing them.\n *\n * For instance, this enables wallets to prefix or suffix nonces to the messages they sign.\n * For each message, instead of returning a {@link SignatureDictionary}, the\n * {@link MessageModifyingSigner#modifyAndSignMessages | modifyAndSignMessages} function\n * returns an updated {@link SignableMessage} with a potentially modified content and signature dictionary.\n *\n * @typeParam TAddress - Supply a string literal to define a signer having a particular address.\n *\n * @example\n * ```ts\n * const signer: MessageModifyingSigner<'1234..5678'> = {\n *     address: address('1234..5678'),\n *     modifyAndSignMessages: async (\n *         messages: SignableMessage[]\n *     ): Promise<SignableMessage[]> => {\n *         // My custom signing logic.\n *     },\n * };\n * ```\n *\n * @remarks\n * Here are the main characteristics of this signer interface:\n *\n * - **Sequential**. Contrary to partial signers, these cannot be executed in\n *   parallel as each call can modify the content of the message.\n * - **First signers**. For a given message, a modifying signer must always be used\n *   before a partial signer as the former will likely modify the message and\n *   thus impact the outcome of the latter.\n * - **Potential conflicts**. If more than one modifying signer is provided, the second\n *   signer may invalidate the signature of the first one. However, modifying signers\n *   may decide not to modify a message based on the existence of signatures for that message.\n *\n * @see {@link SignableMessage}\n * @see {@link createSignableMessage}\n * @see {@link isMessageModifyingSigner}\n * @see {@link assertIsMessageModifyingSigner}\n */\nexport type MessageModifyingSigner<TAddress extends string = string> = Readonly<{\n    address: Address<TAddress>;\n    modifyAndSignMessages(\n        messages: readonly SignableMessage[],\n        config?: MessageModifyingSignerConfig,\n    ): Promise<readonly SignableMessage[]>;\n}>;\n\n/**\n * Checks whether the provided value implements the {@link MessageModifyingSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { isMessageModifyingSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * isMessageModifyingSigner({ address, modifyAndSignMessages: async () => {} }); // true\n * isMessageModifyingSigner({ address }); // false\n * ```\n *\n * @see {@link assertIsMessageModifyingSigner}\n */\nexport function isMessageModifyingSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is MessageModifyingSigner<TAddress> {\n    return (\n        isAddress(value.address) &&\n        'modifyAndSignMessages' in value &&\n        typeof value.modifyAndSignMessages === 'function'\n    );\n}\n\n/**\n * Asserts that the provided value implements the {@link MessageModifyingSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { assertIsMessageModifyingSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * assertIsMessageModifyingSigner({ address, modifyAndSignMessages: async () => {} }); // void\n * assertIsMessageModifyingSigner({ address }); // Throws an error.\n * ```\n *\n * @see {@link isMessageModifyingSigner}\n */\nexport function assertIsMessageModifyingSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is MessageModifyingSigner<TAddress> {\n    if (!isMessageModifyingSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER, SolanaError } from '@solana/errors';\n\nimport { isMessageModifyingSigner, MessageModifyingSigner } from './message-modifying-signer';\nimport { isMessagePartialSigner, MessagePartialSigner } from './message-partial-signer';\n\n/**\n * Defines a signer capable of signing messages.\n *\n * @see {@link MessageModifyingSigner} For signers that can modify messages before signing them.\n * @see {@link MessagePartialSigner} For signers that can be used in parallel.\n * @see {@link isMessageSigner}\n * @see {@link assertIsMessageSigner}\n */\nexport type MessageSigner<TAddress extends string = string> =\n    | MessageModifyingSigner<TAddress>\n    | MessagePartialSigner<TAddress>;\n\n/**\n * Checks whether the provided value implements the {@link MessageSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { isMessageSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * isMessageSigner({ address, signMessages: async () => {} }); // true\n * isMessageSigner({ address, modifyAndSignMessages: async () => {} }); // true\n * isMessageSigner({ address }); // false\n * ```\n *\n * @see {@link assertIsMessageSigner}\n */\nexport function isMessageSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is MessageSigner<TAddress> {\n    return isMessagePartialSigner(value) || isMessageModifyingSigner(value);\n}\n\n/**\n * Asserts that the provided value implements the {@link MessageSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { assertIsMessageSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * assertIsMessageSigner({ address, signMessages: async () => {} }); // void\n * assertIsMessageSigner({ address, modifyAndSignMessages: async () => {} }); // void\n * assertIsMessageSigner({ address }); // Throws an error.\n * ```\n *\n * @see {@link isMessageSigner}\n */\nexport function assertIsMessageSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is MessageSigner<TAddress> {\n    if (!isMessageSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n","import { Address } from '@solana/addresses';\n\nimport { MessagePartialSigner } from './message-partial-signer';\nimport { TransactionPartialSigner } from './transaction-partial-signer';\n\n/**\n * Defines a Noop (No-Operation) signer that pretends to partially sign messages and transactions.\n *\n * For a given {@link Address}, a Noop Signer can be created to offer an implementation of both\n * the {@link MessagePartialSigner} and {@link TransactionPartialSigner} interfaces such that\n * they do not sign anything. Namely, signing a transaction or a message with a `NoopSigner`\n * will return an empty `SignatureDictionary`.\n *\n * @typeParam TAddress - Supply a string literal to define a Noop signer having a particular address.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { createNoopSigner } from '@solana/signers';\n *\n * const signer = createNoopSigner(address('1234..5678'));\n * const [messageSignatures] = await signer.signMessages([message]);\n * const [transactionSignatures] = await signer.signTransactions([transaction]);\n * // ^ Both messageSignatures and transactionSignatures are empty.\n * ```\n *\n * @remarks\n * This signer may be useful:\n *\n * - For testing purposes.\n * - For indicating that a given account is a signer and taking the responsibility to provide\n *   the signature for that account ourselves. For instance, if we need to send the transaction\n *   to a server that will sign it and send it for us.\n *\n * @see {@link createNoopSigner}\n */\nexport type NoopSigner<TAddress extends string = string> = MessagePartialSigner<TAddress> &\n    TransactionPartialSigner<TAddress>;\n\n/**\n * Creates a {@link NoopSigner} from the provided {@link Address}.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { createNoopSigner } from '@solana/signers';\n *\n * const signer = createNoopSigner(address('1234..5678'));\n * ```\n */\nexport function createNoopSigner<TAddress extends string = string>(address: Address<TAddress>): NoopSigner<TAddress> {\n    const out: NoopSigner<TAddress> = {\n        address,\n        signMessages: messages => Promise.resolve(messages.map(() => Object.freeze({}))),\n        signTransactions: transactions => Promise.resolve(transactions.map(() => Object.freeze({}))),\n    };\n\n    return Object.freeze(out);\n}\n","import {\n    SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS,\n    SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING,\n    SolanaError,\n} from '@solana/errors';\nimport { Brand } from '@solana/nominal-types';\nimport { BaseTransactionMessage, TransactionMessageWithFeePayer } from '@solana/transaction-messages';\n\nimport { getSignersFromTransactionMessage, TransactionMessageWithSigners } from './account-signer-meta';\nimport { isTransactionModifyingSigner } from './transaction-modifying-signer';\nimport { isTransactionPartialSigner } from './transaction-partial-signer';\nimport { isTransactionSendingSigner } from './transaction-sending-signer';\n\n/**\n * Defines a transaction message with exactly one {@link TransactionSendingSigner}.\n *\n * This type is used to narrow the type of transaction messages that have been\n * checked to have exactly one sending signer.\n *\n * @example\n * ```ts\n * import { assertIsTransactionMessageWithSingleSendingSigner } from '@solana/signers';\n *\n * assertIsTransactionMessageWithSingleSendingSigner(transactionMessage);\n * transactionMessage satisfies TransactionMessageWithSingleSendingSigner;\n * ```\n *\n * @see {@link isTransactionMessageWithSingleSendingSigner}\n * @see {@link assertIsTransactionMessageWithSingleSendingSigner}\n */\nexport type TransactionMessageWithSingleSendingSigner = Brand<\n    TransactionMessageWithSigners,\n    'TransactionMessageWithSingleSendingSigner'\n>;\n\n/**\n * Checks whether the provided transaction has exactly one {@link TransactionSendingSigner}.\n *\n * This can be useful when using {@link signAndSendTransactionMessageWithSigners} to provide\n * a fallback strategy in case the transaction message cannot be send using this function.\n *\n * @typeParam TTransactionMessage - The inferred type of the transaction message provided.\n *\n * @example\n * ```ts\n * import {\n *     isTransactionMessageWithSingleSendingSigner,\n *     signAndSendTransactionMessageWithSigners,\n *     signTransactionMessageWithSigners,\n * } from '@solana/signers';\n * import { getBase64EncodedWireTransaction } from '@solana/transactions';\n *\n * let transactionSignature: SignatureBytes;\n * if (isTransactionMessageWithSingleSendingSigner(transactionMessage)) {\n *     transactionSignature = await signAndSendTransactionMessageWithSigners(transactionMessage);\n * } else {\n *     const signedTransaction = await signTransactionMessageWithSigners(transactionMessage);\n *     const encodedTransaction = getBase64EncodedWireTransaction(signedTransaction);\n *     transactionSignature = await rpc.sendTransaction(encodedTransaction).send();\n * }\n * ```\n *\n * @see {@link signAndSendTransactionMessageWithSigners}\n * @see {@link assertIsTransactionMessageWithSingleSendingSigner}\n */\nexport function isTransactionMessageWithSingleSendingSigner<\n    TTransactionMessage extends BaseTransactionMessage & TransactionMessageWithFeePayer,\n>(transaction: TTransactionMessage): transaction is TransactionMessageWithSingleSendingSigner & TTransactionMessage {\n    try {\n        assertIsTransactionMessageWithSingleSendingSigner(transaction);\n        return true;\n    } catch {\n        return false;\n    }\n}\n\n/**\n * Asserts that the provided transaction message has exactly one {@link TransactionSendingSigner}.\n *\n * This can be useful when using the {@link signAndSendTransactionMessageWithSigners} function\n * to ensure it will be able to select the correct signer to send the transaction.\n *\n * @typeParam TTransactionMessage - The inferred type of the transaction message provided.\n *\n * @example\n * ```ts\n * import {\n *     assertIsTransactionMessageWithSingleSendingSigner,\n *     signAndSendTransactionMessageWithSigners\n * } from '@solana/signers';\n *\n * assertIsTransactionMessageWithSingleSendingSigner(transactionMessage);\n * const transactionSignature = await signAndSendTransactionMessageWithSigners(transactionMessage);\n * ```\n *\n * @see {@link signAndSendTransactionMessageWithSigners}\n * @see {@link isTransactionMessageWithSingleSendingSigner}\n */\nexport function assertIsTransactionMessageWithSingleSendingSigner<\n    TTransactionMessage extends BaseTransactionMessage & TransactionMessageWithFeePayer,\n>(\n    transaction: TTransactionMessage,\n): asserts transaction is TransactionMessageWithSingleSendingSigner & TTransactionMessage {\n    const signers = getSignersFromTransactionMessage(transaction);\n    const sendingSigners = signers.filter(isTransactionSendingSigner);\n\n    if (sendingSigners.length === 0) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING);\n    }\n\n    // When identifying if there are multiple sending signers, we only need to check for\n    // sending signers that do not implement other transaction signer interfaces as\n    // they will be used as these other signer interfaces in case of a conflict.\n    const sendingOnlySigners = sendingSigners.filter(\n        signer => !isTransactionPartialSigner(signer) && !isTransactionModifyingSigner(signer),\n    );\n\n    if (sendingOnlySigners.length > 1) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS);\n    }\n}\n","import { SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING, SolanaError } from '@solana/errors';\nimport { SignatureBytes } from '@solana/keys';\nimport { BaseTransactionMessage, TransactionMessageWithFeePayer } from '@solana/transaction-messages';\nimport {\n    assertIsFullySignedTransaction,\n    compileTransaction,\n    SendableTransaction,\n    Transaction,\n    TransactionWithinSizeLimit,\n    TransactionWithLifetime,\n} from '@solana/transactions';\n\nimport { getSignersFromTransactionMessage, TransactionMessageWithSigners } from './account-signer-meta';\nimport { deduplicateSigners } from './deduplicate-signers';\nimport {\n    isTransactionModifyingSigner,\n    TransactionModifyingSigner,\n    TransactionModifyingSignerConfig,\n} from './transaction-modifying-signer';\nimport {\n    isTransactionPartialSigner,\n    TransactionPartialSigner,\n    TransactionPartialSignerConfig,\n} from './transaction-partial-signer';\nimport {\n    isTransactionSendingSigner,\n    TransactionSendingSigner,\n    TransactionSendingSignerConfig,\n} from './transaction-sending-signer';\nimport { isTransactionSigner, TransactionSigner } from './transaction-signer';\nimport { assertIsTransactionMessageWithSingleSendingSigner } from './transaction-with-single-sending-signer';\n\n/**\n * Extracts all {@link TransactionSigner | TransactionSigners} inside the provided\n * transaction message and uses them to return a signed transaction.\n *\n * It first uses all {@link TransactionModifyingSigner | TransactionModifyingSigners} sequentially before\n * using all {@link TransactionPartialSigner | TransactionPartialSigners} in parallel.\n *\n * If a composite signer implements both interfaces, it will be used as a\n * {@link TransactionModifyingSigner} if no other signer implements that interface.\n * Otherwise, it will be used as a {@link TransactionPartialSigner}.\n *\n * @example\n * ```ts\n * const signedTransaction = await partiallySignTransactionMessageWithSigners(transactionMessage);\n * ```\n *\n * It also accepts an optional {@link AbortSignal} that will be propagated to all signers.\n *\n * ```ts\n * const signedTransaction = await partiallySignTransactionMessageWithSigners(transactionMessage, {\n *     abortSignal: myAbortController.signal,\n * });\n * ```\n *\n * @remarks\n * Finally, note that this function ignores {@link TransactionSendingSigner | TransactionSendingSigners}\n * as it does not send the transaction. Check out the {@link signAndSendTransactionMessageWithSigners}\n * function for more details on how to use sending signers.\n *\n * @see {@link signTransactionMessageWithSigners}\n * @see {@link signAndSendTransactionMessageWithSigners}\n */\nexport async function partiallySignTransactionMessageWithSigners(\n    transactionMessage: BaseTransactionMessage & TransactionMessageWithFeePayer & TransactionMessageWithSigners,\n    config?: TransactionPartialSignerConfig,\n): Promise<Transaction & TransactionWithinSizeLimit & TransactionWithLifetime> {\n    const { partialSigners, modifyingSigners } = categorizeTransactionSigners(\n        deduplicateSigners(getSignersFromTransactionMessage(transactionMessage).filter(isTransactionSigner)),\n        { identifySendingSigner: false },\n    );\n\n    return await signModifyingAndPartialTransactionSigners(\n        transactionMessage,\n        modifyingSigners,\n        partialSigners,\n        config,\n    );\n}\n\n/**\n * Extracts all {@link TransactionSigner | TransactionSigners} inside the provided\n * transaction message and uses them to return a signed transaction before asserting\n * that all signatures required by the transaction are present.\n *\n * This function delegates to the {@link partiallySignTransactionMessageWithSigners} function\n * in order to extract signers from the transaction message and sign the transaction.\n *\n * @example\n * ```ts\n * const mySignedTransaction = await signTransactionMessageWithSigners(myTransactionMessage);\n *\n * // With additional config.\n * const mySignedTransaction = await signTransactionMessageWithSigners(myTransactionMessage, {\n *     abortSignal: myAbortController.signal,\n * });\n *\n * // We now know the transaction is fully signed.\n * mySignedTransaction satisfies FullySignedTransaction;\n * ```\n *\n * @see {@link partiallySignTransactionMessageWithSigners}\n * @see {@link signAndSendTransactionMessageWithSigners}\n */\nexport async function signTransactionMessageWithSigners(\n    transactionMessage: BaseTransactionMessage & TransactionMessageWithFeePayer & TransactionMessageWithSigners,\n    config?: TransactionPartialSignerConfig,\n): Promise<SendableTransaction & Transaction & TransactionWithLifetime> {\n    const signedTransaction = await partiallySignTransactionMessageWithSigners(transactionMessage, config);\n    assertIsFullySignedTransaction(signedTransaction);\n    return signedTransaction;\n}\n\n/**\n * Extracts all {@link TransactionSigner | TransactionSigners} inside the provided\n * transaction message and uses them to sign it before sending it immediately to the blockchain.\n *\n * It returns the signature of the sent transaction (i.e. its identifier) as bytes.\n *\n * @example\n * ```ts\n * import { signAndSendTransactionMessageWithSigners } from '@solana/signers';\n *\n * const transactionSignature = await signAndSendTransactionMessageWithSigners(transactionMessage);\n *\n * // With additional config.\n * const transactionSignature = await signAndSendTransactionMessageWithSigners(transactionMessage, {\n *     abortSignal: myAbortController.signal,\n * });\n * ```\n *\n * @remarks\n * Similarly to the {@link partiallySignTransactionMessageWithSigners} function, it first uses all\n * {@link TransactionModifyingSigner | TransactionModifyingSigners} sequentially before using all\n * {@link TransactionPartialSigner | TransactionPartialSigners} in parallel.\n * It then sends the transaction using the {@link TransactionSendingSigner} it identified.\n *\n * Composite transaction signers are treated such that at least one sending signer is used if any.\n * When a {@link TransactionSigner} implements more than one interface, we use it as a:\n *\n * - {@link TransactionSendingSigner}, if no other {@link TransactionSendingSigner} exists.\n * - {@link TransactionModifyingSigner}, if no other {@link TransactionModifyingSigner} exists.\n * - {@link TransactionPartialSigner}, otherwise.\n *\n * The provided transaction must contain exactly one {@link TransactionSendingSigner} inside its account metas.\n * If more than one composite signers implement the {@link TransactionSendingSigner} interface,\n * one of them will be selected as the sending signer. Otherwise, if multiple\n * {@link TransactionSendingSigner | TransactionSendingSigners} must be selected, the function will throw an error.\n *\n * If you'd like to assert that a transaction makes use of exactly one {@link TransactionSendingSigner}\n * _before_ calling this function, you may use the {@link assertIsTransactionMessageWithSingleSendingSigner} function.\n *\n * Alternatively, you may use the {@link isTransactionMessageWithSingleSendingSigner} function to provide a\n * fallback in case the transaction does not contain any sending signer.\n *\n * @see {@link assertIsTransactionMessageWithSingleSendingSigner}\n * @see {@link isTransactionMessageWithSingleSendingSigner}\n * @see {@link partiallySignTransactionMessageWithSigners}\n * @see {@link signTransactionMessageWithSigners}\n *\n */\nexport async function signAndSendTransactionMessageWithSigners(\n    transaction: BaseTransactionMessage & TransactionMessageWithFeePayer & TransactionMessageWithSigners,\n    config?: TransactionSendingSignerConfig,\n): Promise<SignatureBytes> {\n    assertIsTransactionMessageWithSingleSendingSigner(transaction);\n\n    const abortSignal = config?.abortSignal;\n    const { partialSigners, modifyingSigners, sendingSigner } = categorizeTransactionSigners(\n        deduplicateSigners(getSignersFromTransactionMessage(transaction).filter(isTransactionSigner)),\n    );\n\n    abortSignal?.throwIfAborted();\n    const signedTransaction = await signModifyingAndPartialTransactionSigners(\n        transaction,\n        modifyingSigners,\n        partialSigners,\n        config,\n    );\n\n    if (!sendingSigner) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING);\n    }\n\n    abortSignal?.throwIfAborted();\n    const [signature] = await sendingSigner.signAndSendTransactions([signedTransaction], config);\n    abortSignal?.throwIfAborted();\n\n    return signature;\n}\n\n/**\n * Identifies each provided TransactionSigner and categorizes them into their respective types.\n * When a signer implements multiple interface, it will try to used to most powerful interface\n * but fallback to the least powerful interface when necessary.\n * For instance, if a signer implements TransactionSendingSigner and TransactionModifyingSigner,\n * it will be categorized as a TransactionSendingSigner if and only if no other signers implement\n * the TransactionSendingSigner interface.\n */\nfunction categorizeTransactionSigners(\n    signers: readonly TransactionSigner[],\n    config: { identifySendingSigner?: boolean } = {},\n): Readonly<{\n    modifyingSigners: readonly TransactionModifyingSigner[];\n    partialSigners: readonly TransactionPartialSigner[];\n    sendingSigner: TransactionSendingSigner | null;\n}> {\n    // Identify the unique sending signer that should be used.\n    const identifySendingSigner = config.identifySendingSigner ?? true;\n    const sendingSigner = identifySendingSigner ? identifyTransactionSendingSigner(signers) : null;\n\n    // Now, focus on the other signers.\n    // I.e. the modifying or partial signers that are not the identified sending signer.\n    // Note that any other sending only signers will be discarded.\n    const otherSigners = signers.filter(\n        (signer): signer is TransactionModifyingSigner | TransactionPartialSigner =>\n            signer !== sendingSigner && (isTransactionModifyingSigner(signer) || isTransactionPartialSigner(signer)),\n    );\n\n    // Identify the modifying signers from the other signers.\n    const modifyingSigners = identifyTransactionModifyingSigners(otherSigners);\n\n    // Use any remaining signers as partial signers.\n    const partialSigners = otherSigners\n        .filter(isTransactionPartialSigner)\n        .filter(signer => !(modifyingSigners as typeof otherSigners).includes(signer));\n\n    return Object.freeze({ modifyingSigners, partialSigners, sendingSigner });\n}\n\n/** Identifies the best signer to use as a TransactionSendingSigner, if any */\nfunction identifyTransactionSendingSigner(signers: readonly TransactionSigner[]): TransactionSendingSigner | null {\n    // Ensure there are any TransactionSendingSigners in the first place.\n    const sendingSigners = signers.filter(isTransactionSendingSigner);\n    if (sendingSigners.length === 0) return null;\n\n    // Prefer sending signers that do not offer other interfaces.\n    const sendingOnlySigners = sendingSigners.filter(\n        signer => !isTransactionModifyingSigner(signer) && !isTransactionPartialSigner(signer),\n    );\n    if (sendingOnlySigners.length > 0) {\n        return sendingOnlySigners[0];\n    }\n\n    // Otherwise, choose any sending signer.\n    return sendingSigners[0];\n}\n\n/** Identifies the best signers to use as TransactionModifyingSigners, if any */\nfunction identifyTransactionModifyingSigners(\n    signers: readonly (TransactionModifyingSigner | TransactionPartialSigner)[],\n): readonly TransactionModifyingSigner[] {\n    // Ensure there are any TransactionModifyingSigner in the first place.\n    const modifyingSigners = signers.filter(isTransactionModifyingSigner);\n    if (modifyingSigners.length === 0) return [];\n\n    // Prefer modifying signers that do not offer partial signing.\n    const nonPartialSigners = modifyingSigners.filter(signer => !isTransactionPartialSigner(signer));\n    if (nonPartialSigners.length > 0) return nonPartialSigners;\n\n    // Otherwise, choose only one modifying signer (whichever).\n    return [modifyingSigners[0]];\n}\n\n/**\n * Signs a transaction using the provided TransactionModifyingSigners\n * sequentially followed by the TransactionPartialSigners in parallel.\n */\nasync function signModifyingAndPartialTransactionSigners(\n    transactionMessage: BaseTransactionMessage & TransactionMessageWithFeePayer & TransactionMessageWithSigners,\n    modifyingSigners: readonly TransactionModifyingSigner[] = [],\n    partialSigners: readonly TransactionPartialSigner[] = [],\n    config?: TransactionModifyingSignerConfig,\n): Promise<Transaction & TransactionWithinSizeLimit & TransactionWithLifetime> {\n    // serialize the transaction\n    const transaction = compileTransaction(transactionMessage);\n\n    // Handle modifying signers sequentially.\n    const modifiedTransaction = (await modifyingSigners.reduce(\n        async (transaction, modifyingSigner) => {\n            config?.abortSignal?.throwIfAborted();\n            const [tx] = await modifyingSigner.modifyAndSignTransactions([await transaction], config);\n            return Object.freeze(tx);\n        },\n        Promise.resolve(transaction) as Promise<Readonly<Transaction & TransactionWithLifetime>>,\n    )) as Transaction & TransactionWithinSizeLimit & TransactionWithLifetime;\n\n    // Handle partial signers in parallel.\n    config?.abortSignal?.throwIfAborted();\n    const signatureDictionaries = await Promise.all(\n        partialSigners.map(async partialSigner => {\n            const [signatures] = await partialSigner.signTransactions([modifiedTransaction], config);\n            return signatures;\n        }),\n    );\n\n    return Object.freeze({\n        ...modifiedTransaction,\n        signatures: Object.freeze(\n            signatureDictionaries.reduce((signatures, signatureDictionary) => {\n                return { ...signatures, ...signatureDictionary };\n            }, modifiedTransaction.signatures ?? {}),\n        ),\n    });\n}\n","import { TextEncoder } from '@solana/text-encoding-impl';\n\nimport { SignatureDictionary } from './types';\n\n/**\n * Defines a message that needs signing and its current set of signatures if any.\n *\n * This interface allows {@link MessageModifyingSigner | MessageModifyingSigners}\n * to decide on whether or not they should modify the provided message depending\n * on whether or not signatures already exist for such message.\n *\n * It also helps create a more consistent API by providing a structure analogous\n * to transactions which also keep track of their {@link SignatureDictionary}.\n *\n * @example\n * ```ts\n * import { createSignableMessage } from '@solana/signers';\n *\n * const message = createSignableMessage(new Uint8Array([1, 2, 3]));\n * message.content; // The content of the message as bytes.\n * message.signatures; // The current set of signatures for this message.\n * ```\n *\n * @see {@link createSignableMessage}\n */\nexport type SignableMessage = Readonly<{\n    content: Uint8Array;\n    signatures: SignatureDictionary;\n}>;\n\n/**\n * Creates a {@link SignableMessage} from a `Uint8Array` or a UTF-8 string.\n *\n * It optionally accepts a signature dictionary if the message already contains signatures.\n *\n * @example\n * ```ts\n * const message = createSignableMessage(new Uint8Array([1, 2, 3]));\n * const messageFromText = createSignableMessage('Hello world!');\n * const messageWithSignatures = createSignableMessage('Hello world!', {\n *     [address('1234..5678')]: new Uint8Array([1, 2, 3]) as SignatureBytes,\n * });\n * ```\n */\nexport function createSignableMessage(\n    content: Uint8Array | string,\n    signatures: SignatureDictionary = {},\n): SignableMessage {\n    return Object.freeze({\n        content: typeof content === 'string' ? new TextEncoder().encode(content) : content,\n        signatures: Object.freeze({ ...signatures }),\n    });\n}\n","/**\n * Forked from https://github.com/digitalloggers/race-as-promised/tree/master\n *\n * Authored by Brian Kim:\n * https://github.com/nodejs/node/issues/17469#issuecomment-685216777\n *\n * Adapted to module structure.\n *\n * This is free and unencumbered software released into the public domain.\n *\n * Anyone is free to copy, modify, publish, use, compile, sell, or\n * distribute this software, either in source code form or as a compiled\n * binary, for any purpose, commercial or non-commercial, and by any\n * means.\n *\n * In jurisdictions that recognize copyright laws, the author or authors\n * of this software dedicate any and all copyright interest in the\n * software to the public domain. We make this dedication for the benefit\n * of the public at large and to the detriment of our heirs and\n * successors. We intend this dedication to be an overt act of\n * relinquishment in perpetuity of all present and future rights to this\n * software under copyright law.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR\n * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n *\n * For more information, please refer to <http://unlicense.org/>\n */\n\ntype Deferred = Readonly<{\n    reject: (reason?: unknown) => void;\n    resolve: (value: unknown) => void;\n}>;\n\nfunction isObject(value: unknown): value is object {\n    return value !== null && (typeof value === 'object' || typeof value === 'function');\n}\n\nfunction addRaceContender(contender: object) {\n    const deferreds = new Set<Deferred>();\n    const record = { deferreds, settled: false };\n\n    // This call to `then` happens once for the lifetime of the value.\n    Promise.resolve(contender).then(\n        value => {\n            for (const { resolve } of deferreds) {\n                resolve(value);\n            }\n\n            deferreds.clear();\n            record.settled = true;\n        },\n        err => {\n            for (const { reject } of deferreds) {\n                reject(err);\n            }\n\n            deferreds.clear();\n            record.settled = true;\n        },\n    );\n    return record;\n}\n\n// Keys are the values passed to race, values are a record of data containing a\n// set of deferreds and whether the value has settled.\nconst wm = new WeakMap<object, { deferreds: Set<Deferred>; settled: boolean }>();\n/**\n * An implementation of [`Promise.race`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race)\n * that causes all of the losing promises to settle. This allows them to be released and garbage\n * collected, preventing memory leaks.\n *\n * Read more here: https://github.com/nodejs/node/issues/17469\n */\nexport async function safeRace<T extends readonly unknown[] | []>(contenders: T): Promise<Awaited<T[number]>> {\n    let deferred: Deferred;\n    const result = new Promise((resolve, reject) => {\n        deferred = { reject, resolve };\n        for (const contender of contenders) {\n            if (!isObject(contender)) {\n                // If the contender is a primitive, attempting to use it as a key in the\n                // weakmap would throw an error. Luckily, it is safe to call\n                // `Promise.resolve(contender).then` on a primitive value multiple times\n                // because the promise fulfills immediately.\n                Promise.resolve(contender).then(resolve, reject);\n                continue;\n            }\n\n            let record = wm.get(contender);\n            if (record === undefined) {\n                record = addRaceContender(contender);\n                record.deferreds.add(deferred);\n                wm.set(contender, record);\n            } else if (record.settled) {\n                // If the value has settled, it is safe to call\n                // `Promise.resolve(contender).then` on it.\n                Promise.resolve(contender).then(resolve, reject);\n            } else {\n                record.deferreds.add(deferred);\n            }\n        }\n    });\n\n    // The finally callback executes when any value settles, preventing any of\n    // the unresolved values from retaining a reference to the resolved value.\n    return await (result.finally(() => {\n        for (const contender of contenders) {\n            if (isObject(contender)) {\n                const record = wm.get(contender)!;\n                record.deferreds.delete(deferred);\n            }\n        }\n    }) as Promise<Awaited<T[number]>>);\n}\n","import { safeRace } from './race';\n\n/**\n * Returns a new promise that will reject if the abort signal fires before the original promise\n * settles. Resolves or rejects with the value of the original promise otherwise.\n *\n * @example\n * ```ts\n * const result = await getAbortablePromise(\n *     // Resolves or rejects when `fetch` settles.\n *     fetch('https://example.com/json').then(r => r.json()),\n *     // ...unless it takes longer than 5 seconds, after which the `AbortSignal` is triggered.\n *     AbortSignal.timeout(5000),\n * );\n * ```\n */\nexport function getAbortablePromise<T>(promise: Promise<T>, abortSignal?: AbortSignal): Promise<T> {\n    if (!abortSignal) {\n        return promise;\n    } else {\n        return safeRace([\n            // This promise only ever rejects if the signal is aborted. Otherwise it idles forever.\n            // It's important that this come before the input promise; in the event of an abort, we\n            // want to throw even if the input promise's result is ready\n            new Promise<never>((_, reject) => {\n                if (abortSignal.aborted) {\n                    // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n                    reject(abortSignal.reason);\n                } else {\n                    abortSignal.addEventListener('abort', function () {\n                        // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n                        reject(this.reason);\n                    });\n                }\n            }),\n            promise,\n        ]);\n    }\n}\n","/**\n * An implementation of the Rust `Option<T>` type in JavaScript.\n *\n * In Rust, optional values are represented using `Option<T>`, which can be either:\n * - `Some(T)`, indicating a present value.\n * - `None`, indicating the absence of a value.\n *\n * In JavaScript, this is typically represented as `T | null`. However, this approach fails with nested options.\n * For example, `Option<Option<T>>` in Rust would translate to `T | null | null` in JavaScript, which is equivalent to `T | null`.\n * This means there is no way to differentiate between `Some(None)` and `None`, making nested options impossible.\n *\n * This `Option` type helps solve this by mirroring Rusts `Option<T>` type.\n *\n * ```ts\n * type Option<T> = Some<T> | None;\n * type Some<T> = { __option: 'Some'; value: T };\n * type None = { __option: 'None' };\n * ```\n *\n * @typeParam T - The type of the contained value.\n *\n * @example\n * Here's how you can create `Option` values.\n *\n * To improve developer experience, helper functions are available.\n * TypeScript can infer the type of `T` or it can be explicitly provided.\n *\n * ```ts\n * // Create an option with a value.\n * some('Hello World');\n * some<number | string>(123);\n *\n * // Create an empty option.\n * none();\n * none<number | string>();\n * ```\n *\n * @see {@link Some}\n * @see {@link None}\n * @see {@link some}\n * @see {@link none}\n */\nexport type Option<T> = None | Some<T>;\n\n/**\n * A flexible type that allows working with {@link Option} values or nullable values.\n *\n * It defines a looser type that can be used when encoding {@link Option | Options}.\n * This allows us to pass `null` or the nested value directly whilst still\n * supporting the Option type for use-cases that need more type safety.\n *\n * @typeParam T - The type of the contained value.\n *\n * @example\n * Accepting both `Option<T>` and `T | null` as input.\n * ```ts\n * function double(value: OptionOrNullable<number>) {\n *   const option = isOption(value) ? value : wrapNullable(value);\n *   return isSome(option) ? option.value * 2 : 'No value';\n * }\n *\n * double(42);       // 84\n * double(some(21)); // 42\n * double(none());   // \"No value\"\n * double(null);     // \"No value\"\n * ```\n *\n * @see {@link Option}\n * @see {@link isOption}\n * @see {@link wrapNullable}\n */\nexport type OptionOrNullable<T> = Option<T> | T | null;\n\n/**\n * Represents an {@link Option} that contains a value.\n *\n * This type mirrors Rusts `Some(T)`, indicating that a value is present.\n *\n * For more details, see {@link Option}.\n *\n * @typeParam T - The type of the contained value.\n *\n * @example\n * Creating a `Some` value.\n * ```ts\n * const value = some(42);\n * isSome(value); // true\n * isNone(value); // false\n * ```\n *\n * @see {@link Option}\n * @see {@link some}\n * @see {@link isSome}\n */\nexport type Some<T> = Readonly<{ __option: 'Some'; value: T }>;\n\n/**\n * Represents an {@link Option} that contains no value.\n *\n * This type mirrors Rusts `None`, indicating the absence of a value.\n *\n * For more details, see {@link Option}.\n *\n * @example\n * Creating a `None` value.\n * ```ts\n * const empty = none();\n * isNone(empty); // true\n * isSome(empty); // false\n * ```\n *\n * @see {@link Option}\n * @see {@link none}\n * @see {@link isNone}\n */\nexport type None = Readonly<{ __option: 'None' }>;\n\n/**\n * Creates a new {@link Option} that contains a value.\n *\n * This function explicitly wraps a value in an {@link Option} type.\n *\n * @typeParam T - The type of the contained value.\n *\n * @param value - The value to wrap in an {@link Option}.\n * @returns An {@link Option} containing the provided value.\n *\n * @example\n * Wrapping a value in an `Option`.\n * ```ts\n * const option = some('Hello');\n * option.value;     // \"Hello\"\n * isOption(option); // true\n * isSome(option);   // true\n * isNone(option);   // false\n * ```\n *\n * @see {@link Option}\n * @see {@link Some}\n */\nexport const some = <T>(value: T): Option<T> => ({ __option: 'Some', value });\n\n/**\n * Creates a new {@link Option} that contains no value.\n *\n * This function explicitly represents an absent value.\n *\n * @typeParam T - The type of the expected absent value.\n *\n * @returns An {@link Option} containing no value.\n *\n * @example\n * Creating an empty `Option`.\n * ```ts\n * const empty = none<number>();\n * isOption(empty); // true\n * isSome(empty);   // false\n * isNone(empty);   // true\n * ```\n *\n * @see {@link Option}\n * @see {@link None}\n */\nexport const none = <T>(): Option<T> => ({ __option: 'None' });\n\n/**\n * Checks whether the given value is an {@link Option}.\n *\n * This function determines whether an input follows the `Option<T>` structure.\n *\n * @typeParam T - The type of the contained value.\n *\n * @param input - The value to check.\n * @returns `true` if the value is an {@link Option}, `false` otherwise.\n *\n * @example\n * Checking for `Option` values.\n * ```ts\n * isOption(some(42));        // true\n * isOption(none());          // true\n * isOption(42);              // false\n * isOption(null);            // false\n * isOption(\"anything else\"); // false\n * ```\n *\n * @see {@link Option}\n */\nexport const isOption = <T = unknown>(input: unknown): input is Option<T> =>\n    !!(\n        input &&\n        typeof input === 'object' &&\n        '__option' in input &&\n        ((input.__option === 'Some' && 'value' in input) || input.__option === 'None')\n    );\n\n/**\n * Checks whether the given {@link Option} contains a value.\n *\n * This function acts as a type guard, ensuring the value is a {@link Some}.\n *\n * @typeParam T - The type of the contained value.\n *\n * @param option - The {@link Option} to check.\n * @returns `true` if the option is a {@link Some}, `false` otherwise.\n *\n * @example\n * Checking for `Some` values.\n * ```ts\n * isSome(some(42)); // true\n * isSome(none());   // false\n * ```\n *\n * @see {@link Option}\n * @see {@link Some}\n */\nexport const isSome = <T>(option: Option<T>): option is Some<T> => option.__option === 'Some';\n\n/**\n * Checks whether the given {@link Option} contains no value.\n *\n * This function acts as a type guard, ensuring the value is a {@link None}.\n *\n * @typeParam T - The type of the expected value.\n *\n * @param option - The {@link Option} to check.\n * @returns `true` if the option is a {@link None}, `false` otherwise.\n *\n * @example\n * Checking for `None` values.\n * ```ts\n * isNone(some(42)); // false\n * isNone(none());   // true\n * ```\n *\n * @see {@link Option}\n * @see {@link None}\n */\nexport const isNone = <T>(option: Option<T>): option is None => option.__option === 'None';\n","import { isSome, none, Option, some } from './option';\n\n/**\n * Unwraps the value of an {@link Option}, returning its contained value or a fallback.\n *\n * This function extracts the value `T` from an `Option<T>` type.\n * - If the option is {@link Some}, it returns the contained value `T`.\n * - If the option is {@link None}, it returns the fallback value `U`, which defaults to `null`.\n *\n * @typeParam T - The type of the contained value.\n * @typeParam U - The type of the fallback value (defaults to `null`).\n *\n * @param option - The {@link Option} to unwrap.\n * @param fallback - A function that provides a fallback value if the option is {@link None}.\n * @returns The contained value if {@link Some}, otherwise the fallback value.\n *\n * @example\n * Unwrapping an `Option` with no fallback.\n * ```ts\n * unwrapOption(some('Hello World')); // \"Hello World\"\n * unwrapOption(none());              // null\n * ```\n *\n * @example\n * Providing a custom fallback value.\n * ```ts\n * unwrapOption(some('Hello World'), () => 'Default'); // \"Hello World\"\n * unwrapOption(none(), () => 'Default');              // \"Default\"\n * ```\n *\n * @see {@link Option}\n * @see {@link Some}\n * @see {@link None}\n */\nexport function unwrapOption<T>(option: Option<T>): T | null;\nexport function unwrapOption<T, U>(option: Option<T>, fallback: () => U): T | U;\nexport function unwrapOption<T, U = null>(option: Option<T>, fallback?: () => U): T | U {\n    if (isSome(option)) return option.value;\n    return fallback ? fallback() : (null as U);\n}\n\n/**\n * Wraps a nullable value into an {@link Option}.\n *\n * - If the input value is `null`, this function returns {@link None}.\n * - Otherwise, it wraps the value in {@link Some}.\n *\n * @typeParam T - The type of the contained value.\n *\n * @param nullable - The nullable value to wrap.\n * @returns An {@link Option} wrapping the value.\n *\n * @example\n * Wrapping nullable values.\n * ```ts\n * wrapNullable('Hello World'); // Option<string> (Some)\n * wrapNullable<string>(null);  // Option<string> (None)\n * ```\n *\n * @see {@link Option}\n * @see {@link Some}\n * @see {@link None}\n */\nexport const wrapNullable = <T>(nullable: T | null): Option<T> => (nullable !== null ? some(nullable) : none<T>());\n","import {\n    assertIsFixedSize,\n    Codec,\n    combineCodec,\n    containsBytes,\n    Decoder,\n    Encoder,\n    fixDecoderSize,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    fixEncoderSize,\n    ReadonlyUint8Array,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    getBooleanDecoder,\n    getBooleanEncoder,\n    getConstantDecoder,\n    getConstantEncoder,\n    getTupleDecoder,\n    getTupleEncoder,\n    getUnionDecoder,\n    getUnionEncoder,\n    getUnitDecoder,\n    getUnitEncoder,\n} from '@solana/codecs-data-structures';\nimport {\n    FixedSizeNumberCodec,\n    FixedSizeNumberDecoder,\n    FixedSizeNumberEncoder,\n    getU8Decoder,\n    getU8Encoder,\n    NumberCodec,\n    NumberDecoder,\n    NumberEncoder,\n} from '@solana/codecs-numbers';\n\nimport { isOption, isSome, None, none, Option, OptionOrNullable, Some, some } from './option';\nimport { wrapNullable } from './unwrap-option';\n\n/**\n * Defines the configuration options for {@link Option} codecs.\n *\n * The `getOptionCodec` function behaves similarly to {@link getNullableCodec}\n * but encodes `Option<T>` types instead of `T | null` types.\n *\n * This configuration controls how {@link None} values are encoded and how presence\n * is determined when decoding.\n *\n * @typeParam TPrefix - A number codec, encoder, or decoder used as the presence prefix.\n *\n * @see {@link getOptionEncoder}\n * @see {@link getOptionDecoder}\n * @see {@link getOptionCodec}\n */\nexport type OptionCodecConfig<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * Specifies how {@link None} values are represented in the encoded data.\n     *\n     * - By default, {@link None} values are omitted from encoding.\n     * - `'zeroes'`: The bytes allocated for the value are filled with zeroes. This requires a fixed-size codec for the item.\n     * - Custom byte array: {@link None} values are replaced with a predefined byte sequence. This results in a variable-size codec.\n     *\n     * @defaultValue No explicit `noneValue` is used; {@link None} values are omitted.\n     */\n    noneValue?: ReadonlyUint8Array | 'zeroes';\n\n    /**\n     * The presence prefix used to distinguish between {@link None} and present values.\n     *\n     * - By default, a `u8` prefix is used (`0 = None`, `1 = Some`).\n     * - Custom number codec: Allows defining a different number size for the prefix.\n     * - `null`: No prefix is used; `noneValue` (if provided) determines {@link None}.\n     *   If no `noneValue` is set, {@link None} is identified by the absence of bytes.\n     *\n     * @defaultValue `u8` prefix.\n     */\n    prefix?: TPrefix | null;\n};\n\n/**\n * Returns an encoder for optional values using the {@link Option} type.\n *\n * This encoder serializes an {@link OptionOrNullable} value using a configurable approach:\n * - By default, a `u8` prefix is used (`0 = None`, `1 = Some`). This can be customized or disabled.\n * - If `noneValue: 'zeroes'` is set, {@link None} values are encoded as zeroes.\n * - If `noneValue` is a byte array, {@link None} values are replaced with the provided constant.\n *\n * Unlike {@link getNullableEncoder}, this encoder accepts both {@link Option} and {@link Nullable} values.\n *\n * For more details, see {@link getOptionCodec}.\n *\n * @typeParam TFrom - The type of the main value being encoded.\n *\n * @param item - The encoder for the value that may be present.\n * @param config - Configuration options for encoding optional values.\n * @returns A `FixedSizeEncoder` or `VariableSizeEncoder` for encoding option values.\n *\n * @example\n * Encoding an optional string.\n * ```ts\n * const stringCodec = addCodecSizePrefix(getUtf8Codec(), getU32Codec());\n * const encoder = getOptionEncoder(stringCodec);\n *\n * encoder.encode(some('Hi'));\n * encoder.encode('Hi');\n * // 0x01020000004869\n * //   | |       -- utf8 string content (\"Hi\").\n * //   | -- u32 string prefix (2 characters).\n * //   -- 1-byte prefix (Some).\n *\n * encoder.encode(none());\n * encoder.encode(null);\n * // 0x00\n * //   -- 1-byte prefix (None).\n * ```\n *\n * @see {@link getOptionCodec}\n */\nexport function getOptionEncoder<TFrom, TSize extends number>(\n    item: FixedSizeEncoder<TFrom, TSize>,\n    config: OptionCodecConfig<NumberEncoder> & { noneValue: 'zeroes'; prefix: null },\n): FixedSizeEncoder<OptionOrNullable<TFrom>, TSize>;\nexport function getOptionEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: OptionCodecConfig<FixedSizeNumberEncoder> & { noneValue: 'zeroes' },\n): FixedSizeEncoder<OptionOrNullable<TFrom>>;\nexport function getOptionEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: OptionCodecConfig<NumberEncoder> & { noneValue: 'zeroes' },\n): VariableSizeEncoder<OptionOrNullable<TFrom>>;\nexport function getOptionEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config?: OptionCodecConfig<NumberEncoder> & { noneValue?: ReadonlyUint8Array },\n): VariableSizeEncoder<OptionOrNullable<TFrom>>;\nexport function getOptionEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: OptionCodecConfig<NumberEncoder> = {},\n): Encoder<OptionOrNullable<TFrom>> {\n    const prefix = (() => {\n        if (config.prefix === null) {\n            return transformEncoder(getUnitEncoder(), (_boolean: boolean) => undefined);\n        }\n        return getBooleanEncoder({ size: config.prefix ?? getU8Encoder() });\n    })();\n    const noneValue = (() => {\n        if (config.noneValue === 'zeroes') {\n            assertIsFixedSize(item);\n            return fixEncoderSize(getUnitEncoder(), item.fixedSize);\n        }\n        if (!config.noneValue) {\n            return getUnitEncoder();\n        }\n        return getConstantEncoder(config.noneValue);\n    })();\n\n    return getUnionEncoder(\n        [\n            transformEncoder(getTupleEncoder([prefix, noneValue]), (_value: None | null): [boolean, void] => [\n                false,\n                undefined,\n            ]),\n            transformEncoder(getTupleEncoder([prefix, item]), (value: Some<TFrom> | TFrom): [boolean, TFrom] => [\n                true,\n                isOption(value) && isSome(value) ? value.value : value,\n            ]),\n        ],\n        variant => {\n            const option = isOption<TFrom>(variant) ? variant : wrapNullable(variant);\n            return Number(isSome(option));\n        },\n    );\n}\n\n/**\n * Returns a decoder for optional values using the {@link Option} type.\n *\n * This decoder deserializes an `Option<T>` value using a configurable approach:\n * - By default, a `u8` prefix is used (`0 = None`, `1 = Some`). This can be customized or disabled.\n * - If `noneValue: 'zeroes'` is set, `None` values are identified by zeroes.\n * - If `noneValue` is a byte array, `None` values match the provided constant.\n *\n * Unlike {@link getNullableDecoder}, this decoder always outputs an {@link Option} type.\n *\n * For more details, see {@link getOptionCodec}.\n *\n * @typeParam TTo - The type of the main value being decoded.\n *\n * @param item - The decoder for the value that may be present.\n * @param config - Configuration options for decoding optional values.\n * @returns A `FixedSizeDecoder` or `VariableSizeDecoder` for decoding option values.\n *\n * @example\n * Decoding an optional string with a size prefix.\n * ```ts\n * const stringCodec = addCodecSizePrefix(getUtf8Codec(), getU32Codec());\n * const decoder = getOptionDecoder(stringCodec);\n *\n * decoder.decode(new Uint8Array([0x01, 0x02, 0x00, 0x00, 0x00, 0x48, 0x69]));\n * // some('Hi')\n *\n * decoder.decode(new Uint8Array([0x00]));\n * // none()\n * ```\n *\n * @see {@link getOptionCodec}\n */\nexport function getOptionDecoder<TTo, TSize extends number>(\n    item: FixedSizeDecoder<TTo, TSize>,\n    config: OptionCodecConfig<NumberDecoder> & { noneValue: 'zeroes'; prefix: null },\n): FixedSizeDecoder<Option<TTo>, TSize>;\nexport function getOptionDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: OptionCodecConfig<FixedSizeNumberDecoder> & { noneValue: 'zeroes' },\n): FixedSizeDecoder<Option<TTo>>;\nexport function getOptionDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: OptionCodecConfig<NumberDecoder> & { noneValue: 'zeroes' },\n): VariableSizeDecoder<Option<TTo>>;\nexport function getOptionDecoder<TTo>(\n    item: Decoder<TTo>,\n    config?: OptionCodecConfig<NumberDecoder> & { noneValue?: ReadonlyUint8Array },\n): VariableSizeDecoder<Option<TTo>>;\nexport function getOptionDecoder<TTo>(\n    item: Decoder<TTo>,\n    config: OptionCodecConfig<NumberDecoder> = {},\n): Decoder<Option<TTo>> {\n    const prefix = (() => {\n        if (config.prefix === null) {\n            return transformDecoder(getUnitDecoder(), () => false);\n        }\n        return getBooleanDecoder({ size: config.prefix ?? getU8Decoder() });\n    })();\n    const noneValue = (() => {\n        if (config.noneValue === 'zeroes') {\n            assertIsFixedSize(item);\n            return fixDecoderSize(getUnitDecoder(), item.fixedSize);\n        }\n        if (!config.noneValue) {\n            return getUnitDecoder();\n        }\n        return getConstantDecoder(config.noneValue);\n    })();\n\n    return getUnionDecoder(\n        [\n            transformDecoder(getTupleDecoder([prefix, noneValue]), () => none<TTo>()),\n            transformDecoder(getTupleDecoder([prefix, item]), ([, value]) => some(value)),\n        ],\n        (bytes, offset) => {\n            if (config.prefix === null && !config.noneValue) {\n                return Number(offset < bytes.length);\n            }\n            if (config.prefix === null && config.noneValue != null) {\n                const zeroValue =\n                    config.noneValue === 'zeroes' ? new Uint8Array(noneValue.fixedSize).fill(0) : config.noneValue;\n                return containsBytes(bytes, zeroValue, offset) ? 0 : 1;\n            }\n            return Number(prefix.read(bytes, offset)[0]);\n        },\n    );\n}\n\n/**\n * Returns a codec for encoding and decoding optional values using the {@link Option} type.\n *\n * This codec serializes and deserializes `Option<T>` values using a configurable approach:\n * - By default, a `u8` prefix is used (`0 = None`, `1 = Some`).\n * - If `noneValue: 'zeroes'` is set, `None` values are encoded/decoded as zeroes.\n * - If `noneValue` is a byte array, `None` values are represented by the provided constant.\n * - If `prefix: null` is set, the codec determines `None` values solely from `noneValue` or the presence of bytes.\n *\n * For more details on the configuration options, see {@link OptionCodecConfig}.\n *\n * Note that this behaves similarly to {@link getNullableCodec}, except it\n * encodes {@link OptionOrNullable} values and decodes {@link Option} values.\n *\n * @typeParam TFrom - The type of the main value being encoded.\n * @typeParam TTo - The type of the main value being decoded.\n *\n * @param item - The codec for the value that may be present.\n * @param config - Configuration options for encoding and decoding option values.\n * @returns A `FixedSizeCodec` or `VariableSizeCodec` for encoding and decoding option values.\n *\n * @example\n * Encoding and decoding an optional string with a size prefix.\n * ```ts\n * const stringCodec = addCodecSizePrefix(getUtf8Codec(), getU32Codec());\n * const codec = getOptionCodec(stringCodec);\n *\n * const someBytes = codec.encode(some('Hi'));\n * // 0x01020000004869\n * //   | |       -- utf8 string content (\"Hi\").\n * //   | -- u32 string prefix (2 characters).\n * //   -- 1-byte prefix (Some).\n *\n * const noneBytes = codec.encode(none());\n * // 0x00\n * //   -- 1-byte prefix (None).\n *\n * codec.decode(someBytes); // some('Hi')\n * codec.decode(noneBytes); // none()\n * ```\n *\n * @example\n * Encoding nullable values.\n * ```ts\n * const stringCodec = addCodecSizePrefix(getUtf8Codec(), getU32Codec());\n * const codec = getOptionCodec(stringCodec);\n *\n * const someBytes = codec.encode('Hi'); // 0x01020000004869\n * const noneBytes = codec.encode(null); // 0x00\n *\n * codec.decode(someBytes); // some('Hi')\n * codec.decode(noneBytes); // none()\n * ```\n *\n * @example\n * Encoding and decoding an optional number with a fixed size.\n * ```ts\n * const codec = getOptionCodec(getU16Codec(), { noneValue: 'zeroes' });\n *\n * const someBytes = codec.encode(some(42)); // 0x012a00\n * const noneBytes = codec.encode(none());   // 0x000000\n *\n * codec.decode(someBytes); // some(42)\n * codec.decode(noneBytes); // none()\n * ```\n *\n * @example\n * Encoding and decoding {@link None} values with a custom byte sequence and no prefix.\n * ```ts\n * const codec = getOptionCodec(getU16Codec(), {\n *   noneValue: new Uint8Array([0xff, 0xff]),\n *   prefix: null,\n * });\n *\n * const someBytes = codec.encode(some(42)); // 0x2a00\n * const noneBytes = codec.encode(none());   // 0xffff\n *\n * codec.decode(someBytes); // some(42)\n * codec.decode(noneBytes); // none()\n * ```\n *\n * @example\n * Identifying {@link None} values by the absence of bytes.\n * ```ts\n * const codec = getOptionCodec(getU16Codec(), { prefix: null });\n *\n * const someBytes = codec.encode(some(42)); // 0x2a00\n * const noneBytes = codec.encode(none());   // new Uint8Array(0)\n *\n * codec.decode(someBytes); // some(42)\n * codec.decode(noneBytes); // none()\n * ```\n *\n * @remarks\n * Separate {@link getOptionEncoder} and {@link getOptionDecoder} functions are available.\n *\n * ```ts\n * const bytes = getOptionEncoder(getU32Encoder()).encode(some(42));\n * const value = getOptionDecoder(getU32Decoder()).decode(bytes);\n * ```\n *\n * @see {@link getOptionEncoder}\n * @see {@link getOptionDecoder}\n */\nexport function getOptionCodec<TFrom, TTo extends TFrom, TSize extends number>(\n    item: FixedSizeCodec<TFrom, TTo, TSize>,\n    config: OptionCodecConfig<NumberCodec> & { noneValue: 'zeroes'; prefix: null },\n): FixedSizeCodec<OptionOrNullable<TFrom>, Option<TTo>, TSize>;\nexport function getOptionCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: OptionCodecConfig<FixedSizeNumberCodec> & { noneValue: 'zeroes' },\n): FixedSizeCodec<OptionOrNullable<TFrom>, Option<TTo>>;\nexport function getOptionCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: OptionCodecConfig<NumberCodec> & { noneValue: 'zeroes' },\n): VariableSizeCodec<OptionOrNullable<TFrom>, Option<TTo>>;\nexport function getOptionCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config?: OptionCodecConfig<NumberCodec> & { noneValue?: ReadonlyUint8Array },\n): VariableSizeCodec<OptionOrNullable<TFrom>, Option<TTo>>;\nexport function getOptionCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: OptionCodecConfig<NumberCodec> = {},\n): Codec<OptionOrNullable<TFrom>, Option<TTo>> {\n    type ConfigCast = OptionCodecConfig<NumberCodec> & { noneValue?: ReadonlyUint8Array };\n    return combineCodec(\n        getOptionEncoder<TFrom>(item, config as ConfigCast),\n        getOptionDecoder<TTo>(item, config as ConfigCast),\n    );\n}\n","import { isOption, isSome, None, Some } from './option';\n\n/**\n * Defines types that should not be recursively unwrapped.\n *\n * These types are preserved as-is when using {@link unwrapOptionRecursively}.\n *\n * @see {@link unwrapOptionRecursively}\n */\ntype UnUnwrappables =\n    | Date\n    | Int8Array\n    | Int16Array\n    | Int32Array\n    | Uint8Array\n    | Uint16Array\n    | Uint32Array\n    | bigint\n    | boolean\n    | number\n    | string\n    | symbol\n    | null\n    | undefined;\n\n/**\n * A type that recursively unwraps nested {@link Option} types.\n *\n * This type resolves all nested {@link Option} values, ensuring\n * that deeply wrapped values are properly extracted.\n *\n * - If `T` is an {@link Option}, it resolves to the contained value.\n * - If `T` is a known primitive or immutable type, it remains unchanged.\n * - If `T` is an object or array, it recursively unwraps any options found.\n *\n * The fallback type `U` (default: `null`) is used in place of `None` values.\n *\n * @typeParam T - The type to be unwrapped.\n * @typeParam U - The fallback type for `None` values (defaults to `null`).\n *\n * @example\n * Resolving nested `Option` types.\n * ```ts\n * UnwrappedOption<Some<Some<string>>>; // string\n * UnwrappedOption<None>;               // null\n * ```\n *\n * @example\n * Resolving options inside objects and arrays.\n * ```ts\n * UnwrappedOption<{ a: Some<number>; b: None }>; // { a: number; b: null }\n * UnwrappedOption<[Some<number>, None]>;         // [number, null]\n * ```\n *\n * @see {@link unwrapOptionRecursively}\n */\nexport type UnwrappedOption<T, U = null> =\n    T extends Some<infer TValue>\n        ? UnwrappedOption<TValue, U>\n        : T extends None\n          ? U\n          : T extends UnUnwrappables\n            ? T\n            : T extends object\n              ? { [key in keyof T]: UnwrappedOption<T[key], U> }\n              : T extends Array<infer TItem>\n                ? Array<UnwrappedOption<TItem, U>>\n                : T;\n\n/**\n * Recursively unwraps all nested {@link Option} types within a value.\n *\n * This function traverses a given value and removes all instances\n * of {@link Option}, replacing them with their contained values.\n *\n * - If an {@link Option} is encountered, its value is extracted.\n * - If an array or object is encountered, its elements are traversed recursively.\n * - If `None` is encountered, it is replaced with the fallback value (default: `null`).\n *\n * @typeParam T - The type of the input value.\n * @typeParam U - The fallback type for `None` values (defaults to `null`).\n *\n * @param input - The value to unwrap.\n * @param fallback - A function that provides a fallback value for `None` options.\n * @returns The recursively unwrapped value.\n *\n * @example\n * Recursively unwrapping nested options.\n * ```ts\n * unwrapOptionRecursively(some(some('Hello World'))); // \"Hello World\"\n * unwrapOptionRecursively(some(none<string>()));      // null\n * ```\n *\n * @example\n * Recursively unwrapping options inside objects and arrays.\n * ```ts\n * unwrapOptionRecursively({\n *   a: 'hello',\n *   b: none(),\n *   c: [{ c1: some(42) }, { c2: none() }],\n * });\n * // { a: \"hello\", b: null, c: [{ c1: 42 }, { c2: null }] }\n * ```\n *\n * @example\n * Using a fallback value for `None` options.\n * ```ts\n * unwrapOptionRecursively(\n *   {\n *     a: 'hello',\n *     b: none(),\n *     c: [{ c1: some(42) }, { c2: none() }],\n *   },\n *   () => 'Default',\n * );\n * // { a: \"hello\", b: \"Default\", c: [{ c1: 42 }, { c2: \"Default\" }] }\n * ```\n *\n * @remarks\n * This function does not mutate objects or arrays.\n *\n * @see {@link Option}\n * @see {@link UnwrappedOption}\n */\nexport function unwrapOptionRecursively<T>(input: T): UnwrappedOption<T>;\nexport function unwrapOptionRecursively<T, U>(input: T, fallback: () => U): UnwrappedOption<T, U>;\nexport function unwrapOptionRecursively<T, U = null>(input: T, fallback?: () => U): UnwrappedOption<T, U> {\n    // Types to bypass.\n    if (!input || ArrayBuffer.isView(input)) {\n        return input as UnwrappedOption<T, U>;\n    }\n\n    const next = <X>(x: X) =>\n        (fallback ? unwrapOptionRecursively(x, fallback) : unwrapOptionRecursively(x)) as UnwrappedOption<X, U>;\n\n    // Handle Option.\n    if (isOption(input)) {\n        if (isSome(input)) return next(input.value) as UnwrappedOption<T, U>;\n        return (fallback ? fallback() : null) as UnwrappedOption<T, U>;\n    }\n\n    // Walk.\n    if (Array.isArray(input)) {\n        return input.map(next) as UnwrappedOption<T, U>;\n    }\n    if (typeof input === 'object') {\n        return Object.fromEntries(Object.entries(input).map(([k, v]) => [k, next(v)])) as UnwrappedOption<T, U>;\n    }\n    return input as UnwrappedOption<T, U>;\n}\n","import type { Address } from '@solana/addresses';\nimport { isSolanaError, SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM, SolanaError } from '@solana/errors';\n\n/**\n * Identifies whether an error -- typically caused by a transaction failure -- is a custom program\n * error from the provided program address.\n *\n * @param transactionMessage The transaction message that failed to execute. Since the RPC response\n * only provides the index of the failed instruction, the transaction message is required to\n * determine its program address\n * @param programAddress The address of the program from which the error is expected to have\n * originated\n * @param code The expected error code of the custom program error. When provided, the function will\n * check that the custom program error code matches the given value.\n *\n * @example\n * ```ts\n * try {\n *     // Send and confirm your transaction.\n * } catch (error) {\n *     if (isProgramError(error, transactionMessage, myProgramAddress, 42)) {\n *         // Handle custom program error 42 from this program.\n *     } else if (isProgramError(error, transactionMessage, myProgramAddress)) {\n *         // Handle all other custom program errors from this program.\n *     } else {\n *         throw error;\n *     }\n * }\n * ```\n */\nexport function isProgramError<TProgramErrorCode extends number>(\n    error: unknown,\n    transactionMessage: { instructions: Record<number, { programAddress: Address }> },\n    programAddress: Address,\n    code?: TProgramErrorCode,\n): error is Readonly<{ context: Readonly<{ code: TProgramErrorCode }> }> &\n    SolanaError<typeof SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM> {\n    if (!isSolanaError(error, SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM)) {\n        return false;\n    }\n    const instructionProgramAddress = transactionMessage.instructions[error.context.index]?.programAddress;\n    if (!instructionProgramAddress || instructionProgramAddress !== programAddress) {\n        return false;\n    }\n    return typeof code === 'undefined' || error.context.code === code;\n}\n","import type { Address } from '@solana/addresses';\nimport { ReadonlyUint8Array } from '@solana/codecs-core';\nimport type { Lamports } from '@solana/rpc-types';\n\n/**\n * The number of bytes required to store the {@link BaseAccount} information without its data.\n *\n * @example\n * ```ts\n * const myTotalAccountSize = myAccountDataSize + BASE_ACCOUNT_SIZE;\n * ```\n */\nexport const BASE_ACCOUNT_SIZE = 128;\n\n/**\n * Defines the attributes common to all Solana accounts. Namely, it contains everything stored\n * on-chain except the account data itself.\n *\n * @interface\n *\n * @example\n * ```ts\n * const BaseAccount: BaseAccount = {\n *     executable: false,\n *     lamports: lamports(1_000_000_000n),\n *     programAddress: address('1111..1111'),\n *     space: 42n,\n * };\n * ```\n */\nexport type BaseAccount = {\n    readonly executable: boolean;\n    readonly lamports: Lamports;\n    readonly programAddress: Address;\n    readonly space: bigint;\n};\n\n/**\n * Contains all the information relevant to a Solana account. It includes the account's address and\n * data, as well as the properties of {@link BaseAccount}.\n *\n * @interface\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TData - The nature of this account's data. It can be represented as either a\n * `Uint8Array` &ndash; meaning the account is encoded &ndash; or a custom data type &ndash; meaning\n * the account is decoded.\n *\n * @example\n * ```ts\n * // Encoded\n * const myEncodedAccount: Account<Uint8Array, '1234..5678'> = {\n *     address: address('1234..5678'),\n *     data: new Uint8Array([1, 2, 3]),\n *     executable: false,\n *     lamports: lamports(1_000_000_000n),\n *     programAddress: address('1111..1111'),\n *     space: 42n,\n * };\n *\n * // Decoded\n * type MyAccountData = { name: string; age: number };\n * const myDecodedAccount: Account<MyAccountData, '1234..5678'> = {\n *     address: address('1234..5678'),\n *     data: { name: 'Alice', age: 30 },\n *     executable: false,\n *     lamports: lamports(1_000_000_000n),\n *     programAddress: address('1111..1111'),\n *     space: 42n,\n * };\n * ```\n */\nexport type Account<TData extends Uint8Array | object, TAddress extends string = string> = BaseAccount & {\n    readonly address: Address<TAddress>;\n    readonly data: TData;\n};\n\n/**\n * Represents an encoded account and is equivalent to an {@link Account} with `Uint8Array` account\n * data.\n *\n * @interface\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n *\n * @example\n * ```ts\n * {\n *     address: address('1234..5678'),\n *     data: new Uint8Array([1, 2, 3]),\n *     executable: false,\n *     lamports: lamports(1_000_000_000n),\n *     programAddress: address('1111..1111'),\n *     space: 42n,\n * } satisfies EncodedAccount<'1234..5678'>;\n * ```\n */\nexport type EncodedAccount<TAddress extends string = string> = Account<ReadonlyUint8Array, TAddress>;\n","import type { Decoder, ReadonlyUint8Array } from '@solana/codecs-core';\nimport {\n    SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED,\n    SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT,\n    SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT,\n    SolanaError,\n} from '@solana/errors';\n\nimport type { Account, EncodedAccount } from './account';\nimport type { MaybeAccount, MaybeEncodedAccount } from './maybe-account';\n\n/**\n * Transforms an {@link EncodedAccount} into an {@link Account} (or a {@link MaybeEncodedAccount}\n * into a {@link MaybeAccount}) by decoding the account data using the provided {@link Decoder}\n * instance.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TData - The type of this account's data.\n *\n * @example\n * ```ts\n * type MyAccountData = { name: string; age: number };\n *\n * const myAccount: EncodedAccount<'1234..5678'>;\n * const myDecoder: Decoder<MyAccountData> = getStructDecoder([\n *     ['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n *     ['age', getU32Decoder()],\n * ]);\n *\n * const myDecodedAccount = decodeAccount(myAccount, myDecoder);\n * myDecodedAccount satisfies Account<MyAccountData, '1234..5678'>;\n * ```\n */\nexport function decodeAccount<TData extends object, TAddress extends string = string>(\n    encodedAccount: EncodedAccount<TAddress>,\n    decoder: Decoder<TData>,\n): Account<TData, TAddress>;\nexport function decodeAccount<TData extends object, TAddress extends string = string>(\n    encodedAccount: MaybeEncodedAccount<TAddress>,\n    decoder: Decoder<TData>,\n): MaybeAccount<TData, TAddress>;\nexport function decodeAccount<TData extends object, TAddress extends string = string>(\n    encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>,\n    decoder: Decoder<TData>,\n): Account<TData, TAddress> | MaybeAccount<TData, TAddress> {\n    try {\n        if ('exists' in encodedAccount && !encodedAccount.exists) {\n            return encodedAccount;\n        }\n        return Object.freeze({ ...encodedAccount, data: decoder.decode(encodedAccount.data) });\n    } catch {\n        throw new SolanaError(SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT, {\n            address: encodedAccount.address,\n        });\n    }\n}\n\nfunction accountExists<TData extends object>(account: Account<TData> | MaybeAccount<TData>): account is Account<TData> {\n    return !('exists' in account) || ('exists' in account && account.exists);\n}\n\n/**\n * Asserts that an account stores decoded data, ie. not a `Uint8Array`.\n *\n * Note that it does not check the shape of the data matches the decoded type, only that it is not a\n * `Uint8Array`.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TData - The type of this account's data.\n *\n * @example\n * ```ts\n * type MyAccountData = { name: string; age: number };\n *\n * const myAccount: Account<MyAccountData | Uint8Array, '1234..5678'>;\n * assertAccountDecoded(myAccount);\n *\n * // now the account data can be used as MyAccountData\n * account.data satisfies MyAccountData;\n * ```\n *\n * This is particularly useful for narrowing the result of fetching a JSON parsed account.\n *\n * ```ts\n * const account: MaybeAccount<MockData | Uint8Array> = await fetchJsonParsedAccount<MockData>(\n *     rpc,\n *     '1234..5678' as Address,\n * );\n *\n * assertAccountDecoded(account);\n * // now we have a MaybeAccount<MockData>\n * account satisfies MaybeAccount<MockData>;\n * ```\n */\nexport function assertAccountDecoded<TData extends object, TAddress extends string = string>(\n    account: Account<TData | Uint8Array, TAddress>,\n): asserts account is Account<TData, TAddress>;\nexport function assertAccountDecoded<TData extends object, TAddress extends string = string>(\n    account: MaybeAccount<TData | Uint8Array, TAddress>,\n): asserts account is MaybeAccount<TData, TAddress>;\nexport function assertAccountDecoded<TData extends object, TAddress extends string = string>(\n    account: Account<TData | Uint8Array, TAddress> | MaybeAccount<TData | Uint8Array, TAddress>,\n): asserts account is Account<TData, TAddress> | MaybeAccount<TData, TAddress> {\n    if (accountExists(account) && account.data instanceof Uint8Array) {\n        throw new SolanaError(SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT, {\n            address: account.address,\n        });\n    }\n}\n\n/**\n * Asserts that all input accounts store decoded data, ie. not a `Uint8Array`.\n *\n * As with {@link assertAccountDecoded} it does not check the shape of the data matches the decoded\n * type, only that it is not a `Uint8Array`.\n *\n * @example\n * ```ts\n * type MyAccountData = { name: string; age: number };\n *\n * const myAccounts: Account<MyAccountData | Uint8Array, Address>[];\n * assertAccountsDecoded(myAccounts);\n *\n * // now the account data can be used as MyAccountData\n * for (const a of account) {\n *     account.data satisfies MyAccountData;\n * }\n * ```\n */\nexport function assertAccountsDecoded<TData extends object, TAddress extends string = string>(\n    accounts: Account<ReadonlyUint8Array | TData, TAddress>[],\n): asserts accounts is Account<TData, TAddress>[];\nexport function assertAccountsDecoded<TData extends object, TAddress extends string = string>(\n    accounts: MaybeAccount<ReadonlyUint8Array | TData, TAddress>[],\n): asserts accounts is MaybeAccount<TData, TAddress>[];\nexport function assertAccountsDecoded<TData extends object, TAddress extends string = string>(\n    accounts: (Account<ReadonlyUint8Array | TData, TAddress> | MaybeAccount<ReadonlyUint8Array | TData, TAddress>)[],\n): asserts accounts is (Account<TData, TAddress> | MaybeAccount<TData, TAddress>)[] {\n    const encoded = accounts.filter(a => accountExists(a) && a.data instanceof Uint8Array);\n    if (encoded.length > 0) {\n        const encodedAddresses = encoded.map(a => a.address);\n        throw new SolanaError(SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED, {\n            addresses: encodedAddresses,\n        });\n    }\n}\n","import type { Address } from '@solana/addresses';\nimport { getBase58Encoder, getBase64Encoder } from '@solana/codecs-strings';\nimport type {\n    AccountInfoBase,\n    AccountInfoWithBase58Bytes,\n    AccountInfoWithBase58EncodedData,\n    AccountInfoWithBase64EncodedData,\n} from '@solana/rpc-types';\n\nimport type { Account, BaseAccount, EncodedAccount } from './account';\nimport type { MaybeAccount, MaybeEncodedAccount } from './maybe-account';\nimport type { JsonParsedDataResponse } from './rpc-api';\n\ntype Base64EncodedRpcAccount = AccountInfoBase & AccountInfoWithBase64EncodedData;\n\n/**\n * Parses a base64-encoded account provided by the RPC client into an {@link EncodedAccount} type or\n * a {@link MaybeEncodedAccount} type if the raw data can be set to `null`.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n *\n * @example\n * ```ts\n * const myAddress = address('1234..5678');\n * const myRpcAccount = await rpc.getAccountInfo(myAddress, { encoding: 'base64' }).send();\n * const myAccount: MaybeEncodedAccount<'1234..5678'> = parseBase64RpcAccount(myRpcAccount);\n * ```\n */\nexport function parseBase64RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base64EncodedRpcAccount,\n): EncodedAccount<TAddress>;\nexport function parseBase64RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base64EncodedRpcAccount | null,\n): MaybeEncodedAccount<TAddress>;\nexport function parseBase64RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base64EncodedRpcAccount | null,\n): EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress> {\n    if (!rpcAccount) return Object.freeze({ address, exists: false });\n    const data = getBase64Encoder().encode(rpcAccount.data[0]);\n    return Object.freeze({ ...parseBaseAccount(rpcAccount), address, data, exists: true });\n}\n\ntype Base58EncodedRpcAccount = AccountInfoBase & (AccountInfoWithBase58Bytes | AccountInfoWithBase58EncodedData);\n\n/**\n * Parses a base58-encoded account provided by the RPC client into an {@link EncodedAccount} type or\n * a {@link MaybeEncodedAccount} type if the raw data can be set to `null`.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n *\n * @example\n * ```ts\n * const myAddress = address('1234..5678');\n * const myRpcAccount = await rpc.getAccountInfo(myAddress, { encoding: 'base58' }).send();\n * const myAccount: MaybeEncodedAccount<'1234..5678'> = parseBase58RpcAccount(myRpcAccount);\n * ```\n */\nexport function parseBase58RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base58EncodedRpcAccount,\n): EncodedAccount<TAddress>;\nexport function parseBase58RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base58EncodedRpcAccount | null,\n): MaybeEncodedAccount<TAddress>;\nexport function parseBase58RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base58EncodedRpcAccount | null,\n): EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress> {\n    if (!rpcAccount) return Object.freeze({ address, exists: false });\n    const data = getBase58Encoder().encode(typeof rpcAccount.data === 'string' ? rpcAccount.data : rpcAccount.data[0]);\n    return Object.freeze({ ...parseBaseAccount(rpcAccount), address, data, exists: true });\n}\n\ntype JsonParsedRpcAccount = AccountInfoBase & { readonly data: JsonParsedDataResponse<unknown> };\n\n/**\n * Parses an arbitrary `jsonParsed` account provided by the RPC client into an {@link Account} type\n * or a {@link MaybeAccount} type if the raw data can be set to `null`.\n *\n * The expected data type should be explicitly provided as the first type parameter.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TData - The expected type of this account's data.\n *\n * @example\n * ```ts\n * const myAccount: Account<MyData> = parseJsonRpcAccount<MyData>(myJsonRpcAccount);\n * ```\n */\nexport function parseJsonRpcAccount<TData extends object, TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: JsonParsedRpcAccount,\n): Account<TData, TAddress>;\nexport function parseJsonRpcAccount<TData extends object, TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: JsonParsedRpcAccount | null,\n): MaybeAccount<TData, TAddress>;\nexport function parseJsonRpcAccount<TData extends object, TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: JsonParsedRpcAccount | null,\n): Account<TData, TAddress> | MaybeAccount<TData, TAddress> {\n    if (!rpcAccount) return Object.freeze({ address, exists: false });\n    const data = rpcAccount.data.parsed.info as TData;\n    return Object.freeze({ ...parseBaseAccount(rpcAccount), address, data, exists: true });\n}\n\nfunction parseBaseAccount(rpcAccount: AccountInfoBase): BaseAccount {\n    return Object.freeze({\n        executable: rpcAccount.executable,\n        lamports: rpcAccount.lamports,\n        programAddress: rpcAccount.owner,\n        space: rpcAccount.space,\n    });\n}\n","import type { Address } from '@solana/addresses';\nimport type { Rpc } from '@solana/rpc-spec';\nimport type { Commitment, Slot } from '@solana/rpc-types';\n\nimport type { MaybeAccount, MaybeEncodedAccount } from './maybe-account';\nimport { parseBase64RpcAccount, parseJsonRpcAccount } from './parse-account';\nimport type { GetAccountInfoApi, GetMultipleAccountsApi } from './rpc-api';\n\n/**\n * Optional configuration for fetching a singular account.\n *\n * @interface\n */\nexport type FetchAccountConfig = {\n    abortSignal?: AbortSignal;\n    /**\n     * Fetch the details of the account as of the highest slot that has reached this level of\n     * commitment.\n     *\n     * @defaultValue Whichever default is applied by the underlying {@link RpcApi} in use. For\n     * example, when using an API created by a `createSolanaRpc*()` helper, the default commitment\n     * is `\"confirmed\"` unless configured otherwise. Unmitigated by an API layer on the client, the\n     * default commitment applied by the server is `\"finalized\"`.\n     */\n    commitment?: Commitment;\n    /**\n     * Prevents accessing stale data by enforcing that the RPC node has processed transactions up to\n     * this slot\n     */\n    minContextSlot?: Slot;\n};\n\n/**\n * Fetches a {@link MaybeEncodedAccount} from the provided RPC client and address.\n *\n * It uses the {@link GetAccountInfoApi.getAccountInfo | getAccountInfo} RPC method under the hood\n * with base64 encoding and an additional configuration object can be provided to customize the\n * behavior of the RPC call.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n *\n * @example\n * ```ts\n * const myAddress = address('1234..5678');\n * const myAccount: MaybeEncodedAccount<'1234..5678'> = await fetchEncodedAccount(rpc, myAddress);\n *\n * // With custom configuration.\n * const myAccount: MaybeEncodedAccount<'1234..5678'> = await fetchEncodedAccount(rpc, myAddress, {\n *     abortSignal: myAbortController.signal,\n *     commitment: 'confirmed',\n * });\n * ```\n */\nexport async function fetchEncodedAccount<TAddress extends string = string>(\n    rpc: Rpc<GetAccountInfoApi>,\n    address: Address<TAddress>,\n    config: FetchAccountConfig = {},\n): Promise<MaybeEncodedAccount<TAddress>> {\n    const { abortSignal, ...rpcConfig } = config;\n    const response = await rpc.getAccountInfo(address, { ...rpcConfig, encoding: 'base64' }).send({ abortSignal });\n    return parseBase64RpcAccount(address, response.value);\n}\n\n/**\n * Fetches a {@link MaybeAccount} from the provided RPC client and address by using\n * {@link GetAccountInfoApi.getAccountInfo | getAccountInfo} under the hood with the `jsonParsed`\n * encoding.\n *\n * It may also return a {@link MaybeEncodedAccount} if the RPC client does not know how to parse the\n * account at the requested address. In any case, the expected data type should be explicitly\n * provided as the first type parameter.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TData - The expected type of this account's data.\n *\n * @example\n * ```ts\n * type TokenData = { mint: Address; owner: Address };\n * const myAccount = await fetchJsonParsedAccount<TokenData>(rpc, myAddress);\n * myAccount satisfies MaybeAccount<TokenData> | MaybeEncodedAccount;\n *\n * // With custom configuration.\n * const myAccount = await fetchJsonParsedAccount<TokenData>(rpc, myAddress, {\n *     abortSignal: myAbortController.signal,\n *     commitment: 'confirmed',\n * });\n * ```\n */\nexport async function fetchJsonParsedAccount<TData extends object, TAddress extends string = string>(\n    rpc: Rpc<GetAccountInfoApi>,\n    address: Address<TAddress>,\n    config: FetchAccountConfig = {},\n): Promise<MaybeAccount<TData, TAddress> | MaybeEncodedAccount<TAddress>> {\n    const { abortSignal, ...rpcConfig } = config;\n    const { value: account } = await rpc\n        .getAccountInfo(address, { ...rpcConfig, encoding: 'jsonParsed' })\n        .send({ abortSignal });\n    return !!account && typeof account === 'object' && 'parsed' in account.data\n        ? parseJsonRpcAccount<TData, TAddress>(address, account as Parameters<typeof parseJsonRpcAccount>[1])\n        : parseBase64RpcAccount<TAddress>(address, account as Parameters<typeof parseBase64RpcAccount>[1]);\n}\n\n/**\n * Optional configuration for fetching multiple accounts.\n *\n * @interface\n */\nexport type FetchAccountsConfig = {\n    abortSignal?: AbortSignal;\n    /**\n     * Fetch the details of the accounts as of the highest slot that has reached this level of\n     * commitment.\n     *\n     * @defaultValue Whichever default is applied by the underlying {@link RpcApi} in use. For\n     * example, when using an API created by a `createSolanaRpc*()` helper, the default commitment\n     * is `\"confirmed\"` unless configured otherwise. Unmitigated by an API layer on the client, the\n     * default commitment applied by the server is `\"finalized\"`.\n     */\n    commitment?: Commitment;\n    /**\n     * Prevents accessing stale data by enforcing that the RPC node has processed transactions up to\n     * this slot\n     */\n    minContextSlot?: Slot;\n};\n\n/**\n * Fetches an array of {@link MaybeEncodedAccount | MaybeEncodedAccounts} from the provided RPC\n * client and an array of addresses.\n *\n * It uses the {@link GetMultipleAccountsApi#getMultipleAccounts | getMultipleAccounts} RPC method\n * under the hood with base64 encodings and an additional configuration object can be provided to\n * customize the behavior of the RPC call.\n *\n * @typeParam TAddresses - Supply an array of string literals to define accounts having particular\n * addresses.\n *\n * @example\n * ```ts\n * const myAddressA = address('1234..5678');\n * const myAddressB = address('8765..4321');\n * const [myAccountA, myAccountB] = await fetchEncodedAccounts(rpc, [myAddressA, myAddressB]);\n * myAccountA satisfies MaybeEncodedAccount<'1234..5678'>;\n * myAccountB satisfies MaybeEncodedAccount<'8765..4321'>;\n *\n * // With custom configuration.\n * const [myAccountA, myAccountB] = await fetchEncodedAccounts(rpc, [myAddressA, myAddressB], {\n *     abortSignal: myAbortController.signal,\n *     commitment: 'confirmed',\n * });\n * ```\n */\nexport async function fetchEncodedAccounts<\n    TAddresses extends string[] = string[],\n    TWrappedAddresses extends { [P in keyof TAddresses]: Address<TAddresses[P]> } = {\n        [P in keyof TAddresses]: Address<TAddresses[P]>;\n    },\n>(rpc: Rpc<GetMultipleAccountsApi>, addresses: TWrappedAddresses, config: FetchAccountsConfig = {}) {\n    const { abortSignal, ...rpcConfig } = config;\n    const response = await rpc\n        .getMultipleAccounts(addresses, { ...rpcConfig, encoding: 'base64' })\n        .send({ abortSignal });\n    return response.value.map((account, index) => parseBase64RpcAccount(addresses[index], account)) as {\n        [P in keyof TAddresses]: MaybeEncodedAccount<TAddresses[P]>;\n    };\n}\n\n/**\n * Fetches an array of {@link MaybeAccount | MaybeAccounts} from a provided RPC client and an array\n * of addresses.\n *\n * It uses the {@link GetMultipleAccountsApi#getMultipleAccounts | getMultipleAccounts} RPC method\n * under the hood with the `jsonParsed` encoding. It may also return a\n * {@link MaybeEncodedAccount} instead of the expected {@link MaybeAccount} if the RPC client does\n * not know how to parse some of the requested accounts. In any case, the array of expected data\n * types should be explicitly provided as the first type parameter.\n *\n * @typeParam TAddresses - Supply an array of string literals to define accounts having particular\n * addresses.\n * @typeParam TData - The expected types of these accounts' data.\n \n * @example\n * ```ts\n * type TokenData = { mint: Address; owner: Address };\n * type MintData = { supply: bigint };\n * const [myAccountA, myAccountB] = await fetchJsonParsedAccounts<[TokenData, MintData]>(rpc, [myAddressA, myAddressB]);\n * myAccountA satisfies MaybeAccount<TokenData> | MaybeEncodedAccount;\n * myAccountB satisfies MaybeAccount<MintData> | MaybeEncodedAccount;\n * ```\n */\nexport async function fetchJsonParsedAccounts<\n    TData extends object[],\n    TAddresses extends string[] = string[],\n    TWrappedAddresses extends { [P in keyof TAddresses]: Address<TAddresses[P]> } = {\n        [P in keyof TAddresses]: Address<TAddresses[P]>;\n    },\n>(rpc: Rpc<GetMultipleAccountsApi>, addresses: TWrappedAddresses, config: FetchAccountsConfig = {}) {\n    const { abortSignal, ...rpcConfig } = config;\n    const response = await rpc\n        .getMultipleAccounts(addresses, { ...rpcConfig, encoding: 'jsonParsed' })\n        .send({ abortSignal });\n    return response.value.map((account, index) => {\n        return !!account && typeof account === 'object' && 'parsed' in account.data\n            ? parseJsonRpcAccount(addresses[index], account as Parameters<typeof parseJsonRpcAccount>[1])\n            : parseBase64RpcAccount(addresses[index], account as Parameters<typeof parseBase64RpcAccount>[1]);\n    }) as {\n        [P in keyof TAddresses]:\n            | MaybeAccount<TData[P & keyof TData], TAddresses[P]>\n            | MaybeEncodedAccount<TAddresses[P]>;\n    } & {\n        [P in keyof TData]:\n            | MaybeAccount<TData[P], TAddresses[P & keyof TAddresses]>\n            | MaybeEncodedAccount<TAddresses[P & keyof TAddresses]>;\n    };\n}\n","import { Address } from '@solana/addresses';\nimport {\n    SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND,\n    SolanaError,\n} from '@solana/errors';\n\nimport { Account } from './account';\n\n/**\n * Represents an account that may or may not exist on-chain.\n *\n * When the account exists, it is represented as an {@link Account} type with an additional `exists`\n * attribute set to `true`. When it does not exist, it is represented by an object containing only\n * the address of the account and an `exists` attribute set to `false`.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TData - The nature of this account's data. It can be represented as either a\n * `Uint8Array` &ndash; meaning the account is encoded &ndash; or a custom data type &ndash; meaning\n * the account is decoded.\n *\n * @example\n * ```ts\n * // Account exists\n * const myExistingAccount: MaybeAccount<MyAccountData, '1234..5678'> = {\n *     exists: true,\n *     address: address('1234..5678'),\n *     data: { name: 'Alice', age: 30 },\n *     // ...\n * };\n *\n * // Account does not exist\n * const myMissingAccount: MaybeAccount<MyAccountData, '8765..4321'> = {\n *     exists: false,\n *     address: address('8765..4321'),\n * };\n * ```\n */\nexport type MaybeAccount<TData extends Uint8Array | object, TAddress extends string = string> =\n    | { readonly address: Address<TAddress>; readonly exists: false }\n    | (Account<TData, TAddress> & { readonly exists: true });\n\n/**\n * Represents an encoded account that may or may not exist on-chain.\n *\n * When the account exists, it is represented as an {@link Account} type having its `TData` type\n * parameter set to `Uint8Array` with an additional `exists` attribute set to `true`. When it does\n * not exist, it is represented by an object containing only the address of the account and an\n * `exists` attribute set to `false`.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n *\n * @example\n * ```ts\n * // Encoded account exists\n * const myExistingAccount: MaybeEncodedAccount<'1234..5678'> = {\n *     exists: true,\n *     address: address('1234..5678'),\n *     data: new Uint8Array([1, 2, 3]),\n *     // ...\n * };\n *\n * // Encoded account does not exist\n * const myMissingAccount: MaybeEncodedAccount<'8765..4321'> = {\n *     exists: false,\n *     address: address('8765..4321'),\n * };\n * ```\n */\nexport type MaybeEncodedAccount<TAddress extends string = string> = MaybeAccount<Uint8Array, TAddress>;\n\n/**\n * Given a {@link MaybeAccount}, asserts that the account exists and allows it to be used as an\n * {@link Account} type going forward.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TData - The nature of this account's data. It can be represented as either a\n * `Uint8Array` &ndash; meaning the account is encoded &ndash; or a custom data type &ndash; meaning\n * the account is decoded.\n *\n * @example\n * ```ts\n * const myAccount: MaybeEncodedAccount<'1234..5678'>;\n * assertAccountExists(myAccount);\n *\n * // Now we can use myAccount as an `EncodedAccount`\n * myAccount satisfies EncodedAccount<'1234..5678'>;\n * ```\n */\nexport function assertAccountExists<TData extends Uint8Array | object, TAddress extends string = string>(\n    account: MaybeAccount<TData, TAddress>,\n): asserts account is Account<TData, TAddress> & { exists: true } {\n    if (!account.exists) {\n        throw new SolanaError(SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND, { address: account.address });\n    }\n}\n\n/**\n * Given an array of {@link MaybeAccount | MaybeAccounts}, asserts that all the accounts exist and\n * allows them to be used as an array of {@link Account | Accounts} going forward.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TData - The nature of this account's data. It can be represented as either a\n * `Uint8Array` &ndash; meaning the account is encoded &ndash; or a custom data type &ndash; meaning\n * the account is decoded.\n *\n * @example\n * ```ts\n * const myAccounts: MaybeEncodedAccount<Address>[];\n * assertAccountsExist(myAccounts);\n *\n * // Now we can use them as an array of `EncodedAccounts`\n * for (const a of myAccounts) {\n *     a satisfies EncodedAccount<Address>;\n * }\n * ```\n */\nexport function assertAccountsExist<TData extends Uint8Array | object, TAddress extends string = string>(\n    accounts: MaybeAccount<TData, TAddress>[],\n): asserts accounts is (Account<TData, TAddress> & { exists: true })[] {\n    const missingAccounts = accounts.filter(a => !a.exists);\n    if (missingAccounts.length > 0) {\n        const missingAddresses = missingAccounts.map(a => a.address);\n        throw new SolanaError(SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND, { addresses: missingAddresses });\n    }\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  assertAccountExists,\n  assertAccountsExist,\n  combineCodec,\n  decodeAccount,\n  fetchEncodedAccount,\n  fetchEncodedAccounts,\n  getAddressDecoder,\n  getAddressEncoder,\n  getBooleanDecoder,\n  getBooleanEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  type Account,\n  type Address,\n  type EncodedAccount,\n  type FetchAccountConfig,\n  type FetchAccountsConfig,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type MaybeAccount,\n  type MaybeEncodedAccount,\n  type Option,\n  type OptionOrNullable,\n} from '@solana/kit';\n\nexport type Mint = {\n  /**\n   * Optional authority used to mint new tokens. The mint authority may only\n   * be provided during mint creation. If no mint authority is present\n   * then the mint has a fixed supply and no further tokens may be minted.\n   */\n  mintAuthority: Option<Address>;\n  /** Total supply of tokens. */\n  supply: bigint;\n  /** Number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n  /** Is `true` if this structure has been initialized. */\n  isInitialized: boolean;\n  /** Optional authority to freeze token accounts. */\n  freezeAuthority: Option<Address>;\n};\n\nexport type MintArgs = {\n  /**\n   * Optional authority used to mint new tokens. The mint authority may only\n   * be provided during mint creation. If no mint authority is present\n   * then the mint has a fixed supply and no further tokens may be minted.\n   */\n  mintAuthority: OptionOrNullable<Address>;\n  /** Total supply of tokens. */\n  supply: number | bigint;\n  /** Number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n  /** Is `true` if this structure has been initialized. */\n  isInitialized: boolean;\n  /** Optional authority to freeze token accounts. */\n  freezeAuthority: OptionOrNullable<Address>;\n};\n\nexport function getMintEncoder(): FixedSizeEncoder<MintArgs> {\n  return getStructEncoder([\n    [\n      'mintAuthority',\n      getOptionEncoder(getAddressEncoder(), {\n        prefix: getU32Encoder(),\n        noneValue: 'zeroes',\n      }),\n    ],\n    ['supply', getU64Encoder()],\n    ['decimals', getU8Encoder()],\n    ['isInitialized', getBooleanEncoder()],\n    [\n      'freezeAuthority',\n      getOptionEncoder(getAddressEncoder(), {\n        prefix: getU32Encoder(),\n        noneValue: 'zeroes',\n      }),\n    ],\n  ]);\n}\n\nexport function getMintDecoder(): FixedSizeDecoder<Mint> {\n  return getStructDecoder([\n    [\n      'mintAuthority',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: getU32Decoder(),\n        noneValue: 'zeroes',\n      }),\n    ],\n    ['supply', getU64Decoder()],\n    ['decimals', getU8Decoder()],\n    ['isInitialized', getBooleanDecoder()],\n    [\n      'freezeAuthority',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: getU32Decoder(),\n        noneValue: 'zeroes',\n      }),\n    ],\n  ]);\n}\n\nexport function getMintCodec(): FixedSizeCodec<MintArgs, Mint> {\n  return combineCodec(getMintEncoder(), getMintDecoder());\n}\n\nexport function decodeMint<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress>\n): Account<Mint, TAddress>;\nexport function decodeMint<TAddress extends string = string>(\n  encodedAccount: MaybeEncodedAccount<TAddress>\n): MaybeAccount<Mint, TAddress>;\nexport function decodeMint<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>\n): Account<Mint, TAddress> | MaybeAccount<Mint, TAddress> {\n  return decodeAccount(\n    encodedAccount as MaybeEncodedAccount<TAddress>,\n    getMintDecoder()\n  );\n}\n\nexport async function fetchMint<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<Account<Mint, TAddress>> {\n  const maybeAccount = await fetchMaybeMint(rpc, address, config);\n  assertAccountExists(maybeAccount);\n  return maybeAccount;\n}\n\nexport async function fetchMaybeMint<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<MaybeAccount<Mint, TAddress>> {\n  const maybeAccount = await fetchEncodedAccount(rpc, address, config);\n  return decodeMint(maybeAccount);\n}\n\nexport async function fetchAllMint(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<Account<Mint>[]> {\n  const maybeAccounts = await fetchAllMaybeMint(rpc, addresses, config);\n  assertAccountsExist(maybeAccounts);\n  return maybeAccounts;\n}\n\nexport async function fetchAllMaybeMint(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<MaybeAccount<Mint>[]> {\n  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);\n  return maybeAccounts.map((maybeAccount) => decodeMint(maybeAccount));\n}\n\nexport function getMintSize(): number {\n  return 82;\n}\n","import {\n    SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN,\n    SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_PACKER_ALREADY_COMPLETE,\n    SolanaError,\n} from '@solana/errors';\nimport { Instruction } from '@solana/instructions';\nimport {\n    appendTransactionMessageInstruction,\n    BaseTransactionMessage,\n    TransactionMessageWithFeePayer,\n} from '@solana/transaction-messages';\nimport { getTransactionMessageSize, TRANSACTION_SIZE_LIMIT } from '@solana/transactions';\n\n/**\n * A set of instructions with constraints on how they can be executed.\n *\n * This is structured as a recursive tree of plans in order to allow for\n * parallel execution, sequential execution and combinations of both.\n *\n * Namely the following plans are supported:\n * - {@link SingleInstructionPlan} - A plan that contains a single instruction.\n *   This is a simple instruction wrapper and the simplest leaf in this tree.\n * - {@link ParallelInstructionPlan} - A plan that contains other plans that\n *   can be executed in parallel.\n * - {@link SequentialInstructionPlan} - A plan that contains other plans that\n *   must be executed sequentially. It also defines whether the plan is divisible\n *   meaning that instructions inside it can be split into separate transactions.\n * - {@link MessagePackerInstructionPlan} - A plan that can dynamically pack\n *  instructions into transaction messages.\n *\n * Helpers are provided for each of these plans to make it easier to create them.\n *\n * @example\n * ```ts\n * const myInstructionPlan: InstructionPlan = parallelInstructionPlan([\n *    sequentialInstructionPlan([instructionA, instructionB]),\n *    instructionC,\n *    instructionD,\n * ]);\n * ```\n *\n * @see {@link SingleInstructionPlan}\n * @see {@link ParallelInstructionPlan}\n * @see {@link SequentialInstructionPlan}\n * @see {@link MessagePackerInstructionPlan}\n */\nexport type InstructionPlan =\n    | MessagePackerInstructionPlan\n    | ParallelInstructionPlan\n    | SequentialInstructionPlan\n    | SingleInstructionPlan;\n\n/**\n * A plan wrapping other plans that must be executed sequentially.\n *\n * It also defines whether nested plans are divisible  meaning that\n * the instructions inside them can be split into separate transactions.\n * When `divisible` is `false`, the instructions inside the plan should\n * all be executed atomically  either in a single transaction or in a\n * transaction bundle.\n *\n * You may use the {@link sequentialInstructionPlan} and {@link nonDivisibleSequentialInstructionPlan}\n * helpers to create objects of this type.\n *\n * @example Simple sequential plan with two instructions.\n * ```ts\n * const plan = sequentialInstructionPlan([instructionA, instructionB]);\n * plan satisfies SequentialInstructionPlan;\n * ```\n *\n * @example Non-divisible sequential plan with two instructions.\n * ```ts\n * const plan = nonDivisibleSequentialInstructionPlan([instructionA, instructionB]);\n * plan satisfies SequentialInstructionPlan & { divisible: false };\n * ```\n *\n * @example Sequential plan with nested parallel plans.\n * Here, instructions A and B can be executed in parallel, but they must both be finalized\n * before instructions C and D can be sent  which can also be executed in parallel.\n * ```ts\n * const plan = sequentialInstructionPlan([\n *   parallelInstructionPlan([instructionA, instructionB]),\n *   parallelInstructionPlan([instructionC, instructionD]),\n * ]);\n * plan satisfies SequentialInstructionPlan & { divisible: false };\n * ```\n *\n * @see {@link sequentialInstructionPlan}\n * @see {@link nonDivisibleSequentialInstructionPlan}\n */\nexport type SequentialInstructionPlan = Readonly<{\n    divisible: boolean;\n    kind: 'sequential';\n    plans: InstructionPlan[];\n}>;\n\n/**\n * A plan wrapping other plans that can be executed in parallel.\n *\n * This means direct children of this plan can be executed in separate\n * parallel transactions without consequence.\n * However, the children themselves can define additional constraints\n * for that specific branch of the tree  such as the {@link SequentialInstructionPlan}.\n *\n * You may use the {@link parallelInstructionPlan} helper to create objects of this type.\n *\n * @example Simple parallel plan with two instructions.\n * ```ts\n * const plan = parallelInstructionPlan([instructionA, instructionB]);\n * plan satisfies ParallelInstructionPlan;\n * ```\n *\n * @example Parallel plan with nested sequential plans.\n * Here, instructions A and B must be executed sequentially and so must instructions C and D,\n * but both pairs can be executed in parallel.\n * ```ts\n * const plan = parallelInstructionPlan([\n *   sequentialInstructionPlan([instructionA, instructionB]),\n *   sequentialInstructionPlan([instructionC, instructionD]),\n * ]);\n * plan satisfies ParallelInstructionPlan;\n * ```\n *\n * @see {@link parallelInstructionPlan}\n */\nexport type ParallelInstructionPlan = Readonly<{\n    kind: 'parallel';\n    plans: InstructionPlan[];\n}>;\n\n/**\n * A plan that contains a single instruction.\n *\n * This is a simple instruction wrapper that transforms an instruction into a plan.\n *\n * You may use the {@link singleInstructionPlan} helper to create objects of this type.\n *\n * @example\n * ```ts\n * const plan = singleInstructionPlan(instructionA);\n * plan satisfies SingleInstructionPlan;\n * ```\n *\n * @see {@link singleInstructionPlan}\n */\nexport type SingleInstructionPlan<TInstruction extends Instruction = Instruction> = Readonly<{\n    instruction: TInstruction;\n    kind: 'single';\n}>;\n\n/**\n * A plan that can dynamically pack instructions into transaction messages.\n *\n * This plan provides a {@link MessagePacker} via the `getMessagePacker`\n * method, which enables instructions to be dynamically packed into the\n * provided transaction message until there are no more instructions to pack.\n * The returned {@link MessagePacker} offers a `packMessageToCapacity(message)`\n * method that packs the provided message  when possible  and a `done()` method\n * that checks whether there are more instructions to pack.\n *\n * Several helper functions are provided to create objects of this type such as\n * {@link getLinearMessagePackerInstructionPlan} or {@link getMessagePackerInstructionPlanFromInstructions}.\n *\n * @example An message packer plan for a write instruction that uses as many bytes as possible.\n * ```ts\n * const plan = getLinearMessagePackerInstructionPlan({\n *   totalLength: dataToWrite.length,\n *   getInstruction: (offset, length) =>\n *     getWriteInstruction({\n *       offset,\n *       data: dataToWrite.slice(offset, offset + length),\n *     }),\n * });\n * plan satisfies MessagePackerInstructionPlan;\n * ```\n *\n * @example A message packer plan for multiple realloc instructions.\n * ```ts\n * const plan = getReallocMessagePackerInstructionPlan({\n *   totalSize: additionalDataSize,\n *   getInstruction: (size) => getExtendInstruction({ length: size }),\n * });\n * plan satisfies MessagePackerInstructionPlan;\n * ```\n *\n * @example Using a message packer plan.\n * ```ts\n * let plan: MessagePackerInstructionPlan;\n * const messagePacker = plan.getMessagePacker();\n *\n * while (!messagePacker.done()) {\n *   try {\n *     transactionMessage = messagePacker.packMessageToCapacity(transactionMessage);\n *   } catch (error) {\n *     // The current transaction message cannot be used to pack this plan.\n *     // We should create a new one and try again.\n *   }\n * }\n * ```\n *\n * @see {@link getLinearMessagePackerInstructionPlan}\n * @see {@link getMessagePackerInstructionPlanFromInstructions}\n * @see {@link getReallocMessagePackerInstructionPlan}\n */\nexport type MessagePackerInstructionPlan = Readonly<{\n    getMessagePacker: () => MessagePacker;\n    kind: 'messagePacker';\n}>;\n\n/**\n * The message packer returned by the {@link MessagePackerInstructionPlan}.\n *\n * It offers a `packMessageToCapacity(transactionMessage)` method that packs as many instructions\n * as possible into the provided transaction message, while still being able to fit into the\n * transaction size limit. It returns the updated transaction message with the packed instructions\n * or throws an error if the current transaction message cannot accommodate this plan.\n *\n * The `done()` method checks whether there are more instructions to pack into\n * transaction messages.\n *\n * @example\n * ```ts\n * let plan: MessagePackerInstructionPlan;\n * const messagePacker = plan.getMessagePacker();\n *\n * while (!messagePacker.done()) {\n *   try {\n *     transactionMessage = messagePacker.packMessageToCapacity(transactionMessage);\n *   } catch (error) {\n *     // The current transaction message cannot be used to pack this plan.\n *     // We should create a new one and try again.\n *   }\n * }\n * ```\n *\n * @see {@link MessagePackerInstructionPlan}\n */\nexport type MessagePacker = Readonly<{\n    /** Checks whether the message packer has more instructions to pack into transaction messages. */\n    done: () => boolean;\n    /**\n     * Packs the provided transaction message with instructions or throws if not possible.\n     *\n     * @throws {@link SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN}\n     *   if the provided transaction message cannot be used to fill the next instructions.\n     * @throws {@link SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_PACKER_ALREADY_COMPLETE}\n     *   if the message packer is already done and no more instructions can be packed.\n     */\n    packMessageToCapacity: (\n        transactionMessage: BaseTransactionMessage & TransactionMessageWithFeePayer,\n    ) => BaseTransactionMessage & TransactionMessageWithFeePayer;\n}>;\n\n/**\n * Creates a {@link ParallelInstructionPlan} from an array of nested plans.\n *\n * It can accept {@link Instruction} objects directly, which will be wrapped\n * in {@link SingleInstructionPlan | SingleInstructionPlans} automatically.\n *\n * @example Using explicit {@link SingleInstructionPlan | SingleInstructionPlans}.\n * ```ts\n * const plan = parallelInstructionPlan([\n *   singleInstructionPlan(instructionA),\n *   singleInstructionPlan(instructionB),\n * ]);\n * ```\n *\n * @example Using {@link Instruction | Instructions} directly.\n * ```ts\n * const plan = parallelInstructionPlan([instructionA, instructionB]);\n * ```\n *\n * @see {@link ParallelInstructionPlan}\n */\nexport function parallelInstructionPlan(plans: (Instruction | InstructionPlan)[]): ParallelInstructionPlan {\n    return Object.freeze({\n        kind: 'parallel',\n        plans: parseSingleInstructionPlans(plans),\n    });\n}\n\n/**\n * Creates a divisible {@link SequentialInstructionPlan} from an array of nested plans.\n *\n * It can accept {@link Instruction} objects directly, which will be wrapped\n * in {@link SingleInstructionPlan | SingleInstructionPlans} automatically.\n *\n * @example Using explicit {@link SingleInstructionPlan | SingleInstructionPlans}.\n * ```ts\n * const plan = sequentialInstructionPlan([\n *   singleInstructionPlan(instructionA),\n *   singleInstructionPlan(instructionB),\n * ]);\n * ```\n *\n * @example Using {@link Instruction | Instructions} directly.\n * ```ts\n * const plan = sequentialInstructionPlan([instructionA, instructionB]);\n * ```\n *\n * @see {@link SequentialInstructionPlan}\n */\nexport function sequentialInstructionPlan(\n    plans: (Instruction | InstructionPlan)[],\n): SequentialInstructionPlan & { divisible: true } {\n    return Object.freeze({\n        divisible: true,\n        kind: 'sequential',\n        plans: parseSingleInstructionPlans(plans),\n    });\n}\n\n/**\n * Creates a non-divisible {@link SequentialInstructionPlan} from an array of nested plans.\n *\n * It can accept {@link Instruction} objects directly, which will be wrapped\n * in {@link SingleInstructionPlan | SingleInstructionPlans} automatically.\n *\n * @example Using explicit {@link SingleInstructionPlan | SingleInstructionPlans}.\n * ```ts\n * const plan = nonDivisibleSequentialInstructionPlan([\n *   singleInstructionPlan(instructionA),\n *   singleInstructionPlan(instructionB),\n * ]);\n * ```\n *\n * @example Using {@link Instruction | Instructions} directly.\n * ```ts\n * const plan = nonDivisibleSequentialInstructionPlan([instructionA, instructionB]);\n * ```\n *\n * @see {@link SequentialInstructionPlan}\n */\nexport function nonDivisibleSequentialInstructionPlan(\n    plans: (Instruction | InstructionPlan)[],\n): SequentialInstructionPlan & { divisible: false } {\n    return Object.freeze({\n        divisible: false,\n        kind: 'sequential',\n        plans: parseSingleInstructionPlans(plans),\n    });\n}\n\n/**\n * Creates a {@link SingleInstructionPlan} from an {@link Instruction} object.\n *\n * @example\n * ```ts\n * const plan = singleInstructionPlan(instructionA);\n * ```\n *\n * @see {@link SingleInstructionPlan}\n */\nexport function singleInstructionPlan(instruction: Instruction): SingleInstructionPlan {\n    return Object.freeze({ instruction, kind: 'single' });\n}\n\nfunction parseSingleInstructionPlans(plans: (Instruction | InstructionPlan)[]): InstructionPlan[] {\n    return plans.map(plan => ('kind' in plan ? plan : singleInstructionPlan(plan)));\n}\n\n/**\n * Creates a {@link MessagePackerInstructionPlan} that packs instructions\n * such that each instruction consumes as many bytes as possible from the given\n * `totalLength` while still being able to fit into the given transaction messages.\n *\n * This is particularly useful for instructions that write data to accounts and must\n * span multiple transactions due to their size limit.\n *\n * This message packer will first call `getInstruction` with a length of zero to\n * determine the base size of the instruction before figuring out how many\n * additional bytes can be packed into the transaction message. That remaining space\n * will then be used to call `getInstruction` again with the appropriate length.\n *\n * @param getInstruction - A function that returns an instruction for a given offset and length.\n * @param totalLength - The total length of the data to write, in bytes.\n *\n * @example\n * ```ts\n * const plan = getLinearMessagePackerInstructionPlan({\n *   totalLength: dataToWrite.length,\n *   getInstruction: (offset, length) =>\n *     getWriteInstruction({\n *       offset,\n *       data: dataToWrite.slice(offset, offset + length),\n *     }),\n * });\n * plan satisfies MessagePackerInstructionPlan;\n * ```\n *\n * @see {@link MessagePackerInstructionPlan}\n */\nexport function getLinearMessagePackerInstructionPlan({\n    getInstruction,\n    totalLength: totalBytes,\n}: {\n    getInstruction: (offset: number, length: number) => Instruction;\n    totalLength: number;\n}): MessagePackerInstructionPlan {\n    return Object.freeze({\n        getMessagePacker: () => {\n            let offset = 0;\n            return Object.freeze({\n                done: () => offset >= totalBytes,\n                packMessageToCapacity: (message: BaseTransactionMessage & TransactionMessageWithFeePayer) => {\n                    if (offset >= totalBytes) {\n                        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_PACKER_ALREADY_COMPLETE);\n                    }\n\n                    const messageSizeWithBaseInstruction = getTransactionMessageSize(\n                        appendTransactionMessageInstruction(getInstruction(offset, 0), message),\n                    );\n                    const freeSpace =\n                        TRANSACTION_SIZE_LIMIT -\n                        messageSizeWithBaseInstruction /* Includes the base instruction (length: 0). */ -\n                        1; /* Leeway for shortU16 numbers in transaction headers. */\n\n                    if (freeSpace <= 0) {\n                        const messageSize = getTransactionMessageSize(message);\n                        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN, {\n                            // (+1) We need to pack at least one byte of data otherwise\n                            // there is no point packing the base instruction alone.\n                            numBytesRequired: messageSizeWithBaseInstruction - messageSize + 1,\n                            // (-1) Leeway for shortU16 numbers in transaction headers.\n                            numFreeBytes: TRANSACTION_SIZE_LIMIT - messageSize - 1,\n                        });\n                    }\n\n                    const length = Math.min(totalBytes - offset, freeSpace);\n                    const instruction = getInstruction(offset, length);\n                    offset += length;\n                    return appendTransactionMessageInstruction(instruction, message);\n                },\n            });\n        },\n        kind: 'messagePacker',\n    });\n}\n\n/**\n * Creates a {@link MessagePackerInstructionPlan} from a list of instructions.\n *\n * This can be useful to prepare a set of instructions that can be iterated over\n *  e.g. to pack a list of instructions that gradually reallocate the size of an account\n * one `REALLOC_LIMIT` (10'240 bytes) at a time.\n *\n * @example\n * ```ts\n * const plan = getMessagePackerInstructionPlanFromInstructions([\n *   instructionA,\n *   instructionB,\n *   instructionC,\n * ]);\n *\n * const messagePacker = plan.getMessagePacker();\n * firstTransactionMessage = messagePacker.packMessageToCapacity(firstTransactionMessage);\n * // Contains instruction A and instruction B.\n * secondTransactionMessage = messagePacker.packMessageToCapacity(secondTransactionMessage);\n * // Contains instruction C.\n * messagePacker.done(); // true\n * ```\n *\n * @see {@link MessagePackerInstructionPlan}\n * @see {@link getReallocMessagePackerInstructionPlan}\n */\nexport function getMessagePackerInstructionPlanFromInstructions<TInstruction extends Instruction = Instruction>(\n    instructions: TInstruction[],\n): MessagePackerInstructionPlan {\n    return Object.freeze({\n        getMessagePacker: () => {\n            let instructionIndex = 0;\n            return Object.freeze({\n                done: () => instructionIndex >= instructions.length,\n                packMessageToCapacity: (message: BaseTransactionMessage & TransactionMessageWithFeePayer) => {\n                    if (instructionIndex >= instructions.length) {\n                        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_PACKER_ALREADY_COMPLETE);\n                    }\n\n                    const originalMessageSize = getTransactionMessageSize(message);\n\n                    for (let index = instructionIndex; index < instructions.length; index++) {\n                        message = appendTransactionMessageInstruction(instructions[index], message);\n                        const messageSize = getTransactionMessageSize(message);\n\n                        if (messageSize > TRANSACTION_SIZE_LIMIT) {\n                            if (index === instructionIndex) {\n                                throw new SolanaError(\n                                    SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN,\n                                    {\n                                        numBytesRequired: messageSize - originalMessageSize,\n                                        numFreeBytes: TRANSACTION_SIZE_LIMIT - originalMessageSize,\n                                    },\n                                );\n                            }\n                            instructionIndex = index;\n                            return message;\n                        }\n                    }\n\n                    instructionIndex = instructions.length;\n                    return message;\n                },\n            });\n        },\n        kind: 'messagePacker',\n    });\n}\n\nconst REALLOC_LIMIT = 10_240;\n\n/**\n * Creates a {@link MessagePackerInstructionPlan} that packs a list of realloc instructions.\n *\n * That is, it splits instruction by chunks of `REALLOC_LIMIT` (10'240) bytes until\n * the given total size is reached.\n *\n * @example\n * ```ts\n * const plan = getReallocMessagePackerInstructionPlan({\n *   totalSize: additionalDataSize,\n *   getInstruction: (size) => getExtendInstruction({ length: size }),\n * });\n * ```\n *\n * @see {@link MessagePackerInstructionPlan}\n */\nexport function getReallocMessagePackerInstructionPlan({\n    getInstruction,\n    totalSize,\n}: {\n    getInstruction: (size: number) => Instruction;\n    totalSize: number;\n}): MessagePackerInstructionPlan {\n    const numberOfInstructions = Math.ceil(totalSize / REALLOC_LIMIT);\n    const lastInstructionSize = totalSize % REALLOC_LIMIT;\n    const instructions = new Array(numberOfInstructions)\n        .fill(0)\n        .map((_, i) => getInstruction(i === numberOfInstructions - 1 ? lastInstructionSize : REALLOC_LIMIT));\n\n    return getMessagePackerInstructionPlanFromInstructions(instructions);\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  assertAccountExists,\n  assertAccountsExist,\n  combineCodec,\n  decodeAccount,\n  fetchEncodedAccount,\n  fetchEncodedAccounts,\n  getAddressDecoder,\n  getAddressEncoder,\n  getArrayDecoder,\n  getArrayEncoder,\n  getBooleanDecoder,\n  getBooleanEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  type Account,\n  type Address,\n  type EncodedAccount,\n  type FetchAccountConfig,\n  type FetchAccountsConfig,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type MaybeAccount,\n  type MaybeEncodedAccount,\n} from '@solana/kit';\n\nexport type Multisig = {\n  /** Number of signers required. */\n  m: number;\n  /** Number of valid signers. */\n  n: number;\n  /** Is `true` if this structure has been initialized. */\n  isInitialized: boolean;\n  /** Signer public keys. */\n  signers: Array<Address>;\n};\n\nexport type MultisigArgs = Multisig;\n\nexport function getMultisigEncoder(): FixedSizeEncoder<MultisigArgs> {\n  return getStructEncoder([\n    ['m', getU8Encoder()],\n    ['n', getU8Encoder()],\n    ['isInitialized', getBooleanEncoder()],\n    ['signers', getArrayEncoder(getAddressEncoder(), { size: 11 })],\n  ]);\n}\n\nexport function getMultisigDecoder(): FixedSizeDecoder<Multisig> {\n  return getStructDecoder([\n    ['m', getU8Decoder()],\n    ['n', getU8Decoder()],\n    ['isInitialized', getBooleanDecoder()],\n    ['signers', getArrayDecoder(getAddressDecoder(), { size: 11 })],\n  ]);\n}\n\nexport function getMultisigCodec(): FixedSizeCodec<MultisigArgs, Multisig> {\n  return combineCodec(getMultisigEncoder(), getMultisigDecoder());\n}\n\nexport function decodeMultisig<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress>\n): Account<Multisig, TAddress>;\nexport function decodeMultisig<TAddress extends string = string>(\n  encodedAccount: MaybeEncodedAccount<TAddress>\n): MaybeAccount<Multisig, TAddress>;\nexport function decodeMultisig<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>\n): Account<Multisig, TAddress> | MaybeAccount<Multisig, TAddress> {\n  return decodeAccount(\n    encodedAccount as MaybeEncodedAccount<TAddress>,\n    getMultisigDecoder()\n  );\n}\n\nexport async function fetchMultisig<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<Account<Multisig, TAddress>> {\n  const maybeAccount = await fetchMaybeMultisig(rpc, address, config);\n  assertAccountExists(maybeAccount);\n  return maybeAccount;\n}\n\nexport async function fetchMaybeMultisig<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<MaybeAccount<Multisig, TAddress>> {\n  const maybeAccount = await fetchEncodedAccount(rpc, address, config);\n  return decodeMultisig(maybeAccount);\n}\n\nexport async function fetchAllMultisig(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<Account<Multisig>[]> {\n  const maybeAccounts = await fetchAllMaybeMultisig(rpc, addresses, config);\n  assertAccountsExist(maybeAccounts);\n  return maybeAccounts;\n}\n\nexport async function fetchAllMaybeMultisig(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<MaybeAccount<Multisig>[]> {\n  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);\n  return maybeAccounts.map((maybeAccount) => decodeMultisig(maybeAccount));\n}\n\nexport function getMultisigSize(): number {\n  return 355;\n}\n","import { SolanaError } from '@solana/errors';\nimport { BaseTransactionMessage, TransactionMessageWithFeePayer } from '@solana/transaction-messages';\nimport { Transaction } from '@solana/transactions';\n\n/**\n * The result of executing a transaction plan.\n *\n * This is structured as a recursive tree of results that mirrors the structure\n * of the original transaction plan, capturing the execution status at each level.\n *\n * Namely, the following result types are supported:\n * - {@link SingleTransactionPlanResult} - A result for a single transaction message\n *   containing its execution status.\n * - {@link ParallelTransactionPlanResult} - A result containing other results that\n *   were executed in parallel.\n * - {@link SequentialTransactionPlanResult} - A result containing other results that\n *   were executed sequentially. It also retains the divisibility property from the\n *   original plan.\n *\n * @template TContext - The type of the context object that may be passed along with successful results\n *\n * @see {@link SingleTransactionPlanResult}\n * @see {@link ParallelTransactionPlanResult}\n * @see {@link SequentialTransactionPlanResult}\n * @see {@link TransactionPlanResultStatus}\n */\nexport type TransactionPlanResult<TContext extends TransactionPlanResultContext = TransactionPlanResultContext> =\n    | ParallelTransactionPlanResult<TContext>\n    | SequentialTransactionPlanResult<TContext>\n    | SingleTransactionPlanResult<TContext>;\n\n/** A context object that may be passed along with successful results. */\nexport type TransactionPlanResultContext = Record<number | string | symbol, unknown>;\n\n/**\n * A result for a sequential transaction plan.\n *\n * This represents the execution result of a {@link SequentialTransactionPlan} and\n * contains child results that were executed sequentially. It also retains the\n * divisibility property from the original plan.\n *\n * You may use the {@link sequentialTransactionPlanResult} and\n * {@link nonDivisibleSequentialTransactionPlanResult} helpers to create objects of this type.\n *\n * @template TContext - The type of the context object that may be passed along with successful results\n *\n * @example\n * ```ts\n * const result = sequentialTransactionPlanResult([\n *   singleResultA,\n *   singleResultB,\n * ]);\n * result satisfies SequentialTransactionPlanResult;\n * ```\n *\n * @example\n * Non-divisible sequential result.\n * ```ts\n * const result = nonDivisibleSequentialTransactionPlanResult([\n *   singleResultA,\n *   singleResultB,\n * ]);\n * result satisfies SequentialTransactionPlanResult & { divisible: false };\n * ```\n *\n * @see {@link sequentialTransactionPlanResult}\n * @see {@link nonDivisibleSequentialTransactionPlanResult}\n */\nexport type SequentialTransactionPlanResult<\n    TContext extends TransactionPlanResultContext = TransactionPlanResultContext,\n> = Readonly<{\n    divisible: boolean;\n    kind: 'sequential';\n    plans: TransactionPlanResult<TContext>[];\n}>;\n\n/**\n * A result for a parallel transaction plan.\n *\n * This represents the execution result of a {@link ParallelTransactionPlan} and\n * contains child results that were executed in parallel.\n *\n * You may use the {@link parallelTransactionPlanResult} helper to create objects of this type.\n *\n * @template TContext - The type of the context object that may be passed along with successful results\n *\n * @example\n * ```ts\n * const result = parallelTransactionPlanResult([\n *   singleResultA,\n *   singleResultB,\n * ]);\n * result satisfies ParallelTransactionPlanResult;\n * ```\n *\n * @see {@link parallelTransactionPlanResult}\n */\nexport type ParallelTransactionPlanResult<\n    TContext extends TransactionPlanResultContext = TransactionPlanResultContext,\n> = Readonly<{\n    kind: 'parallel';\n    plans: TransactionPlanResult<TContext>[];\n}>;\n\n/**\n * A result for a single transaction plan.\n *\n * This represents the execution result of a {@link SingleTransactionPlan} and\n * contains the original transaction message along with its execution status.\n *\n * You may use the {@link successfulSingleTransactionPlanResult},\n * {@link failedSingleTransactionPlanResult}, or {@link canceledSingleTransactionPlanResult}\n * helpers to create objects of this type.\n *\n * @template TContext - The type of the context object that may be passed along with successful results\n * @template TTransactionMessage - The type of the transaction message\n *\n * @example\n * Successful result with a transaction and context.\n * ```ts\n * const result = successfulSingleTransactionPlanResult(\n *   transactionMessage,\n *   transaction\n * );\n * result satisfies SingleTransactionPlanResult;\n * ```\n *\n * @example\n * Failed result with an error.\n * ```ts\n * const result = failedSingleTransactionPlanResult(\n *   transactionMessage,\n *   new SolanaError(SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE),\n * );\n * result satisfies SingleTransactionPlanResult;\n * ```\n *\n * @example\n * Canceled result.\n * ```ts\n * const result = canceledSingleTransactionPlanResult(transactionMessage);\n * result satisfies SingleTransactionPlanResult;\n * ```\n *\n * @see {@link successfulSingleTransactionPlanResult}\n * @see {@link failedSingleTransactionPlanResult}\n * @see {@link canceledSingleTransactionPlanResult}\n */\nexport type SingleTransactionPlanResult<\n    TContext extends TransactionPlanResultContext = TransactionPlanResultContext,\n    TTransactionMessage extends BaseTransactionMessage & TransactionMessageWithFeePayer = BaseTransactionMessage &\n        TransactionMessageWithFeePayer,\n> = Readonly<{\n    kind: 'single';\n    message: TTransactionMessage;\n    status: TransactionPlanResultStatus<TContext>;\n}>;\n\n/**\n * The status of a single transaction plan execution.\n *\n * This represents the outcome of executing a single transaction message and can be one of:\n * - `successful` - The transaction was successfully executed. Contains the transaction\n *   and an optional context object.\n * - `failed` - The transaction execution failed. Contains the error that caused the failure.\n * - `canceled` - The transaction execution was canceled.\n *\n * @template TContext - The type of the context object that may be passed along with successful results\n */\nexport type TransactionPlanResultStatus<TContext extends TransactionPlanResultContext = TransactionPlanResultContext> =\n    | Readonly<{ context: TContext; kind: 'successful'; transaction: Transaction }>\n    | Readonly<{ error: SolanaError; kind: 'failed' }>\n    | Readonly<{ kind: 'canceled' }>;\n\n/**\n * Creates a divisible {@link SequentialTransactionPlanResult} from an array of nested results.\n *\n * This function creates a sequential result with the `divisible` property set to `true`,\n * indicating that the nested plans were executed sequentially but could have been\n * split into separate transactions or batches.\n *\n * @template TContext - The type of the context object that may be passed along with successful results\n * @param plans - The child results that were executed sequentially\n *\n * @example\n * ```ts\n * const result = sequentialTransactionPlanResult([\n *   singleResultA,\n *   singleResultB,\n * ]);\n * result satisfies SequentialTransactionPlanResult & { divisible: true };\n * ```\n *\n * @see {@link SequentialTransactionPlanResult}\n */\nexport function sequentialTransactionPlanResult<\n    TContext extends TransactionPlanResultContext = TransactionPlanResultContext,\n>(plans: TransactionPlanResult<TContext>[]): SequentialTransactionPlanResult<TContext> & { divisible: true } {\n    return Object.freeze({ divisible: true, kind: 'sequential', plans });\n}\n\n/**\n * Creates a non-divisible {@link SequentialTransactionPlanResult} from an array of nested results.\n *\n * This function creates a sequential result with the `divisible` property set to `false`,\n * indicating that the nested plans were executed sequentially and could not have been\n * split into separate transactions or batches (e.g., they were executed as a transaction bundle).\n *\n * @template TContext - The type of the context object that may be passed along with successful results\n * @param plans - The child results that were executed sequentially\n *\n * @example\n * ```ts\n * const result = nonDivisibleSequentialTransactionPlanResult([\n *   singleResultA,\n *   singleResultB,\n * ]);\n * result satisfies SequentialTransactionPlanResult & { divisible: false };\n * ```\n *\n * @see {@link SequentialTransactionPlanResult}\n */\nexport function nonDivisibleSequentialTransactionPlanResult<\n    TContext extends TransactionPlanResultContext = TransactionPlanResultContext,\n>(plans: TransactionPlanResult<TContext>[]): SequentialTransactionPlanResult<TContext> & { divisible: false } {\n    return Object.freeze({ divisible: false, kind: 'sequential', plans });\n}\n\n/**\n * Creates a {@link ParallelTransactionPlanResult} from an array of nested results.\n *\n * This function creates a parallel result indicating that the nested plans\n * were executed in parallel.\n *\n * @template TContext - The type of the context object that may be passed along with successful results\n * @param plans - The child results that were executed in parallel\n *\n * @example\n * ```ts\n * const result = parallelTransactionPlanResult([\n *   singleResultA,\n *   singleResultB,\n * ]);\n * result satisfies ParallelTransactionPlanResult;\n * ```\n *\n * @see {@link ParallelTransactionPlanResult}\n */\nexport function parallelTransactionPlanResult<\n    TContext extends TransactionPlanResultContext = TransactionPlanResultContext,\n>(plans: TransactionPlanResult<TContext>[]): ParallelTransactionPlanResult<TContext> {\n    return Object.freeze({ kind: 'parallel', plans });\n}\n\n/**\n * Creates a successful {@link SingleTransactionPlanResult} from a transaction message and transaction.\n *\n * This function creates a single result with a 'successful' status, indicating that\n * the transaction was successfully executed. It also includes the original transaction\n * message, the executed transaction, and an optional context object.\n *\n * @template TContext - The type of the context object\n * @template TTransactionMessage - The type of the transaction message\n * @param transactionMessage - The original transaction message\n * @param transaction - The successfully executed transaction\n * @param context - Optional context object to be included with the result\n *\n * @example\n * ```ts\n * const result = successfulSingleTransactionPlanResult(\n *   transactionMessage,\n *   transaction\n * );\n * result satisfies SingleTransactionPlanResult;\n * ```\n *\n * @see {@link SingleTransactionPlanResult}\n */\nexport function successfulSingleTransactionPlanResult<\n    TContext extends TransactionPlanResultContext = TransactionPlanResultContext,\n    TTransactionMessage extends BaseTransactionMessage & TransactionMessageWithFeePayer = BaseTransactionMessage &\n        TransactionMessageWithFeePayer,\n>(\n    transactionMessage: TTransactionMessage,\n    transaction: Transaction,\n    context?: TContext,\n): SingleTransactionPlanResult<TContext, TTransactionMessage> {\n    return Object.freeze({\n        kind: 'single',\n        message: transactionMessage,\n        status: Object.freeze({ context: context ?? ({} as TContext), kind: 'successful', transaction }),\n    });\n}\n\n/**\n * Creates a failed {@link SingleTransactionPlanResult} from a transaction message and error.\n *\n * This function creates a single result with a 'failed' status, indicating that\n * the transaction execution failed. It includes the original transaction message\n * and the error that caused the failure.\n *\n * @template TContext - The type of the context object (not used in failed results)\n * @template TTransactionMessage - The type of the transaction message\n * @param transactionMessage - The original transaction message\n * @param error - The error that caused the transaction to fail\n *\n * @example\n * ```ts\n * const result = failedSingleTransactionPlanResult(\n *   transactionMessage,\n *   new SolanaError({\n *     code: 123,\n *     message: 'Transaction simulation failed',\n *   }),\n * );\n * result satisfies SingleTransactionPlanResult;\n * ```\n *\n * @see {@link SingleTransactionPlanResult}\n */\nexport function failedSingleTransactionPlanResult<\n    TContext extends TransactionPlanResultContext = TransactionPlanResultContext,\n    TTransactionMessage extends BaseTransactionMessage & TransactionMessageWithFeePayer = BaseTransactionMessage &\n        TransactionMessageWithFeePayer,\n>(\n    transactionMessage: TTransactionMessage,\n    error: SolanaError,\n): SingleTransactionPlanResult<TContext, TTransactionMessage> {\n    return Object.freeze({\n        kind: 'single',\n        message: transactionMessage,\n        status: Object.freeze({ error, kind: 'failed' }),\n    });\n}\n\n/**\n * Creates a canceled {@link SingleTransactionPlanResult} from a transaction message.\n *\n * This function creates a single result with a 'canceled' status, indicating that\n * the transaction execution was canceled. It includes the original transaction message.\n *\n * @template TContext - The type of the context object (not used in canceled results)\n * @template TTransactionMessage - The type of the transaction message\n * @param transactionMessage - The original transaction message\n *\n * @example\n * ```ts\n * const result = canceledSingleTransactionPlanResult(transactionMessage);\n * result satisfies SingleTransactionPlanResult;\n * ```\n *\n * @see {@link SingleTransactionPlanResult}\n */\nexport function canceledSingleTransactionPlanResult<\n    TContext extends TransactionPlanResultContext = TransactionPlanResultContext,\n    TTransactionMessage extends BaseTransactionMessage & TransactionMessageWithFeePayer = BaseTransactionMessage &\n        TransactionMessageWithFeePayer,\n>(transactionMessage: TTransactionMessage): SingleTransactionPlanResult<TContext, TTransactionMessage> {\n    return Object.freeze({\n        kind: 'single',\n        message: transactionMessage,\n        status: Object.freeze({ kind: 'canceled' }),\n    });\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getEnumDecoder,\n  getEnumEncoder,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n} from '@solana/kit';\n\nexport enum AccountState {\n  Uninitialized,\n  Initialized,\n  Frozen,\n}\n\nexport type AccountStateArgs = AccountState;\n\nexport function getAccountStateEncoder(): FixedSizeEncoder<AccountStateArgs> {\n  return getEnumEncoder(AccountState);\n}\n\nexport function getAccountStateDecoder(): FixedSizeDecoder<AccountState> {\n  return getEnumDecoder(AccountState);\n}\n\nexport function getAccountStateCodec(): FixedSizeCodec<\n  AccountStateArgs,\n  AccountState\n> {\n  return combineCodec(getAccountStateEncoder(), getAccountStateDecoder());\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getEnumDecoder,\n  getEnumEncoder,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n} from '@solana/kit';\n\nexport enum AuthorityType {\n  MintTokens,\n  FreezeAccount,\n  AccountOwner,\n  CloseAccount,\n}\n\nexport type AuthorityTypeArgs = AuthorityType;\n\nexport function getAuthorityTypeEncoder(): FixedSizeEncoder<AuthorityTypeArgs> {\n  return getEnumEncoder(AuthorityType);\n}\n\nexport function getAuthorityTypeDecoder(): FixedSizeDecoder<AuthorityType> {\n  return getEnumDecoder(AuthorityType);\n}\n\nexport function getAuthorityTypeCodec(): FixedSizeCodec<\n  AuthorityTypeArgs,\n  AuthorityType\n> {\n  return combineCodec(getAuthorityTypeEncoder(), getAuthorityTypeDecoder());\n}\n","import {\n    SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN,\n    SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND,\n    SolanaError,\n} from '@solana/errors';\nimport { getAbortablePromise } from '@solana/promises';\nimport { BaseTransactionMessage, TransactionMessageWithFeePayer } from '@solana/transaction-messages';\nimport { Transaction } from '@solana/transactions';\n\nimport type {\n    ParallelTransactionPlan,\n    SequentialTransactionPlan,\n    SingleTransactionPlan,\n    TransactionPlan,\n} from './transaction-plan';\nimport {\n    canceledSingleTransactionPlanResult,\n    failedSingleTransactionPlanResult,\n    nonDivisibleSequentialTransactionPlanResult,\n    parallelTransactionPlanResult,\n    sequentialTransactionPlanResult,\n    successfulSingleTransactionPlanResult,\n    type TransactionPlanResult,\n    type TransactionPlanResultContext,\n} from './transaction-plan-result';\n\nexport type TransactionPlanExecutor<TContext extends TransactionPlanResultContext = TransactionPlanResultContext> = (\n    transactionPlan: TransactionPlan,\n    config?: { abortSignal?: AbortSignal },\n) => Promise<TransactionPlanResult<TContext>>;\n\ntype ExecuteTransactionMessage = <TContext extends TransactionPlanResultContext = TransactionPlanResultContext>(\n    transactionMessage: BaseTransactionMessage & TransactionMessageWithFeePayer,\n    config?: { abortSignal?: AbortSignal },\n) => Promise<{ context?: TContext; transaction: Transaction }>;\n\n/**\n * Configuration object for creating a new transaction plan executor.\n *\n * @see {@link createTransactionPlanExecutor}\n */\nexport type TransactionPlanExecutorConfig = {\n    /** Called whenever a transaction message must be sent to the blockchain. */\n    executeTransactionMessage: ExecuteTransactionMessage;\n};\n\n/**\n * Creates a new transaction plan executor based on the provided configuration.\n *\n * The executor will traverse the provided `TransactionPlan` sequentially or in parallel,\n * executing each transaction message using the `executeTransactionMessage` function.\n *\n * - If that function is successful, the executor will return a successful `TransactionPlanResult`\n * for that message including the transaction and any custom context.\n * - If that function throws an error, the executor will stop processing and cancel all\n * remaining transaction messages in the plan.\n * - If the `abortSignal` is triggered, the executor will immediately stop processing the plan and\n * return a `TransactionPlanResult` with the status set to `canceled`.\n *\n * @example\n * ```ts\n * const sendAndConfirmTransaction = sendAndConfirmTransactionFactory({ rpc, rpcSubscriptions });\n *\n * const transactionPlanExecutor = createTransactionPlanExecutor({\n *   executeTransactionMessage: (message) => {\n *     const transaction = await signTransactionMessageWithSigners(message);\n *     await sendAndConfirmTransaction(transaction, { commitment: 'confirmed' });\n *     return { transaction };\n *   }\n * });\n * ```\n *\n * @see {@link TransactionPlannerConfig}\n */\nexport function createTransactionPlanExecutor(config: TransactionPlanExecutorConfig): TransactionPlanExecutor {\n    return async (plan, { abortSignal } = {}): Promise<TransactionPlanResult> => {\n        const context: TraverseContext = {\n            ...config,\n            abortSignal: abortSignal,\n            canceled: abortSignal?.aborted ?? false,\n        };\n\n        const cancelHandler = () => {\n            context.canceled = true;\n        };\n        abortSignal?.addEventListener('abort', cancelHandler);\n        const transactionPlanResult = await traverse(plan, context);\n        abortSignal?.removeEventListener('abort', cancelHandler);\n\n        if (context.canceled) {\n            const abortReason = abortSignal?.aborted ? abortSignal.reason : undefined;\n            const context = { cause: findErrorFromTransactionPlanResult(transactionPlanResult) ?? abortReason };\n            // Here we want the `transactionPlanResult` to be available in the error context\n            // so applications can create recovery plans but we don't want this object to be\n            // serialized with the error. This is why we set it as a non-enumerable property.\n            Object.defineProperty(context, 'transactionPlanResult', {\n                configurable: false,\n                enumerable: false,\n                value: transactionPlanResult,\n                writable: false,\n            });\n            throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN, context);\n        }\n\n        return transactionPlanResult;\n    };\n}\n\ntype TraverseContext = TransactionPlanExecutorConfig & {\n    abortSignal?: AbortSignal;\n    canceled: boolean;\n};\n\nasync function traverse(transactionPlan: TransactionPlan, context: TraverseContext): Promise<TransactionPlanResult> {\n    const kind = transactionPlan.kind;\n    switch (kind) {\n        case 'sequential':\n            return await traverseSequential(transactionPlan, context);\n        case 'parallel':\n            return await traverseParallel(transactionPlan, context);\n        case 'single':\n            return await traverseSingle(transactionPlan, context);\n        default:\n            transactionPlan satisfies never;\n            throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND, { kind });\n    }\n}\n\nasync function traverseSequential(\n    transactionPlan: SequentialTransactionPlan,\n    context: TraverseContext,\n): Promise<TransactionPlanResult> {\n    const results: TransactionPlanResult[] = [];\n\n    for (const subPlan of transactionPlan.plans) {\n        const result = await traverse(subPlan, context);\n        results.push(result);\n    }\n\n    return transactionPlan.divisible\n        ? sequentialTransactionPlanResult(results)\n        : nonDivisibleSequentialTransactionPlanResult(results);\n}\n\nasync function traverseParallel(\n    transactionPlan: ParallelTransactionPlan,\n    context: TraverseContext,\n): Promise<TransactionPlanResult> {\n    const results = await Promise.all(transactionPlan.plans.map(plan => traverse(plan, context)));\n    return parallelTransactionPlanResult(results);\n}\n\nasync function traverseSingle(\n    transactionPlan: SingleTransactionPlan,\n    context: TraverseContext,\n): Promise<TransactionPlanResult> {\n    if (context.canceled) {\n        return canceledSingleTransactionPlanResult(transactionPlan.message);\n    }\n\n    try {\n        const result = await getAbortablePromise(\n            context.executeTransactionMessage(transactionPlan.message, { abortSignal: context.abortSignal }),\n            context.abortSignal,\n        );\n        return successfulSingleTransactionPlanResult(transactionPlan.message, result.transaction, result.context);\n    } catch (error) {\n        context.canceled = true;\n        return failedSingleTransactionPlanResult(transactionPlan.message, error as SolanaError);\n    }\n}\n\nfunction findErrorFromTransactionPlanResult(result: TransactionPlanResult): SolanaError | undefined {\n    if (result.kind === 'single') {\n        return result.status.kind === 'failed' ? result.status.error : undefined;\n    }\n    for (const plan of result.plans) {\n        const error = findErrorFromTransactionPlanResult(plan);\n        if (error) {\n            return error;\n        }\n    }\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  assertAccountExists,\n  assertAccountsExist,\n  combineCodec,\n  decodeAccount,\n  fetchEncodedAccount,\n  fetchEncodedAccounts,\n  getAddressDecoder,\n  getAddressEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  type Account,\n  type Address,\n  type EncodedAccount,\n  type FetchAccountConfig,\n  type FetchAccountsConfig,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type MaybeAccount,\n  type MaybeEncodedAccount,\n  type Option,\n  type OptionOrNullable,\n} from '@solana/kit';\nimport {\n  getAccountStateDecoder,\n  getAccountStateEncoder,\n  type AccountState,\n  type AccountStateArgs,\n} from '../types';\n\nexport type Token = {\n  /** The mint associated with this account. */\n  mint: Address;\n  /** The owner of this account. */\n  owner: Address;\n  /** The amount of tokens this account holds. */\n  amount: bigint;\n  /**\n   * If `delegate` is `Some` then `delegated_amount` represents\n   * the amount authorized by the delegate.\n   */\n  delegate: Option<Address>;\n  /** The account's state. */\n  state: AccountState;\n  /**\n   * If is_native.is_some, this is a native token, and the value logs the\n   * rent-exempt reserve. An Account is required to be rent-exempt, so\n   * the value is used by the Processor to ensure that wrapped SOL\n   * accounts do not drop below this threshold.\n   */\n  isNative: Option<bigint>;\n  /** The amount delegated. */\n  delegatedAmount: bigint;\n  /** Optional authority to close the account. */\n  closeAuthority: Option<Address>;\n};\n\nexport type TokenArgs = {\n  /** The mint associated with this account. */\n  mint: Address;\n  /** The owner of this account. */\n  owner: Address;\n  /** The amount of tokens this account holds. */\n  amount: number | bigint;\n  /**\n   * If `delegate` is `Some` then `delegated_amount` represents\n   * the amount authorized by the delegate.\n   */\n  delegate: OptionOrNullable<Address>;\n  /** The account's state. */\n  state: AccountStateArgs;\n  /**\n   * If is_native.is_some, this is a native token, and the value logs the\n   * rent-exempt reserve. An Account is required to be rent-exempt, so\n   * the value is used by the Processor to ensure that wrapped SOL\n   * accounts do not drop below this threshold.\n   */\n  isNative: OptionOrNullable<number | bigint>;\n  /** The amount delegated. */\n  delegatedAmount: number | bigint;\n  /** Optional authority to close the account. */\n  closeAuthority: OptionOrNullable<Address>;\n};\n\nexport function getTokenEncoder(): FixedSizeEncoder<TokenArgs> {\n  return getStructEncoder([\n    ['mint', getAddressEncoder()],\n    ['owner', getAddressEncoder()],\n    ['amount', getU64Encoder()],\n    [\n      'delegate',\n      getOptionEncoder(getAddressEncoder(), {\n        prefix: getU32Encoder(),\n        noneValue: 'zeroes',\n      }),\n    ],\n    ['state', getAccountStateEncoder()],\n    [\n      'isNative',\n      getOptionEncoder(getU64Encoder(), {\n        prefix: getU32Encoder(),\n        noneValue: 'zeroes',\n      }),\n    ],\n    ['delegatedAmount', getU64Encoder()],\n    [\n      'closeAuthority',\n      getOptionEncoder(getAddressEncoder(), {\n        prefix: getU32Encoder(),\n        noneValue: 'zeroes',\n      }),\n    ],\n  ]);\n}\n\nexport function getTokenDecoder(): FixedSizeDecoder<Token> {\n  return getStructDecoder([\n    ['mint', getAddressDecoder()],\n    ['owner', getAddressDecoder()],\n    ['amount', getU64Decoder()],\n    [\n      'delegate',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: getU32Decoder(),\n        noneValue: 'zeroes',\n      }),\n    ],\n    ['state', getAccountStateDecoder()],\n    [\n      'isNative',\n      getOptionDecoder(getU64Decoder(), {\n        prefix: getU32Decoder(),\n        noneValue: 'zeroes',\n      }),\n    ],\n    ['delegatedAmount', getU64Decoder()],\n    [\n      'closeAuthority',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: getU32Decoder(),\n        noneValue: 'zeroes',\n      }),\n    ],\n  ]);\n}\n\nexport function getTokenCodec(): FixedSizeCodec<TokenArgs, Token> {\n  return combineCodec(getTokenEncoder(), getTokenDecoder());\n}\n\nexport function decodeToken<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress>\n): Account<Token, TAddress>;\nexport function decodeToken<TAddress extends string = string>(\n  encodedAccount: MaybeEncodedAccount<TAddress>\n): MaybeAccount<Token, TAddress>;\nexport function decodeToken<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>\n): Account<Token, TAddress> | MaybeAccount<Token, TAddress> {\n  return decodeAccount(\n    encodedAccount as MaybeEncodedAccount<TAddress>,\n    getTokenDecoder()\n  );\n}\n\nexport async function fetchToken<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<Account<Token, TAddress>> {\n  const maybeAccount = await fetchMaybeToken(rpc, address, config);\n  assertAccountExists(maybeAccount);\n  return maybeAccount;\n}\n\nexport async function fetchMaybeToken<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<MaybeAccount<Token, TAddress>> {\n  const maybeAccount = await fetchEncodedAccount(rpc, address, config);\n  return decodeToken(maybeAccount);\n}\n\nexport async function fetchAllToken(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<Account<Token>[]> {\n  const maybeAccounts = await fetchAllMaybeToken(rpc, addresses, config);\n  assertAccountsExist(maybeAccounts);\n  return maybeAccounts;\n}\n\nexport async function fetchAllMaybeToken(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<MaybeAccount<Token>[]> {\n  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);\n  return maybeAccounts.map((maybeAccount) => decodeToken(maybeAccount));\n}\n\nexport function getTokenSize(): number {\n  return 165;\n}\n","import { BaseTransactionMessage, TransactionMessageWithFeePayer } from '@solana/transaction-messages';\n\n/**\n * A set of transaction messages with constraints on how they can be executed.\n *\n * This is structured as a recursive tree of plans to allow for\n * parallel execution, sequential execution and combinations of both.\n *\n * Namely, the following plans are supported:\n * - {@link SingleTransactionPlan} - A plan that contains a single transaction message.\n *   This is the simplest leaf in this tree.\n * - {@link ParallelTransactionPlan} - A plan that contains other plans that\n *   can be executed in parallel.\n * - {@link SequentialTransactionPlan} - A plan that contains other plans that\n *   must be executed sequentially. It also defines whether the plan is divisible\n *   meaning that transaction messages inside it can be split into separate batches.\n *\n * Helpers are provided for each of these plans to make it easier to create them.\n *\n * @example\n * ```ts\n * const myTransactionPlan: TransactionPlan = parallelTransactionPlan([\n *   sequentialTransactionPlan([messageA, messageB]),\n *   messageC,\n * ]);\n * ```\n *\n * @see {@link SingleTransactionPlan}\n * @see {@link ParallelTransactionPlan}\n * @see {@link SequentialTransactionPlan}\n */\nexport type TransactionPlan = ParallelTransactionPlan | SequentialTransactionPlan | SingleTransactionPlan;\n\n/**\n * A plan wrapping other plans that must be executed sequentially.\n *\n * It also defines whether nested plans are divisible  meaning that\n * the transaction messages inside them can be split into separate batches.\n * When `divisible` is `false`, the transaction messages inside the plan should\n * all be executed atomically  usually in a transaction bundle.\n *\n * You may use the {@link sequentialTransactionPlan} and {@link nonDivisibleSequentialTransactionPlan}\n * helpers to create objects of this type.\n *\n * @example\n * Simple sequential plan with two transaction messages.\n * ```ts\n * const plan = sequentialTransactionPlan([messageA, messageB]);\n * plan satisfies SequentialTransactionPlan;\n * ```\n *\n * @example\n * Non-divisible sequential plan with two transaction messages.\n * ```ts\n * const plan = nonDivisibleSequentialTransactionPlan([messageA, messageB]);\n * plan satisfies SequentialTransactionPlan & { divisible: false };\n * ```\n *\n * @example\n * Sequential plan with nested parallel plans.\n * Here, messages A and B can be executed in parallel, but they must both be finalized\n * before messages C and D can be sent  which can also be executed in parallel.\n * ```ts\n * const plan = sequentialTransactionPlan([\n *   parallelTransactionPlan([messageA, messageB]),\n *   parallelTransactionPlan([messageC, messageD]),\n * ]);\n * ```\n *\n * @see {@link sequentialTransactionPlan}\n * @see {@link nonDivisibleSequentialTransactionPlan}\n */\nexport type SequentialTransactionPlan = Readonly<{\n    divisible: boolean;\n    kind: 'sequential';\n    plans: TransactionPlan[];\n}>;\n\n/**\n * A plan wrapping other plans that can be executed in parallel.\n *\n * This means direct children of this plan can be executed in separate\n * parallel transactions without causing any side effects.\n * However, the children themselves can define additional constraints\n * for that specific branch of the tree  such as the {@link SequentialTransactionPlan}.\n *\n * You may use the {@link parallelTransactionPlan} helper to create objects of this type.\n *\n * @example\n * Simple parallel plan with two transaction messages.\n * ```ts\n * const plan = parallelTransactionPlan([messageA, messageB]);\n * plan satisfies ParallelTransactionPlan;\n * ```\n *\n * @example\n * Parallel plan with nested sequential plans.\n * Here, messages A and B must be executed sequentially and so must messages C and D,\n * but both pairs can be executed in parallel.\n * ```ts\n * const plan = parallelTransactionPlan([\n *   sequentialTransactionPlan([messageA, messageB]),\n *   sequentialTransactionPlan([messageC, messageD]),\n * ]);\n * plan satisfies ParallelTransactionPlan;\n * ```\n *\n * @see {@link parallelTransactionPlan}\n */\nexport type ParallelTransactionPlan = Readonly<{\n    kind: 'parallel';\n    plans: TransactionPlan[];\n}>;\n\n/**\n * A plan that contains a single transaction message.\n *\n * This is a simple transaction message wrapper that transforms a message into a plan.\n *\n * You may use the {@link singleTransactionPlan} helper to create objects of this type.\n *\n * @example\n * ```ts\n * const plan = singleTransactionPlan(transactionMessage);\n * plan satisfies SingleTransactionPlan;\n * ```\n *\n * @see {@link singleTransactionPlan}\n */\nexport type SingleTransactionPlan<\n    TTransactionMessage extends BaseTransactionMessage & TransactionMessageWithFeePayer = BaseTransactionMessage &\n        TransactionMessageWithFeePayer,\n> = Readonly<{\n    kind: 'single';\n    message: TTransactionMessage;\n}>;\n\n/**\n * Creates a {@link ParallelTransactionPlan} from an array of nested plans.\n *\n * It can accept {@link TransactionMessage} objects directly, which will be wrapped\n * in {@link SingleTransactionPlan | SingleTransactionPlans} automatically.\n *\n * @example\n * Using explicit {@link SingleTransactionPlan | SingleTransactionPlans}.\n * ```ts\n * const plan = parallelTransactionPlan([\n *   singleTransactionPlan(messageA),\n *   singleTransactionPlan(messageB),\n * ]);\n * ```\n *\n * @example\n * Using {@link TransactionMessage | TransactionMessages} directly.\n * ```ts\n * const plan = parallelTransactionPlan([messageA, messageB]);\n * ```\n *\n * @see {@link ParallelTransactionPlan}\n */\nexport function parallelTransactionPlan(\n    plans: (TransactionPlan | (BaseTransactionMessage & TransactionMessageWithFeePayer))[],\n): ParallelTransactionPlan {\n    return Object.freeze({ kind: 'parallel', plans: parseSingleTransactionPlans(plans) });\n}\n\n/**\n * Creates a divisible {@link SequentialTransactionPlan} from an array of nested plans.\n *\n * It can accept {@link TransactionMessage} objects directly, which will be wrapped\n * in {@link SingleTransactionPlan | SingleTransactionPlans} automatically.\n *\n * @example\n * Using explicit {@link SingleTransactionPlan | SingleTransactionPlans}.\n * ```ts\n * const plan = sequentialTransactionPlan([\n *   singleTransactionPlan(messageA),\n *   singleTransactionPlan(messageB),\n * ]);\n * ```\n *\n * @example\n * Using {@link TransactionMessage | TransactionMessages} directly.\n * ```ts\n * const plan = sequentialTransactionPlan([messageA, messageB]);\n * ```\n *\n * @see {@link SequentialTransactionPlan}\n */\nexport function sequentialTransactionPlan(\n    plans: (TransactionPlan | (BaseTransactionMessage & TransactionMessageWithFeePayer))[],\n): SequentialTransactionPlan & { divisible: true } {\n    return Object.freeze({ divisible: true, kind: 'sequential', plans: parseSingleTransactionPlans(plans) });\n}\n\n/**\n * Creates a non-divisible {@link SequentialTransactionPlan} from an array of nested plans.\n *\n * It can accept {@link TransactionMessage} objects directly, which will be wrapped\n * in {@link SingleTransactionPlan | SingleTransactionPlans} automatically.\n *\n * @example\n * Using explicit {@link SingleTransactionPlan | SingleTransactionPlans}.\n * ```ts\n * const plan = nonDivisibleSequentialTransactionPlan([\n *   singleTransactionPlan(messageA),\n *   singleTransactionPlan(messageB),\n * ]);\n * ```\n *\n * @example\n * Using {@link TransactionMessage | TransactionMessages} directly.\n * ```ts\n * const plan = nonDivisibleSequentialTransactionPlan([messageA, messageB]);\n * ```\n *\n * @see {@link SequentialTransactionPlan}\n */\nexport function nonDivisibleSequentialTransactionPlan(\n    plans: (TransactionPlan | (BaseTransactionMessage & TransactionMessageWithFeePayer))[],\n): SequentialTransactionPlan & { divisible: false } {\n    return Object.freeze({ divisible: false, kind: 'sequential', plans: parseSingleTransactionPlans(plans) });\n}\n\n/**\n * Creates a {@link SingleTransactionPlan} from a {@link TransactionMessage} object.\n *\n * @example\n * ```ts\n * const plan = singleTransactionPlan(transactionMessage);\n * plan satisfies SingleTransactionPlan;\n * ```\n *\n * @see {@link SingleTransactionPlan}\n */\nexport function singleTransactionPlan<\n    TTransactionMessage extends BaseTransactionMessage & TransactionMessageWithFeePayer = BaseTransactionMessage &\n        TransactionMessageWithFeePayer,\n>(transactionMessage: TTransactionMessage): SingleTransactionPlan<TTransactionMessage> {\n    return Object.freeze({ kind: 'single', message: transactionMessage });\n}\n\nfunction parseSingleTransactionPlans(\n    plans: (TransactionPlan | (BaseTransactionMessage & TransactionMessageWithFeePayer))[],\n): TransactionPlan[] {\n    return plans.map(plan => ('kind' in plan ? plan : singleTransactionPlan(plan)));\n}\n\n/**\n * Retrieves all individual {@link SingleTransactionPlan} instances from a transaction plan tree.\n *\n * This function recursively traverses any nested structure of transaction plans and extracts\n * all the single transaction plans they contain. It's useful when you need to access all\n * the actual transaction messages that will be executed, regardless of their organization\n * in the plan tree (parallel or sequential).\n *\n * @param transactionPlan - The transaction plan to extract single plans from\n * @returns An array of all single transaction plans contained in the tree\n *\n * @example\n * ```ts\n * const plan = parallelTransactionPlan([\n *   sequentialTransactionPlan([messageA, messageB]),\n *   nonDivisibleSequentialTransactionPlan([messageC, messageD]),\n *   messageE,\n * ]);\n *\n * const singlePlans = getAllSingleTransactionPlans(plan);\n * // Array of `SingleTransactionPlan` containing:\n * // messageA, messageB, messageC and messageD.\n * ```\n */\nexport function getAllSingleTransactionPlans(transactionPlan: TransactionPlan): SingleTransactionPlan[] {\n    if (transactionPlan.kind === 'single') {\n        return [transactionPlan];\n    }\n    return transactionPlan.plans.flatMap(getAllSingleTransactionPlans);\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  containsBytes,\n  getU8Encoder,\n  type Address,\n  type ReadonlyUint8Array,\n} from '@solana/kit';\nimport {\n  type ParsedCreateAssociatedTokenIdempotentInstruction,\n  type ParsedCreateAssociatedTokenInstruction,\n  type ParsedRecoverNestedAssociatedTokenInstruction,\n} from '../instructions';\n\nexport const ASSOCIATED_TOKEN_PROGRAM_ADDRESS =\n  'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL' as Address<'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL'>;\n\nexport enum AssociatedTokenInstruction {\n  CreateAssociatedToken,\n  CreateAssociatedTokenIdempotent,\n  RecoverNestedAssociatedToken,\n}\n\nexport function identifyAssociatedTokenInstruction(\n  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array\n): AssociatedTokenInstruction {\n  const data = 'data' in instruction ? instruction.data : instruction;\n  if (containsBytes(data, getU8Encoder().encode(0), 0)) {\n    return AssociatedTokenInstruction.CreateAssociatedToken;\n  }\n  if (containsBytes(data, getU8Encoder().encode(1), 0)) {\n    return AssociatedTokenInstruction.CreateAssociatedTokenIdempotent;\n  }\n  if (containsBytes(data, getU8Encoder().encode(2), 0)) {\n    return AssociatedTokenInstruction.RecoverNestedAssociatedToken;\n  }\n  throw new Error(\n    'The provided instruction could not be identified as a associatedToken instruction.'\n  );\n}\n\nexport type ParsedAssociatedTokenInstruction<\n  TProgram extends string = 'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL',\n> =\n  | ({\n      instructionType: AssociatedTokenInstruction.CreateAssociatedToken;\n    } & ParsedCreateAssociatedTokenInstruction<TProgram>)\n  | ({\n      instructionType: AssociatedTokenInstruction.CreateAssociatedTokenIdempotent;\n    } & ParsedCreateAssociatedTokenIdempotentInstruction<TProgram>)\n  | ({\n      instructionType: AssociatedTokenInstruction.RecoverNestedAssociatedToken;\n    } & ParsedRecoverNestedAssociatedTokenInstruction<TProgram>);\n","import {\n    isSolanaError,\n    SOLANA_ERROR__INSTRUCTION_PLANS__EMPTY_INSTRUCTION_PLAN,\n    SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN,\n    SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND,\n    SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND,\n    SolanaError,\n} from '@solana/errors';\nimport { getAbortablePromise } from '@solana/promises';\nimport {\n    appendTransactionMessageInstructions,\n    BaseTransactionMessage,\n    TransactionMessageWithFeePayer,\n} from '@solana/transaction-messages';\nimport { getTransactionMessageSize, TRANSACTION_SIZE_LIMIT } from '@solana/transactions';\n\nimport {\n    InstructionPlan,\n    MessagePackerInstructionPlan,\n    ParallelInstructionPlan,\n    SequentialInstructionPlan,\n    SingleInstructionPlan,\n} from './instruction-plan';\nimport {\n    getAllSingleTransactionPlans,\n    nonDivisibleSequentialTransactionPlan,\n    parallelTransactionPlan,\n    sequentialTransactionPlan,\n    SingleTransactionPlan,\n    singleTransactionPlan,\n    TransactionPlan,\n} from './transaction-plan';\n\n/**\n * Plans one or more transactions according to the provided instruction plan.\n *\n * @param instructionPlan - The instruction plan to be planned and executed.\n * @param config - Optional configuration object that can include an `AbortSignal` to cancel the planning process.\n *\n * @see {@link InstructionPlan}\n * @see {@link TransactionPlan}\n */\nexport type TransactionPlanner = (\n    instructionPlan: InstructionPlan,\n    config?: { abortSignal?: AbortSignal },\n) => Promise<TransactionPlan>;\n\ntype Mutable<T> = { -readonly [P in keyof T]: T[P] };\n\ntype CreateTransactionMessage = (config?: {\n    abortSignal?: AbortSignal;\n}) =>\n    | Promise<BaseTransactionMessage & TransactionMessageWithFeePayer>\n    | (BaseTransactionMessage & TransactionMessageWithFeePayer);\n\ntype OnTransactionMessageUpdated = (\n    transactionMessage: BaseTransactionMessage & TransactionMessageWithFeePayer,\n    config?: { abortSignal?: AbortSignal },\n) =>\n    | Promise<BaseTransactionMessage & TransactionMessageWithFeePayer>\n    | (BaseTransactionMessage & TransactionMessageWithFeePayer);\n\n/**\n * Configuration object for creating a new transaction planner.\n *\n * @see {@link createTransactionPlanner}\n */\nexport type TransactionPlannerConfig = {\n    /** Called whenever a new transaction message is needed. */\n    createTransactionMessage: CreateTransactionMessage;\n    /**\n     * Called whenever a transaction message is updated  e.g. new instructions were added.\n     * This function must return the updated transaction message back  even if no changes were made.\n     */\n    onTransactionMessageUpdated?: OnTransactionMessageUpdated;\n};\n\n/**\n * Creates a new transaction planner based on the provided configuration.\n *\n * At the very least, the `createTransactionMessage` function must be provided.\n * This function is used to create new transaction messages whenever needed.\n *\n * Additionally, the `onTransactionMessageUpdated` function can be provided\n * to update transaction messages during the planning process. This function will\n * be called whenever a transaction message is updated, e.g. when new instructions\n * are added to a transaction message. It accepts the updated transaction message\n * and must return a transaction message back, even if no changes were made.\n *\n * @example\n * ```ts\n * const transactionPlanner = createTransactionPlanner({\n *   createTransactionMessage: () => pipe(\n *     createTransactionMessage({ version: 0 }),\n *     message => setTransactionMessageFeePayerSigner(mySigner, message),\n *   )\n * });\n * ```\n *\n * @see {@link TransactionPlannerConfig}\n */\nexport function createTransactionPlanner(config: TransactionPlannerConfig): TransactionPlanner {\n    return async (instructionPlan, { abortSignal } = {}): Promise<TransactionPlan> => {\n        const plan = await traverse(instructionPlan, {\n            abortSignal,\n            createTransactionMessage: config.createTransactionMessage,\n            onTransactionMessageUpdated: config.onTransactionMessageUpdated ?? (msg => msg),\n            parent: null,\n            parentCandidates: [],\n        });\n\n        if (!plan) {\n            throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__EMPTY_INSTRUCTION_PLAN);\n        }\n\n        return freezeTransactionPlan(plan);\n    };\n}\n\ntype MutableTransactionPlan = Mutable<TransactionPlan>;\ntype MutableSingleTransactionPlan = Mutable<SingleTransactionPlan>;\n\ntype TraverseContext = {\n    abortSignal?: AbortSignal;\n    createTransactionMessage: CreateTransactionMessage;\n    onTransactionMessageUpdated: OnTransactionMessageUpdated;\n    parent: InstructionPlan | null;\n    parentCandidates: MutableSingleTransactionPlan[];\n};\n\nasync function traverse(\n    instructionPlan: InstructionPlan,\n    context: TraverseContext,\n): Promise<MutableTransactionPlan | null> {\n    context.abortSignal?.throwIfAborted();\n    const kind = instructionPlan.kind;\n    switch (kind) {\n        case 'sequential':\n            return await traverseSequential(instructionPlan, context);\n        case 'parallel':\n            return await traverseParallel(instructionPlan, context);\n        case 'single':\n            return await traverseSingle(instructionPlan, context);\n        case 'messagePacker':\n            return await traverseMessagePacker(instructionPlan, context);\n        default:\n            instructionPlan satisfies never;\n            throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND, { kind });\n    }\n}\n\nasync function traverseSequential(\n    instructionPlan: SequentialInstructionPlan,\n    context: TraverseContext,\n): Promise<MutableTransactionPlan | null> {\n    let candidate: MutableSingleTransactionPlan | null = null;\n\n    // Check if the sequential plan must fit entirely in its parent candidates\n    // due to constraints like being inside a parallel plan or not being divisible.\n    const mustEntirelyFitInParentCandidate =\n        context.parent && (context.parent.kind === 'parallel' || !instructionPlan.divisible);\n\n    // If so, try to fit the entire plan inside one of the parent candidates.\n    if (mustEntirelyFitInParentCandidate) {\n        const candidate = await selectAndMutateCandidate(context, context.parentCandidates, message =>\n            fitEntirePlanInsideMessage(instructionPlan, message),\n        );\n        // If that's possible, we the candidate is mutated and we can return null.\n        // Otherwise, we proceed with the normal traversal and no parent candidate.\n        if (candidate) {\n            return null;\n        }\n    } else {\n        // Otherwise, we can use the first parent candidate, if any,\n        // since we know it must be a divisible sequential plan.\n        candidate = context.parentCandidates.length > 0 ? context.parentCandidates[0] : null;\n    }\n\n    const transactionPlans: TransactionPlan[] = [];\n    for (const plan of instructionPlan.plans) {\n        const transactionPlan = await traverse(plan, {\n            ...context,\n            parent: instructionPlan,\n            parentCandidates: candidate ? [candidate] : [],\n        });\n        if (transactionPlan) {\n            candidate = getSequentialCandidate(transactionPlan);\n            const newPlans =\n                transactionPlan.kind === 'sequential' && (transactionPlan.divisible || !instructionPlan.divisible)\n                    ? transactionPlan.plans\n                    : [transactionPlan];\n            transactionPlans.push(...newPlans);\n        }\n    }\n\n    // Wrap in a sequential plan or simplify.\n    if (transactionPlans.length === 1) {\n        return transactionPlans[0];\n    }\n    if (transactionPlans.length === 0) {\n        return null;\n    }\n    return {\n        divisible: instructionPlan.divisible,\n        kind: 'sequential',\n        plans: transactionPlans,\n    };\n}\n\nasync function traverseParallel(\n    instructionPlan: ParallelInstructionPlan,\n    context: TraverseContext,\n): Promise<MutableTransactionPlan | null> {\n    const candidates: MutableSingleTransactionPlan[] = [...context.parentCandidates];\n    const transactionPlans: TransactionPlan[] = [];\n\n    // Reorder children so message packer plans are last.\n    const sortedChildren = Array.from(instructionPlan.plans).sort(\n        (a, b) => Number(a.kind === 'messagePacker') - Number(b.kind === 'messagePacker'),\n    );\n\n    for (const plan of sortedChildren) {\n        const transactionPlan = await traverse(plan, {\n            ...context,\n            parent: instructionPlan,\n            parentCandidates: candidates,\n        });\n        if (transactionPlan) {\n            candidates.push(...getParallelCandidates(transactionPlan));\n            const newPlans = transactionPlan.kind === 'parallel' ? transactionPlan.plans : [transactionPlan];\n            transactionPlans.push(...newPlans);\n        }\n    }\n\n    // Wrap in a parallel plan or simplify.\n    if (transactionPlans.length === 1) {\n        return transactionPlans[0];\n    }\n    if (transactionPlans.length === 0) {\n        return null;\n    }\n    return { kind: 'parallel', plans: transactionPlans };\n}\n\nasync function traverseSingle(\n    instructionPlan: SingleInstructionPlan,\n    context: TraverseContext,\n): Promise<MutableTransactionPlan | null> {\n    const predicate = (message: BaseTransactionMessage & TransactionMessageWithFeePayer) =>\n        appendTransactionMessageInstructions([instructionPlan.instruction], message);\n    const candidate = await selectAndMutateCandidate(context, context.parentCandidates, predicate);\n    if (candidate) {\n        return null;\n    }\n    const message = await createNewMessage(context, predicate);\n    return { kind: 'single', message };\n}\n\nasync function traverseMessagePacker(\n    instructionPlan: MessagePackerInstructionPlan,\n    context: TraverseContext,\n): Promise<MutableTransactionPlan | null> {\n    const messagePacker = instructionPlan.getMessagePacker();\n    const transactionPlans: SingleTransactionPlan[] = [];\n    const candidates = [...context.parentCandidates];\n\n    while (!messagePacker.done()) {\n        const candidate = await selectAndMutateCandidate(context, candidates, messagePacker.packMessageToCapacity);\n        if (!candidate) {\n            const message = await createNewMessage(context, messagePacker.packMessageToCapacity);\n            const newPlan: MutableSingleTransactionPlan = { kind: 'single', message };\n            transactionPlans.push(newPlan);\n        }\n    }\n\n    if (transactionPlans.length === 1) {\n        return transactionPlans[0];\n    }\n    if (transactionPlans.length === 0) {\n        return null;\n    }\n    if (context.parent?.kind === 'parallel') {\n        return { kind: 'parallel', plans: transactionPlans };\n    }\n    return {\n        divisible: context.parent?.kind === 'sequential' ? context.parent.divisible : true,\n        kind: 'sequential',\n        plans: transactionPlans,\n    };\n}\n\nfunction getSequentialCandidate(latestPlan: MutableTransactionPlan): MutableSingleTransactionPlan | null {\n    if (latestPlan.kind === 'single') {\n        return latestPlan;\n    }\n    if (latestPlan.kind === 'sequential' && latestPlan.plans.length > 0) {\n        return getSequentialCandidate(latestPlan.plans[latestPlan.plans.length - 1]);\n    }\n    return null;\n}\n\nfunction getParallelCandidates(latestPlan: TransactionPlan): MutableSingleTransactionPlan[] {\n    return getAllSingleTransactionPlans(latestPlan);\n}\n\nasync function selectAndMutateCandidate(\n    context: Pick<TraverseContext, 'abortSignal' | 'onTransactionMessageUpdated'>,\n    candidates: MutableSingleTransactionPlan[],\n    predicate: (\n        message: BaseTransactionMessage & TransactionMessageWithFeePayer,\n    ) => BaseTransactionMessage & TransactionMessageWithFeePayer,\n): Promise<MutableSingleTransactionPlan | null> {\n    for (const candidate of candidates) {\n        try {\n            const message = await getAbortablePromise(\n                Promise.resolve(\n                    context.onTransactionMessageUpdated(predicate(candidate.message), {\n                        abortSignal: context.abortSignal,\n                    }),\n                ),\n                context.abortSignal,\n            );\n            if (getTransactionMessageSize(message) <= TRANSACTION_SIZE_LIMIT) {\n                candidate.message = message;\n                return candidate;\n            }\n        } catch (error) {\n            if (isSolanaError(error, SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN)) {\n                // Try the next candidate.\n            } else {\n                throw error;\n            }\n        }\n    }\n    return null;\n}\n\nasync function createNewMessage(\n    context: Pick<TraverseContext, 'abortSignal' | 'createTransactionMessage' | 'onTransactionMessageUpdated'>,\n    predicate: (\n        message: BaseTransactionMessage & TransactionMessageWithFeePayer,\n    ) => BaseTransactionMessage & TransactionMessageWithFeePayer,\n): Promise<BaseTransactionMessage & TransactionMessageWithFeePayer> {\n    const newMessage = await getAbortablePromise(\n        Promise.resolve(context.createTransactionMessage({ abortSignal: context.abortSignal })),\n        context.abortSignal,\n    );\n    const updatedMessage = await getAbortablePromise(\n        Promise.resolve(\n            context.onTransactionMessageUpdated(predicate(newMessage), { abortSignal: context.abortSignal }),\n        ),\n        context.abortSignal,\n    );\n    const updatedMessageSize = getTransactionMessageSize(updatedMessage);\n    if (updatedMessageSize > TRANSACTION_SIZE_LIMIT) {\n        const newMessageSize = getTransactionMessageSize(newMessage);\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN, {\n            numBytesRequired: updatedMessageSize - newMessageSize,\n            numFreeBytes: TRANSACTION_SIZE_LIMIT - newMessageSize,\n        });\n    }\n    return updatedMessage;\n}\n\nfunction freezeTransactionPlan(plan: MutableTransactionPlan): TransactionPlan {\n    const kind = plan.kind;\n    switch (kind) {\n        case 'single':\n            return singleTransactionPlan(plan.message);\n        case 'sequential':\n            return plan.divisible\n                ? sequentialTransactionPlan(plan.plans.map(freezeTransactionPlan))\n                : nonDivisibleSequentialTransactionPlan(plan.plans.map(freezeTransactionPlan));\n        case 'parallel':\n            return parallelTransactionPlan(plan.plans.map(freezeTransactionPlan));\n        default:\n            plan satisfies never;\n            throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND, { kind });\n    }\n}\n\nfunction fitEntirePlanInsideMessage(\n    instructionPlan: InstructionPlan,\n    message: BaseTransactionMessage & TransactionMessageWithFeePayer,\n): BaseTransactionMessage & TransactionMessageWithFeePayer {\n    let newMessage: BaseTransactionMessage & TransactionMessageWithFeePayer = message;\n\n    const kind = instructionPlan.kind;\n    switch (kind) {\n        case 'sequential':\n        case 'parallel':\n            for (const plan of instructionPlan.plans) {\n                newMessage = fitEntirePlanInsideMessage(plan, newMessage);\n            }\n            return newMessage;\n        case 'single':\n            newMessage = appendTransactionMessageInstructions([instructionPlan.instruction], message);\n            // eslint-disable-next-line no-case-declarations\n            const newMessageSize = getTransactionMessageSize(newMessage);\n            if (newMessageSize > TRANSACTION_SIZE_LIMIT) {\n                const baseMessageSize = getTransactionMessageSize(message);\n                throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN, {\n                    numBytesRequired: newMessageSize - baseMessageSize,\n                    numFreeBytes: TRANSACTION_SIZE_LIMIT - baseMessageSize,\n                });\n            }\n            return newMessage;\n        case 'messagePacker':\n            // eslint-disable-next-line no-case-declarations\n            const messagePacker = instructionPlan.getMessagePacker();\n            while (!messagePacker.done()) {\n                newMessage = messagePacker.packMessageToCapacity(message);\n            }\n            return newMessage;\n        default:\n            instructionPlan satisfies never;\n            throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND, { kind });\n    }\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  containsBytes,\n  getU8Encoder,\n  type Address,\n  type ReadonlyUint8Array,\n} from '@solana/kit';\nimport {\n  type ParsedAmountToUiAmountInstruction,\n  type ParsedApproveCheckedInstruction,\n  type ParsedApproveInstruction,\n  type ParsedBurnCheckedInstruction,\n  type ParsedBurnInstruction,\n  type ParsedCloseAccountInstruction,\n  type ParsedFreezeAccountInstruction,\n  type ParsedGetAccountDataSizeInstruction,\n  type ParsedInitializeAccount2Instruction,\n  type ParsedInitializeAccount3Instruction,\n  type ParsedInitializeAccountInstruction,\n  type ParsedInitializeImmutableOwnerInstruction,\n  type ParsedInitializeMint2Instruction,\n  type ParsedInitializeMintInstruction,\n  type ParsedInitializeMultisig2Instruction,\n  type ParsedInitializeMultisigInstruction,\n  type ParsedMintToCheckedInstruction,\n  type ParsedMintToInstruction,\n  type ParsedRevokeInstruction,\n  type ParsedSetAuthorityInstruction,\n  type ParsedSyncNativeInstruction,\n  type ParsedThawAccountInstruction,\n  type ParsedTransferCheckedInstruction,\n  type ParsedTransferInstruction,\n  type ParsedUiAmountToAmountInstruction,\n} from '../instructions';\n\nexport const TOKEN_PROGRAM_ADDRESS =\n  'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address<'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'>;\n\nexport enum TokenAccount {\n  Mint,\n  Token,\n  Multisig,\n}\n\nexport function identifyTokenAccount(\n  account: { data: ReadonlyUint8Array } | ReadonlyUint8Array\n): TokenAccount {\n  const data = 'data' in account ? account.data : account;\n  if (data.length === 82) {\n    return TokenAccount.Mint;\n  }\n  if (data.length === 165) {\n    return TokenAccount.Token;\n  }\n  if (data.length === 355) {\n    return TokenAccount.Multisig;\n  }\n  throw new Error(\n    'The provided account could not be identified as a token account.'\n  );\n}\n\nexport enum TokenInstruction {\n  InitializeMint,\n  InitializeAccount,\n  InitializeMultisig,\n  Transfer,\n  Approve,\n  Revoke,\n  SetAuthority,\n  MintTo,\n  Burn,\n  CloseAccount,\n  FreezeAccount,\n  ThawAccount,\n  TransferChecked,\n  ApproveChecked,\n  MintToChecked,\n  BurnChecked,\n  InitializeAccount2,\n  SyncNative,\n  InitializeAccount3,\n  InitializeMultisig2,\n  InitializeMint2,\n  GetAccountDataSize,\n  InitializeImmutableOwner,\n  AmountToUiAmount,\n  UiAmountToAmount,\n}\n\nexport function identifyTokenInstruction(\n  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array\n): TokenInstruction {\n  const data = 'data' in instruction ? instruction.data : instruction;\n  if (containsBytes(data, getU8Encoder().encode(0), 0)) {\n    return TokenInstruction.InitializeMint;\n  }\n  if (containsBytes(data, getU8Encoder().encode(1), 0)) {\n    return TokenInstruction.InitializeAccount;\n  }\n  if (containsBytes(data, getU8Encoder().encode(2), 0)) {\n    return TokenInstruction.InitializeMultisig;\n  }\n  if (containsBytes(data, getU8Encoder().encode(3), 0)) {\n    return TokenInstruction.Transfer;\n  }\n  if (containsBytes(data, getU8Encoder().encode(4), 0)) {\n    return TokenInstruction.Approve;\n  }\n  if (containsBytes(data, getU8Encoder().encode(5), 0)) {\n    return TokenInstruction.Revoke;\n  }\n  if (containsBytes(data, getU8Encoder().encode(6), 0)) {\n    return TokenInstruction.SetAuthority;\n  }\n  if (containsBytes(data, getU8Encoder().encode(7), 0)) {\n    return TokenInstruction.MintTo;\n  }\n  if (containsBytes(data, getU8Encoder().encode(8), 0)) {\n    return TokenInstruction.Burn;\n  }\n  if (containsBytes(data, getU8Encoder().encode(9), 0)) {\n    return TokenInstruction.CloseAccount;\n  }\n  if (containsBytes(data, getU8Encoder().encode(10), 0)) {\n    return TokenInstruction.FreezeAccount;\n  }\n  if (containsBytes(data, getU8Encoder().encode(11), 0)) {\n    return TokenInstruction.ThawAccount;\n  }\n  if (containsBytes(data, getU8Encoder().encode(12), 0)) {\n    return TokenInstruction.TransferChecked;\n  }\n  if (containsBytes(data, getU8Encoder().encode(13), 0)) {\n    return TokenInstruction.ApproveChecked;\n  }\n  if (containsBytes(data, getU8Encoder().encode(14), 0)) {\n    return TokenInstruction.MintToChecked;\n  }\n  if (containsBytes(data, getU8Encoder().encode(15), 0)) {\n    return TokenInstruction.BurnChecked;\n  }\n  if (containsBytes(data, getU8Encoder().encode(16), 0)) {\n    return TokenInstruction.InitializeAccount2;\n  }\n  if (containsBytes(data, getU8Encoder().encode(17), 0)) {\n    return TokenInstruction.SyncNative;\n  }\n  if (containsBytes(data, getU8Encoder().encode(18), 0)) {\n    return TokenInstruction.InitializeAccount3;\n  }\n  if (containsBytes(data, getU8Encoder().encode(19), 0)) {\n    return TokenInstruction.InitializeMultisig2;\n  }\n  if (containsBytes(data, getU8Encoder().encode(20), 0)) {\n    return TokenInstruction.InitializeMint2;\n  }\n  if (containsBytes(data, getU8Encoder().encode(21), 0)) {\n    return TokenInstruction.GetAccountDataSize;\n  }\n  if (containsBytes(data, getU8Encoder().encode(22), 0)) {\n    return TokenInstruction.InitializeImmutableOwner;\n  }\n  if (containsBytes(data, getU8Encoder().encode(23), 0)) {\n    return TokenInstruction.AmountToUiAmount;\n  }\n  if (containsBytes(data, getU8Encoder().encode(24), 0)) {\n    return TokenInstruction.UiAmountToAmount;\n  }\n  throw new Error(\n    'The provided instruction could not be identified as a token instruction.'\n  );\n}\n\nexport type ParsedTokenInstruction<\n  TProgram extends string = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',\n> =\n  | ({\n      instructionType: TokenInstruction.InitializeMint;\n    } & ParsedInitializeMintInstruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.InitializeAccount;\n    } & ParsedInitializeAccountInstruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.InitializeMultisig;\n    } & ParsedInitializeMultisigInstruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.Transfer;\n    } & ParsedTransferInstruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.Approve;\n    } & ParsedApproveInstruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.Revoke;\n    } & ParsedRevokeInstruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.SetAuthority;\n    } & ParsedSetAuthorityInstruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.MintTo;\n    } & ParsedMintToInstruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.Burn;\n    } & ParsedBurnInstruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.CloseAccount;\n    } & ParsedCloseAccountInstruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.FreezeAccount;\n    } & ParsedFreezeAccountInstruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.ThawAccount;\n    } & ParsedThawAccountInstruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.TransferChecked;\n    } & ParsedTransferCheckedInstruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.ApproveChecked;\n    } & ParsedApproveCheckedInstruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.MintToChecked;\n    } & ParsedMintToCheckedInstruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.BurnChecked;\n    } & ParsedBurnCheckedInstruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.InitializeAccount2;\n    } & ParsedInitializeAccount2Instruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.SyncNative;\n    } & ParsedSyncNativeInstruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.InitializeAccount3;\n    } & ParsedInitializeAccount3Instruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.InitializeMultisig2;\n    } & ParsedInitializeMultisig2Instruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.InitializeMint2;\n    } & ParsedInitializeMint2Instruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.GetAccountDataSize;\n    } & ParsedGetAccountDataSizeInstruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.InitializeImmutableOwner;\n    } & ParsedInitializeImmutableOwnerInstruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.AmountToUiAmount;\n    } & ParsedAmountToUiAmountInstruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.UiAmountToAmount;\n    } & ParsedUiAmountToAmountInstruction<TProgram>);\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  isProgramError,\n  type Address,\n  type SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM,\n  type SolanaError,\n} from '@solana/kit';\nimport { ASSOCIATED_TOKEN_PROGRAM_ADDRESS } from '../programs';\n\n/** InvalidOwner: Associated token account owner does not match address derivation */\nexport const ASSOCIATED_TOKEN_ERROR__INVALID_OWNER = 0x0; // 0\n\nexport type AssociatedTokenError = typeof ASSOCIATED_TOKEN_ERROR__INVALID_OWNER;\n\nlet associatedTokenErrorMessages:\n  | Record<AssociatedTokenError, string>\n  | undefined;\nif (process.env.NODE_ENV !== 'production') {\n  associatedTokenErrorMessages = {\n    [ASSOCIATED_TOKEN_ERROR__INVALID_OWNER]: `Associated token account owner does not match address derivation`,\n  };\n}\n\nexport function getAssociatedTokenErrorMessage(\n  code: AssociatedTokenError\n): string {\n  if (process.env.NODE_ENV !== 'production') {\n    return (\n      associatedTokenErrorMessages as Record<AssociatedTokenError, string>\n    )[code];\n  }\n\n  return 'Error message not available in production bundles.';\n}\n\nexport function isAssociatedTokenError<\n  TProgramErrorCode extends AssociatedTokenError,\n>(\n  error: unknown,\n  transactionMessage: {\n    instructions: Record<number, { programAddress: Address }>;\n  },\n  code?: TProgramErrorCode\n): error is SolanaError<typeof SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM> &\n  Readonly<{ context: Readonly<{ code: TProgramErrorCode }> }> {\n  return isProgramError<TProgramErrorCode>(\n    error,\n    transactionMessage,\n    ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n    code\n  );\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  isProgramError,\n  type Address,\n  type SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM,\n  type SolanaError,\n} from '@solana/kit';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\n\n/** NotRentExempt: Lamport balance below rent-exempt threshold */\nexport const TOKEN_ERROR__NOT_RENT_EXEMPT = 0x0; // 0\n/** InsufficientFunds: Insufficient funds */\nexport const TOKEN_ERROR__INSUFFICIENT_FUNDS = 0x1; // 1\n/** InvalidMint: Invalid Mint */\nexport const TOKEN_ERROR__INVALID_MINT = 0x2; // 2\n/** MintMismatch: Account not associated with this Mint */\nexport const TOKEN_ERROR__MINT_MISMATCH = 0x3; // 3\n/** OwnerMismatch: Owner does not match */\nexport const TOKEN_ERROR__OWNER_MISMATCH = 0x4; // 4\n/** FixedSupply: Fixed supply */\nexport const TOKEN_ERROR__FIXED_SUPPLY = 0x5; // 5\n/** AlreadyInUse: Already in use */\nexport const TOKEN_ERROR__ALREADY_IN_USE = 0x6; // 6\n/** InvalidNumberOfProvidedSigners: Invalid number of provided signers */\nexport const TOKEN_ERROR__INVALID_NUMBER_OF_PROVIDED_SIGNERS = 0x7; // 7\n/** InvalidNumberOfRequiredSigners: Invalid number of required signers */\nexport const TOKEN_ERROR__INVALID_NUMBER_OF_REQUIRED_SIGNERS = 0x8; // 8\n/** UninitializedState: State is unititialized */\nexport const TOKEN_ERROR__UNINITIALIZED_STATE = 0x9; // 9\n/** NativeNotSupported: Instruction does not support native tokens */\nexport const TOKEN_ERROR__NATIVE_NOT_SUPPORTED = 0xa; // 10\n/** NonNativeHasBalance: Non-native account can only be closed if its balance is zero */\nexport const TOKEN_ERROR__NON_NATIVE_HAS_BALANCE = 0xb; // 11\n/** InvalidInstruction: Invalid instruction */\nexport const TOKEN_ERROR__INVALID_INSTRUCTION = 0xc; // 12\n/** InvalidState: State is invalid for requested operation */\nexport const TOKEN_ERROR__INVALID_STATE = 0xd; // 13\n/** Overflow: Operation overflowed */\nexport const TOKEN_ERROR__OVERFLOW = 0xe; // 14\n/** AuthorityTypeNotSupported: Account does not support specified authority type */\nexport const TOKEN_ERROR__AUTHORITY_TYPE_NOT_SUPPORTED = 0xf; // 15\n/** MintCannotFreeze: This token mint cannot freeze accounts */\nexport const TOKEN_ERROR__MINT_CANNOT_FREEZE = 0x10; // 16\n/** AccountFrozen: Account is frozen */\nexport const TOKEN_ERROR__ACCOUNT_FROZEN = 0x11; // 17\n/** MintDecimalsMismatch: The provided decimals value different from the Mint decimals */\nexport const TOKEN_ERROR__MINT_DECIMALS_MISMATCH = 0x12; // 18\n/** NonNativeNotSupported: Instruction does not support non-native tokens */\nexport const TOKEN_ERROR__NON_NATIVE_NOT_SUPPORTED = 0x13; // 19\n\nexport type TokenError =\n  | typeof TOKEN_ERROR__ACCOUNT_FROZEN\n  | typeof TOKEN_ERROR__ALREADY_IN_USE\n  | typeof TOKEN_ERROR__AUTHORITY_TYPE_NOT_SUPPORTED\n  | typeof TOKEN_ERROR__FIXED_SUPPLY\n  | typeof TOKEN_ERROR__INSUFFICIENT_FUNDS\n  | typeof TOKEN_ERROR__INVALID_INSTRUCTION\n  | typeof TOKEN_ERROR__INVALID_MINT\n  | typeof TOKEN_ERROR__INVALID_NUMBER_OF_PROVIDED_SIGNERS\n  | typeof TOKEN_ERROR__INVALID_NUMBER_OF_REQUIRED_SIGNERS\n  | typeof TOKEN_ERROR__INVALID_STATE\n  | typeof TOKEN_ERROR__MINT_CANNOT_FREEZE\n  | typeof TOKEN_ERROR__MINT_DECIMALS_MISMATCH\n  | typeof TOKEN_ERROR__MINT_MISMATCH\n  | typeof TOKEN_ERROR__NATIVE_NOT_SUPPORTED\n  | typeof TOKEN_ERROR__NON_NATIVE_HAS_BALANCE\n  | typeof TOKEN_ERROR__NON_NATIVE_NOT_SUPPORTED\n  | typeof TOKEN_ERROR__NOT_RENT_EXEMPT\n  | typeof TOKEN_ERROR__OVERFLOW\n  | typeof TOKEN_ERROR__OWNER_MISMATCH\n  | typeof TOKEN_ERROR__UNINITIALIZED_STATE;\n\nlet tokenErrorMessages: Record<TokenError, string> | undefined;\nif (process.env.NODE_ENV !== 'production') {\n  tokenErrorMessages = {\n    [TOKEN_ERROR__ACCOUNT_FROZEN]: `Account is frozen`,\n    [TOKEN_ERROR__ALREADY_IN_USE]: `Already in use`,\n    [TOKEN_ERROR__AUTHORITY_TYPE_NOT_SUPPORTED]: `Account does not support specified authority type`,\n    [TOKEN_ERROR__FIXED_SUPPLY]: `Fixed supply`,\n    [TOKEN_ERROR__INSUFFICIENT_FUNDS]: `Insufficient funds`,\n    [TOKEN_ERROR__INVALID_INSTRUCTION]: `Invalid instruction`,\n    [TOKEN_ERROR__INVALID_MINT]: `Invalid Mint`,\n    [TOKEN_ERROR__INVALID_NUMBER_OF_PROVIDED_SIGNERS]: `Invalid number of provided signers`,\n    [TOKEN_ERROR__INVALID_NUMBER_OF_REQUIRED_SIGNERS]: `Invalid number of required signers`,\n    [TOKEN_ERROR__INVALID_STATE]: `State is invalid for requested operation`,\n    [TOKEN_ERROR__MINT_CANNOT_FREEZE]: `This token mint cannot freeze accounts`,\n    [TOKEN_ERROR__MINT_DECIMALS_MISMATCH]: `The provided decimals value different from the Mint decimals`,\n    [TOKEN_ERROR__MINT_MISMATCH]: `Account not associated with this Mint`,\n    [TOKEN_ERROR__NATIVE_NOT_SUPPORTED]: `Instruction does not support native tokens`,\n    [TOKEN_ERROR__NON_NATIVE_HAS_BALANCE]: `Non-native account can only be closed if its balance is zero`,\n    [TOKEN_ERROR__NON_NATIVE_NOT_SUPPORTED]: `Instruction does not support non-native tokens`,\n    [TOKEN_ERROR__NOT_RENT_EXEMPT]: `Lamport balance below rent-exempt threshold`,\n    [TOKEN_ERROR__OVERFLOW]: `Operation overflowed`,\n    [TOKEN_ERROR__OWNER_MISMATCH]: `Owner does not match`,\n    [TOKEN_ERROR__UNINITIALIZED_STATE]: `State is unititialized`,\n  };\n}\n\nexport function getTokenErrorMessage(code: TokenError): string {\n  if (process.env.NODE_ENV !== 'production') {\n    return (tokenErrorMessages as Record<TokenError, string>)[code];\n  }\n\n  return 'Error message not available in production bundles.';\n}\n\nexport function isTokenError<TProgramErrorCode extends TokenError>(\n  error: unknown,\n  transactionMessage: {\n    instructions: Record<number, { programAddress: Address }>;\n  },\n  code?: TProgramErrorCode\n): error is SolanaError<typeof SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM> &\n  Readonly<{ context: Readonly<{ code: TProgramErrorCode }> }> {\n  return isProgramError<TProgramErrorCode>(\n    error,\n    transactionMessage,\n    TOKEN_PROGRAM_ADDRESS,\n    code\n  );\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  isProgramDerivedAddress,\n  isTransactionSigner as kitIsTransactionSigner,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type ProgramDerivedAddress,\n  type TransactionSigner,\n  upgradeRoleToSigner,\n} from '@solana/kit';\n\n/**\n * Asserts that the given value is not null or undefined.\n * @internal\n */\nexport function expectSome<T>(value: T | null | undefined): T {\n  if (value === null || value === undefined) {\n    throw new Error('Expected a value but received null or undefined.');\n  }\n  return value;\n}\n\n/**\n * Asserts that the given value is a PublicKey.\n * @internal\n */\nexport function expectAddress<T extends string = string>(\n  value:\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null\n    | undefined\n): Address<T> {\n  if (!value) {\n    throw new Error('Expected a Address.');\n  }\n  if (typeof value === 'object' && 'address' in value) {\n    return value.address;\n  }\n  if (Array.isArray(value)) {\n    return value[0] as Address<T>;\n  }\n  return value as Address<T>;\n}\n\n/**\n * Asserts that the given value is a PDA.\n * @internal\n */\nexport function expectProgramDerivedAddress<T extends string = string>(\n  value:\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null\n    | undefined\n): ProgramDerivedAddress<T> {\n  if (!value || !Array.isArray(value) || !isProgramDerivedAddress(value)) {\n    throw new Error('Expected a ProgramDerivedAddress.');\n  }\n  return value;\n}\n\n/**\n * Asserts that the given value is a TransactionSigner.\n * @internal\n */\nexport function expectTransactionSigner<T extends string = string>(\n  value:\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null\n    | undefined\n): TransactionSigner<T> {\n  if (!value || !isTransactionSigner(value)) {\n    throw new Error('Expected a TransactionSigner.');\n  }\n  return value;\n}\n\n/**\n * Defines an instruction account to resolve.\n * @internal\n */\nexport type ResolvedAccount<\n  T extends string = string,\n  U extends\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null =\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null,\n> = {\n  isWritable: boolean;\n  value: U;\n};\n\n/**\n * Defines an instruction that stores additional bytes on-chain.\n * @internal\n */\nexport type InstructionWithByteDelta = {\n  byteDelta: number;\n};\n\n/**\n * Get account metas and signers from resolved accounts.\n * @internal\n */\nexport function getAccountMetaFactory(\n  programAddress: Address,\n  optionalAccountStrategy: 'omitted' | 'programId'\n) {\n  return (\n    account: ResolvedAccount\n  ): AccountMeta | AccountSignerMeta | undefined => {\n    if (!account.value) {\n      if (optionalAccountStrategy === 'omitted') return;\n      return Object.freeze({\n        address: programAddress,\n        role: AccountRole.READONLY,\n      });\n    }\n\n    const writableRole = account.isWritable\n      ? AccountRole.WRITABLE\n      : AccountRole.READONLY;\n    return Object.freeze({\n      address: expectAddress(account.value),\n      role: isTransactionSigner(account.value)\n        ? upgradeRoleToSigner(writableRole)\n        : writableRole,\n      ...(isTransactionSigner(account.value) ? { signer: account.value } : {}),\n    });\n  };\n}\n\nexport function isTransactionSigner<TAddress extends string = string>(\n  value:\n    | Address<TAddress>\n    | ProgramDerivedAddress<TAddress>\n    | TransactionSigner<TAddress>\n): value is TransactionSigner<TAddress> {\n  return (\n    !!value &&\n    typeof value === 'object' &&\n    'address' in value &&\n    kitIsTransactionSigner(value)\n  );\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlyUint8Array,\n} from '@solana/kit';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const AMOUNT_TO_UI_AMOUNT_DISCRIMINATOR = 23;\n\nexport function getAmountToUiAmountDiscriminatorBytes() {\n  return getU8Encoder().encode(AMOUNT_TO_UI_AMOUNT_DISCRIMINATOR);\n}\n\nexport type AmountToUiAmountInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type AmountToUiAmountInstructionData = {\n  discriminator: number;\n  /** The amount of tokens to reformat. */\n  amount: bigint;\n};\n\nexport type AmountToUiAmountInstructionDataArgs = {\n  /** The amount of tokens to reformat. */\n  amount: number | bigint;\n};\n\nexport function getAmountToUiAmountInstructionDataEncoder(): FixedSizeEncoder<AmountToUiAmountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: AMOUNT_TO_UI_AMOUNT_DISCRIMINATOR })\n  );\n}\n\nexport function getAmountToUiAmountInstructionDataDecoder(): FixedSizeDecoder<AmountToUiAmountInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n  ]);\n}\n\nexport function getAmountToUiAmountInstructionDataCodec(): FixedSizeCodec<\n  AmountToUiAmountInstructionDataArgs,\n  AmountToUiAmountInstructionData\n> {\n  return combineCodec(\n    getAmountToUiAmountInstructionDataEncoder(),\n    getAmountToUiAmountInstructionDataDecoder()\n  );\n}\n\nexport type AmountToUiAmountInput<TAccountMint extends string = string> = {\n  /** The mint to calculate for. */\n  mint: Address<TAccountMint>;\n  amount: AmountToUiAmountInstructionDataArgs['amount'];\n};\n\nexport function getAmountToUiAmountInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: AmountToUiAmountInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): AmountToUiAmountInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.mint)],\n    data: getAmountToUiAmountInstructionDataEncoder().encode(\n      args as AmountToUiAmountInstructionDataArgs\n    ),\n    programAddress,\n  } as AmountToUiAmountInstruction<TProgramAddress, TAccountMint>);\n}\n\nexport type ParsedAmountToUiAmountInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to calculate for. */\n    mint: TAccountMetas[0];\n  };\n  data: AmountToUiAmountInstructionData;\n};\n\nexport function parseAmountToUiAmountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedAmountToUiAmountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount() },\n    data: getAmountToUiAmountInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const APPROVE_DISCRIMINATOR = 4;\n\nexport function getApproveDiscriminatorBytes() {\n  return getU8Encoder().encode(APPROVE_DISCRIMINATOR);\n}\n\nexport type ApproveInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountSource extends string | AccountMeta<string> = string,\n  TAccountDelegate extends string | AccountMeta<string> = string,\n  TAccountOwner extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountSource extends string\n        ? WritableAccount<TAccountSource>\n        : TAccountSource,\n      TAccountDelegate extends string\n        ? ReadonlyAccount<TAccountDelegate>\n        : TAccountDelegate,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type ApproveInstructionData = {\n  discriminator: number;\n  /** The amount of tokens the delegate is approved for. */\n  amount: bigint;\n};\n\nexport type ApproveInstructionDataArgs = {\n  /** The amount of tokens the delegate is approved for. */\n  amount: number | bigint;\n};\n\nexport function getApproveInstructionDataEncoder(): FixedSizeEncoder<ApproveInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: APPROVE_DISCRIMINATOR })\n  );\n}\n\nexport function getApproveInstructionDataDecoder(): FixedSizeDecoder<ApproveInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n  ]);\n}\n\nexport function getApproveInstructionDataCodec(): FixedSizeCodec<\n  ApproveInstructionDataArgs,\n  ApproveInstructionData\n> {\n  return combineCodec(\n    getApproveInstructionDataEncoder(),\n    getApproveInstructionDataDecoder()\n  );\n}\n\nexport type ApproveInput<\n  TAccountSource extends string = string,\n  TAccountDelegate extends string = string,\n  TAccountOwner extends string = string,\n> = {\n  /** The source account. */\n  source: Address<TAccountSource>;\n  /** The delegate. */\n  delegate: Address<TAccountDelegate>;\n  /** The source account owner or its multisignature account. */\n  owner: Address<TAccountOwner> | TransactionSigner<TAccountOwner>;\n  amount: ApproveInstructionDataArgs['amount'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getApproveInstruction<\n  TAccountSource extends string,\n  TAccountDelegate extends string,\n  TAccountOwner extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: ApproveInput<TAccountSource, TAccountDelegate, TAccountOwner>,\n  config?: { programAddress?: TProgramAddress }\n): ApproveInstruction<\n  TProgramAddress,\n  TAccountSource,\n  TAccountDelegate,\n  (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n    ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n    : TAccountOwner\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    source: { value: input.source ?? null, isWritable: true },\n    delegate: { value: input.delegate ?? null, isWritable: false },\n    owner: { value: input.owner ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.source),\n      getAccountMeta(accounts.delegate),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts,\n    ],\n    data: getApproveInstructionDataEncoder().encode(\n      args as ApproveInstructionDataArgs\n    ),\n    programAddress,\n  } as ApproveInstruction<\n    TProgramAddress,\n    TAccountSource,\n    TAccountDelegate,\n    (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n      ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n      : TAccountOwner\n  >);\n}\n\nexport type ParsedApproveInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The source account. */\n    source: TAccountMetas[0];\n    /** The delegate. */\n    delegate: TAccountMetas[1];\n    /** The source account owner or its multisignature account. */\n    owner: TAccountMetas[2];\n  };\n  data: ApproveInstructionData;\n};\n\nexport function parseApproveInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedApproveInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      source: getNextAccount(),\n      delegate: getNextAccount(),\n      owner: getNextAccount(),\n    },\n    data: getApproveInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const APPROVE_CHECKED_DISCRIMINATOR = 13;\n\nexport function getApproveCheckedDiscriminatorBytes() {\n  return getU8Encoder().encode(APPROVE_CHECKED_DISCRIMINATOR);\n}\n\nexport type ApproveCheckedInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountSource extends string | AccountMeta<string> = string,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountDelegate extends string | AccountMeta<string> = string,\n  TAccountOwner extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountSource extends string\n        ? WritableAccount<TAccountSource>\n        : TAccountSource,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountDelegate extends string\n        ? ReadonlyAccount<TAccountDelegate>\n        : TAccountDelegate,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type ApproveCheckedInstructionData = {\n  discriminator: number;\n  /** The amount of tokens the delegate is approved for. */\n  amount: bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n};\n\nexport type ApproveCheckedInstructionDataArgs = {\n  /** The amount of tokens the delegate is approved for. */\n  amount: number | bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n};\n\nexport function getApproveCheckedInstructionDataEncoder(): FixedSizeEncoder<ApproveCheckedInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n      ['decimals', getU8Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: APPROVE_CHECKED_DISCRIMINATOR })\n  );\n}\n\nexport function getApproveCheckedInstructionDataDecoder(): FixedSizeDecoder<ApproveCheckedInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n    ['decimals', getU8Decoder()],\n  ]);\n}\n\nexport function getApproveCheckedInstructionDataCodec(): FixedSizeCodec<\n  ApproveCheckedInstructionDataArgs,\n  ApproveCheckedInstructionData\n> {\n  return combineCodec(\n    getApproveCheckedInstructionDataEncoder(),\n    getApproveCheckedInstructionDataDecoder()\n  );\n}\n\nexport type ApproveCheckedInput<\n  TAccountSource extends string = string,\n  TAccountMint extends string = string,\n  TAccountDelegate extends string = string,\n  TAccountOwner extends string = string,\n> = {\n  /** The source account. */\n  source: Address<TAccountSource>;\n  /** The token mint. */\n  mint: Address<TAccountMint>;\n  /** The delegate. */\n  delegate: Address<TAccountDelegate>;\n  /** The source account owner or its multisignature account. */\n  owner: Address<TAccountOwner> | TransactionSigner<TAccountOwner>;\n  amount: ApproveCheckedInstructionDataArgs['amount'];\n  decimals: ApproveCheckedInstructionDataArgs['decimals'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getApproveCheckedInstruction<\n  TAccountSource extends string,\n  TAccountMint extends string,\n  TAccountDelegate extends string,\n  TAccountOwner extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: ApproveCheckedInput<\n    TAccountSource,\n    TAccountMint,\n    TAccountDelegate,\n    TAccountOwner\n  >,\n  config?: { programAddress?: TProgramAddress }\n): ApproveCheckedInstruction<\n  TProgramAddress,\n  TAccountSource,\n  TAccountMint,\n  TAccountDelegate,\n  (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n    ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n    : TAccountOwner\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    source: { value: input.source ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    delegate: { value: input.delegate ?? null, isWritable: false },\n    owner: { value: input.owner ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.source),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.delegate),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts,\n    ],\n    data: getApproveCheckedInstructionDataEncoder().encode(\n      args as ApproveCheckedInstructionDataArgs\n    ),\n    programAddress,\n  } as ApproveCheckedInstruction<\n    TProgramAddress,\n    TAccountSource,\n    TAccountMint,\n    TAccountDelegate,\n    (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n      ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n      : TAccountOwner\n  >);\n}\n\nexport type ParsedApproveCheckedInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The source account. */\n    source: TAccountMetas[0];\n    /** The token mint. */\n    mint: TAccountMetas[1];\n    /** The delegate. */\n    delegate: TAccountMetas[2];\n    /** The source account owner or its multisignature account. */\n    owner: TAccountMetas[3];\n  };\n  data: ApproveCheckedInstructionData;\n};\n\nexport function parseApproveCheckedInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedApproveCheckedInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 4) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      source: getNextAccount(),\n      mint: getNextAccount(),\n      delegate: getNextAccount(),\n      owner: getNextAccount(),\n    },\n    data: getApproveCheckedInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const BURN_DISCRIMINATOR = 8;\n\nexport function getBurnDiscriminatorBytes() {\n  return getU8Encoder().encode(BURN_DISCRIMINATOR);\n}\n\nexport type BurnInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountAccount extends string | AccountMeta<string> = string,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type BurnInstructionData = {\n  /** The amount of tokens to burn. */\n  discriminator: number;\n  amount: bigint;\n};\n\nexport type BurnInstructionDataArgs = { amount: number | bigint };\n\nexport function getBurnInstructionDataEncoder(): FixedSizeEncoder<BurnInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: BURN_DISCRIMINATOR })\n  );\n}\n\nexport function getBurnInstructionDataDecoder(): FixedSizeDecoder<BurnInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n  ]);\n}\n\nexport function getBurnInstructionDataCodec(): FixedSizeCodec<\n  BurnInstructionDataArgs,\n  BurnInstructionData\n> {\n  return combineCodec(\n    getBurnInstructionDataEncoder(),\n    getBurnInstructionDataDecoder()\n  );\n}\n\nexport type BurnInput<\n  TAccountAccount extends string = string,\n  TAccountMint extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The account to burn from. */\n  account: Address<TAccountAccount>;\n  /** The token mint. */\n  mint: Address<TAccountMint>;\n  /** The account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  amount: BurnInstructionDataArgs['amount'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getBurnInstruction<\n  TAccountAccount extends string,\n  TAccountMint extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: BurnInput<TAccountAccount, TAccountMint, TAccountAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): BurnInstruction<\n  TProgramAddress,\n  TAccountAccount,\n  TAccountMint,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        AccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.account),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    data: getBurnInstructionDataEncoder().encode(\n      args as BurnInstructionDataArgs\n    ),\n    programAddress,\n  } as BurnInstruction<\n    TProgramAddress,\n    TAccountAccount,\n    TAccountMint,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          AccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >);\n}\n\nexport type ParsedBurnInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The account to burn from. */\n    account: TAccountMetas[0];\n    /** The token mint. */\n    mint: TAccountMetas[1];\n    /** The account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[2];\n  };\n  data: BurnInstructionData;\n};\n\nexport function parseBurnInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedBurnInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n      mint: getNextAccount(),\n      authority: getNextAccount(),\n    },\n    data: getBurnInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const BURN_CHECKED_DISCRIMINATOR = 15;\n\nexport function getBurnCheckedDiscriminatorBytes() {\n  return getU8Encoder().encode(BURN_CHECKED_DISCRIMINATOR);\n}\n\nexport type BurnCheckedInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountAccount extends string | AccountMeta<string> = string,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type BurnCheckedInstructionData = {\n  discriminator: number;\n  /** The amount of tokens to burn. */\n  amount: bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n};\n\nexport type BurnCheckedInstructionDataArgs = {\n  /** The amount of tokens to burn. */\n  amount: number | bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n};\n\nexport function getBurnCheckedInstructionDataEncoder(): FixedSizeEncoder<BurnCheckedInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n      ['decimals', getU8Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: BURN_CHECKED_DISCRIMINATOR })\n  );\n}\n\nexport function getBurnCheckedInstructionDataDecoder(): FixedSizeDecoder<BurnCheckedInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n    ['decimals', getU8Decoder()],\n  ]);\n}\n\nexport function getBurnCheckedInstructionDataCodec(): FixedSizeCodec<\n  BurnCheckedInstructionDataArgs,\n  BurnCheckedInstructionData\n> {\n  return combineCodec(\n    getBurnCheckedInstructionDataEncoder(),\n    getBurnCheckedInstructionDataDecoder()\n  );\n}\n\nexport type BurnCheckedInput<\n  TAccountAccount extends string = string,\n  TAccountMint extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The account to burn from. */\n  account: Address<TAccountAccount>;\n  /** The token mint. */\n  mint: Address<TAccountMint>;\n  /** The account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  amount: BurnCheckedInstructionDataArgs['amount'];\n  decimals: BurnCheckedInstructionDataArgs['decimals'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getBurnCheckedInstruction<\n  TAccountAccount extends string,\n  TAccountMint extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: BurnCheckedInput<TAccountAccount, TAccountMint, TAccountAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): BurnCheckedInstruction<\n  TProgramAddress,\n  TAccountAccount,\n  TAccountMint,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        AccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.account),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    data: getBurnCheckedInstructionDataEncoder().encode(\n      args as BurnCheckedInstructionDataArgs\n    ),\n    programAddress,\n  } as BurnCheckedInstruction<\n    TProgramAddress,\n    TAccountAccount,\n    TAccountMint,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          AccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >);\n}\n\nexport type ParsedBurnCheckedInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The account to burn from. */\n    account: TAccountMetas[0];\n    /** The token mint. */\n    mint: TAccountMetas[1];\n    /** The account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[2];\n  };\n  data: BurnCheckedInstructionData;\n};\n\nexport function parseBurnCheckedInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedBurnCheckedInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n      mint: getNextAccount(),\n      authority: getNextAccount(),\n    },\n    data: getBurnCheckedInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const CLOSE_ACCOUNT_DISCRIMINATOR = 9;\n\nexport function getCloseAccountDiscriminatorBytes() {\n  return getU8Encoder().encode(CLOSE_ACCOUNT_DISCRIMINATOR);\n}\n\nexport type CloseAccountInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountAccount extends string | AccountMeta<string> = string,\n  TAccountDestination extends string | AccountMeta<string> = string,\n  TAccountOwner extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      TAccountDestination extends string\n        ? WritableAccount<TAccountDestination>\n        : TAccountDestination,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type CloseAccountInstructionData = { discriminator: number };\n\nexport type CloseAccountInstructionDataArgs = {};\n\nexport function getCloseAccountInstructionDataEncoder(): FixedSizeEncoder<CloseAccountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({ ...value, discriminator: CLOSE_ACCOUNT_DISCRIMINATOR })\n  );\n}\n\nexport function getCloseAccountInstructionDataDecoder(): FixedSizeDecoder<CloseAccountInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getCloseAccountInstructionDataCodec(): FixedSizeCodec<\n  CloseAccountInstructionDataArgs,\n  CloseAccountInstructionData\n> {\n  return combineCodec(\n    getCloseAccountInstructionDataEncoder(),\n    getCloseAccountInstructionDataDecoder()\n  );\n}\n\nexport type CloseAccountInput<\n  TAccountAccount extends string = string,\n  TAccountDestination extends string = string,\n  TAccountOwner extends string = string,\n> = {\n  /** The account to close. */\n  account: Address<TAccountAccount>;\n  /** The destination account. */\n  destination: Address<TAccountDestination>;\n  /** The account's owner or its multisignature account. */\n  owner: Address<TAccountOwner> | TransactionSigner<TAccountOwner>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getCloseAccountInstruction<\n  TAccountAccount extends string,\n  TAccountDestination extends string,\n  TAccountOwner extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: CloseAccountInput<TAccountAccount, TAccountDestination, TAccountOwner>,\n  config?: { programAddress?: TProgramAddress }\n): CloseAccountInstruction<\n  TProgramAddress,\n  TAccountAccount,\n  TAccountDestination,\n  (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n    ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n    : TAccountOwner\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n    destination: { value: input.destination ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.account),\n      getAccountMeta(accounts.destination),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts,\n    ],\n    data: getCloseAccountInstructionDataEncoder().encode({}),\n    programAddress,\n  } as CloseAccountInstruction<\n    TProgramAddress,\n    TAccountAccount,\n    TAccountDestination,\n    (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n      ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n      : TAccountOwner\n  >);\n}\n\nexport type ParsedCloseAccountInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The account to close. */\n    account: TAccountMetas[0];\n    /** The destination account. */\n    destination: TAccountMetas[1];\n    /** The account's owner or its multisignature account. */\n    owner: TAccountMetas[2];\n  };\n  data: CloseAccountInstructionData;\n};\n\nexport function parseCloseAccountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedCloseAccountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n      destination: getNextAccount(),\n      owner: getNextAccount(),\n    },\n    data: getCloseAccountInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  getAddressEncoder,\n  getProgramDerivedAddress,\n  type Address,\n  type ProgramDerivedAddress,\n} from '@solana/kit';\n\nexport type AssociatedTokenSeeds = {\n  /** The wallet address of the associated token account. */\n  owner: Address;\n  /** The address of the token program to use. */\n  tokenProgram: Address;\n  /** The mint address of the associated token account. */\n  mint: Address;\n};\n\nexport async function findAssociatedTokenPda(\n  seeds: AssociatedTokenSeeds,\n  config: { programAddress?: Address | undefined } = {}\n): Promise<ProgramDerivedAddress> {\n  const {\n    programAddress = 'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL' as Address<'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL'>,\n  } = config;\n  return await getProgramDerivedAddress({\n    programAddress,\n    seeds: [\n      getAddressEncoder().encode(seeds.owner),\n      getAddressEncoder().encode(seeds.tokenProgram),\n      getAddressEncoder().encode(seeds.mint),\n    ],\n  });\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { findAssociatedTokenPda } from '../pdas';\nimport { ASSOCIATED_TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport {\n  expectAddress,\n  getAccountMetaFactory,\n  type ResolvedAccount,\n} from '../shared';\n\nexport const CREATE_ASSOCIATED_TOKEN_DISCRIMINATOR = 0;\n\nexport function getCreateAssociatedTokenDiscriminatorBytes() {\n  return getU8Encoder().encode(CREATE_ASSOCIATED_TOKEN_DISCRIMINATOR);\n}\n\nexport type CreateAssociatedTokenInstruction<\n  TProgram extends string = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n  TAccountPayer extends string | AccountMeta<string> = string,\n  TAccountAta extends string | AccountMeta<string> = string,\n  TAccountOwner extends string | AccountMeta<string> = string,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountSystemProgram extends\n    | string\n    | AccountMeta<string> = '11111111111111111111111111111111',\n  TAccountTokenProgram extends\n    | string\n    | AccountMeta<string> = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountPayer extends string\n        ? WritableSignerAccount<TAccountPayer> &\n            AccountSignerMeta<TAccountPayer>\n        : TAccountPayer,\n      TAccountAta extends string ? WritableAccount<TAccountAta> : TAccountAta,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountSystemProgram extends string\n        ? ReadonlyAccount<TAccountSystemProgram>\n        : TAccountSystemProgram,\n      TAccountTokenProgram extends string\n        ? ReadonlyAccount<TAccountTokenProgram>\n        : TAccountTokenProgram,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type CreateAssociatedTokenInstructionData = { discriminator: number };\n\nexport type CreateAssociatedTokenInstructionDataArgs = {};\n\nexport function getCreateAssociatedTokenInstructionDataEncoder(): FixedSizeEncoder<CreateAssociatedTokenInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({\n      ...value,\n      discriminator: CREATE_ASSOCIATED_TOKEN_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getCreateAssociatedTokenInstructionDataDecoder(): FixedSizeDecoder<CreateAssociatedTokenInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getCreateAssociatedTokenInstructionDataCodec(): FixedSizeCodec<\n  CreateAssociatedTokenInstructionDataArgs,\n  CreateAssociatedTokenInstructionData\n> {\n  return combineCodec(\n    getCreateAssociatedTokenInstructionDataEncoder(),\n    getCreateAssociatedTokenInstructionDataDecoder()\n  );\n}\n\nexport type CreateAssociatedTokenAsyncInput<\n  TAccountPayer extends string = string,\n  TAccountAta extends string = string,\n  TAccountOwner extends string = string,\n  TAccountMint extends string = string,\n  TAccountSystemProgram extends string = string,\n  TAccountTokenProgram extends string = string,\n> = {\n  /** Funding account (must be a system account). */\n  payer: TransactionSigner<TAccountPayer>;\n  /** Associated token account address to be created. */\n  ata?: Address<TAccountAta>;\n  /** Wallet address for the new associated token account. */\n  owner: Address<TAccountOwner>;\n  /** The token mint for the new associated token account. */\n  mint: Address<TAccountMint>;\n  /** System program. */\n  systemProgram?: Address<TAccountSystemProgram>;\n  /** SPL Token program. */\n  tokenProgram?: Address<TAccountTokenProgram>;\n};\n\nexport async function getCreateAssociatedTokenInstructionAsync<\n  TAccountPayer extends string,\n  TAccountAta extends string,\n  TAccountOwner extends string,\n  TAccountMint extends string,\n  TAccountSystemProgram extends string,\n  TAccountTokenProgram extends string,\n  TProgramAddress extends Address = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n>(\n  input: CreateAssociatedTokenAsyncInput<\n    TAccountPayer,\n    TAccountAta,\n    TAccountOwner,\n    TAccountMint,\n    TAccountSystemProgram,\n    TAccountTokenProgram\n  >,\n  config?: { programAddress?: TProgramAddress }\n): Promise<\n  CreateAssociatedTokenInstruction<\n    TProgramAddress,\n    TAccountPayer,\n    TAccountAta,\n    TAccountOwner,\n    TAccountMint,\n    TAccountSystemProgram,\n    TAccountTokenProgram\n  >\n> {\n  // Program address.\n  const programAddress =\n    config?.programAddress ?? ASSOCIATED_TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    payer: { value: input.payer ?? null, isWritable: true },\n    ata: { value: input.ata ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n    mint: { value: input.mint ?? null, isWritable: false },\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false },\n    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Resolve default values.\n  if (!accounts.tokenProgram.value) {\n    accounts.tokenProgram.value =\n      'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address<'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'>;\n  }\n  if (!accounts.ata.value) {\n    accounts.ata.value = await findAssociatedTokenPda({\n      owner: expectAddress(accounts.owner.value),\n      tokenProgram: expectAddress(accounts.tokenProgram.value),\n      mint: expectAddress(accounts.mint.value),\n    });\n  }\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value =\n      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.payer),\n      getAccountMeta(accounts.ata),\n      getAccountMeta(accounts.owner),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.systemProgram),\n      getAccountMeta(accounts.tokenProgram),\n    ],\n    data: getCreateAssociatedTokenInstructionDataEncoder().encode({}),\n    programAddress,\n  } as CreateAssociatedTokenInstruction<\n    TProgramAddress,\n    TAccountPayer,\n    TAccountAta,\n    TAccountOwner,\n    TAccountMint,\n    TAccountSystemProgram,\n    TAccountTokenProgram\n  >);\n}\n\nexport type CreateAssociatedTokenInput<\n  TAccountPayer extends string = string,\n  TAccountAta extends string = string,\n  TAccountOwner extends string = string,\n  TAccountMint extends string = string,\n  TAccountSystemProgram extends string = string,\n  TAccountTokenProgram extends string = string,\n> = {\n  /** Funding account (must be a system account). */\n  payer: TransactionSigner<TAccountPayer>;\n  /** Associated token account address to be created. */\n  ata: Address<TAccountAta>;\n  /** Wallet address for the new associated token account. */\n  owner: Address<TAccountOwner>;\n  /** The token mint for the new associated token account. */\n  mint: Address<TAccountMint>;\n  /** System program. */\n  systemProgram?: Address<TAccountSystemProgram>;\n  /** SPL Token program. */\n  tokenProgram?: Address<TAccountTokenProgram>;\n};\n\nexport function getCreateAssociatedTokenInstruction<\n  TAccountPayer extends string,\n  TAccountAta extends string,\n  TAccountOwner extends string,\n  TAccountMint extends string,\n  TAccountSystemProgram extends string,\n  TAccountTokenProgram extends string,\n  TProgramAddress extends Address = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n>(\n  input: CreateAssociatedTokenInput<\n    TAccountPayer,\n    TAccountAta,\n    TAccountOwner,\n    TAccountMint,\n    TAccountSystemProgram,\n    TAccountTokenProgram\n  >,\n  config?: { programAddress?: TProgramAddress }\n): CreateAssociatedTokenInstruction<\n  TProgramAddress,\n  TAccountPayer,\n  TAccountAta,\n  TAccountOwner,\n  TAccountMint,\n  TAccountSystemProgram,\n  TAccountTokenProgram\n> {\n  // Program address.\n  const programAddress =\n    config?.programAddress ?? ASSOCIATED_TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    payer: { value: input.payer ?? null, isWritable: true },\n    ata: { value: input.ata ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n    mint: { value: input.mint ?? null, isWritable: false },\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false },\n    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Resolve default values.\n  if (!accounts.tokenProgram.value) {\n    accounts.tokenProgram.value =\n      'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address<'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'>;\n  }\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value =\n      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.payer),\n      getAccountMeta(accounts.ata),\n      getAccountMeta(accounts.owner),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.systemProgram),\n      getAccountMeta(accounts.tokenProgram),\n    ],\n    data: getCreateAssociatedTokenInstructionDataEncoder().encode({}),\n    programAddress,\n  } as CreateAssociatedTokenInstruction<\n    TProgramAddress,\n    TAccountPayer,\n    TAccountAta,\n    TAccountOwner,\n    TAccountMint,\n    TAccountSystemProgram,\n    TAccountTokenProgram\n  >);\n}\n\nexport type ParsedCreateAssociatedTokenInstruction<\n  TProgram extends string = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** Funding account (must be a system account). */\n    payer: TAccountMetas[0];\n    /** Associated token account address to be created. */\n    ata: TAccountMetas[1];\n    /** Wallet address for the new associated token account. */\n    owner: TAccountMetas[2];\n    /** The token mint for the new associated token account. */\n    mint: TAccountMetas[3];\n    /** System program. */\n    systemProgram: TAccountMetas[4];\n    /** SPL Token program. */\n    tokenProgram: TAccountMetas[5];\n  };\n  data: CreateAssociatedTokenInstructionData;\n};\n\nexport function parseCreateAssociatedTokenInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedCreateAssociatedTokenInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 6) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      payer: getNextAccount(),\n      ata: getNextAccount(),\n      owner: getNextAccount(),\n      mint: getNextAccount(),\n      systemProgram: getNextAccount(),\n      tokenProgram: getNextAccount(),\n    },\n    data: getCreateAssociatedTokenInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { findAssociatedTokenPda } from '../pdas';\nimport { ASSOCIATED_TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport {\n  expectAddress,\n  getAccountMetaFactory,\n  type ResolvedAccount,\n} from '../shared';\n\nexport const CREATE_ASSOCIATED_TOKEN_IDEMPOTENT_DISCRIMINATOR = 1;\n\nexport function getCreateAssociatedTokenIdempotentDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    CREATE_ASSOCIATED_TOKEN_IDEMPOTENT_DISCRIMINATOR\n  );\n}\n\nexport type CreateAssociatedTokenIdempotentInstruction<\n  TProgram extends string = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n  TAccountPayer extends string | AccountMeta<string> = string,\n  TAccountAta extends string | AccountMeta<string> = string,\n  TAccountOwner extends string | AccountMeta<string> = string,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountSystemProgram extends\n    | string\n    | AccountMeta<string> = '11111111111111111111111111111111',\n  TAccountTokenProgram extends\n    | string\n    | AccountMeta<string> = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountPayer extends string\n        ? WritableSignerAccount<TAccountPayer> &\n            AccountSignerMeta<TAccountPayer>\n        : TAccountPayer,\n      TAccountAta extends string ? WritableAccount<TAccountAta> : TAccountAta,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountSystemProgram extends string\n        ? ReadonlyAccount<TAccountSystemProgram>\n        : TAccountSystemProgram,\n      TAccountTokenProgram extends string\n        ? ReadonlyAccount<TAccountTokenProgram>\n        : TAccountTokenProgram,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type CreateAssociatedTokenIdempotentInstructionData = {\n  discriminator: number;\n};\n\nexport type CreateAssociatedTokenIdempotentInstructionDataArgs = {};\n\nexport function getCreateAssociatedTokenIdempotentInstructionDataEncoder(): FixedSizeEncoder<CreateAssociatedTokenIdempotentInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({\n      ...value,\n      discriminator: CREATE_ASSOCIATED_TOKEN_IDEMPOTENT_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getCreateAssociatedTokenIdempotentInstructionDataDecoder(): FixedSizeDecoder<CreateAssociatedTokenIdempotentInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getCreateAssociatedTokenIdempotentInstructionDataCodec(): FixedSizeCodec<\n  CreateAssociatedTokenIdempotentInstructionDataArgs,\n  CreateAssociatedTokenIdempotentInstructionData\n> {\n  return combineCodec(\n    getCreateAssociatedTokenIdempotentInstructionDataEncoder(),\n    getCreateAssociatedTokenIdempotentInstructionDataDecoder()\n  );\n}\n\nexport type CreateAssociatedTokenIdempotentAsyncInput<\n  TAccountPayer extends string = string,\n  TAccountAta extends string = string,\n  TAccountOwner extends string = string,\n  TAccountMint extends string = string,\n  TAccountSystemProgram extends string = string,\n  TAccountTokenProgram extends string = string,\n> = {\n  /** Funding account (must be a system account). */\n  payer: TransactionSigner<TAccountPayer>;\n  /** Associated token account address to be created. */\n  ata?: Address<TAccountAta>;\n  /** Wallet address for the new associated token account. */\n  owner: Address<TAccountOwner>;\n  /** The token mint for the new associated token account. */\n  mint: Address<TAccountMint>;\n  /** System program. */\n  systemProgram?: Address<TAccountSystemProgram>;\n  /** SPL Token program. */\n  tokenProgram?: Address<TAccountTokenProgram>;\n};\n\nexport async function getCreateAssociatedTokenIdempotentInstructionAsync<\n  TAccountPayer extends string,\n  TAccountAta extends string,\n  TAccountOwner extends string,\n  TAccountMint extends string,\n  TAccountSystemProgram extends string,\n  TAccountTokenProgram extends string,\n  TProgramAddress extends Address = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n>(\n  input: CreateAssociatedTokenIdempotentAsyncInput<\n    TAccountPayer,\n    TAccountAta,\n    TAccountOwner,\n    TAccountMint,\n    TAccountSystemProgram,\n    TAccountTokenProgram\n  >,\n  config?: { programAddress?: TProgramAddress }\n): Promise<\n  CreateAssociatedTokenIdempotentInstruction<\n    TProgramAddress,\n    TAccountPayer,\n    TAccountAta,\n    TAccountOwner,\n    TAccountMint,\n    TAccountSystemProgram,\n    TAccountTokenProgram\n  >\n> {\n  // Program address.\n  const programAddress =\n    config?.programAddress ?? ASSOCIATED_TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    payer: { value: input.payer ?? null, isWritable: true },\n    ata: { value: input.ata ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n    mint: { value: input.mint ?? null, isWritable: false },\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false },\n    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Resolve default values.\n  if (!accounts.tokenProgram.value) {\n    accounts.tokenProgram.value =\n      'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address<'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'>;\n  }\n  if (!accounts.ata.value) {\n    accounts.ata.value = await findAssociatedTokenPda({\n      owner: expectAddress(accounts.owner.value),\n      tokenProgram: expectAddress(accounts.tokenProgram.value),\n      mint: expectAddress(accounts.mint.value),\n    });\n  }\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value =\n      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.payer),\n      getAccountMeta(accounts.ata),\n      getAccountMeta(accounts.owner),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.systemProgram),\n      getAccountMeta(accounts.tokenProgram),\n    ],\n    data: getCreateAssociatedTokenIdempotentInstructionDataEncoder().encode({}),\n    programAddress,\n  } as CreateAssociatedTokenIdempotentInstruction<\n    TProgramAddress,\n    TAccountPayer,\n    TAccountAta,\n    TAccountOwner,\n    TAccountMint,\n    TAccountSystemProgram,\n    TAccountTokenProgram\n  >);\n}\n\nexport type CreateAssociatedTokenIdempotentInput<\n  TAccountPayer extends string = string,\n  TAccountAta extends string = string,\n  TAccountOwner extends string = string,\n  TAccountMint extends string = string,\n  TAccountSystemProgram extends string = string,\n  TAccountTokenProgram extends string = string,\n> = {\n  /** Funding account (must be a system account). */\n  payer: TransactionSigner<TAccountPayer>;\n  /** Associated token account address to be created. */\n  ata: Address<TAccountAta>;\n  /** Wallet address for the new associated token account. */\n  owner: Address<TAccountOwner>;\n  /** The token mint for the new associated token account. */\n  mint: Address<TAccountMint>;\n  /** System program. */\n  systemProgram?: Address<TAccountSystemProgram>;\n  /** SPL Token program. */\n  tokenProgram?: Address<TAccountTokenProgram>;\n};\n\nexport function getCreateAssociatedTokenIdempotentInstruction<\n  TAccountPayer extends string,\n  TAccountAta extends string,\n  TAccountOwner extends string,\n  TAccountMint extends string,\n  TAccountSystemProgram extends string,\n  TAccountTokenProgram extends string,\n  TProgramAddress extends Address = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n>(\n  input: CreateAssociatedTokenIdempotentInput<\n    TAccountPayer,\n    TAccountAta,\n    TAccountOwner,\n    TAccountMint,\n    TAccountSystemProgram,\n    TAccountTokenProgram\n  >,\n  config?: { programAddress?: TProgramAddress }\n): CreateAssociatedTokenIdempotentInstruction<\n  TProgramAddress,\n  TAccountPayer,\n  TAccountAta,\n  TAccountOwner,\n  TAccountMint,\n  TAccountSystemProgram,\n  TAccountTokenProgram\n> {\n  // Program address.\n  const programAddress =\n    config?.programAddress ?? ASSOCIATED_TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    payer: { value: input.payer ?? null, isWritable: true },\n    ata: { value: input.ata ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n    mint: { value: input.mint ?? null, isWritable: false },\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false },\n    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Resolve default values.\n  if (!accounts.tokenProgram.value) {\n    accounts.tokenProgram.value =\n      'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address<'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'>;\n  }\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value =\n      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.payer),\n      getAccountMeta(accounts.ata),\n      getAccountMeta(accounts.owner),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.systemProgram),\n      getAccountMeta(accounts.tokenProgram),\n    ],\n    data: getCreateAssociatedTokenIdempotentInstructionDataEncoder().encode({}),\n    programAddress,\n  } as CreateAssociatedTokenIdempotentInstruction<\n    TProgramAddress,\n    TAccountPayer,\n    TAccountAta,\n    TAccountOwner,\n    TAccountMint,\n    TAccountSystemProgram,\n    TAccountTokenProgram\n  >);\n}\n\nexport type ParsedCreateAssociatedTokenIdempotentInstruction<\n  TProgram extends string = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** Funding account (must be a system account). */\n    payer: TAccountMetas[0];\n    /** Associated token account address to be created. */\n    ata: TAccountMetas[1];\n    /** Wallet address for the new associated token account. */\n    owner: TAccountMetas[2];\n    /** The token mint for the new associated token account. */\n    mint: TAccountMetas[3];\n    /** System program. */\n    systemProgram: TAccountMetas[4];\n    /** SPL Token program. */\n    tokenProgram: TAccountMetas[5];\n  };\n  data: CreateAssociatedTokenIdempotentInstructionData;\n};\n\nexport function parseCreateAssociatedTokenIdempotentInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedCreateAssociatedTokenIdempotentInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 6) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      payer: getNextAccount(),\n      ata: getNextAccount(),\n      owner: getNextAccount(),\n      mint: getNextAccount(),\n      systemProgram: getNextAccount(),\n      tokenProgram: getNextAccount(),\n    },\n    data: getCreateAssociatedTokenIdempotentInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const FREEZE_ACCOUNT_DISCRIMINATOR = 10;\n\nexport function getFreezeAccountDiscriminatorBytes() {\n  return getU8Encoder().encode(FREEZE_ACCOUNT_DISCRIMINATOR);\n}\n\nexport type FreezeAccountInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountAccount extends string | AccountMeta<string> = string,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountOwner extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type FreezeAccountInstructionData = { discriminator: number };\n\nexport type FreezeAccountInstructionDataArgs = {};\n\nexport function getFreezeAccountInstructionDataEncoder(): FixedSizeEncoder<FreezeAccountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({ ...value, discriminator: FREEZE_ACCOUNT_DISCRIMINATOR })\n  );\n}\n\nexport function getFreezeAccountInstructionDataDecoder(): FixedSizeDecoder<FreezeAccountInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getFreezeAccountInstructionDataCodec(): FixedSizeCodec<\n  FreezeAccountInstructionDataArgs,\n  FreezeAccountInstructionData\n> {\n  return combineCodec(\n    getFreezeAccountInstructionDataEncoder(),\n    getFreezeAccountInstructionDataDecoder()\n  );\n}\n\nexport type FreezeAccountInput<\n  TAccountAccount extends string = string,\n  TAccountMint extends string = string,\n  TAccountOwner extends string = string,\n> = {\n  /** The account to freeze. */\n  account: Address<TAccountAccount>;\n  /** The token mint. */\n  mint: Address<TAccountMint>;\n  /** The mint freeze authority or its multisignature account. */\n  owner: Address<TAccountOwner> | TransactionSigner<TAccountOwner>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getFreezeAccountInstruction<\n  TAccountAccount extends string,\n  TAccountMint extends string,\n  TAccountOwner extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: FreezeAccountInput<TAccountAccount, TAccountMint, TAccountOwner>,\n  config?: { programAddress?: TProgramAddress }\n): FreezeAccountInstruction<\n  TProgramAddress,\n  TAccountAccount,\n  TAccountMint,\n  (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n    ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n    : TAccountOwner\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    owner: { value: input.owner ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.account),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts,\n    ],\n    data: getFreezeAccountInstructionDataEncoder().encode({}),\n    programAddress,\n  } as FreezeAccountInstruction<\n    TProgramAddress,\n    TAccountAccount,\n    TAccountMint,\n    (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n      ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n      : TAccountOwner\n  >);\n}\n\nexport type ParsedFreezeAccountInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The account to freeze. */\n    account: TAccountMetas[0];\n    /** The token mint. */\n    mint: TAccountMetas[1];\n    /** The mint freeze authority or its multisignature account. */\n    owner: TAccountMetas[2];\n  };\n  data: FreezeAccountInstructionData;\n};\n\nexport function parseFreezeAccountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedFreezeAccountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n      mint: getNextAccount(),\n      owner: getNextAccount(),\n    },\n    data: getFreezeAccountInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlyUint8Array,\n} from '@solana/kit';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const GET_ACCOUNT_DATA_SIZE_DISCRIMINATOR = 21;\n\nexport function getGetAccountDataSizeDiscriminatorBytes() {\n  return getU8Encoder().encode(GET_ACCOUNT_DATA_SIZE_DISCRIMINATOR);\n}\n\nexport type GetAccountDataSizeInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type GetAccountDataSizeInstructionData = { discriminator: number };\n\nexport type GetAccountDataSizeInstructionDataArgs = {};\n\nexport function getGetAccountDataSizeInstructionDataEncoder(): FixedSizeEncoder<GetAccountDataSizeInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({\n      ...value,\n      discriminator: GET_ACCOUNT_DATA_SIZE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getGetAccountDataSizeInstructionDataDecoder(): FixedSizeDecoder<GetAccountDataSizeInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getGetAccountDataSizeInstructionDataCodec(): FixedSizeCodec<\n  GetAccountDataSizeInstructionDataArgs,\n  GetAccountDataSizeInstructionData\n> {\n  return combineCodec(\n    getGetAccountDataSizeInstructionDataEncoder(),\n    getGetAccountDataSizeInstructionDataDecoder()\n  );\n}\n\nexport type GetAccountDataSizeInput<TAccountMint extends string = string> = {\n  /** The mint to calculate for. */\n  mint: Address<TAccountMint>;\n};\n\nexport function getGetAccountDataSizeInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: GetAccountDataSizeInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): GetAccountDataSizeInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.mint)],\n    data: getGetAccountDataSizeInstructionDataEncoder().encode({}),\n    programAddress,\n  } as GetAccountDataSizeInstruction<TProgramAddress, TAccountMint>);\n}\n\nexport type ParsedGetAccountDataSizeInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to calculate for. */\n    mint: TAccountMetas[0];\n  };\n  data: GetAccountDataSizeInstructionData;\n};\n\nexport function parseGetAccountDataSizeInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedGetAccountDataSizeInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount() },\n    data: getGetAccountDataSizeInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_ACCOUNT_DISCRIMINATOR = 1;\n\nexport function getInitializeAccountDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_ACCOUNT_DISCRIMINATOR);\n}\n\nexport type InitializeAccountInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountAccount extends string | AccountMeta<string> = string,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountOwner extends string | AccountMeta<string> = string,\n  TAccountRent extends\n    | string\n    | AccountMeta<string> = 'SysvarRent111111111111111111111111111111111',\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      TAccountRent extends string\n        ? ReadonlyAccount<TAccountRent>\n        : TAccountRent,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeAccountInstructionData = { discriminator: number };\n\nexport type InitializeAccountInstructionDataArgs = {};\n\nexport function getInitializeAccountInstructionDataEncoder(): FixedSizeEncoder<InitializeAccountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({ ...value, discriminator: INITIALIZE_ACCOUNT_DISCRIMINATOR })\n  );\n}\n\nexport function getInitializeAccountInstructionDataDecoder(): FixedSizeDecoder<InitializeAccountInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getInitializeAccountInstructionDataCodec(): FixedSizeCodec<\n  InitializeAccountInstructionDataArgs,\n  InitializeAccountInstructionData\n> {\n  return combineCodec(\n    getInitializeAccountInstructionDataEncoder(),\n    getInitializeAccountInstructionDataDecoder()\n  );\n}\n\nexport type InitializeAccountInput<\n  TAccountAccount extends string = string,\n  TAccountMint extends string = string,\n  TAccountOwner extends string = string,\n  TAccountRent extends string = string,\n> = {\n  /** The account to initialize. */\n  account: Address<TAccountAccount>;\n  /** The mint this account will be associated with. */\n  mint: Address<TAccountMint>;\n  /** The new account's owner/multisignature. */\n  owner: Address<TAccountOwner>;\n  /** Rent sysvar. */\n  rent?: Address<TAccountRent>;\n};\n\nexport function getInitializeAccountInstruction<\n  TAccountAccount extends string,\n  TAccountMint extends string,\n  TAccountOwner extends string,\n  TAccountRent extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: InitializeAccountInput<\n    TAccountAccount,\n    TAccountMint,\n    TAccountOwner,\n    TAccountRent\n  >,\n  config?: { programAddress?: TProgramAddress }\n): InitializeAccountInstruction<\n  TProgramAddress,\n  TAccountAccount,\n  TAccountMint,\n  TAccountOwner,\n  TAccountRent\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    owner: { value: input.owner ?? null, isWritable: false },\n    rent: { value: input.rent ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Resolve default values.\n  if (!accounts.rent.value) {\n    accounts.rent.value =\n      'SysvarRent111111111111111111111111111111111' as Address<'SysvarRent111111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.account),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.owner),\n      getAccountMeta(accounts.rent),\n    ],\n    data: getInitializeAccountInstructionDataEncoder().encode({}),\n    programAddress,\n  } as InitializeAccountInstruction<\n    TProgramAddress,\n    TAccountAccount,\n    TAccountMint,\n    TAccountOwner,\n    TAccountRent\n  >);\n}\n\nexport type ParsedInitializeAccountInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The account to initialize. */\n    account: TAccountMetas[0];\n    /** The mint this account will be associated with. */\n    mint: TAccountMetas[1];\n    /** The new account's owner/multisignature. */\n    owner: TAccountMetas[2];\n    /** Rent sysvar. */\n    rent: TAccountMetas[3];\n  };\n  data: InitializeAccountInstructionData;\n};\n\nexport function parseInitializeAccountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedInitializeAccountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 4) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n      mint: getNextAccount(),\n      owner: getNextAccount(),\n      rent: getNextAccount(),\n    },\n    data: getInitializeAccountInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_ACCOUNT2_DISCRIMINATOR = 16;\n\nexport function getInitializeAccount2DiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_ACCOUNT2_DISCRIMINATOR);\n}\n\nexport type InitializeAccount2Instruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountAccount extends string | AccountMeta<string> = string,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountRent extends\n    | string\n    | AccountMeta<string> = 'SysvarRent111111111111111111111111111111111',\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountRent extends string\n        ? ReadonlyAccount<TAccountRent>\n        : TAccountRent,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeAccount2InstructionData = {\n  discriminator: number;\n  /** The new account's owner/multisignature. */\n  owner: Address;\n};\n\nexport type InitializeAccount2InstructionDataArgs = {\n  /** The new account's owner/multisignature. */\n  owner: Address;\n};\n\nexport function getInitializeAccount2InstructionDataEncoder(): FixedSizeEncoder<InitializeAccount2InstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['owner', getAddressEncoder()],\n    ]),\n    (value) => ({ ...value, discriminator: INITIALIZE_ACCOUNT2_DISCRIMINATOR })\n  );\n}\n\nexport function getInitializeAccount2InstructionDataDecoder(): FixedSizeDecoder<InitializeAccount2InstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['owner', getAddressDecoder()],\n  ]);\n}\n\nexport function getInitializeAccount2InstructionDataCodec(): FixedSizeCodec<\n  InitializeAccount2InstructionDataArgs,\n  InitializeAccount2InstructionData\n> {\n  return combineCodec(\n    getInitializeAccount2InstructionDataEncoder(),\n    getInitializeAccount2InstructionDataDecoder()\n  );\n}\n\nexport type InitializeAccount2Input<\n  TAccountAccount extends string = string,\n  TAccountMint extends string = string,\n  TAccountRent extends string = string,\n> = {\n  /** The account to initialize. */\n  account: Address<TAccountAccount>;\n  /** The mint this account will be associated with. */\n  mint: Address<TAccountMint>;\n  /** Rent sysvar. */\n  rent?: Address<TAccountRent>;\n  owner: InitializeAccount2InstructionDataArgs['owner'];\n};\n\nexport function getInitializeAccount2Instruction<\n  TAccountAccount extends string,\n  TAccountMint extends string,\n  TAccountRent extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: InitializeAccount2Input<TAccountAccount, TAccountMint, TAccountRent>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeAccount2Instruction<\n  TProgramAddress,\n  TAccountAccount,\n  TAccountMint,\n  TAccountRent\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    rent: { value: input.rent ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.rent.value) {\n    accounts.rent.value =\n      'SysvarRent111111111111111111111111111111111' as Address<'SysvarRent111111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.account),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.rent),\n    ],\n    data: getInitializeAccount2InstructionDataEncoder().encode(\n      args as InitializeAccount2InstructionDataArgs\n    ),\n    programAddress,\n  } as InitializeAccount2Instruction<\n    TProgramAddress,\n    TAccountAccount,\n    TAccountMint,\n    TAccountRent\n  >);\n}\n\nexport type ParsedInitializeAccount2Instruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The account to initialize. */\n    account: TAccountMetas[0];\n    /** The mint this account will be associated with. */\n    mint: TAccountMetas[1];\n    /** Rent sysvar. */\n    rent: TAccountMetas[2];\n  };\n  data: InitializeAccount2InstructionData;\n};\n\nexport function parseInitializeAccount2Instruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedInitializeAccount2Instruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n      mint: getNextAccount(),\n      rent: getNextAccount(),\n    },\n    data: getInitializeAccount2InstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_ACCOUNT3_DISCRIMINATOR = 18;\n\nexport function getInitializeAccount3DiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_ACCOUNT3_DISCRIMINATOR);\n}\n\nexport type InitializeAccount3Instruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountAccount extends string | AccountMeta<string> = string,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeAccount3InstructionData = {\n  discriminator: number;\n  /** The new account's owner/multisignature. */\n  owner: Address;\n};\n\nexport type InitializeAccount3InstructionDataArgs = {\n  /** The new account's owner/multisignature. */\n  owner: Address;\n};\n\nexport function getInitializeAccount3InstructionDataEncoder(): FixedSizeEncoder<InitializeAccount3InstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['owner', getAddressEncoder()],\n    ]),\n    (value) => ({ ...value, discriminator: INITIALIZE_ACCOUNT3_DISCRIMINATOR })\n  );\n}\n\nexport function getInitializeAccount3InstructionDataDecoder(): FixedSizeDecoder<InitializeAccount3InstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['owner', getAddressDecoder()],\n  ]);\n}\n\nexport function getInitializeAccount3InstructionDataCodec(): FixedSizeCodec<\n  InitializeAccount3InstructionDataArgs,\n  InitializeAccount3InstructionData\n> {\n  return combineCodec(\n    getInitializeAccount3InstructionDataEncoder(),\n    getInitializeAccount3InstructionDataDecoder()\n  );\n}\n\nexport type InitializeAccount3Input<\n  TAccountAccount extends string = string,\n  TAccountMint extends string = string,\n> = {\n  /** The account to initialize. */\n  account: Address<TAccountAccount>;\n  /** The mint this account will be associated with. */\n  mint: Address<TAccountMint>;\n  owner: InitializeAccount3InstructionDataArgs['owner'];\n};\n\nexport function getInitializeAccount3Instruction<\n  TAccountAccount extends string,\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: InitializeAccount3Input<TAccountAccount, TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeAccount3Instruction<\n  TProgramAddress,\n  TAccountAccount,\n  TAccountMint\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.account), getAccountMeta(accounts.mint)],\n    data: getInitializeAccount3InstructionDataEncoder().encode(\n      args as InitializeAccount3InstructionDataArgs\n    ),\n    programAddress,\n  } as InitializeAccount3Instruction<\n    TProgramAddress,\n    TAccountAccount,\n    TAccountMint\n  >);\n}\n\nexport type ParsedInitializeAccount3Instruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The account to initialize. */\n    account: TAccountMetas[0];\n    /** The mint this account will be associated with. */\n    mint: TAccountMetas[1];\n  };\n  data: InitializeAccount3InstructionData;\n};\n\nexport function parseInitializeAccount3Instruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedInitializeAccount3Instruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { account: getNextAccount(), mint: getNextAccount() },\n    data: getInitializeAccount3InstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_IMMUTABLE_OWNER_DISCRIMINATOR = 22;\n\nexport function getInitializeImmutableOwnerDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_IMMUTABLE_OWNER_DISCRIMINATOR);\n}\n\nexport type InitializeImmutableOwnerInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountAccount extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeImmutableOwnerInstructionData = { discriminator: number };\n\nexport type InitializeImmutableOwnerInstructionDataArgs = {};\n\nexport function getInitializeImmutableOwnerInstructionDataEncoder(): FixedSizeEncoder<InitializeImmutableOwnerInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_IMMUTABLE_OWNER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeImmutableOwnerInstructionDataDecoder(): FixedSizeDecoder<InitializeImmutableOwnerInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getInitializeImmutableOwnerInstructionDataCodec(): FixedSizeCodec<\n  InitializeImmutableOwnerInstructionDataArgs,\n  InitializeImmutableOwnerInstructionData\n> {\n  return combineCodec(\n    getInitializeImmutableOwnerInstructionDataEncoder(),\n    getInitializeImmutableOwnerInstructionDataDecoder()\n  );\n}\n\nexport type InitializeImmutableOwnerInput<\n  TAccountAccount extends string = string,\n> = {\n  /** The account to initialize. */\n  account: Address<TAccountAccount>;\n};\n\nexport function getInitializeImmutableOwnerInstruction<\n  TAccountAccount extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: InitializeImmutableOwnerInput<TAccountAccount>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeImmutableOwnerInstruction<TProgramAddress, TAccountAccount> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.account)],\n    data: getInitializeImmutableOwnerInstructionDataEncoder().encode({}),\n    programAddress,\n  } as InitializeImmutableOwnerInstruction<TProgramAddress, TAccountAccount>);\n}\n\nexport type ParsedInitializeImmutableOwnerInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The account to initialize. */\n    account: TAccountMetas[0];\n  };\n  data: InitializeImmutableOwnerInstructionData;\n};\n\nexport function parseInitializeImmutableOwnerInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedInitializeImmutableOwnerInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { account: getNextAccount() },\n    data: getInitializeImmutableOwnerInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  none,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyAccount,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_MINT_DISCRIMINATOR = 0;\n\nexport function getInitializeMintDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_MINT_DISCRIMINATOR);\n}\n\nexport type InitializeMintInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountRent extends\n    | string\n    | AccountMeta<string> = 'SysvarRent111111111111111111111111111111111',\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountRent extends string\n        ? ReadonlyAccount<TAccountRent>\n        : TAccountRent,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeMintInstructionData = {\n  discriminator: number;\n  /** Number of decimals in token account amounts. */\n  decimals: number;\n  /** Minting authority. */\n  mintAuthority: Address;\n  /** Optional authority that can freeze token accounts. */\n  freezeAuthority: Option<Address>;\n};\n\nexport type InitializeMintInstructionDataArgs = {\n  /** Number of decimals in token account amounts. */\n  decimals: number;\n  /** Minting authority. */\n  mintAuthority: Address;\n  /** Optional authority that can freeze token accounts. */\n  freezeAuthority?: OptionOrNullable<Address>;\n};\n\nexport function getInitializeMintInstructionDataEncoder(): Encoder<InitializeMintInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['decimals', getU8Encoder()],\n      ['mintAuthority', getAddressEncoder()],\n      ['freezeAuthority', getOptionEncoder(getAddressEncoder())],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_MINT_DISCRIMINATOR,\n      freezeAuthority: value.freezeAuthority ?? none(),\n    })\n  );\n}\n\nexport function getInitializeMintInstructionDataDecoder(): Decoder<InitializeMintInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['decimals', getU8Decoder()],\n    ['mintAuthority', getAddressDecoder()],\n    ['freezeAuthority', getOptionDecoder(getAddressDecoder())],\n  ]);\n}\n\nexport function getInitializeMintInstructionDataCodec(): Codec<\n  InitializeMintInstructionDataArgs,\n  InitializeMintInstructionData\n> {\n  return combineCodec(\n    getInitializeMintInstructionDataEncoder(),\n    getInitializeMintInstructionDataDecoder()\n  );\n}\n\nexport type InitializeMintInput<\n  TAccountMint extends string = string,\n  TAccountRent extends string = string,\n> = {\n  /** Token mint account. */\n  mint: Address<TAccountMint>;\n  /** Rent sysvar. */\n  rent?: Address<TAccountRent>;\n  decimals: InitializeMintInstructionDataArgs['decimals'];\n  mintAuthority: InitializeMintInstructionDataArgs['mintAuthority'];\n  freezeAuthority?: InitializeMintInstructionDataArgs['freezeAuthority'];\n};\n\nexport function getInitializeMintInstruction<\n  TAccountMint extends string,\n  TAccountRent extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: InitializeMintInput<TAccountMint, TAccountRent>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeMintInstruction<TProgramAddress, TAccountMint, TAccountRent> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    rent: { value: input.rent ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.rent.value) {\n    accounts.rent.value =\n      'SysvarRent111111111111111111111111111111111' as Address<'SysvarRent111111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.mint), getAccountMeta(accounts.rent)],\n    data: getInitializeMintInstructionDataEncoder().encode(\n      args as InitializeMintInstructionDataArgs\n    ),\n    programAddress,\n  } as InitializeMintInstruction<TProgramAddress, TAccountMint, TAccountRent>);\n}\n\nexport type ParsedInitializeMintInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** Token mint account. */\n    mint: TAccountMetas[0];\n    /** Rent sysvar. */\n    rent: TAccountMetas[1];\n  };\n  data: InitializeMintInstructionData;\n};\n\nexport function parseInitializeMintInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedInitializeMintInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount(), rent: getNextAccount() },\n    data: getInitializeMintInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  none,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_MINT2_DISCRIMINATOR = 20;\n\nexport function getInitializeMint2DiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_MINT2_DISCRIMINATOR);\n}\n\nexport type InitializeMint2Instruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeMint2InstructionData = {\n  discriminator: number;\n  /** Number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n  /** The authority/multisignature to mint tokens. */\n  mintAuthority: Address;\n  /** The optional freeze authority/multisignature of the mint. */\n  freezeAuthority: Option<Address>;\n};\n\nexport type InitializeMint2InstructionDataArgs = {\n  /** Number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n  /** The authority/multisignature to mint tokens. */\n  mintAuthority: Address;\n  /** The optional freeze authority/multisignature of the mint. */\n  freezeAuthority?: OptionOrNullable<Address>;\n};\n\nexport function getInitializeMint2InstructionDataEncoder(): Encoder<InitializeMint2InstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['decimals', getU8Encoder()],\n      ['mintAuthority', getAddressEncoder()],\n      ['freezeAuthority', getOptionEncoder(getAddressEncoder())],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_MINT2_DISCRIMINATOR,\n      freezeAuthority: value.freezeAuthority ?? none(),\n    })\n  );\n}\n\nexport function getInitializeMint2InstructionDataDecoder(): Decoder<InitializeMint2InstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['decimals', getU8Decoder()],\n    ['mintAuthority', getAddressDecoder()],\n    ['freezeAuthority', getOptionDecoder(getAddressDecoder())],\n  ]);\n}\n\nexport function getInitializeMint2InstructionDataCodec(): Codec<\n  InitializeMint2InstructionDataArgs,\n  InitializeMint2InstructionData\n> {\n  return combineCodec(\n    getInitializeMint2InstructionDataEncoder(),\n    getInitializeMint2InstructionDataDecoder()\n  );\n}\n\nexport type InitializeMint2Input<TAccountMint extends string = string> = {\n  /** The mint to initialize. */\n  mint: Address<TAccountMint>;\n  decimals: InitializeMint2InstructionDataArgs['decimals'];\n  mintAuthority: InitializeMint2InstructionDataArgs['mintAuthority'];\n  freezeAuthority?: InitializeMint2InstructionDataArgs['freezeAuthority'];\n};\n\nexport function getInitializeMint2Instruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: InitializeMint2Input<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeMint2Instruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.mint)],\n    data: getInitializeMint2InstructionDataEncoder().encode(\n      args as InitializeMint2InstructionDataArgs\n    ),\n    programAddress,\n  } as InitializeMint2Instruction<TProgramAddress, TAccountMint>);\n}\n\nexport type ParsedInitializeMint2Instruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to initialize. */\n    mint: TAccountMetas[0];\n  };\n  data: InitializeMint2InstructionData;\n};\n\nexport function parseInitializeMint2Instruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedInitializeMint2Instruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount() },\n    data: getInitializeMint2InstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_MULTISIG_DISCRIMINATOR = 2;\n\nexport function getInitializeMultisigDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_MULTISIG_DISCRIMINATOR);\n}\n\nexport type InitializeMultisigInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMultisig extends string | AccountMeta<string> = string,\n  TAccountRent extends\n    | string\n    | AccountMeta<string> = 'SysvarRent111111111111111111111111111111111',\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMultisig extends string\n        ? WritableAccount<TAccountMultisig>\n        : TAccountMultisig,\n      TAccountRent extends string\n        ? ReadonlyAccount<TAccountRent>\n        : TAccountRent,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeMultisigInstructionData = {\n  discriminator: number;\n  /** The number of signers (M) required to validate this multisignature account. */\n  m: number;\n};\n\nexport type InitializeMultisigInstructionDataArgs = {\n  /** The number of signers (M) required to validate this multisignature account. */\n  m: number;\n};\n\nexport function getInitializeMultisigInstructionDataEncoder(): FixedSizeEncoder<InitializeMultisigInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['m', getU8Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: INITIALIZE_MULTISIG_DISCRIMINATOR })\n  );\n}\n\nexport function getInitializeMultisigInstructionDataDecoder(): FixedSizeDecoder<InitializeMultisigInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['m', getU8Decoder()],\n  ]);\n}\n\nexport function getInitializeMultisigInstructionDataCodec(): FixedSizeCodec<\n  InitializeMultisigInstructionDataArgs,\n  InitializeMultisigInstructionData\n> {\n  return combineCodec(\n    getInitializeMultisigInstructionDataEncoder(),\n    getInitializeMultisigInstructionDataDecoder()\n  );\n}\n\nexport type InitializeMultisigInput<\n  TAccountMultisig extends string = string,\n  TAccountRent extends string = string,\n> = {\n  /** The multisignature account to initialize. */\n  multisig: Address<TAccountMultisig>;\n  /** Rent sysvar. */\n  rent?: Address<TAccountRent>;\n  m: InitializeMultisigInstructionDataArgs['m'];\n  signers: Array<Address>;\n};\n\nexport function getInitializeMultisigInstruction<\n  TAccountMultisig extends string,\n  TAccountRent extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: InitializeMultisigInput<TAccountMultisig, TAccountRent>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeMultisigInstruction<\n  TProgramAddress,\n  TAccountMultisig,\n  TAccountRent\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    multisig: { value: input.multisig ?? null, isWritable: true },\n    rent: { value: input.rent ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.rent.value) {\n    accounts.rent.value =\n      'SysvarRent111111111111111111111111111111111' as Address<'SysvarRent111111111111111111111111111111111'>;\n  }\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = args.signers.map((address) => ({\n    address,\n    role: AccountRole.READONLY,\n  }));\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.multisig),\n      getAccountMeta(accounts.rent),\n      ...remainingAccounts,\n    ],\n    data: getInitializeMultisigInstructionDataEncoder().encode(\n      args as InitializeMultisigInstructionDataArgs\n    ),\n    programAddress,\n  } as InitializeMultisigInstruction<\n    TProgramAddress,\n    TAccountMultisig,\n    TAccountRent\n  >);\n}\n\nexport type ParsedInitializeMultisigInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The multisignature account to initialize. */\n    multisig: TAccountMetas[0];\n    /** Rent sysvar. */\n    rent: TAccountMetas[1];\n  };\n  data: InitializeMultisigInstructionData;\n};\n\nexport function parseInitializeMultisigInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedInitializeMultisigInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { multisig: getNextAccount(), rent: getNextAccount() },\n    data: getInitializeMultisigInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_MULTISIG2_DISCRIMINATOR = 19;\n\nexport function getInitializeMultisig2DiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_MULTISIG2_DISCRIMINATOR);\n}\n\nexport type InitializeMultisig2Instruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMultisig extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMultisig extends string\n        ? WritableAccount<TAccountMultisig>\n        : TAccountMultisig,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeMultisig2InstructionData = {\n  discriminator: number;\n  /** The number of signers (M) required to validate this multisignature account. */\n  m: number;\n};\n\nexport type InitializeMultisig2InstructionDataArgs = {\n  /** The number of signers (M) required to validate this multisignature account. */\n  m: number;\n};\n\nexport function getInitializeMultisig2InstructionDataEncoder(): FixedSizeEncoder<InitializeMultisig2InstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['m', getU8Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: INITIALIZE_MULTISIG2_DISCRIMINATOR })\n  );\n}\n\nexport function getInitializeMultisig2InstructionDataDecoder(): FixedSizeDecoder<InitializeMultisig2InstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['m', getU8Decoder()],\n  ]);\n}\n\nexport function getInitializeMultisig2InstructionDataCodec(): FixedSizeCodec<\n  InitializeMultisig2InstructionDataArgs,\n  InitializeMultisig2InstructionData\n> {\n  return combineCodec(\n    getInitializeMultisig2InstructionDataEncoder(),\n    getInitializeMultisig2InstructionDataDecoder()\n  );\n}\n\nexport type InitializeMultisig2Input<TAccountMultisig extends string = string> =\n  {\n    /** The multisignature account to initialize. */\n    multisig: Address<TAccountMultisig>;\n    m: InitializeMultisig2InstructionDataArgs['m'];\n    signers: Array<Address>;\n  };\n\nexport function getInitializeMultisig2Instruction<\n  TAccountMultisig extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: InitializeMultisig2Input<TAccountMultisig>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeMultisig2Instruction<TProgramAddress, TAccountMultisig> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    multisig: { value: input.multisig ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = args.signers.map((address) => ({\n    address,\n    role: AccountRole.READONLY,\n  }));\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.multisig), ...remainingAccounts],\n    data: getInitializeMultisig2InstructionDataEncoder().encode(\n      args as InitializeMultisig2InstructionDataArgs\n    ),\n    programAddress,\n  } as InitializeMultisig2Instruction<TProgramAddress, TAccountMultisig>);\n}\n\nexport type ParsedInitializeMultisig2Instruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The multisignature account to initialize. */\n    multisig: TAccountMetas[0];\n  };\n  data: InitializeMultisig2InstructionData;\n};\n\nexport function parseInitializeMultisig2Instruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedInitializeMultisig2Instruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { multisig: getNextAccount() },\n    data: getInitializeMultisig2InstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const MINT_TO_DISCRIMINATOR = 7;\n\nexport function getMintToDiscriminatorBytes() {\n  return getU8Encoder().encode(MINT_TO_DISCRIMINATOR);\n}\n\nexport type MintToInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountToken extends string | AccountMeta<string> = string,\n  TAccountMintAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountMintAuthority extends string\n        ? ReadonlyAccount<TAccountMintAuthority>\n        : TAccountMintAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type MintToInstructionData = {\n  discriminator: number;\n  /** The amount of new tokens to mint. */\n  amount: bigint;\n};\n\nexport type MintToInstructionDataArgs = {\n  /** The amount of new tokens to mint. */\n  amount: number | bigint;\n};\n\nexport function getMintToInstructionDataEncoder(): FixedSizeEncoder<MintToInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: MINT_TO_DISCRIMINATOR })\n  );\n}\n\nexport function getMintToInstructionDataDecoder(): FixedSizeDecoder<MintToInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n  ]);\n}\n\nexport function getMintToInstructionDataCodec(): FixedSizeCodec<\n  MintToInstructionDataArgs,\n  MintToInstructionData\n> {\n  return combineCodec(\n    getMintToInstructionDataEncoder(),\n    getMintToInstructionDataDecoder()\n  );\n}\n\nexport type MintToInput<\n  TAccountMint extends string = string,\n  TAccountToken extends string = string,\n  TAccountMintAuthority extends string = string,\n> = {\n  /** The mint account. */\n  mint: Address<TAccountMint>;\n  /** The account to mint tokens to. */\n  token: Address<TAccountToken>;\n  /** The mint's minting authority or its multisignature account. */\n  mintAuthority:\n    | Address<TAccountMintAuthority>\n    | TransactionSigner<TAccountMintAuthority>;\n  amount: MintToInstructionDataArgs['amount'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getMintToInstruction<\n  TAccountMint extends string,\n  TAccountToken extends string,\n  TAccountMintAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: MintToInput<TAccountMint, TAccountToken, TAccountMintAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): MintToInstruction<\n  TProgramAddress,\n  TAccountMint,\n  TAccountToken,\n  (typeof input)['mintAuthority'] extends TransactionSigner<TAccountMintAuthority>\n    ? ReadonlySignerAccount<TAccountMintAuthority> &\n        AccountSignerMeta<TAccountMintAuthority>\n    : TAccountMintAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    token: { value: input.token ?? null, isWritable: true },\n    mintAuthority: { value: input.mintAuthority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.mintAuthority),\n      ...remainingAccounts,\n    ],\n    data: getMintToInstructionDataEncoder().encode(\n      args as MintToInstructionDataArgs\n    ),\n    programAddress,\n  } as MintToInstruction<\n    TProgramAddress,\n    TAccountMint,\n    TAccountToken,\n    (typeof input)['mintAuthority'] extends TransactionSigner<TAccountMintAuthority>\n      ? ReadonlySignerAccount<TAccountMintAuthority> &\n          AccountSignerMeta<TAccountMintAuthority>\n      : TAccountMintAuthority\n  >);\n}\n\nexport type ParsedMintToInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint account. */\n    mint: TAccountMetas[0];\n    /** The account to mint tokens to. */\n    token: TAccountMetas[1];\n    /** The mint's minting authority or its multisignature account. */\n    mintAuthority: TAccountMetas[2];\n  };\n  data: MintToInstructionData;\n};\n\nexport function parseMintToInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedMintToInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      token: getNextAccount(),\n      mintAuthority: getNextAccount(),\n    },\n    data: getMintToInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const MINT_TO_CHECKED_DISCRIMINATOR = 14;\n\nexport function getMintToCheckedDiscriminatorBytes() {\n  return getU8Encoder().encode(MINT_TO_CHECKED_DISCRIMINATOR);\n}\n\nexport type MintToCheckedInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountToken extends string | AccountMeta<string> = string,\n  TAccountMintAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountMintAuthority extends string\n        ? ReadonlyAccount<TAccountMintAuthority>\n        : TAccountMintAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type MintToCheckedInstructionData = {\n  discriminator: number;\n  /** The amount of new tokens to mint. */\n  amount: bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n};\n\nexport type MintToCheckedInstructionDataArgs = {\n  /** The amount of new tokens to mint. */\n  amount: number | bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n};\n\nexport function getMintToCheckedInstructionDataEncoder(): FixedSizeEncoder<MintToCheckedInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n      ['decimals', getU8Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: MINT_TO_CHECKED_DISCRIMINATOR })\n  );\n}\n\nexport function getMintToCheckedInstructionDataDecoder(): FixedSizeDecoder<MintToCheckedInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n    ['decimals', getU8Decoder()],\n  ]);\n}\n\nexport function getMintToCheckedInstructionDataCodec(): FixedSizeCodec<\n  MintToCheckedInstructionDataArgs,\n  MintToCheckedInstructionData\n> {\n  return combineCodec(\n    getMintToCheckedInstructionDataEncoder(),\n    getMintToCheckedInstructionDataDecoder()\n  );\n}\n\nexport type MintToCheckedInput<\n  TAccountMint extends string = string,\n  TAccountToken extends string = string,\n  TAccountMintAuthority extends string = string,\n> = {\n  /** The mint. */\n  mint: Address<TAccountMint>;\n  /** The account to mint tokens to. */\n  token: Address<TAccountToken>;\n  /** The mint's minting authority or its multisignature account. */\n  mintAuthority:\n    | Address<TAccountMintAuthority>\n    | TransactionSigner<TAccountMintAuthority>;\n  amount: MintToCheckedInstructionDataArgs['amount'];\n  decimals: MintToCheckedInstructionDataArgs['decimals'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getMintToCheckedInstruction<\n  TAccountMint extends string,\n  TAccountToken extends string,\n  TAccountMintAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: MintToCheckedInput<TAccountMint, TAccountToken, TAccountMintAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): MintToCheckedInstruction<\n  TProgramAddress,\n  TAccountMint,\n  TAccountToken,\n  (typeof input)['mintAuthority'] extends TransactionSigner<TAccountMintAuthority>\n    ? ReadonlySignerAccount<TAccountMintAuthority> &\n        AccountSignerMeta<TAccountMintAuthority>\n    : TAccountMintAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    token: { value: input.token ?? null, isWritable: true },\n    mintAuthority: { value: input.mintAuthority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.mintAuthority),\n      ...remainingAccounts,\n    ],\n    data: getMintToCheckedInstructionDataEncoder().encode(\n      args as MintToCheckedInstructionDataArgs\n    ),\n    programAddress,\n  } as MintToCheckedInstruction<\n    TProgramAddress,\n    TAccountMint,\n    TAccountToken,\n    (typeof input)['mintAuthority'] extends TransactionSigner<TAccountMintAuthority>\n      ? ReadonlySignerAccount<TAccountMintAuthority> &\n          AccountSignerMeta<TAccountMintAuthority>\n      : TAccountMintAuthority\n  >);\n}\n\nexport type ParsedMintToCheckedInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint. */\n    mint: TAccountMetas[0];\n    /** The account to mint tokens to. */\n    token: TAccountMetas[1];\n    /** The mint's minting authority or its multisignature account. */\n    mintAuthority: TAccountMetas[2];\n  };\n  data: MintToCheckedInstructionData;\n};\n\nexport function parseMintToCheckedInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedMintToCheckedInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      token: getNextAccount(),\n      mintAuthority: getNextAccount(),\n    },\n    data: getMintToCheckedInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { findAssociatedTokenPda } from '../pdas';\nimport { ASSOCIATED_TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport {\n  expectAddress,\n  getAccountMetaFactory,\n  type ResolvedAccount,\n} from '../shared';\n\nexport const RECOVER_NESTED_ASSOCIATED_TOKEN_DISCRIMINATOR = 2;\n\nexport function getRecoverNestedAssociatedTokenDiscriminatorBytes() {\n  return getU8Encoder().encode(RECOVER_NESTED_ASSOCIATED_TOKEN_DISCRIMINATOR);\n}\n\nexport type RecoverNestedAssociatedTokenInstruction<\n  TProgram extends string = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n  TAccountNestedAssociatedAccountAddress extends\n    | string\n    | AccountMeta<string> = string,\n  TAccountNestedTokenMintAddress extends string | AccountMeta<string> = string,\n  TAccountDestinationAssociatedAccountAddress extends\n    | string\n    | AccountMeta<string> = string,\n  TAccountOwnerAssociatedAccountAddress extends\n    | string\n    | AccountMeta<string> = string,\n  TAccountOwnerTokenMintAddress extends string | AccountMeta<string> = string,\n  TAccountWalletAddress extends string | AccountMeta<string> = string,\n  TAccountTokenProgram extends\n    | string\n    | AccountMeta<string> = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountNestedAssociatedAccountAddress extends string\n        ? WritableAccount<TAccountNestedAssociatedAccountAddress>\n        : TAccountNestedAssociatedAccountAddress,\n      TAccountNestedTokenMintAddress extends string\n        ? ReadonlyAccount<TAccountNestedTokenMintAddress>\n        : TAccountNestedTokenMintAddress,\n      TAccountDestinationAssociatedAccountAddress extends string\n        ? WritableAccount<TAccountDestinationAssociatedAccountAddress>\n        : TAccountDestinationAssociatedAccountAddress,\n      TAccountOwnerAssociatedAccountAddress extends string\n        ? ReadonlyAccount<TAccountOwnerAssociatedAccountAddress>\n        : TAccountOwnerAssociatedAccountAddress,\n      TAccountOwnerTokenMintAddress extends string\n        ? ReadonlyAccount<TAccountOwnerTokenMintAddress>\n        : TAccountOwnerTokenMintAddress,\n      TAccountWalletAddress extends string\n        ? WritableSignerAccount<TAccountWalletAddress> &\n            AccountSignerMeta<TAccountWalletAddress>\n        : TAccountWalletAddress,\n      TAccountTokenProgram extends string\n        ? ReadonlyAccount<TAccountTokenProgram>\n        : TAccountTokenProgram,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type RecoverNestedAssociatedTokenInstructionData = {\n  discriminator: number;\n};\n\nexport type RecoverNestedAssociatedTokenInstructionDataArgs = {};\n\nexport function getRecoverNestedAssociatedTokenInstructionDataEncoder(): FixedSizeEncoder<RecoverNestedAssociatedTokenInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({\n      ...value,\n      discriminator: RECOVER_NESTED_ASSOCIATED_TOKEN_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getRecoverNestedAssociatedTokenInstructionDataDecoder(): FixedSizeDecoder<RecoverNestedAssociatedTokenInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getRecoverNestedAssociatedTokenInstructionDataCodec(): FixedSizeCodec<\n  RecoverNestedAssociatedTokenInstructionDataArgs,\n  RecoverNestedAssociatedTokenInstructionData\n> {\n  return combineCodec(\n    getRecoverNestedAssociatedTokenInstructionDataEncoder(),\n    getRecoverNestedAssociatedTokenInstructionDataDecoder()\n  );\n}\n\nexport type RecoverNestedAssociatedTokenAsyncInput<\n  TAccountNestedAssociatedAccountAddress extends string = string,\n  TAccountNestedTokenMintAddress extends string = string,\n  TAccountDestinationAssociatedAccountAddress extends string = string,\n  TAccountOwnerAssociatedAccountAddress extends string = string,\n  TAccountOwnerTokenMintAddress extends string = string,\n  TAccountWalletAddress extends string = string,\n  TAccountTokenProgram extends string = string,\n> = {\n  /** Nested associated token account, must be owned by `ownerAssociatedAccountAddress`. */\n  nestedAssociatedAccountAddress?: Address<TAccountNestedAssociatedAccountAddress>;\n  /** Token mint for the nested associated token account. */\n  nestedTokenMintAddress: Address<TAccountNestedTokenMintAddress>;\n  /** Wallet's associated token account. */\n  destinationAssociatedAccountAddress?: Address<TAccountDestinationAssociatedAccountAddress>;\n  /** Owner associated token account address, must be owned by `walletAddress`. */\n  ownerAssociatedAccountAddress?: Address<TAccountOwnerAssociatedAccountAddress>;\n  /** Token mint for the owner associated token account. */\n  ownerTokenMintAddress: Address<TAccountOwnerTokenMintAddress>;\n  /** Wallet address for the owner associated token account. */\n  walletAddress: TransactionSigner<TAccountWalletAddress>;\n  /** SPL Token program. */\n  tokenProgram?: Address<TAccountTokenProgram>;\n};\n\nexport async function getRecoverNestedAssociatedTokenInstructionAsync<\n  TAccountNestedAssociatedAccountAddress extends string,\n  TAccountNestedTokenMintAddress extends string,\n  TAccountDestinationAssociatedAccountAddress extends string,\n  TAccountOwnerAssociatedAccountAddress extends string,\n  TAccountOwnerTokenMintAddress extends string,\n  TAccountWalletAddress extends string,\n  TAccountTokenProgram extends string,\n  TProgramAddress extends Address = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n>(\n  input: RecoverNestedAssociatedTokenAsyncInput<\n    TAccountNestedAssociatedAccountAddress,\n    TAccountNestedTokenMintAddress,\n    TAccountDestinationAssociatedAccountAddress,\n    TAccountOwnerAssociatedAccountAddress,\n    TAccountOwnerTokenMintAddress,\n    TAccountWalletAddress,\n    TAccountTokenProgram\n  >,\n  config?: { programAddress?: TProgramAddress }\n): Promise<\n  RecoverNestedAssociatedTokenInstruction<\n    TProgramAddress,\n    TAccountNestedAssociatedAccountAddress,\n    TAccountNestedTokenMintAddress,\n    TAccountDestinationAssociatedAccountAddress,\n    TAccountOwnerAssociatedAccountAddress,\n    TAccountOwnerTokenMintAddress,\n    TAccountWalletAddress,\n    TAccountTokenProgram\n  >\n> {\n  // Program address.\n  const programAddress =\n    config?.programAddress ?? ASSOCIATED_TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    nestedAssociatedAccountAddress: {\n      value: input.nestedAssociatedAccountAddress ?? null,\n      isWritable: true,\n    },\n    nestedTokenMintAddress: {\n      value: input.nestedTokenMintAddress ?? null,\n      isWritable: false,\n    },\n    destinationAssociatedAccountAddress: {\n      value: input.destinationAssociatedAccountAddress ?? null,\n      isWritable: true,\n    },\n    ownerAssociatedAccountAddress: {\n      value: input.ownerAssociatedAccountAddress ?? null,\n      isWritable: false,\n    },\n    ownerTokenMintAddress: {\n      value: input.ownerTokenMintAddress ?? null,\n      isWritable: false,\n    },\n    walletAddress: { value: input.walletAddress ?? null, isWritable: true },\n    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Resolve default values.\n  if (!accounts.tokenProgram.value) {\n    accounts.tokenProgram.value =\n      'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address<'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'>;\n  }\n  if (!accounts.ownerAssociatedAccountAddress.value) {\n    accounts.ownerAssociatedAccountAddress.value = await findAssociatedTokenPda(\n      {\n        owner: expectAddress(accounts.walletAddress.value),\n        tokenProgram: expectAddress(accounts.tokenProgram.value),\n        mint: expectAddress(accounts.ownerTokenMintAddress.value),\n      }\n    );\n  }\n  if (!accounts.nestedAssociatedAccountAddress.value) {\n    accounts.nestedAssociatedAccountAddress.value =\n      await findAssociatedTokenPda({\n        owner: expectAddress(accounts.ownerAssociatedAccountAddress.value),\n        tokenProgram: expectAddress(accounts.tokenProgram.value),\n        mint: expectAddress(accounts.nestedTokenMintAddress.value),\n      });\n  }\n  if (!accounts.destinationAssociatedAccountAddress.value) {\n    accounts.destinationAssociatedAccountAddress.value =\n      await findAssociatedTokenPda({\n        owner: expectAddress(accounts.walletAddress.value),\n        tokenProgram: expectAddress(accounts.tokenProgram.value),\n        mint: expectAddress(accounts.nestedTokenMintAddress.value),\n      });\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.nestedAssociatedAccountAddress),\n      getAccountMeta(accounts.nestedTokenMintAddress),\n      getAccountMeta(accounts.destinationAssociatedAccountAddress),\n      getAccountMeta(accounts.ownerAssociatedAccountAddress),\n      getAccountMeta(accounts.ownerTokenMintAddress),\n      getAccountMeta(accounts.walletAddress),\n      getAccountMeta(accounts.tokenProgram),\n    ],\n    data: getRecoverNestedAssociatedTokenInstructionDataEncoder().encode({}),\n    programAddress,\n  } as RecoverNestedAssociatedTokenInstruction<\n    TProgramAddress,\n    TAccountNestedAssociatedAccountAddress,\n    TAccountNestedTokenMintAddress,\n    TAccountDestinationAssociatedAccountAddress,\n    TAccountOwnerAssociatedAccountAddress,\n    TAccountOwnerTokenMintAddress,\n    TAccountWalletAddress,\n    TAccountTokenProgram\n  >);\n}\n\nexport type RecoverNestedAssociatedTokenInput<\n  TAccountNestedAssociatedAccountAddress extends string = string,\n  TAccountNestedTokenMintAddress extends string = string,\n  TAccountDestinationAssociatedAccountAddress extends string = string,\n  TAccountOwnerAssociatedAccountAddress extends string = string,\n  TAccountOwnerTokenMintAddress extends string = string,\n  TAccountWalletAddress extends string = string,\n  TAccountTokenProgram extends string = string,\n> = {\n  /** Nested associated token account, must be owned by `ownerAssociatedAccountAddress`. */\n  nestedAssociatedAccountAddress: Address<TAccountNestedAssociatedAccountAddress>;\n  /** Token mint for the nested associated token account. */\n  nestedTokenMintAddress: Address<TAccountNestedTokenMintAddress>;\n  /** Wallet's associated token account. */\n  destinationAssociatedAccountAddress: Address<TAccountDestinationAssociatedAccountAddress>;\n  /** Owner associated token account address, must be owned by `walletAddress`. */\n  ownerAssociatedAccountAddress: Address<TAccountOwnerAssociatedAccountAddress>;\n  /** Token mint for the owner associated token account. */\n  ownerTokenMintAddress: Address<TAccountOwnerTokenMintAddress>;\n  /** Wallet address for the owner associated token account. */\n  walletAddress: TransactionSigner<TAccountWalletAddress>;\n  /** SPL Token program. */\n  tokenProgram?: Address<TAccountTokenProgram>;\n};\n\nexport function getRecoverNestedAssociatedTokenInstruction<\n  TAccountNestedAssociatedAccountAddress extends string,\n  TAccountNestedTokenMintAddress extends string,\n  TAccountDestinationAssociatedAccountAddress extends string,\n  TAccountOwnerAssociatedAccountAddress extends string,\n  TAccountOwnerTokenMintAddress extends string,\n  TAccountWalletAddress extends string,\n  TAccountTokenProgram extends string,\n  TProgramAddress extends Address = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n>(\n  input: RecoverNestedAssociatedTokenInput<\n    TAccountNestedAssociatedAccountAddress,\n    TAccountNestedTokenMintAddress,\n    TAccountDestinationAssociatedAccountAddress,\n    TAccountOwnerAssociatedAccountAddress,\n    TAccountOwnerTokenMintAddress,\n    TAccountWalletAddress,\n    TAccountTokenProgram\n  >,\n  config?: { programAddress?: TProgramAddress }\n): RecoverNestedAssociatedTokenInstruction<\n  TProgramAddress,\n  TAccountNestedAssociatedAccountAddress,\n  TAccountNestedTokenMintAddress,\n  TAccountDestinationAssociatedAccountAddress,\n  TAccountOwnerAssociatedAccountAddress,\n  TAccountOwnerTokenMintAddress,\n  TAccountWalletAddress,\n  TAccountTokenProgram\n> {\n  // Program address.\n  const programAddress =\n    config?.programAddress ?? ASSOCIATED_TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    nestedAssociatedAccountAddress: {\n      value: input.nestedAssociatedAccountAddress ?? null,\n      isWritable: true,\n    },\n    nestedTokenMintAddress: {\n      value: input.nestedTokenMintAddress ?? null,\n      isWritable: false,\n    },\n    destinationAssociatedAccountAddress: {\n      value: input.destinationAssociatedAccountAddress ?? null,\n      isWritable: true,\n    },\n    ownerAssociatedAccountAddress: {\n      value: input.ownerAssociatedAccountAddress ?? null,\n      isWritable: false,\n    },\n    ownerTokenMintAddress: {\n      value: input.ownerTokenMintAddress ?? null,\n      isWritable: false,\n    },\n    walletAddress: { value: input.walletAddress ?? null, isWritable: true },\n    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Resolve default values.\n  if (!accounts.tokenProgram.value) {\n    accounts.tokenProgram.value =\n      'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address<'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.nestedAssociatedAccountAddress),\n      getAccountMeta(accounts.nestedTokenMintAddress),\n      getAccountMeta(accounts.destinationAssociatedAccountAddress),\n      getAccountMeta(accounts.ownerAssociatedAccountAddress),\n      getAccountMeta(accounts.ownerTokenMintAddress),\n      getAccountMeta(accounts.walletAddress),\n      getAccountMeta(accounts.tokenProgram),\n    ],\n    data: getRecoverNestedAssociatedTokenInstructionDataEncoder().encode({}),\n    programAddress,\n  } as RecoverNestedAssociatedTokenInstruction<\n    TProgramAddress,\n    TAccountNestedAssociatedAccountAddress,\n    TAccountNestedTokenMintAddress,\n    TAccountDestinationAssociatedAccountAddress,\n    TAccountOwnerAssociatedAccountAddress,\n    TAccountOwnerTokenMintAddress,\n    TAccountWalletAddress,\n    TAccountTokenProgram\n  >);\n}\n\nexport type ParsedRecoverNestedAssociatedTokenInstruction<\n  TProgram extends string = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** Nested associated token account, must be owned by `ownerAssociatedAccountAddress`. */\n    nestedAssociatedAccountAddress: TAccountMetas[0];\n    /** Token mint for the nested associated token account. */\n    nestedTokenMintAddress: TAccountMetas[1];\n    /** Wallet's associated token account. */\n    destinationAssociatedAccountAddress: TAccountMetas[2];\n    /** Owner associated token account address, must be owned by `walletAddress`. */\n    ownerAssociatedAccountAddress: TAccountMetas[3];\n    /** Token mint for the owner associated token account. */\n    ownerTokenMintAddress: TAccountMetas[4];\n    /** Wallet address for the owner associated token account. */\n    walletAddress: TAccountMetas[5];\n    /** SPL Token program. */\n    tokenProgram: TAccountMetas[6];\n  };\n  data: RecoverNestedAssociatedTokenInstructionData;\n};\n\nexport function parseRecoverNestedAssociatedTokenInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedRecoverNestedAssociatedTokenInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 7) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      nestedAssociatedAccountAddress: getNextAccount(),\n      nestedTokenMintAddress: getNextAccount(),\n      destinationAssociatedAccountAddress: getNextAccount(),\n      ownerAssociatedAccountAddress: getNextAccount(),\n      ownerTokenMintAddress: getNextAccount(),\n      walletAddress: getNextAccount(),\n      tokenProgram: getNextAccount(),\n    },\n    data: getRecoverNestedAssociatedTokenInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const REVOKE_DISCRIMINATOR = 5;\n\nexport function getRevokeDiscriminatorBytes() {\n  return getU8Encoder().encode(REVOKE_DISCRIMINATOR);\n}\n\nexport type RevokeInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountSource extends string | AccountMeta<string> = string,\n  TAccountOwner extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountSource extends string\n        ? WritableAccount<TAccountSource>\n        : TAccountSource,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type RevokeInstructionData = { discriminator: number };\n\nexport type RevokeInstructionDataArgs = {};\n\nexport function getRevokeInstructionDataEncoder(): FixedSizeEncoder<RevokeInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({ ...value, discriminator: REVOKE_DISCRIMINATOR })\n  );\n}\n\nexport function getRevokeInstructionDataDecoder(): FixedSizeDecoder<RevokeInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getRevokeInstructionDataCodec(): FixedSizeCodec<\n  RevokeInstructionDataArgs,\n  RevokeInstructionData\n> {\n  return combineCodec(\n    getRevokeInstructionDataEncoder(),\n    getRevokeInstructionDataDecoder()\n  );\n}\n\nexport type RevokeInput<\n  TAccountSource extends string = string,\n  TAccountOwner extends string = string,\n> = {\n  /** The source account. */\n  source: Address<TAccountSource>;\n  /** The source account owner or its multisignature. */\n  owner: Address<TAccountOwner> | TransactionSigner<TAccountOwner>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getRevokeInstruction<\n  TAccountSource extends string,\n  TAccountOwner extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: RevokeInput<TAccountSource, TAccountOwner>,\n  config?: { programAddress?: TProgramAddress }\n): RevokeInstruction<\n  TProgramAddress,\n  TAccountSource,\n  (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n    ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n    : TAccountOwner\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    source: { value: input.source ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.source),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts,\n    ],\n    data: getRevokeInstructionDataEncoder().encode({}),\n    programAddress,\n  } as RevokeInstruction<\n    TProgramAddress,\n    TAccountSource,\n    (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n      ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n      : TAccountOwner\n  >);\n}\n\nexport type ParsedRevokeInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The source account. */\n    source: TAccountMetas[0];\n    /** The source account owner or its multisignature. */\n    owner: TAccountMetas[1];\n  };\n  data: RevokeInstructionData;\n};\n\nexport function parseRevokeInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedRevokeInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { source: getNextAccount(), owner: getNextAccount() },\n    data: getRevokeInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\nimport {\n  getAuthorityTypeDecoder,\n  getAuthorityTypeEncoder,\n  type AuthorityType,\n  type AuthorityTypeArgs,\n} from '../types';\n\nexport const SET_AUTHORITY_DISCRIMINATOR = 6;\n\nexport function getSetAuthorityDiscriminatorBytes() {\n  return getU8Encoder().encode(SET_AUTHORITY_DISCRIMINATOR);\n}\n\nexport type SetAuthorityInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountOwned extends string | AccountMeta<string> = string,\n  TAccountOwner extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountOwned extends string\n        ? WritableAccount<TAccountOwned>\n        : TAccountOwned,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type SetAuthorityInstructionData = {\n  discriminator: number;\n  /** The type of authority to update. */\n  authorityType: AuthorityType;\n  /** The new authority */\n  newAuthority: Option<Address>;\n};\n\nexport type SetAuthorityInstructionDataArgs = {\n  /** The type of authority to update. */\n  authorityType: AuthorityTypeArgs;\n  /** The new authority */\n  newAuthority: OptionOrNullable<Address>;\n};\n\nexport function getSetAuthorityInstructionDataEncoder(): Encoder<SetAuthorityInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['authorityType', getAuthorityTypeEncoder()],\n      ['newAuthority', getOptionEncoder(getAddressEncoder())],\n    ]),\n    (value) => ({ ...value, discriminator: SET_AUTHORITY_DISCRIMINATOR })\n  );\n}\n\nexport function getSetAuthorityInstructionDataDecoder(): Decoder<SetAuthorityInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['authorityType', getAuthorityTypeDecoder()],\n    ['newAuthority', getOptionDecoder(getAddressDecoder())],\n  ]);\n}\n\nexport function getSetAuthorityInstructionDataCodec(): Codec<\n  SetAuthorityInstructionDataArgs,\n  SetAuthorityInstructionData\n> {\n  return combineCodec(\n    getSetAuthorityInstructionDataEncoder(),\n    getSetAuthorityInstructionDataDecoder()\n  );\n}\n\nexport type SetAuthorityInput<\n  TAccountOwned extends string = string,\n  TAccountOwner extends string = string,\n> = {\n  /** The mint or account to change the authority of. */\n  owned: Address<TAccountOwned>;\n  /** The current authority or the multisignature account of the mint or account to update. */\n  owner: Address<TAccountOwner> | TransactionSigner<TAccountOwner>;\n  authorityType: SetAuthorityInstructionDataArgs['authorityType'];\n  newAuthority: SetAuthorityInstructionDataArgs['newAuthority'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getSetAuthorityInstruction<\n  TAccountOwned extends string,\n  TAccountOwner extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: SetAuthorityInput<TAccountOwned, TAccountOwner>,\n  config?: { programAddress?: TProgramAddress }\n): SetAuthorityInstruction<\n  TProgramAddress,\n  TAccountOwned,\n  (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n    ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n    : TAccountOwner\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    owned: { value: input.owned ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.owned),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts,\n    ],\n    data: getSetAuthorityInstructionDataEncoder().encode(\n      args as SetAuthorityInstructionDataArgs\n    ),\n    programAddress,\n  } as SetAuthorityInstruction<\n    TProgramAddress,\n    TAccountOwned,\n    (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n      ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n      : TAccountOwner\n  >);\n}\n\nexport type ParsedSetAuthorityInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint or account to change the authority of. */\n    owned: TAccountMetas[0];\n    /** The current authority or the multisignature account of the mint or account to update. */\n    owner: TAccountMetas[1];\n  };\n  data: SetAuthorityInstructionData;\n};\n\nexport function parseSetAuthorityInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedSetAuthorityInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { owned: getNextAccount(), owner: getNextAccount() },\n    data: getSetAuthorityInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const SYNC_NATIVE_DISCRIMINATOR = 17;\n\nexport function getSyncNativeDiscriminatorBytes() {\n  return getU8Encoder().encode(SYNC_NATIVE_DISCRIMINATOR);\n}\n\nexport type SyncNativeInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountAccount extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type SyncNativeInstructionData = { discriminator: number };\n\nexport type SyncNativeInstructionDataArgs = {};\n\nexport function getSyncNativeInstructionDataEncoder(): FixedSizeEncoder<SyncNativeInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({ ...value, discriminator: SYNC_NATIVE_DISCRIMINATOR })\n  );\n}\n\nexport function getSyncNativeInstructionDataDecoder(): FixedSizeDecoder<SyncNativeInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getSyncNativeInstructionDataCodec(): FixedSizeCodec<\n  SyncNativeInstructionDataArgs,\n  SyncNativeInstructionData\n> {\n  return combineCodec(\n    getSyncNativeInstructionDataEncoder(),\n    getSyncNativeInstructionDataDecoder()\n  );\n}\n\nexport type SyncNativeInput<TAccountAccount extends string = string> = {\n  /** The native token account to sync with its underlying lamports. */\n  account: Address<TAccountAccount>;\n};\n\nexport function getSyncNativeInstruction<\n  TAccountAccount extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: SyncNativeInput<TAccountAccount>,\n  config?: { programAddress?: TProgramAddress }\n): SyncNativeInstruction<TProgramAddress, TAccountAccount> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.account)],\n    data: getSyncNativeInstructionDataEncoder().encode({}),\n    programAddress,\n  } as SyncNativeInstruction<TProgramAddress, TAccountAccount>);\n}\n\nexport type ParsedSyncNativeInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The native token account to sync with its underlying lamports. */\n    account: TAccountMetas[0];\n  };\n  data: SyncNativeInstructionData;\n};\n\nexport function parseSyncNativeInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedSyncNativeInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { account: getNextAccount() },\n    data: getSyncNativeInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const THAW_ACCOUNT_DISCRIMINATOR = 11;\n\nexport function getThawAccountDiscriminatorBytes() {\n  return getU8Encoder().encode(THAW_ACCOUNT_DISCRIMINATOR);\n}\n\nexport type ThawAccountInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountAccount extends string | AccountMeta<string> = string,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountOwner extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type ThawAccountInstructionData = { discriminator: number };\n\nexport type ThawAccountInstructionDataArgs = {};\n\nexport function getThawAccountInstructionDataEncoder(): FixedSizeEncoder<ThawAccountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({ ...value, discriminator: THAW_ACCOUNT_DISCRIMINATOR })\n  );\n}\n\nexport function getThawAccountInstructionDataDecoder(): FixedSizeDecoder<ThawAccountInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getThawAccountInstructionDataCodec(): FixedSizeCodec<\n  ThawAccountInstructionDataArgs,\n  ThawAccountInstructionData\n> {\n  return combineCodec(\n    getThawAccountInstructionDataEncoder(),\n    getThawAccountInstructionDataDecoder()\n  );\n}\n\nexport type ThawAccountInput<\n  TAccountAccount extends string = string,\n  TAccountMint extends string = string,\n  TAccountOwner extends string = string,\n> = {\n  /** The account to thaw. */\n  account: Address<TAccountAccount>;\n  /** The token mint. */\n  mint: Address<TAccountMint>;\n  /** The mint freeze authority or its multisignature account. */\n  owner: Address<TAccountOwner> | TransactionSigner<TAccountOwner>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getThawAccountInstruction<\n  TAccountAccount extends string,\n  TAccountMint extends string,\n  TAccountOwner extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: ThawAccountInput<TAccountAccount, TAccountMint, TAccountOwner>,\n  config?: { programAddress?: TProgramAddress }\n): ThawAccountInstruction<\n  TProgramAddress,\n  TAccountAccount,\n  TAccountMint,\n  (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n    ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n    : TAccountOwner\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    owner: { value: input.owner ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.account),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts,\n    ],\n    data: getThawAccountInstructionDataEncoder().encode({}),\n    programAddress,\n  } as ThawAccountInstruction<\n    TProgramAddress,\n    TAccountAccount,\n    TAccountMint,\n    (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n      ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n      : TAccountOwner\n  >);\n}\n\nexport type ParsedThawAccountInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The account to thaw. */\n    account: TAccountMetas[0];\n    /** The token mint. */\n    mint: TAccountMetas[1];\n    /** The mint freeze authority or its multisignature account. */\n    owner: TAccountMetas[2];\n  };\n  data: ThawAccountInstructionData;\n};\n\nexport function parseThawAccountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedThawAccountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n      mint: getNextAccount(),\n      owner: getNextAccount(),\n    },\n    data: getThawAccountInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const TRANSFER_DISCRIMINATOR = 3;\n\nexport function getTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(TRANSFER_DISCRIMINATOR);\n}\n\nexport type TransferInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountSource extends string | AccountMeta<string> = string,\n  TAccountDestination extends string | AccountMeta<string> = string,\n  TAccountAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountSource extends string\n        ? WritableAccount<TAccountSource>\n        : TAccountSource,\n      TAccountDestination extends string\n        ? WritableAccount<TAccountDestination>\n        : TAccountDestination,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type TransferInstructionData = {\n  discriminator: number;\n  /** The amount of tokens to transfer. */\n  amount: bigint;\n};\n\nexport type TransferInstructionDataArgs = {\n  /** The amount of tokens to transfer. */\n  amount: number | bigint;\n};\n\nexport function getTransferInstructionDataEncoder(): FixedSizeEncoder<TransferInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: TRANSFER_DISCRIMINATOR })\n  );\n}\n\nexport function getTransferInstructionDataDecoder(): FixedSizeDecoder<TransferInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n  ]);\n}\n\nexport function getTransferInstructionDataCodec(): FixedSizeCodec<\n  TransferInstructionDataArgs,\n  TransferInstructionData\n> {\n  return combineCodec(\n    getTransferInstructionDataEncoder(),\n    getTransferInstructionDataDecoder()\n  );\n}\n\nexport type TransferInput<\n  TAccountSource extends string = string,\n  TAccountDestination extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The source account. */\n  source: Address<TAccountSource>;\n  /** The destination account. */\n  destination: Address<TAccountDestination>;\n  /** The source account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  amount: TransferInstructionDataArgs['amount'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getTransferInstruction<\n  TAccountSource extends string,\n  TAccountDestination extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: TransferInput<TAccountSource, TAccountDestination, TAccountAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): TransferInstruction<\n  TProgramAddress,\n  TAccountSource,\n  TAccountDestination,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        AccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    source: { value: input.source ?? null, isWritable: true },\n    destination: { value: input.destination ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.source),\n      getAccountMeta(accounts.destination),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    data: getTransferInstructionDataEncoder().encode(\n      args as TransferInstructionDataArgs\n    ),\n    programAddress,\n  } as TransferInstruction<\n    TProgramAddress,\n    TAccountSource,\n    TAccountDestination,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          AccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >);\n}\n\nexport type ParsedTransferInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The source account. */\n    source: TAccountMetas[0];\n    /** The destination account. */\n    destination: TAccountMetas[1];\n    /** The source account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[2];\n  };\n  data: TransferInstructionData;\n};\n\nexport function parseTransferInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedTransferInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      source: getNextAccount(),\n      destination: getNextAccount(),\n      authority: getNextAccount(),\n    },\n    data: getTransferInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const TRANSFER_CHECKED_DISCRIMINATOR = 12;\n\nexport function getTransferCheckedDiscriminatorBytes() {\n  return getU8Encoder().encode(TRANSFER_CHECKED_DISCRIMINATOR);\n}\n\nexport type TransferCheckedInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountSource extends string | AccountMeta<string> = string,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountDestination extends string | AccountMeta<string> = string,\n  TAccountAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountSource extends string\n        ? WritableAccount<TAccountSource>\n        : TAccountSource,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountDestination extends string\n        ? WritableAccount<TAccountDestination>\n        : TAccountDestination,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type TransferCheckedInstructionData = {\n  discriminator: number;\n  /** The amount of tokens to transfer. */\n  amount: bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n};\n\nexport type TransferCheckedInstructionDataArgs = {\n  /** The amount of tokens to transfer. */\n  amount: number | bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n};\n\nexport function getTransferCheckedInstructionDataEncoder(): FixedSizeEncoder<TransferCheckedInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n      ['decimals', getU8Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: TRANSFER_CHECKED_DISCRIMINATOR })\n  );\n}\n\nexport function getTransferCheckedInstructionDataDecoder(): FixedSizeDecoder<TransferCheckedInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n    ['decimals', getU8Decoder()],\n  ]);\n}\n\nexport function getTransferCheckedInstructionDataCodec(): FixedSizeCodec<\n  TransferCheckedInstructionDataArgs,\n  TransferCheckedInstructionData\n> {\n  return combineCodec(\n    getTransferCheckedInstructionDataEncoder(),\n    getTransferCheckedInstructionDataDecoder()\n  );\n}\n\nexport type TransferCheckedInput<\n  TAccountSource extends string = string,\n  TAccountMint extends string = string,\n  TAccountDestination extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The source account. */\n  source: Address<TAccountSource>;\n  /** The token mint. */\n  mint: Address<TAccountMint>;\n  /** The destination account. */\n  destination: Address<TAccountDestination>;\n  /** The source account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  amount: TransferCheckedInstructionDataArgs['amount'];\n  decimals: TransferCheckedInstructionDataArgs['decimals'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getTransferCheckedInstruction<\n  TAccountSource extends string,\n  TAccountMint extends string,\n  TAccountDestination extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: TransferCheckedInput<\n    TAccountSource,\n    TAccountMint,\n    TAccountDestination,\n    TAccountAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): TransferCheckedInstruction<\n  TProgramAddress,\n  TAccountSource,\n  TAccountMint,\n  TAccountDestination,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        AccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    source: { value: input.source ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    destination: { value: input.destination ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.source),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.destination),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    data: getTransferCheckedInstructionDataEncoder().encode(\n      args as TransferCheckedInstructionDataArgs\n    ),\n    programAddress,\n  } as TransferCheckedInstruction<\n    TProgramAddress,\n    TAccountSource,\n    TAccountMint,\n    TAccountDestination,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          AccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >);\n}\n\nexport type ParsedTransferCheckedInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The source account. */\n    source: TAccountMetas[0];\n    /** The token mint. */\n    mint: TAccountMetas[1];\n    /** The destination account. */\n    destination: TAccountMetas[2];\n    /** The source account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[3];\n  };\n  data: TransferCheckedInstructionData;\n};\n\nexport function parseTransferCheckedInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedTransferCheckedInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 4) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      source: getNextAccount(),\n      mint: getNextAccount(),\n      destination: getNextAccount(),\n      authority: getNextAccount(),\n    },\n    data: getTransferCheckedInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  getUtf8Decoder,\n  getUtf8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlyUint8Array,\n} from '@solana/kit';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const UI_AMOUNT_TO_AMOUNT_DISCRIMINATOR = 24;\n\nexport function getUiAmountToAmountDiscriminatorBytes() {\n  return getU8Encoder().encode(UI_AMOUNT_TO_AMOUNT_DISCRIMINATOR);\n}\n\nexport type UiAmountToAmountInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type UiAmountToAmountInstructionData = {\n  discriminator: number;\n  /** The ui_amount of tokens to reformat. */\n  uiAmount: string;\n};\n\nexport type UiAmountToAmountInstructionDataArgs = {\n  /** The ui_amount of tokens to reformat. */\n  uiAmount: string;\n};\n\nexport function getUiAmountToAmountInstructionDataEncoder(): Encoder<UiAmountToAmountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['uiAmount', getUtf8Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: UI_AMOUNT_TO_AMOUNT_DISCRIMINATOR })\n  );\n}\n\nexport function getUiAmountToAmountInstructionDataDecoder(): Decoder<UiAmountToAmountInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['uiAmount', getUtf8Decoder()],\n  ]);\n}\n\nexport function getUiAmountToAmountInstructionDataCodec(): Codec<\n  UiAmountToAmountInstructionDataArgs,\n  UiAmountToAmountInstructionData\n> {\n  return combineCodec(\n    getUiAmountToAmountInstructionDataEncoder(),\n    getUiAmountToAmountInstructionDataDecoder()\n  );\n}\n\nexport type UiAmountToAmountInput<TAccountMint extends string = string> = {\n  /** The mint to calculate for. */\n  mint: Address<TAccountMint>;\n  uiAmount: UiAmountToAmountInstructionDataArgs['uiAmount'];\n};\n\nexport function getUiAmountToAmountInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: UiAmountToAmountInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): UiAmountToAmountInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.mint)],\n    data: getUiAmountToAmountInstructionDataEncoder().encode(\n      args as UiAmountToAmountInstructionDataArgs\n    ),\n    programAddress,\n  } as UiAmountToAmountInstruction<TProgramAddress, TAccountMint>);\n}\n\nexport type ParsedUiAmountToAmountInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to calculate for. */\n    mint: TAccountMetas[0];\n  };\n  data: UiAmountToAmountInstructionData;\n};\n\nexport function parseUiAmountToAmountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedUiAmountToAmountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount() },\n    data: getUiAmountToAmountInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  containsBytes,\n  getU32Encoder,\n  type Address,\n  type ReadonlyUint8Array,\n} from '@solana/kit';\nimport {\n  type ParsedAdvanceNonceAccountInstruction,\n  type ParsedAllocateInstruction,\n  type ParsedAllocateWithSeedInstruction,\n  type ParsedAssignInstruction,\n  type ParsedAssignWithSeedInstruction,\n  type ParsedAuthorizeNonceAccountInstruction,\n  type ParsedCreateAccountInstruction,\n  type ParsedCreateAccountWithSeedInstruction,\n  type ParsedInitializeNonceAccountInstruction,\n  type ParsedTransferSolInstruction,\n  type ParsedTransferSolWithSeedInstruction,\n  type ParsedUpgradeNonceAccountInstruction,\n  type ParsedWithdrawNonceAccountInstruction,\n} from '../instructions';\n\nexport const SYSTEM_PROGRAM_ADDRESS =\n  '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n\nexport enum SystemAccount {\n  Nonce,\n}\n\nexport enum SystemInstruction {\n  CreateAccount,\n  Assign,\n  TransferSol,\n  CreateAccountWithSeed,\n  AdvanceNonceAccount,\n  WithdrawNonceAccount,\n  InitializeNonceAccount,\n  AuthorizeNonceAccount,\n  Allocate,\n  AllocateWithSeed,\n  AssignWithSeed,\n  TransferSolWithSeed,\n  UpgradeNonceAccount,\n}\n\nexport function identifySystemInstruction(\n  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array\n): SystemInstruction {\n  const data = 'data' in instruction ? instruction.data : instruction;\n  if (containsBytes(data, getU32Encoder().encode(0), 0)) {\n    return SystemInstruction.CreateAccount;\n  }\n  if (containsBytes(data, getU32Encoder().encode(1), 0)) {\n    return SystemInstruction.Assign;\n  }\n  if (containsBytes(data, getU32Encoder().encode(2), 0)) {\n    return SystemInstruction.TransferSol;\n  }\n  if (containsBytes(data, getU32Encoder().encode(3), 0)) {\n    return SystemInstruction.CreateAccountWithSeed;\n  }\n  if (containsBytes(data, getU32Encoder().encode(4), 0)) {\n    return SystemInstruction.AdvanceNonceAccount;\n  }\n  if (containsBytes(data, getU32Encoder().encode(5), 0)) {\n    return SystemInstruction.WithdrawNonceAccount;\n  }\n  if (containsBytes(data, getU32Encoder().encode(6), 0)) {\n    return SystemInstruction.InitializeNonceAccount;\n  }\n  if (containsBytes(data, getU32Encoder().encode(7), 0)) {\n    return SystemInstruction.AuthorizeNonceAccount;\n  }\n  if (containsBytes(data, getU32Encoder().encode(8), 0)) {\n    return SystemInstruction.Allocate;\n  }\n  if (containsBytes(data, getU32Encoder().encode(9), 0)) {\n    return SystemInstruction.AllocateWithSeed;\n  }\n  if (containsBytes(data, getU32Encoder().encode(10), 0)) {\n    return SystemInstruction.AssignWithSeed;\n  }\n  if (containsBytes(data, getU32Encoder().encode(11), 0)) {\n    return SystemInstruction.TransferSolWithSeed;\n  }\n  if (containsBytes(data, getU32Encoder().encode(12), 0)) {\n    return SystemInstruction.UpgradeNonceAccount;\n  }\n  throw new Error(\n    'The provided instruction could not be identified as a system instruction.'\n  );\n}\n\nexport type ParsedSystemInstruction<\n  TProgram extends string = '11111111111111111111111111111111',\n> =\n  | ({\n      instructionType: SystemInstruction.CreateAccount;\n    } & ParsedCreateAccountInstruction<TProgram>)\n  | ({\n      instructionType: SystemInstruction.Assign;\n    } & ParsedAssignInstruction<TProgram>)\n  | ({\n      instructionType: SystemInstruction.TransferSol;\n    } & ParsedTransferSolInstruction<TProgram>)\n  | ({\n      instructionType: SystemInstruction.CreateAccountWithSeed;\n    } & ParsedCreateAccountWithSeedInstruction<TProgram>)\n  | ({\n      instructionType: SystemInstruction.AdvanceNonceAccount;\n    } & ParsedAdvanceNonceAccountInstruction<TProgram>)\n  | ({\n      instructionType: SystemInstruction.WithdrawNonceAccount;\n    } & ParsedWithdrawNonceAccountInstruction<TProgram>)\n  | ({\n      instructionType: SystemInstruction.InitializeNonceAccount;\n    } & ParsedInitializeNonceAccountInstruction<TProgram>)\n  | ({\n      instructionType: SystemInstruction.AuthorizeNonceAccount;\n    } & ParsedAuthorizeNonceAccountInstruction<TProgram>)\n  | ({\n      instructionType: SystemInstruction.Allocate;\n    } & ParsedAllocateInstruction<TProgram>)\n  | ({\n      instructionType: SystemInstruction.AllocateWithSeed;\n    } & ParsedAllocateWithSeedInstruction<TProgram>)\n  | ({\n      instructionType: SystemInstruction.AssignWithSeed;\n    } & ParsedAssignWithSeedInstruction<TProgram>)\n  | ({\n      instructionType: SystemInstruction.TransferSolWithSeed;\n    } & ParsedTransferSolWithSeedInstruction<TProgram>)\n  | ({\n      instructionType: SystemInstruction.UpgradeNonceAccount;\n    } & ParsedUpgradeNonceAccountInstruction<TProgram>);\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  isProgramError,\n  type Address,\n  type SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM,\n  type SolanaError,\n} from '@solana/kit';\nimport { SYSTEM_PROGRAM_ADDRESS } from '../programs';\n\n/** AccountAlreadyInUse: an account with the same address already exists */\nexport const SYSTEM_ERROR__ACCOUNT_ALREADY_IN_USE = 0x0; // 0\n/** ResultWithNegativeLamports: account does not have enough SOL to perform the operation */\nexport const SYSTEM_ERROR__RESULT_WITH_NEGATIVE_LAMPORTS = 0x1; // 1\n/** InvalidProgramId: cannot assign account to this program id */\nexport const SYSTEM_ERROR__INVALID_PROGRAM_ID = 0x2; // 2\n/** InvalidAccountDataLength: cannot allocate account data of this length */\nexport const SYSTEM_ERROR__INVALID_ACCOUNT_DATA_LENGTH = 0x3; // 3\n/** MaxSeedLengthExceeded: length of requested seed is too long */\nexport const SYSTEM_ERROR__MAX_SEED_LENGTH_EXCEEDED = 0x4; // 4\n/** AddressWithSeedMismatch: provided address does not match addressed derived from seed */\nexport const SYSTEM_ERROR__ADDRESS_WITH_SEED_MISMATCH = 0x5; // 5\n/** NonceNoRecentBlockhashes: advancing stored nonce requires a populated RecentBlockhashes sysvar */\nexport const SYSTEM_ERROR__NONCE_NO_RECENT_BLOCKHASHES = 0x6; // 6\n/** NonceBlockhashNotExpired: stored nonce is still in recent_blockhashes */\nexport const SYSTEM_ERROR__NONCE_BLOCKHASH_NOT_EXPIRED = 0x7; // 7\n/** NonceUnexpectedBlockhashValue: specified nonce does not match stored nonce */\nexport const SYSTEM_ERROR__NONCE_UNEXPECTED_BLOCKHASH_VALUE = 0x8; // 8\n\nexport type SystemError =\n  | typeof SYSTEM_ERROR__ACCOUNT_ALREADY_IN_USE\n  | typeof SYSTEM_ERROR__ADDRESS_WITH_SEED_MISMATCH\n  | typeof SYSTEM_ERROR__INVALID_ACCOUNT_DATA_LENGTH\n  | typeof SYSTEM_ERROR__INVALID_PROGRAM_ID\n  | typeof SYSTEM_ERROR__MAX_SEED_LENGTH_EXCEEDED\n  | typeof SYSTEM_ERROR__NONCE_BLOCKHASH_NOT_EXPIRED\n  | typeof SYSTEM_ERROR__NONCE_NO_RECENT_BLOCKHASHES\n  | typeof SYSTEM_ERROR__NONCE_UNEXPECTED_BLOCKHASH_VALUE\n  | typeof SYSTEM_ERROR__RESULT_WITH_NEGATIVE_LAMPORTS;\n\nlet systemErrorMessages: Record<SystemError, string> | undefined;\nif (process.env.NODE_ENV !== 'production') {\n  systemErrorMessages = {\n    [SYSTEM_ERROR__ACCOUNT_ALREADY_IN_USE]: `an account with the same address already exists`,\n    [SYSTEM_ERROR__ADDRESS_WITH_SEED_MISMATCH]: `provided address does not match addressed derived from seed`,\n    [SYSTEM_ERROR__INVALID_ACCOUNT_DATA_LENGTH]: `cannot allocate account data of this length`,\n    [SYSTEM_ERROR__INVALID_PROGRAM_ID]: `cannot assign account to this program id`,\n    [SYSTEM_ERROR__MAX_SEED_LENGTH_EXCEEDED]: `length of requested seed is too long`,\n    [SYSTEM_ERROR__NONCE_BLOCKHASH_NOT_EXPIRED]: `stored nonce is still in recent_blockhashes`,\n    [SYSTEM_ERROR__NONCE_NO_RECENT_BLOCKHASHES]: `advancing stored nonce requires a populated RecentBlockhashes sysvar`,\n    [SYSTEM_ERROR__NONCE_UNEXPECTED_BLOCKHASH_VALUE]: `specified nonce does not match stored nonce`,\n    [SYSTEM_ERROR__RESULT_WITH_NEGATIVE_LAMPORTS]: `account does not have enough SOL to perform the operation`,\n  };\n}\n\nexport function getSystemErrorMessage(code: SystemError): string {\n  if (process.env.NODE_ENV !== 'production') {\n    return (systemErrorMessages as Record<SystemError, string>)[code];\n  }\n\n  return 'Error message not available in production bundles.';\n}\n\nexport function isSystemError<TProgramErrorCode extends SystemError>(\n  error: unknown,\n  transactionMessage: {\n    instructions: Record<number, { programAddress: Address }>;\n  },\n  code?: TProgramErrorCode\n): error is SolanaError<typeof SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM> &\n  Readonly<{ context: Readonly<{ code: TProgramErrorCode }> }> {\n  return isProgramError<TProgramErrorCode>(\n    error,\n    transactionMessage,\n    SYSTEM_PROGRAM_ADDRESS,\n    code\n  );\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  isProgramDerivedAddress,\n  isTransactionSigner as kitIsTransactionSigner,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type ProgramDerivedAddress,\n  type TransactionSigner,\n  upgradeRoleToSigner,\n} from '@solana/kit';\n\n/**\n * Asserts that the given value is not null or undefined.\n * @internal\n */\nexport function expectSome<T>(value: T | null | undefined): T {\n  if (value === null || value === undefined) {\n    throw new Error('Expected a value but received null or undefined.');\n  }\n  return value;\n}\n\n/**\n * Asserts that the given value is a PublicKey.\n * @internal\n */\nexport function expectAddress<T extends string = string>(\n  value:\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null\n    | undefined\n): Address<T> {\n  if (!value) {\n    throw new Error('Expected a Address.');\n  }\n  if (typeof value === 'object' && 'address' in value) {\n    return value.address;\n  }\n  if (Array.isArray(value)) {\n    return value[0] as Address<T>;\n  }\n  return value as Address<T>;\n}\n\n/**\n * Asserts that the given value is a PDA.\n * @internal\n */\nexport function expectProgramDerivedAddress<T extends string = string>(\n  value:\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null\n    | undefined\n): ProgramDerivedAddress<T> {\n  if (!value || !Array.isArray(value) || !isProgramDerivedAddress(value)) {\n    throw new Error('Expected a ProgramDerivedAddress.');\n  }\n  return value;\n}\n\n/**\n * Asserts that the given value is a TransactionSigner.\n * @internal\n */\nexport function expectTransactionSigner<T extends string = string>(\n  value:\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null\n    | undefined\n): TransactionSigner<T> {\n  if (!value || !isTransactionSigner(value)) {\n    throw new Error('Expected a TransactionSigner.');\n  }\n  return value;\n}\n\n/**\n * Defines an instruction account to resolve.\n * @internal\n */\nexport type ResolvedAccount<\n  T extends string = string,\n  U extends\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null =\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null,\n> = {\n  isWritable: boolean;\n  value: U;\n};\n\n/**\n * Defines an instruction that stores additional bytes on-chain.\n * @internal\n */\nexport type InstructionWithByteDelta = {\n  byteDelta: number;\n};\n\n/**\n * Get account metas and signers from resolved accounts.\n * @internal\n */\nexport function getAccountMetaFactory(\n  programAddress: Address,\n  optionalAccountStrategy: 'omitted' | 'programId'\n) {\n  return (\n    account: ResolvedAccount\n  ): AccountMeta | AccountSignerMeta | undefined => {\n    if (!account.value) {\n      if (optionalAccountStrategy === 'omitted') return;\n      return Object.freeze({\n        address: programAddress,\n        role: AccountRole.READONLY,\n      });\n    }\n\n    const writableRole = account.isWritable\n      ? AccountRole.WRITABLE\n      : AccountRole.READONLY;\n    return Object.freeze({\n      address: expectAddress(account.value),\n      role: isTransactionSigner(account.value)\n        ? upgradeRoleToSigner(writableRole)\n        : writableRole,\n      ...(isTransactionSigner(account.value) ? { signer: account.value } : {}),\n    });\n  };\n}\n\nexport function isTransactionSigner<TAddress extends string = string>(\n  value:\n    | Address<TAddress>\n    | ProgramDerivedAddress<TAddress>\n    | TransactionSigner<TAddress>\n): value is TransactionSigner<TAddress> {\n  return (\n    !!value &&\n    typeof value === 'object' &&\n    'address' in value &&\n    kitIsTransactionSigner(value)\n  );\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  BASE_ACCOUNT_SIZE,\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { SYSTEM_PROGRAM_ADDRESS } from '../programs';\nimport {\n  getAccountMetaFactory,\n  type InstructionWithByteDelta,\n  type ResolvedAccount,\n} from '../shared';\n\nexport const CREATE_ACCOUNT_DISCRIMINATOR = 0;\n\nexport function getCreateAccountDiscriminatorBytes() {\n  return getU32Encoder().encode(CREATE_ACCOUNT_DISCRIMINATOR);\n}\n\nexport type CreateAccountInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountPayer extends string | AccountMeta<string> = string,\n  TAccountNewAccount extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountPayer extends string\n        ? WritableSignerAccount<TAccountPayer> &\n            AccountSignerMeta<TAccountPayer>\n        : TAccountPayer,\n      TAccountNewAccount extends string\n        ? WritableSignerAccount<TAccountNewAccount> &\n            AccountSignerMeta<TAccountNewAccount>\n        : TAccountNewAccount,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type CreateAccountInstructionData = {\n  discriminator: number;\n  lamports: bigint;\n  space: bigint;\n  programAddress: Address;\n};\n\nexport type CreateAccountInstructionDataArgs = {\n  lamports: number | bigint;\n  space: number | bigint;\n  programAddress: Address;\n};\n\nexport function getCreateAccountInstructionDataEncoder(): FixedSizeEncoder<CreateAccountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU32Encoder()],\n      ['lamports', getU64Encoder()],\n      ['space', getU64Encoder()],\n      ['programAddress', getAddressEncoder()],\n    ]),\n    (value) => ({ ...value, discriminator: CREATE_ACCOUNT_DISCRIMINATOR })\n  );\n}\n\nexport function getCreateAccountInstructionDataDecoder(): FixedSizeDecoder<CreateAccountInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU32Decoder()],\n    ['lamports', getU64Decoder()],\n    ['space', getU64Decoder()],\n    ['programAddress', getAddressDecoder()],\n  ]);\n}\n\nexport function getCreateAccountInstructionDataCodec(): FixedSizeCodec<\n  CreateAccountInstructionDataArgs,\n  CreateAccountInstructionData\n> {\n  return combineCodec(\n    getCreateAccountInstructionDataEncoder(),\n    getCreateAccountInstructionDataDecoder()\n  );\n}\n\nexport type CreateAccountInput<\n  TAccountPayer extends string = string,\n  TAccountNewAccount extends string = string,\n> = {\n  payer: TransactionSigner<TAccountPayer>;\n  newAccount: TransactionSigner<TAccountNewAccount>;\n  lamports: CreateAccountInstructionDataArgs['lamports'];\n  space: CreateAccountInstructionDataArgs['space'];\n  programAddress: CreateAccountInstructionDataArgs['programAddress'];\n};\n\nexport function getCreateAccountInstruction<\n  TAccountPayer extends string,\n  TAccountNewAccount extends string,\n  TProgramAddress extends Address = typeof SYSTEM_PROGRAM_ADDRESS,\n>(\n  input: CreateAccountInput<TAccountPayer, TAccountNewAccount>,\n  config?: { programAddress?: TProgramAddress }\n): CreateAccountInstruction<\n  TProgramAddress,\n  TAccountPayer,\n  TAccountNewAccount\n> &\n  InstructionWithByteDelta {\n  // Program address.\n  const programAddress = config?.programAddress ?? SYSTEM_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    payer: { value: input.payer ?? null, isWritable: true },\n    newAccount: { value: input.newAccount ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Bytes created or reallocated by the instruction.\n  const byteDelta: number = [Number(args.space) + BASE_ACCOUNT_SIZE].reduce(\n    (a, b) => a + b,\n    0\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'omitted');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.payer),\n      getAccountMeta(accounts.newAccount),\n    ],\n    byteDelta,\n    data: getCreateAccountInstructionDataEncoder().encode(\n      args as CreateAccountInstructionDataArgs\n    ),\n    programAddress,\n  } as CreateAccountInstruction<\n    TProgramAddress,\n    TAccountPayer,\n    TAccountNewAccount\n  > &\n    InstructionWithByteDelta);\n}\n\nexport type ParsedCreateAccountInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    payer: TAccountMetas[0];\n    newAccount: TAccountMetas[1];\n  };\n  data: CreateAccountInstructionData;\n};\n\nexport function parseCreateAccountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedCreateAccountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { payer: getNextAccount(), newAccount: getNextAccount() },\n    data: getCreateAccountInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","import { getCreateAccountInstruction } from '@solana-program/system';\nimport {\n  Address,\n  InstructionPlan,\n  OptionOrNullable,\n  sequentialInstructionPlan,\n  TransactionSigner,\n} from '@solana/kit';\nimport {\n  getInitializeMint2Instruction,\n  getMintSize,\n  TOKEN_PROGRAM_ADDRESS,\n} from './generated';\n\n// RPC `getMinimumBalanceForRentExemption` for 82 bytes, which is token mint size\n// Hardcoded to avoid requiring an RPC request each time\nconst MINIMUM_BALANCE_FOR_MINT = 1461600;\n\nexport type CreateMintInstructionPlanInput = {\n  /** Funding account (must be a system account). */\n  payer: TransactionSigner;\n  /** New mint account to create. */\n  newMint: TransactionSigner;\n  /** Number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n  /** The authority/multisignature to mint tokens. */\n  mintAuthority: Address;\n  /** The optional freeze authority/multisignature of the mint. */\n  freezeAuthority?: OptionOrNullable<Address>;\n  /**\n   * Optional override for the amount of Lamports to fund the mint account with.\n   * @default 1461600\n   *  */\n  mintAccountLamports?: number;\n};\n\ntype CreateMintInstructionPlanConfig = {\n  systemProgram?: Address;\n  tokenProgram?: Address;\n};\n\nexport function getCreateMintInstructionPlan(\n  input: CreateMintInstructionPlanInput,\n  config?: CreateMintInstructionPlanConfig\n): InstructionPlan {\n  return sequentialInstructionPlan([\n    getCreateAccountInstruction(\n      {\n        payer: input.payer,\n        newAccount: input.newMint,\n        lamports: input.mintAccountLamports ?? MINIMUM_BALANCE_FOR_MINT,\n        space: getMintSize(),\n        programAddress: config?.tokenProgram ?? TOKEN_PROGRAM_ADDRESS,\n      },\n      {\n        programAddress: config?.systemProgram,\n      }\n    ),\n    getInitializeMint2Instruction(\n      {\n        mint: input.newMint.address,\n        decimals: input.decimals,\n        mintAuthority: input.mintAuthority,\n        freezeAuthority: input.freezeAuthority,\n      },\n      {\n        programAddress: config?.tokenProgram,\n      }\n    ),\n  ]);\n}\n","import {\n  InstructionPlan,\n  sequentialInstructionPlan,\n  Address,\n  TransactionSigner,\n} from '@solana/kit';\nimport {\n  findAssociatedTokenPda,\n  getCreateAssociatedTokenIdempotentInstruction,\n  getMintToCheckedInstruction,\n  TOKEN_PROGRAM_ADDRESS,\n} from './generated';\n\ntype MintToATAInstructionPlanInput = {\n  /** Funding account (must be a system account). */\n  payer: TransactionSigner;\n  /** Associated token account address to mint to.\n   * Will be created if it does not already exist.\n   * Note: Use {@link getMintToATAInstructionPlanAsync} instead to derive this automatically.\n   * Note: Use {@link findAssociatedTokenPda} to derive the associated token account address.\n   */\n  ata: Address;\n  /** Wallet address for the associated token account. */\n  owner: Address;\n  /** The token mint for the associated token account. */\n  mint: Address;\n  /** The mint's minting authority or its multisignature account. */\n  mintAuthority: Address | TransactionSigner;\n  /** The amount of new tokens to mint. */\n  amount: number | bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n  multiSigners?: Array<TransactionSigner>;\n};\n\ntype MintToATAInstructionPlanConfig = {\n  systemProgram?: Address;\n  tokenProgram?: Address;\n  associatedTokenProgram?: Address;\n};\n\nexport function getMintToATAInstructionPlan(\n  input: MintToATAInstructionPlanInput,\n  config?: MintToATAInstructionPlanConfig\n): InstructionPlan {\n  return sequentialInstructionPlan([\n    getCreateAssociatedTokenIdempotentInstruction(\n      {\n        payer: input.payer,\n        ata: input.ata,\n        owner: input.owner,\n        mint: input.mint,\n        systemProgram: config?.systemProgram,\n        tokenProgram: config?.tokenProgram,\n      },\n      {\n        programAddress: config?.associatedTokenProgram,\n      }\n    ),\n    // mint to this token account\n    getMintToCheckedInstruction(\n      {\n        mint: input.mint,\n        token: input.ata,\n        mintAuthority: input.mintAuthority,\n        amount: input.amount,\n        decimals: input.decimals,\n        multiSigners: input.multiSigners,\n      },\n      {\n        programAddress: config?.tokenProgram,\n      }\n    ),\n  ]);\n}\n\ntype MintToATAInstructionPlanAsyncInput = Omit<\n  MintToATAInstructionPlanInput,\n  'ata'\n>;\n\nexport async function getMintToATAInstructionPlanAsync(\n  input: MintToATAInstructionPlanAsyncInput,\n  config?: MintToATAInstructionPlanConfig\n): Promise<InstructionPlan> {\n  const [ataAddress] = await findAssociatedTokenPda({\n    owner: input.owner,\n    tokenProgram: config?.tokenProgram ?? TOKEN_PROGRAM_ADDRESS,\n    mint: input.mint,\n  });\n  return getMintToATAInstructionPlan(\n    {\n      ...input,\n      ata: ataAddress,\n    },\n    config\n  );\n}\n","import {\n  InstructionPlan,\n  sequentialInstructionPlan,\n  Address,\n  TransactionSigner,\n} from '@solana/kit';\nimport {\n  findAssociatedTokenPda,\n  getCreateAssociatedTokenIdempotentInstruction,\n  getTransferCheckedInstruction,\n  TOKEN_PROGRAM_ADDRESS,\n} from './generated';\n\ntype TransferToATAInstructionPlanInput = {\n  /** Funding account (must be a system account). */\n  payer: TransactionSigner;\n  /** The token mint to transfer. */\n  mint: Address;\n  /** The source account for the transfer. */\n  source: Address;\n  /** The source account's owner/delegate or its multisignature account. */\n  authority: Address | TransactionSigner;\n  /** Associated token account address to transfer to.\n   * Will be created if it does not already exist.\n   * Note: Use {@link getTransferToATAInstructionPlanAsync} instead to derive this automatically.\n   * Note: Use {@link findAssociatedTokenPda} to derive the associated token account address.\n   */\n  destination: Address;\n  /** Wallet address for the destination. */\n  recipient: Address;\n  /** The amount of tokens to transfer. */\n  amount: number | bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n  multiSigners?: Array<TransactionSigner>;\n};\n\ntype TransferToATAInstructionPlanConfig = {\n  systemProgram?: Address;\n  tokenProgram?: Address;\n  associatedTokenProgram?: Address;\n};\n\nexport function getTransferToATAInstructionPlan(\n  input: TransferToATAInstructionPlanInput,\n  config?: TransferToATAInstructionPlanConfig\n): InstructionPlan {\n  return sequentialInstructionPlan([\n    getCreateAssociatedTokenIdempotentInstruction(\n      {\n        payer: input.payer,\n        ata: input.destination,\n        owner: input.recipient,\n        mint: input.mint,\n        systemProgram: config?.systemProgram,\n        tokenProgram: config?.tokenProgram,\n      },\n      {\n        programAddress: config?.associatedTokenProgram,\n      }\n    ),\n    getTransferCheckedInstruction(\n      {\n        source: input.source,\n        mint: input.mint,\n        destination: input.destination,\n        authority: input.authority,\n        amount: input.amount,\n        decimals: input.decimals,\n        multiSigners: input.multiSigners,\n      },\n      {\n        programAddress: config?.tokenProgram,\n      }\n    ),\n  ]);\n}\n\ntype TransferToATAInstructionPlanAsyncInput = Omit<\n  TransferToATAInstructionPlanInput,\n  'destination'\n>;\n\nexport async function getTransferToATAInstructionPlanAsync(\n  input: TransferToATAInstructionPlanAsyncInput,\n  config?: TransferToATAInstructionPlanConfig\n): Promise<InstructionPlan> {\n  const [ataAddress] = await findAssociatedTokenPda({\n    owner: input.recipient,\n    tokenProgram: config?.tokenProgram ?? TOKEN_PROGRAM_ADDRESS,\n    mint: input.mint,\n  });\n  return getTransferToATAInstructionPlan(\n    {\n      ...input,\n      destination: ataAddress,\n    },\n    config\n  );\n}\n","import{useMemo as t}from\"react\";import{u as e}from\"./internal-context-DLZicboG.mjs\";const r=()=>{let{walletProxy:r,client:a}=e();return t((()=>({signWithUserSigner:async({message:t,targetAppId:e})=>{if(!r)throw Error(\"Wallet proxy not initialized\");let i=await a.getAccessToken();if(!i)throw Error(\"User must be authenticated\");let{signature:s}=await r.signWithUserSigner({accessToken:i,message:t,targetAppId:e});return{signature:s}}})),[r,a])};export{r as u};\n"],"names":["isSolanaError","ORDERED_ERROR_NAMES","AccountRole","alphabet","SolanaError","createEncoder","SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE","createDecoder","combineCodec","address","signature","privateKey","Endian","newOffset","getEncodedSize","isFixedSize","getU8Encoder","transformEncoder","getU8Decoder","transformDecoder","containsBytes","getStructEncoder","getStructDecoder","getArrayEncoder","getShortU16Encoder","getArrayDecoder","getShortU16Decoder","getAddressEncoder","getAddressDecoder","getAddressComparator","isWritableRole","isSignerRole","getBytesEncoder","SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT","SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING","transaction","TextEncoder","getBooleanEncoder","getBooleanDecoder","decodeAccount","assertAccountExists","fetchEncodedAccount","assertAccountsExist","fetchEncodedAccounts","AccountState","AuthorityType","getEnumEncoder","getEnumDecoder","getU64Encoder","getOptionEncoder","context","getU32Encoder","getU64Decoder","getOptionDecoder","getU32Decoder","AssociatedTokenInstruction","traverse","TokenAccount","traverseSequential","traverseSingle","candidate","TokenInstruction","traverseParallel","message","getAbortablePromise","getTransactionMessageSize","TRANSACTION_SIZE_LIMIT","SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN","SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND","isProgramError","kitIsTransactionSigner","none","expectAddress","getAccountMetaFactory","isTransactionSigner","upgradeRoleToSigner","sequentialInstructionPlan"],"mappings":"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","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306]}